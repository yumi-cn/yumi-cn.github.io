{"pages":[{"title":"关于我","text":"一个普普通通程序员，专攻(自封)图形学、实时渲染以及游戏引擎，其他领域的例如机器学习、深度学习、数据挖掘、后端开发、前端开发之类的，也都多少懂一点点，出于兴趣学习。 日常就是学点喜欢的技术，写点喜欢的代码，闲的时候画点画。 博客主要用于记载一些阅读书籍的笔记心得，偶尔放一些用于当作品集的炫酷Demo。 联系方式： 日常练习: augbubbles@foxmail.com 工作相关: mi.work@outlook.com","link":"/about/index.html"}],"posts":[{"title":"《剑指Offer》第1章笔记","text":"第1章主要介绍的是几种面试方式的不同流程以及注意事项。 “…技术面试中的5个要素，是全书的大纲,…” 远程桌面面试 思考清楚再开始编码； 良好的代码命名和缩进对齐； 单元测试、断点调试。 面试的3个环节行为面试、技术面试、应聘者提问。 行为面试 自我介绍：30s-1min，介绍主要学习和工作经历； 项目经验：STAR模型描述项目经历； Situation：简短的项目背景； Task：自己完成的任务，注意区分“参与”和“负责”； Action：如何完成任务的，详细介绍自己完成任务的方式方法； Result：自己的贡献，尝试量化自己的产出，让人直接接收到你的成果。 掌握技能：注意区分“了解”、“熟悉”和“精通”； 了解：上过课、看过书，但没有做过实际项目，通常只建议有用的时候再写； 熟悉：通常的情况，指能够独立解决大部分问题； 精通：得心应手，能够轻松回答领域内的绝大多数问题。 为什么跳槽：尽量不说抱怨层面的原因，多从自我发展的角度阐述选择的理由。 技术面试平均1个小时的面试，技术面试会占据40-50分钟的时间。 总的来说面试官关注应聘者的5种素质： 扎实的基础知识：编程语言、数据结构和算法； 能写高质量的代码：代码鲁棒性，边界考虑（另外还需要注意代码规范或者风格）； 分析问题的思路清晰：从简单完备的思路出发，用各种方法来尝试优化，例如画图形象化，举例具象化，分解简单化； 能够优化时间、空间效率：熟知数据结构优缺点，熟练掌握常用算法； 学习、沟通、综合能力。 PS：5个要素分别对应本书的第2、3、4、5、6章节内容。 应聘者提问如果觉得面试后临时想比较困难，可以在面试前提前准备一些问题。 主要围绕公司、职位、项目等工作上的事情，不太适合问较远较模糊或者和工薪相关的问题（之后再和HR聊也可以）。","link":"/2020/11/24/s2o-c1/"},{"title":"《剑指Offer》第2章笔记 编程语言","text":"第2章主要围绕编程语言、数据结构和算法，介绍技术面所需要的“基础知识”。 编程语言书里代码都是用 C/C++/C# 实现的，后面分别从 C++ 和 C# 语言的角度来讲述其中一些被问道的细节点，这样的细节点因为篇幅限制，不可能都写进书里，所以还需要通过阅读对应编程语言的书籍来进阶了解，同时其他语言的使用者也可以从其中窥探到面试官在针对语言掌握的考量时，都是从什么样的角度出发的。 C++通常语言面试的问题有3种类型： 对于语言中概念的理解程度； 面对代码，分析运行结果（或错误）； 在上下文环境中，定义类型或实现函数。 作者推荐的几本C++书，根据自己的情况选择阅读顺序： 《Effective C++》：书中列举了C++经常出现的问题以及解决这些问题的技巧（大多是面试官比较喜欢问的方向），适合面试之前突击C++； 《C++ Primer》：人称C++全书，适合全面了解的时候阅读，也可以当作宝典查询； 《深度探索C++对象模型》：深度了解C++对象的内部机制，介绍很多较为底层的知识点； 《The C++ Programming Language》：C++圣经（大概），适合全面深入掌握C++。 下面通过一道面试题（第3种类型）来表现一下这类题目是如何考查语言知识点的。 面试题1：赋值运算符函数，如下为类型CMyString的声明，请为该类型添加赋值运算符函数。 123456789class CMyString { public: CMyString(char* pData=nullptr); CMyString(const CMyString&amp; str); ~CMyString(void); private: char* m_pData;}; Tips：赋值运算符主要负责变量在进行赋值 = 运算时，如何处理变量对象内部成员变化。 定义C++中的赋值运算符函数时，需要关注点有： 返回值类型声明为引用，函数结束前返回实例自身的引用，因为返回引用才允许连续赋值的情况，例如 str1 = str2 = str3，否则无法通过编译； 把传入的参数类型声明为常量引用，如果不是引用，形参到实参传递会调用一次复制构造函数（函数的传值引用），引用可以避免这样的开销；同时因为赋值运算并不会修改传入的实例的状态，所以应进一步加上 const 关键字； 释放实例自身已有的内存，主要在对象有动态分配内存情况下考虑，如果忘记在分配新内存前释放旧内存空间，程序旧出现了内存泄漏(memory leakge)，这块内存无法被回收使用（资源浪费、占用空间导致空间不够用）； 判断传入参数和当前实例(*this)是不是同一个实例，是则不进行赋值，如果不判断就直接赋值，在同一个实例情况下，会导致在还没有拷贝到传入参数（自己）的内存时，就释放自己的内存，这也就导致传入参数的内存被释放了（因为函数是传引用），最后找不到待赋值的内容。 经典解法： 123456789101112131415#include &lt;cstring&gt;CMyString&amp; CMyString::operator=(const CMyString&amp; str) { if(this == &amp;str) { // 对象的 this 是一个地址 return *this; // 传对象 而不是地址 } delete []m_pData; // 数组的释放方式 m_pData = nullptr; m_pData = new char[strlen(str.m_pData) + 1]; // 申请新空间，多的1位给'\\0' strcpy(m_pData, str.m_pData); // 复制 赋值 return *this;} 如果对自己有更高的要求，应该再进一步地考虑其中涉及到的问题。 前面的函数中，分配内存之前先释放了内存，如果在分配内存时，内存不足就会导致 new char 排除异常，m_pData将是一个空指针，并且无法回退到之前的结果，也就是说一旦赋值运算符内部抛出了异常，实例不再保持有效的状态（并不是原有的状态），这违背了异常安全性（Exception Safety）原则（正常情况下，如果抛出异常也不应该导致内容被错误操作）。 简单的方法是先用 new 分配新内容，再 delete 释放已有的； 更好的办法是创建一个临时实例，再交换临时实例和原来的实例。 12345678910#include &lt;cstring&gt;#include &lt;algorithm&gt;CMyString&amp; CMyString::operator=(const CMyString&amp; str) { if(this == &amp;str) { CMyString tmp(str); // 复制构造函数 std::swap(m_pData, tmp.m_pData); // 交换地址 } return *this;} 当 tmp 局部变量遇到 if 结束时，会自动调用它的析构函数，会把交换下来的 this 的 m_pData 所指向的内存释放掉；在新的代码中，在复制构造函数中分配内存，如果由于内存不足抛出异常时，由于此时还没有修改原来的实例状态，实例的状态依旧是有效的（原有的），也就保证了异常安全性。 完整代码（包含所有实现和测试）： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;class CMyString { public: CMyString(char* pData); // 第一个参数设定默认值会导致无法通过编译 CMyString(const CMyString&amp; str); ~CMyString(void); CMyString&amp; operator=(const CMyString&amp; str); // 赋值运算符函数声明 void print(void); // 标准输出函数 private: char* m_pData;};// 构造函数CMyString::CMyString(char* pData) { if(pData != nullptr) { m_pData = new char[strlen(pData) + 1]; strcpy(m_pData, pData); }}// 复制构造函数CMyString::CMyString(const CMyString&amp; str) { if(str.m_pData != nullptr) { m_pData = new char[strlen(str.m_pData) + 1]; strcpy(m_pData, str.m_pData); }}// 析构函数CMyString::~CMyString(void) { if(m_pData != nullptr) { delete []m_pData; m_pData = nullptr; }}void CMyString::print(void) { std::cout &lt;&lt; m_pData &lt;&lt; std::endl;}// 赋值运算符函数CMyString&amp; CMyString::operator=(const CMyString&amp; str) { if(this != &amp;str) { CMyString tmp(str); // 复制构造函数 std::swap(m_pData, tmp.m_pData); // 交换地址 } return *this;}int main() { // 测试CMyString CMyString str1(&quot;Sword&quot;); CMyString str2(&quot;2&quot;); CMyString str3(&quot;Offer&quot;); str1 = str2 = str3; str1.print(); // Offer str2.print(); // Offer str3.print(); // Offer return 0;} 如果完整的去实现上面这个题目，会引出一些非常容易忽略的细节问题（并且会导致严重错误），例如在初始化变量 str1 时，CMyString str1(&quot;Sword&quot;);，其中所传入的参数一般都是程序声明的字符串常量，如果在构造函数中简单地实现为： 1234// Mem ErrorCMyString::CMyString(char* pData) { m_pData = pData;} 就会导致赋值运算符函数中的析构函数调用过程发生错误，因为析构函数中的 delete []m_pData 的delete操作符只负责操作堆(Heap)中的内存区域(因为new只在堆里申请内存区域)，如果使用delete操作符去释放一个字符串常量指针所指向的区域，就会发生错误（大概是访问越界）。 所以在初始化时应该使用和delete对应的new操作，在堆中申请内存，再把传入参数的内容复制到其中。 123456CMyString::CMyString(char* pData) { if(pData != nullptr) { m_pData = new char[strlen(pData) + 1]; strcpy(m_pData, pData); }} C#因为还没怎么学C#的东西，C#的部分暂时跳过，记录一下推荐的书： 《Professional C#》：特点是附录中有描述C#和其他语言的区别； 《CLR Via C#》：深入介绍C#，对CLR和.NET进行剖析，可以方便理解装箱卸箱、垃圾回收、反射等概念。 面试题2：实现Singleton模式（单例模式） 暂时跳过。 涉及到设计模式的部分，列举一些可以参考阅读的资料： 《设计模式：C++常用设计模式》：https://refactoringguru.cn/design-patterns/cpp ； 《Head First 设计模式》：感觉是一本比较老的书，可能之后看看吧； 《Game Programming Patterns》：http://gameprogrammingpatterns.com/contents.html 。","link":"/2020/11/25/s2o-c2-lg/"},{"title":"《3D图形的数学》第1章笔记 向量","text":"对于成功的3D程序猿，掌握如何进行向量运算是一种基本的技能要求。 原书：《3D游戏与计算机图形学中的数学方法》 by Eric.Lengyel 1 向量的形式一个n维向量V可以表示为： $$ \\textbf{V} = < V_{1}, V_{2}, ... , V_{n} > \\tag{1.1} $$ 系数a和向量V的乘积可以定义为： $$ a\\textbf{V} = < aV_{1}, aV_{2}, ... , aV_{n} > \\tag{1.4} $$ 向量加减运算： $$ \\textbf{P} + \\textbf{Q} = < P_{1} + Q_{1}, P_{2} + Q_{2}, ... , P_{n} + Q_{n} > \\tag{1.5} $$ 【定理1.1】对于给定的任何两个系数a和b，以及任何三个向量P、Q和R，有以下运算规律： \\(\\textbf{P} + \\textbf{Q} = \\textbf{Q} + \\textbf{P}\\) \\((\\textbf{P} + \\textbf{Q}) + \\textbf{R} = \\textbf{P} + (\\textbf{Q} + \\textbf{R})\\) \\((ab)\\textbf{P} = a(b\\textbf{P})\\) \\(a(\\textbf{P} + \\textbf{Q}) = a\\textbf{P} + a\\textbf{Q}\\) \\((a + b)\\textbf{P} = a\\textbf{P} + b\\textbf{P}\\) n维向量V的模，||V||： $$ \\textbf{||V||} = \\sqrt{\\sum_{i=1}^{n} V_{i}^{2}} \\tag{1.6} $$ 模也称为向量的范数或者长度，模为1的向量称为单位向量。 设向量V表示一个三维点或方向，则公式(1.6)可以展开为： $$ \\textbf{||V||} = \\sqrt{V_{x}^{2} + V_{y}^{2} + V_{z}^{2}} \\tag{1.7} $$ 如果向量V至少有至少有一个非零分量，可以通过乘 \\(1/\\textbf{||V||}\\) 得到V方向上的一个单位向量，也叫做单位化、规格化。 【定理1.2】 对于任意给定系数a，任意的两个向量P和Q，有以下性质： \\( \\textbf{||P||} \\geq 0 \\) 当且仅当 \\( \\textbf{||P||}=&lt;0, 0, …, 0&gt; \\)时，\\( \\textbf{||P||}=0 \\) \\( \\textbf{||aP||}=|a|\\textbf{||P||} \\) \\( \\textbf{||P + Q||} \\leq \\textbf{||P||} + \\textbf{||Q||} \\) 其中的第4条，可以由三角不等式得到。 2 点积向量间的点积，也叫做数量积或内积，3D图形中经常用点积来度量两个向量指向的差异。 【定理1.3】 两个n维向量P和Q的点积，记作P·Q，即： $$ \\textbf{P} \\cdot \\textbf{Q} = \\sum_{i=1}^{n} P_{i}Q_{i} \\tag{1.9} $$ 向量的点积等于两个向量的对应分量乘积之和。 在三维空间中，有： $$ \\textbf{P} \\cdot \\textbf{Q} = P_{x}Q_{x} + P_{y}Q_{y} + P_{z}Q_{z} \\tag{1.10} $$ 【定理1.4】 对于给定的两个向量P和Q，点积满足公式： $$ \\textbf{P} \\cdot \\textbf{Q} = \\textbf{||P||}\\textbf{||Q||} cos \\alpha \\tag{1.12} $$ \\(\\alpha\\)是向量P和Q之间的夹角（详细的说是P和Q的起点、终点决定的平面夹角）。 Tips：定理1.4的证明要用到余弦定理，一个三角形有三条边\\(a,b,c\\)，\\(a,b\\)夹角是\\(\\alpha\\)时，三边满足等式关系\\(c^{2} = a^{2} + b^{2} - 2abcos\\alpha\\)。 定理1.4可以得出两个结论： 当且仅当 \\(\\textbf{P} \\cdot \\textbf{Q} = 0\\) 时， 向量P和向量Q相互垂直。点积为0的向量称为正交向量，零向量和任意向量正交； 点积正负号说明两个向量的方向情况，例如在看平面法线和平面外一点，可以查看点相对于平面的位置，是在法线同侧（点积为正）还是在不同侧（点积为负）。 【定理1.5】 对于任意给定系数a，任意的两个向量P和Q，有以下性质： \\( \\textbf{P} \\cdot \\textbf{Q} = \\textbf{Q} \\cdot \\textbf{P} \\) \\( (a\\textbf{P}) \\cdot \\textbf{Q} = a(\\textbf{P} \\cdot \\textbf{Q}) \\) \\( \\textbf{P} \\cdot (\\textbf{Q} + \\textbf{R}) = \\textbf{P} \\cdot \\textbf{Q} + \\textbf{P} \\cdot \\textbf{R} \\) \\( \\textbf{P} \\cdot \\textbf{P} = \\textbf{||P||}^{2} \\) \\( | \\textbf{P} \\cdot \\textbf{Q} | \\leq \\textbf{||P||} \\cdot \\textbf{||Q||} \\) 向量P在向量Q上的投影长度： $$ \\textbf{||P||}cos\\alpha = \\frac{\\textbf{P}\\cdot\\textbf{Q}}{\\textbf{||Q||}} \\tag{1.17} $$ 如果再乘以单位向量 \\( \\frac{\\textbf{Q}}{\\textbf{||Q||}} \\)，就可以得到具有该长度并且平行于Q的一个向量，即表示向量P到向量Q的投影，记作\\( proj_{\\textbf{Q}} \\textbf{P} \\)： $$ proj_{\\textbf{Q}}\\textbf{P} = \\frac{\\textbf{P} \\cdot \\textbf{Q}}{\\textbf{||Q||}^{2}} \\textbf{Q} \\tag{1.18} $$ P到Q的投影也可以看作是一个线性变换过程，所以可以表示为矩阵和向量乘积，三维情况下，\\( proj_{\\textbf{Q}} \\textbf{P} \\) 也可以用下面的公式计算： $$ proj_{\\textbf{Q}} \\textbf{P} = \\frac{1}{\\textbf{Q}^{2}} \\left[ \\begin{matrix} Q_{x}^{2} & Q_{x}Q_{y} & Q_{x}Q_{z} \\\\ Q_{x}Q_{y} & Q_{y}^{2} & Q_{y}Q_{z} \\\\ Q_{x}Q_{z} & Q_{y}Q_{z} & Q_{z}^{2} \\end{matrix} \\right] \\left[ \\begin{matrix} P_{x} \\\\ P_{y} \\\\ P_{z} \\end{matrix} \\right] \\tag{1.20} $$ 向量P相对于向量Q的垂直分量记作\\( perp_{\\textbf{Q}} \\textbf{P} \\)，可以用向量P减去投影分量得到垂直分量： $$ perp_{\\textbf{Q}} \\textbf{P} = \\textbf{P} - proj_{\\textbf{Q}} \\textbf{P} \\tag{1.19} $$ 3 叉积两个三维向量的叉积又称为向量积，结果是一个新的向量，这个向量垂直于原来的两个向量。 在3D图形学中，已知曲面上一点的两个不同方向的切向量，就可以通过求叉积得到曲面在该点的法向量。 【定义1.6】 两个3D向量P和Q的叉积记作 \\(\\textbf{P} \\times \\textbf{Q}\\)，结果向量为： $$ \\textbf{P} \\times \\textbf{Q} = < P_{y}Q_{z} - P_{z}Q_{y}, P_{z}Q_{x} - P_{x}Q_{z}, P_{x}Q_{y} - P_{y}Q_{x} > \\tag{1.21} $$ 便于记忆的一个工具是伪行列式： $$ \\textbf{P} \\times \\textbf{Q} = \\left| \\begin{matrix} i & j & k \\\\ P_{x} & P_{y} & P_{z} \\\\ Q_{x} & Q_{y} & Q_{z} \\end{matrix} \\right| \\tag{1.22} $$ 这里i,j,k是x,y,z轴的单位向量： $$ \\begin{aligned} \\textbf{i} &= \\\\ \\textbf{j} &= \\\\ \\textbf{k} &= \\end{aligned} \\tag{1.23} $$ 叉积\\(\\textbf{P} \\times \\textbf{Q}\\)也可以用线性变换的形式表示，变换矩阵派生于P，作用于Q： $$ \\textbf{P} \\times \\textbf{Q} = \\left[ \\begin{matrix} 0 & -P_{z} & P_{y} \\\\ P_{z} & 0 & -P_{x} \\\\ -P_{y} & P_{x} & 0 \\end{matrix} \\right] \\left[ \\begin{matrix} Q_{x} \\\\ Q_{y} \\\\ Q_{z} \\end{matrix} \\right] \\tag{1.25} $$ Tips：原书P7的公式(1.25)有疏漏，变换矩阵中出现了Q的分量。 对于任意给定的三个3D向量P、Q和R，等式 \\((\\textbf{P} \\times \\textbf{Q}) \\cdot \\textbf{R}\\) 的值可以通过伪行列式乘以R得到： $$ (\\textbf{P} \\times \\textbf{Q}) \\cdot \\textbf{R} = \\left| \\begin{matrix} R_{x} & R_{y} & R_{z} \\\\ P_{x} & P_{y} & P_{z} \\\\ Q_{x} & Q_{y} & Q_{z} \\end{matrix} \\right| = \\left| \\begin{matrix} P_{x} & P_{y} & P_{z} \\\\ Q_{x} & Q_{y} & Q_{z} \\\\ R_{x} & R_{y} & R_{z} \\end{matrix} \\right| \\tag{1.27} $$ Tips：行列式表达我在这里书写了两种表达形式，第一种是延续之前伪行列式的写法，只是将R替代了ijk的位置，第二种写法来自于书上，遵循PQR的出现次序的记忆法，两者的值根据初等变化法则是相等的。 如果P、Q和R中任何一个可以表示为其他两个向量的线性组合，则行列式的值为0（根据垂直法则和点积定理推导）。 【定理1.8】 对于给定的两个3D向量P和Q，叉积\\(\\textbf{P} \\times \\textbf{Q}\\)满足下面公式： $$ ||\\textbf{P} \\times \\textbf{Q}|| = \\textbf{||P||}\\textbf{||Q||}sin\\alpha \\tag{1.28} $$ \\(\\alpha\\)为P和Q的夹角。 由定理1.8可知，叉积\\(\\textbf{P} \\times \\textbf{Q}\\)的模等于由向量P和Q组成的平行四边形的面积。因此，一个三角形的顶点\\(V_{1}, V_{2}, V_{3}\\)，可以计算其面积A: $$ A = \\frac{1}{2} || (V_{2} - V_{1}) \\times (V_{3} - V_{1}) || \\tag{1.32} $$ 叉积得到的非零向量一定垂直于原本的两个向量，但满足要求的有两种方向，为了确定叉积方向，引入叉积遵循的右手法则。例如，使用右手手指指向P方向，手心朝向Q反向，则大拇指就是叉积\\(\\textbf{P} \\times \\textbf{Q}\\)的方向。 空间轴的单位向量ijk，按照圆形循环的方式排序，i在j之前，j在k之前，k在i之前，则这样的顺序叉积乘等于第三个向量： $$ \\begin{aligned} \\textbf{i} \\times \\textbf{j} &= \\textbf{k} \\\\ \\textbf{j} \\times \\textbf{k} &= \\textbf{i} \\\\ \\textbf{k} \\times \\textbf{i} &= \\textbf{j} \\end{aligned} \\tag{1.33} $$ 反之，按照相反的顺序相接的叉乘等于第三个向量的负值。 【定理1.9】 对于给定系数a，b和任意三个3D向量P、Q和R，有以下性质： \\( \\textbf{P} \\times \\textbf{Q} = - (\\textbf{Q} \\times \\textbf{P}) \\) \\( (a\\textbf{P}) \\times \\textbf{Q} = a(\\textbf{P} \\times \\textbf{Q}) \\) \\( \\textbf{P} \\times (\\textbf{Q} + \\textbf{R}) = \\textbf{P} \\times \\textbf{Q} + \\textbf{P} \\times \\textbf{R} \\) \\( \\textbf{P} \\times \\textbf{P} = \\textbf{0} = &lt;0, 0, 0&gt; \\) \\( (\\textbf{P} \\times \\textbf{Q}) \\cdot \\textbf{R} = (\\textbf{R} \\times \\textbf{P}) \\cdot \\textbf{Q} = (\\textbf{Q} \\times \\textbf{R}) \\cdot \\textbf{P} \\) （注意顺序，满足圆形循环） \\( \\textbf{P} \\times (\\textbf{Q} \\times \\textbf{P}) = \\textbf{P} \\times \\textbf{Q} \\times \\textbf{P} = \\textbf{P}^{2}\\textbf{Q} - (\\textbf{P} \\cdot \\textbf{Q}) \\textbf{P} \\) 前五条都比较容易证明，稍微说一下最后一条的证明方式： $$ \\begin{aligned} \\textbf{P} \\times (\\textbf{Q} \\times \\textbf{P}) &= \\textbf{P} \\times [-(\\textbf{P} \\times \\textbf{Q})] \\\\ &= [\\textbf{P} \\times -(\\textbf{P} \\times \\textbf{Q})] \\\\ &= -[-(\\textbf{P} \\times \\textbf{Q}) \\times \\textbf{P}] \\\\ &= (\\textbf{P} \\times \\textbf{Q}) \\times \\textbf{P} \\\\ &= \\textbf{P} \\times \\textbf{Q} \\times \\textbf{P} \\end{aligned} \\tag{1.35} $$ 后面的具体计算式，是通过对三个分量分别求值得到的结果，不再赘述。 由定理1.9可以得到 叉积不满足交换律和结合律。 4 向量空间【定理1.10】 向量空间是一个集合V，元素成为向量，下面定义向量空间中的加法和乘数，并介绍一些性质： V对于加法运算封闭； V对于乘数运算封闭； V中存在一个零元素 \\(\\textbf{0}\\)； V中任意向量P存在向量Q使其 \\( \\textbf{P} + \\textbf{Q} = \\textbf{0}\\)； 加法满足结合律； 乘数满足结合律； 乘数对于加法满足分配率，\\( a(\\textbf{P} + \\textbf{Q}) = a\\textbf{P} + a\\textbf{Q}\\)； 系数加法对于乘数满足分配率，\\( (a + b)\\textbf{P} = a\\textbf{P} + b\\textbf{P}\\)。 将由n元组组成的向量空间记作 \\(R^{n}\\)，比如三维的向量空间记作\\(R^{3}\\)。 每一个向量空间都可以由一组向量的线性组合来生成，生成向量空间的向量组成为基。 【定义1.11】 对于一组向量 {\\( \\textbf{e}_{1}, \\textbf{e}_{2}, …, \\textbf{e}_{n} \\)}，如果不存在这样一组实数 {\\(a_{1}, a_{2}, …, a_{n}\\)}，其中至少有一个 \\(a_{i}\\) 不为0，使得下式成立： $$ a_{1}\\textbf{e}_{1} + a_{2}\\textbf{e}_{2} + \\cdots + a_{n}\\textbf{e}_{n} = 0 \\tag{1.40} $$ 则称这组向量线性无关，否则称向量组线性相关。 一个n维向量空间可以由n个线性无关的向量组成的向量集合生成，这个向量组成为基。 【定义1.12】 向量空间V的基B是一个由n个线性无关的向量组成的集合，即 \\(\\textbf{B}\\)={\\(\\textbf{e}_{1}, \\textbf{e}_{2}, …, \\textbf{e}_{n} \\)}，对于向量空间V中的任意一个元素P，都存在一组实数使得： $$ \\textbf{P} = a_{1}\\textbf{e}_{1} + a_{2}\\textbf{e}_{2} + \\cdots + a_{n}\\textbf{e}_{n} \\tag{1.41} $$ 任意空间向量\\(R^{n}\\)都具有无限个基，对基的形式进行一些限定后，可以使基具有特定的性质。 【定义1.13】 对于向量空间的基\\(\\textbf{B}\\)={\\(\\textbf{e}_{1}, \\textbf{e}_{2}, …, \\textbf{e}_{n} \\)}，如果对于任意 \\(i \\neq j\\) 都有 \\(\\textbf{e}_{i} \\cdot \\textbf{e}_{j} = 0\\)，则该基为正交基。 【定理1.14】 对于给定的两个向量 \\(\\textbf{e}_{1}\\) 和 \\(\\textbf{e}_{2}\\)， 如果\\(\\textbf{e}_{1} \\cdot \\textbf{e}_{2} = 0\\)，则\\(\\textbf{e}_{1}\\) 和 \\(\\textbf{e}_{2}\\)线性无关。 对基的另一个形式限定就是基的所有向量都具有单位长度（更简单化了），引入Kronecker delta符号 \\(\\delta_{ij}\\)，定义如下： $$ \\delta_{ij} = \\left\\{ \\begin{aligned} 1, i&=j \\\\ 0, i&\\neq j \\end{aligned} \\right. \\tag{1.42} $$ 【定理1.15】 如果对于每一对 \\((i, j)\\) 有 \\(\\textbf{e}_{i} \\cdot \\textbf{e}_{j} = \\delta_{ij}\\)，则基 \\(\\beta\\)={\\(\\textbf{e}_{1}, \\textbf{e}_{2}, …, \\textbf{e}_{n} \\)}称为向量空间的正交规范基。 显然向量组{\\(\\textbf{i}, \\textbf{j}, \\textbf{k}\\)}是\\(R^{3}\\)的一个正交规范基。 有一个方法可以将具有n个线性无关向量的向量组转换为向量空间\\(R^{n}\\)的正交基，基本思想是减去向量在前面每个向量上的投影，结果肯定和前面所有的向量正交。 【定理1.16】 Gram-Schmidt 正交规范化： 对于由n个线性无关想了组成的向量组\\(\\textbf{B}\\)={\\(\\textbf{e}_{1}, \\textbf{e}_{2}, …, \\textbf{e}_{n} \\)}，算法可以产生向量组\\(\\beta\\)={\\(\\textbf{e}_{1}^{‘}, \\textbf{e}_{2}^{‘}, …, \\textbf{e}_{n}^{‘} \\)}，当 \\(i \\neq j\\)时，\\(\\textbf{e}_{i}^{i} \\cdot \\textbf{e}_{j}^{i} = 0\\)。 设 \\(\\textbf{e}_{1}^{‘} = \\textbf{e}_{1}\\)； 从i=2开始； 从\\(\\textbf{e}_{i}\\)中减去\\(\\textbf{e}_{i}\\)在向量\\(\\textbf{e}_{1}^{‘}, \\textbf{e}_{2}^{‘}, …, \\textbf{e}_{i-1}^{‘} \\)上地投影，结果为\\(\\textbf{e}_{i}^{‘}\\)，即 $$ \\textbf{e}_{i}^{'} = \\textbf{e}_{i} - \\sum_{k=1}^{i-1} proj_{\\textbf{e}_{k}} \\textbf{e}_{i} = \\textbf{e}_{i} - \\sum_{k=1}^{i-1} \\frac{\\textbf{e}_{i} \\cdot \\textbf{e}_{k}}{\\textbf{e}_{k}^{2}} \\textbf{e}_{k} \\tag{1.43} $$ 如果i &lt; n，i加1，重复步骤3。 如果需要进一步生成正交规范基，就对每个\\(\\textbf{e}_{i}^{‘}\\)进行规范化。","link":"/2020/11/27/3dmath-c1/"},{"title":"《剑指Offer》第2章笔记 数组","text":"数据结构是技术面的重点，主要围绕数组、字符串、链表、树、栈以及队列这几种常见的数据结构展开。 嗯，除了语言和算法以外的最重要的（废话）。 数组的一些特点（主要是指C/C++中的基础数组类型）： 连续的内存，按照顺序存储； 创建时需要指定数组的容量大小； O(1)时间读/写任何位置元素； 为了解决基础数组空间效率不高的问题，人们设计了动态数组，比如 C++ STL 中的 vector ，其中为了避免空间浪费，先为数组开辟小空间，当数据数目超过容量时，再重新分配一块更大的空间，把之间的数据复制到新的数组中，再把之前的内存释放（一般没有延续之前地址往后申请内存的操作，所以只能整块申请，然后再释放掉新的），但是这样就会带来内存空间申请和数据迁移的时间开销，因此使用动态数组要尽量减少改变数组容量大小的操作。 在C/C++中，数组和指针既相互关联又有区别。 声明一个数组时，数组的名字也是一个指针（不可修改的指针变量），该指针指向数组的第一个元素。需要注意的是，C/C++不会主动记录数组的大小，所以在访问数组元素时，程序要确保不会超过边界。 1234567891011121314151617int get_size(int data[]) { return sizeof(data);}Error: Cannot find module 'gulplog'int main() { int data1[] = {1, 2, 3, 4, 5}; int size1 = sizeof(data1); int* data2 = data1; int size2 = sizeof(data2); int size3 = get_size(data1); printf(&quot;%d, %d, %d&quot;, size1, size2, size3); // 20, 4, 4} 在上面的代码中： sizeof(data1) == 20：sizeof(data1)求数组的大小（字节数），data1包含5个整数，每个整数4字节，所以20字节； sizeof(data2) == 4：data2声明是指针，尽管指向了数组指针，但本质仍然是指针，在32位系统上，对任意指针求sizeof都是4(32位系统是4个字节的地址)； get_size(data1) == 4：在C/C++中，数组作为函数参数传递时，会退化为同类型的指针，尽管函数声明的是数组参数，但还是会退化为指针（语言概念特色），所以结果仍然是4。 面试题3 题目一：找出数组中重复的数字。 数组长度n，数字都在 0 - n-1 的范围内，数组中某些数字重复，但不知道有几个数字重复，请找出数组中任意一个重复数字；例如{2, 3, 1, 0, 2, 5, 3}，重复数字2或者3。 思路1：简单的排序再搜索就可以，但需要 O(nlogn) 的时间开销； 改进思路2：常用的一种优化思路是使用哈希表，从头到尾记录所有数字的出现次数，如果次数大于2就是重复的数字，时间开销降低到了 O(n) ，但凭空多了哈希表的 O(n) 开销； 大部分的人都能想到第二种方法，然后书的作者会介绍第三种方法： 数字都在0~n-1的范围内，如果数组不重复，则数字i出现在下标i的位置，如果重复，则某些位置有多个数字，同时有些位置没有数字。 但我觉得对这种方法的阐述，稍微有点凭空跳脱，没有和之前提到的前两种思路有任何延续，所以一时可能较于难以理解这里的思路，尤其是之后的算法流程。 我们可以延续之前的改进思路2，使用哈希表的优点是时间开销少，缺点是多了空间开销，那么进一步的优化思路是：如何减少空间上的开销？ 在已知数字出现在 0 ~ n-1 范围内时，哈希表的一种简单实现是位置i存储数字i的出现频率： 1234int array[5] = {1, 3, 3, 0, 2};int hash[5] = {0, 0, 0, 0, 0};... // for num in array to finish hashcout &lt;&lt; hash &lt;&lt; endl; // [1, 1, 1, 2, 0] 那么，你可以想到的一种优化思路是：原数组存储的数字在读取过一次后其实就没有作用了，所以在数字i被读取了之后，将它“自己的位置”作为哈希表的存储位，不就不需要额外的空间了么？ 更加细节地，在数字i被读取了过后，尽管它本身可能不在位置i上，可以把原本位置i的数字替换到当前的位置，最后我们使用位置i作为数字i的哈希表存储位，就完成了一步操作；对全数组的数字都执行这样的操作，就可以找出重复的数字了。 这个方法本质上是延续哈希表的思路，并且具体实现的方式你就会发现和作者提出的方法是一致的，所以我猜测作者的实质本意是将改进思路2的一种延续优化，但并没有在书中进行说明这种思路转变，稍微有点儿可惜。 PS：这样的改进思路在延续了简单哈希表实现的同时，也延续了这样的哈希表缺点，即无法处理0 ~ n-1 范围以外的数字情况。 从头到尾依次扫描数组中的每个数字，当扫描到位置i的数字m时，判断m==i： 如果相等，说明数字i在位置i上，继续执行； 如果不相等，将位置m上的数字交换到位置i上，位置m上放置了数字m，从位置i继续下一步判断；如果在交换之前发现，位置m上已经是数字m了，那么就说明数字m重复了，程序结束。 一个栗子： 12345678[1, 3, 3, 0, 2] // i=0[3, 1, 3, 0, 2] // i=0 1 on 1[0, 1, 3, 3, 2] // i=0 3 on 3[0, 1, 3, 3, 2] // i=0 0 on 0[0, 1, 3, 3, 2] // i=1 1 on 1[0, 1, 2, 3, 3] // i=2 2 on 2[0, 1, 2, 3, 3] // i=3 3 on 3[0, 1, 2, 3, 3] // i=4 3 already on 3, 3 repeat 完整代码实现： 123456789101112131415161718192021222324252627282930313233#include &lt;iostream&gt;int find_repeat(int array[], int len) { int i = 0; while(i &lt; len) { int m = array[i]; if(m != i) { if(array[m] != m) { // swap int temp = array[m]; array[m] = m; array[i] = temp; } else { return m; } } else { i++; } } return len;}int main() { int array[] = {1, 3, 3, 0, 2}; int len = sizeof(array) / sizeof(array[0]); int dup = find_repeat(array, len); if(dup == len) { printf(&quot;No Repeat Number\\n&quot;); } else { printf(&quot;Repeat Number: %d\\n&quot;, dup); } return 0;} 在其中还可以加上前一节提到的安全、边界等问题的考虑，在下面贴的作者的实现里面可以看到： 1234567891011121314151617181920212223242526bool duplicate(int array[], int len, int* dup) { // 考虑参数失效 if(array == nullptr || len &lt;= 0) { return false; } // 考虑超过边界 for(int i = 0; i &lt; len; i++) { if(array[i] &lt; 0 || array[i] &gt; len - 1) { return false; } } // 实现比较优雅 流程相同 for(int i = 0; i &lt; len; i++) { while(array[i] != i) { if(array[i] == array[array[i]]) { *dup = array[i]; return true; } // swap int temp = array[i]; array[i] = array[temp]; array[temp] = temp; } } return false;} 面试题3 题目二：不修改数组找出重复的数字。 在长度n+1的数组里的所有数字都在1~n的范围内，所以数组至少有一个数字是重复的。请找出数组中任意一个重复的数字，但不能修改输入的数组。 这一题虽然可以像题目一那样，只需要多开辟一个n+1长度的辅助数组，用来解决问题，但是这样就多了O(n)的空间开销。 一般在这种限定情况下，很难再和题目一一样做到时间、空间开销非常小的情况下完成任务，所以可以退一步，不需要缩减到O(n)时间，比如维持和快排复杂度O(nlogn)相同情况下，达成O(1)的空间开销也是一种优化的思路。 因为出发点不同，我们再次退回到最简单的方法： 没有额外的空间帮助记录时，就只能每次判断一个数字是否有重复，即判断n次，每次有n长度的遍历开销，也就是O(n^2)； 所以有两个优化的方向：（1）减少判断的次数n；（2）减少遍历长度n。 在没有额外信息辅助的情况下，优化（2）一般是很难做的（因为每个数只有遍历了全部才知道是否有重复），所以我们可以尝试优化（1）的部分。 最简单思路下，只有遍历了1~n的n个数在数组中的情况，才能知道谁重复了，我们可以用一些技巧来减少需要判断的次数。 其实非常巧妙，这条技巧就在题目中：“1~n范围内的数，在长度n+1的数组中必然存在一个重复”，这个命题成立的原因是，如果你遍历一次数组，统计1~n范围内数字的出现次数(n+1)，出现情况是大于n的（这里的n指1~n的这个范围长度），进一步地推广到一个普适命题“i~j范围内的数，在长度n+1的数组中，如果出现次数大于(j-i+1)，那必然存在重复”； 也就是意味着我们只用使用一次O(n)的遍历时间，就可以确定一个范围的数字是否存在重复。这样的性质可以让我们不断地缩小所需要判断的数字范围，这也就是时间开销上的优化。 具体地，我们可以联想到二分法： 一开始将范围1~n分为两部分，一半是1~m，另一半是m+1~n； 如果范围1~m的数字的统计次数大于m，则这个范围内有重复的数字；否则另一半m+1~n的区间里一定有包含重复的数字； 继续二分存在重复数字的范围，重复步骤； 直到确定到某个重复数字。 比如说题目给的例子{ 2, 3, 5, 4, 3, 2, 6, 7 }： [1-4]范围的数字出现5次，[5-7]范围的数字出现3次，重复在[1-4]; [1-2]范围的数字出现2次，[3-4]范围的数字出现3次，重复在[3-4]； [3]数字出现2次，[4]数字出现1次，重复数字是3。 然后简单分析一下时间复杂度，每次遍历统计的时间开销不变O(n)，因为数字范围二分，一共需要走O(logn)步，所以在O(nlogn)时间中可以找出重复数字。 完整代码实现： 123456789101112131415161718192021222324252627282930313233#include &lt;iostream&gt;bool is_repeat(int array[], int len, int start, int end) { int count = 0; for(int i = 0; i &lt; len; i++) { if(array[i] &lt;= end &amp;&amp; array[i] &gt;= start) { count += 1; } } return count &gt; (end - start + 1);}int find_repeat(int array[], int len) { int start = 1; int end = len-1; while(end != start) { int mid = (end + start) / 2; if(is_repeat(array, len, start, mid)) { end = mid; } else { start = mid+1; } } return start;}int main() { int array[] = {2, 3, 5, 4, 3, 2, 6, 7}; int len = sizeof(array) / sizeof(array[0]); int dup = find_repeat(array, len); printf(&quot;Repeat Number: %d\\n&quot;, dup); // 3 return 0;} Tips：上述代码没有考虑一些安全、边界问题，所以比较简短。 需要指出的一点是，上面的使用的这种方法不能保证找出所有重复的数字，例如其中的2也是重复数字，但是算法只找出了3，一个原因是因为只会检查其中一半范围，例如检查到前一半有重复的时候，就不会再检查后一半范围了，另一个原因是算法无法确定是其中一个数字出现2次还是几次。 面试题4：二维数组中的查找 在一个二维整数数组中，每一行从左到右递增，每一列从上到下递增，判断数组中是否含有指定数字。 例如： $$ \\begin{matrix} 1 & 2 & 8 & 9 \\\\ 2 & 4 & 9 & 12 \\\\ 4 & 7 & 10 & 13 \\\\ 6 & 8 & 11 & 15 \\end{matrix} $$ 当一个数和矩阵中间的一个数比较时，除了相等，还有两种情况： (a)当查询数字小于目标数字时，说明目标数字一定不会出现在左上角，剩下需要判断的区域在其右边和下边； (b)当查询数字大于目标数字时，说明目标数字一定不会出现在右下角，剩下需要判断的区域在其左边和上边。 当我们按照常规思路，尝试从(0,0)出发，向右下角进行搜索时，我们跳转到下一格只有通过2种方式，从上转移到下，和从左转移到右，如果我们把已遍历的位置称为“已知信息”，我们可以看到这种搜索方式，大部分“已知信息”都集中在左上部，这在比较出现的两种情况中，要么无法提供任何信息，要么只能提供重叠区域的信息，无法让转移确定下一次的方向。 所以为了避免“已知信息”的浪费，我们可以尝试从右上角(0, n-1)出发，向左下角进行搜索，这样会提供更多的信息，如果发生向下转移，代表上边没有比目标数更大的，如果发生向左转移，代表右边的数比目标数更大，所以导致更加明确的在左下角区域中搜索目标数。 完整代码实现： 1234567891011121314151617181920212223242526272829303132#include &lt;iostream&gt;bool find(int matrix[][4], int rows, int cols, int target) { int i = 0; int j = cols - 1; while(i &lt; rows &amp;&amp; j &gt;= 0) { if(matrix[i][j] &lt; target) { i++; } else if(matrix[i][j] &gt; target) { j--; } else { return true; } } return false;}int main() { int matrix[][4] = { {1, 2, 8, 9}, {2, 4, 9, 12}, {4, 7, 10, 13}, {6, 8, 11, 15} }; int target = 7; if(find(matrix, 4, 4, target)) { printf(&quot;Found!\\n&quot;); } else { printf(&quot;Not Found!\\n&quot;); } return 0;}","link":"/2020/11/26/s2o-c2-array/"},{"title":"《剑指Offer》第2章笔记 链表","text":"链表应该是面试时被提及最频繁的数据结构。 链表的结构很简单，它由指针把若干个节点连接成链状结构，链表的创建、插入节点、删除节点等操作都只需要20行左右的代码就能实现，代码量比较适合面试（哈希表、有向图等复杂的一个操作可能就需要很多代码）。 链表是一种动态数据结构，创建链表时，无须知道链表长度，插入节点时，只需要为新节点分配内存，然后调整指针的指向来确保新节点被链接到链表中；内存分配不是在创建链表时一次性完成的，而是每添加一个节点分配一次内存。 典型的单向链表节点定义： 1234struct Node { int value; Node* next;}; 往链表末尾添加一个节点： 1234567891011121314151617void add_to_tail(Node** phead, int value) { // 头结点是一个指针的指针 Node* pnew = new Node(); pnew-&gt;value = value; pnew-&gt;next = nullptr; if(*phead == nullptr) { // 创建头节点 *phead = pnew; } else { // 添加节点到尾部 Node* pnode = *phead; while(pnode-&gt;next != nullptr) { pnode = pnode-&gt;next; } pnode-&gt;next = pnew; }} 想要在链表中找到第i个节点，那我们只能从头结点开始遍历链表，时间效率为O(n)，而在数组中只需要O(1)的时间。 找到第一个含有某值节点并删除该节点的代码： 1234567891011121314151617181920212223242526272829void remove_node(Node** phead, int value) { if(phead==nullptr || *phead==nullptr) { return; } Node* p_delete = nullptr; if((*phead)-&gt;value == value) { // 头结点删除需要单独考虑操作 p_delete = *phead; *phead = (*phead)-&gt;next; } else { Node* pnode = *phead; // 寻找删除节点的前一个节点 while(pnode-&gt;next != nullptr &amp;&amp; pnode-&gt;next-&gt;value != value) { pnode = pnode-&gt;next; } if(pnode-&gt;next != nullptr &amp;&amp; pnode-&gt;next-&gt;value == value) { // 调整删除节点前一个节点的链接 p_delete = pnode-&gt;next; pnode-&gt;next = pnode-&gt;next-&gt;next; } } if(p_delete != nullptr) { delete p_delete; p_delete = nullptr; }} 一些特殊形式的链表也会被经常考到： 环形链表：链表末尾节点指向头结点（面试题62）； 双向链表：节点还有一个指向前一个节点的指针（面试题36）； 复杂链表：节点还有拥有指向任意节点的指针（面试题35）。 面试题6：从尾到头打印链表 输入一个链表的头节点，从尾到头反过来打印每个节点的值。 1234struct Node { int value; Node* next;}; Tips：如果打算修改输入数据，最好先问面试官是不是允许修改，这里假设面试官不能改变链表的结构。 这道题目需要先访问的节点后输出，可以想到使用栈这种数据结构，每次访问到节点，就压到栈中，输出的时候只需要循环出栈即可。 完整代码实现： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#include &lt;iostream&gt;#include &lt;stack&gt;struct Node { int value; Node* next;};void add_to_tail(Node** phead, int value) { // 头结点是一个指针的指针 Node* pnew = new Node(); pnew-&gt;value = value; pnew-&gt;next = nullptr; if(*phead == nullptr) { // 创建头节点 *phead = pnew; } else { // 添加节点到尾部 Node* pnode = *phead; while(pnode-&gt;next != nullptr) { pnode = pnode-&gt;next; } pnode-&gt;next = pnew; }}void reverse_print(Node** phead) { if(phead==nullptr || *phead==nullptr) { return; } std::stack&lt;Node*&gt; pstack; Node* pnode = *phead; while(pnode != nullptr) { pstack.push(pnode); pnode = pnode-&gt;next; } while(!pstack.empty()) { pnode = pstack.top(); printf(&quot;%d\\t&quot;, pnode-&gt;value); pstack.pop(); }}int main() { int values[] = {1, 2, 3, 4, 5}; Node** phead = new Node*; *phead = nullptr; for(int i = 0; i &lt; 5; i++) { add_to_tail(phead, values[i]); } reverse_print(phead); return 0;} 具体的实现中需要注意到的一个点是头节点的初始化，因为是指针的指针，所以需要先申请一个Node指针类型的指针，new Node*，然后再将头结点指向的节点设置为nullptr，这样才不会在访问时出错。 如果可以使用栈结构来实现，也可以考虑使用递归的方式实现，通过递归访问，只有在返回函数的时候再输出节点，就可以实现逆序输出。 12345678// 调用的时候要使用 *pheadvoid reverse_print_rec(Node* node) { if(node == nullptr) { return; } reverse_print_rec(node-&gt;next); printf(&quot;%d\\t&quot;, node-&gt;value);} 递归的代码相比于使用栈会简洁很多，但是使用递归是有代价的，函数递归使用的栈空间通常会有限制（比自己建立栈的空间要小），所以如果链表过于长可能会导致函数调用栈溢出。","link":"/2020/11/30/s2o-c2-linked/"},{"title":"《剑指Offer》第2章笔记 字符串","text":"字符串的使用频率非常高，为了优化，很多语言都对字符串做了特殊的规定。 C/C++中每个字符串都以字符 \\0 做为结尾，这样便于运行时判断字符数组的尾部，由于这个特点，字符串数组的长度比真实字符串长度要多1才可以，这样容易导致一些错误： 12char str[10];strcpy(str, &quot;0123456789&quot;); // Error 为了节省内存，C/C++把常量字符串放到一个单独的内存区域，当几个指针赋值给相同的常量字符串时，实际上会指向相同的内存地址。但用常量内存来初始化字符数组时，情况又有所不同了，看下面的例子： 12345678910111213int main() { char str1[] = &quot;hello world&quot;; char str2[] = &quot;hello world&quot;; char* str3 = &quot;hello world&quot;; char* str4 = &quot;hello world&quot;; printf(&quot;str1 =%p\\n&quot;, str1); // 0061fe04 printf(&quot;str2 =%p\\n&quot;, str2); // 0061fdf8 printf(&quot;str3 =%p\\n&quot;, str3); // 00409001 printf(&quot;str4 =%p\\n&quot;, str4); // 00409001 return 0;} str1和str2是两个字符数组，在初始化赋值时，运行时为为他们分配两个长度为12字节的内存空间，并把字符串赋值到数组中去（而不是直接拷贝字符串常量地址），所以他们的初始地址是不同的。 str3和str4是两个指针，不需要再分配内存来存储内容，只需要传递地址，所以他们就拷贝了同一个地址。 面试题5：替换空格 实现一个函数，把字符串的每个空格替换成%20，例如输入We are happy.，则输出We%20are%20happy.。 题目来自于网络编程中的URL特殊字符编码，有时候服务器不一定支持一些特殊字符URL，所以需要先将特殊转换成ASCII码的两位十六进制表示，比如空格的ASCII码是32，即十六进制的0x20，空格被替换成%20，比如#的ASCII码为35，十六进制0x23，在URL中被替换成%23。 一般有两种解决方向： 在原字符数组上进行处理； 申请新字符数组，将新内容写进去； 在面试过程中遇到这样的问题，如果确定题目中没有限定说明，可以向面试官进一步地问清楚应该考虑什么样的限定条件。 在这里我们假设（作者假设）面试官需要在原字符数组上替换，输入的字符串后面有足够多的内存空间。 我们仍然从最简思路入手： 思路1：在字符串中进行遍历，当碰到空格时，将空格替换为%20，由于替换的字符串比空格多2个字符，为了放入%20，所以要将后续的字符串后移两位，重复该操作直到字符串没有空格。 假设字符串长度n，对于每个空格字符，需要移动后面O(n)个字符，所以时间开销是O(n^2)。 显然这个方法过于简单，还不是最优解，观察可以发现，有些字符串被反复后移，但其实对于一个固定空格个数的字符串，这些字符串所应该处的最终位置我们是可以计算出来的，比如We are happy.中We前面没有空格，不需要向后移动，are前面有1个空格，所以字符串会被后移2位，happy.前面有2个空格，需要移动4位。 所以对于某些字符串其最终的位置反而是通过计算得到的，不需要反复的重复移动（拷贝字符串时间开销大）。 思路2：使用一个空格计数器，在移动字符串时，根据当前空格计数器来判断当前字符需要后移多少位，然后直接将字符移动到目标位置上，遇到空格时，根据计算的后移位置，直接顺序写入%20。时间开销因为只需要遍历一次字符串，所以是O(n)。 这样的思路还是有亿点点问题需要考虑，如果从头开始移动字符串，则后面的字符串还没有空出来时，就需要先移动后面的字符串，这样就导致问题变得稍微有点复杂，所以我们可以反过来，从尾部开始处理移动操作。 思路3：先遍历一次字符串，统计空格出现次数，计算最终字符串的长度，然后从尾部开始处理移动，申请两个指针，一个指向原字符位置，一个指向移动目标位置，当遇到普通字符时，直接转移，遇到空格时，在目标位置写入替换字符串。时间开销仍然是O(n)。 完整实现代码: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include &lt;iostream&gt;#include &lt;cstring&gt;bool replace(char* str, char* ori, char* rep) { if(str != nullptr &amp;&amp; ori != nullptr &amp;&amp; rep != nullptr &amp;&amp; strlen(str) &gt; 0 &amp;&amp; strlen(ori) &gt; 0 &amp;&amp; strlen(rep) &gt; 0) { int count = 0; int ori_len = strlen(ori); int rep_len = strlen(rep); for(int i = 0; i &lt; strlen(str); i++) { if(strncmp((str+i), ori, ori_len) == 0) { count++; } } if(count == 0) { return true; } char* po = str + strlen(str) + 1; char* pr = po + count * (rep_len - ori_len); while(po &gt;= str) { if(strncmp(po, ori, ori_len) == 0) { for(char* tmp = rep + (rep_len - 1); tmp &gt;= rep; tmp--) { *pr = *tmp; pr--; } po--; } else { *pr = *po; po--; pr--; } } return true; } else { return false; }}int main() { char str[100] = &quot;We are happy.&quot;; char ori[10] = &quot; &quot;; char rep[10] = &quot;%20&quot;; if(replace(str, ori, rep)) { printf(&quot;%s\\n&quot;, str); } else { printf(&quot;Error\\n&quot;); }} Tips：代码和原作者的实现有出入，实现了相对来说比较通用的字符串替换，但是方法以及代码仅仅只针对这道题目而言是有效的，还有非常多该题目以外的问题其实是没有考虑到的，例如需要被替换不是单个的空格而是多个空格甚至是任意字符、替换的字符串如果长度小于被替换字符串该怎么处理，等等（修改上述代码中的初始字符串即可看到结果会出现问题）；不过不在这里继续讨论，可以自行尝试思考。 拓展题练习题： 已排序的两个数组A1和A2，A1尾部有足够多的空间容纳A2，将A2的所有数组插入A1中，并且最终A1中所有数字是有序的。","link":"/2020/11/28/s2o-c2-string/"},{"title":"《3D图形的数学》第2章笔记 矩阵","text":"在三维变换中，矩阵运算是最常用的表达方式。 1 矩阵的性质一个 \\(n \\times m\\) 的矩阵M就是一个有n行和m列的数组，如果 \\(n = m\\) 则矩阵M是方阵，把矩阵M第j列的第i行元素（或者第i行第j列）记作 \\(M_{ij}\\)。 矩阵M的转置，记作 \\(\\textbf{M}^{T}\\)，是一个\\(m \\times n\\)矩阵，其中 \\(M_{ij}^{T} = M_{ji}\\)。 矩阵的数乘，或者叫标量乘积，和向量类似，是乘以矩阵的每个元素。 矩阵的加法，两个相同大小的矩阵，对应行列的元素相加。 矩阵的乘法，如果矩阵F的行数和矩阵G的列数相等，则矩阵F和G可以相乘，假设F是\\(n \\times m\\)的矩阵，G是\\(m \\times p\\)的矩阵，FG就是\\(n \\times p\\)的矩阵，FG在(i, j)位置上的元素可以表示为： $$ (\\textbf{F}\\textbf{G})_{ij} = \\sum_{k=1}^{m}F_{ik}G_{kj} = \\textbf{F}_{i*} \\cdot \\textbf{G}_{*j} \\tag{2.5} $$ 其实也可以看作是矩阵F的第i行和矩阵G的第j列元素之间的点积。 单位阵是\\(n \\times n\\)的矩阵，记作\\(\\textbf{I}_{n}\\)，对于\\(n \\times n\\)的矩阵M，有 \\( \\textbf{M} \\textbf{I}_{n}\\) = \\(\\textbf{I}_{n} \\textbf{M}\\) = \\(\\textbf{M}\\)。 $$ \\textbf{I}_{n} = \\left[ \\begin{matrix} 1 & 0 & \\cdots & 0 \\\\ 0 & 1 & \\cdots & 0 \\\\ \\vdots & \\vdots & \\ddots & \\vdots \\\\ 0 & 0 & \\cdots & 1 \\end{matrix} \\right] \\tag{2.6} $$ 因为单位阵尺寸由情况而定，所以通常把下标n去掉，记作 \\(\\textbf{I}\\)。 【定理2.1】 矩阵有以下性质： 矩阵加法满足交换律和结合律； 系数加法乘矩阵、系数乘矩阵加法，均满足分配率； 【定理2.2】 还具有以下性质： 系数乘矩阵先后不影响结果； 矩阵连乘，先后不影响结果； \\((\\textbf{F}\\textbf{G})^{T}=\\textbf{G}^{T}\\textbf{F}^{T}\\)。 2 线性方程组矩阵提供了一种有效并且简便的线性方程组表示法，例如线性方程组： $$ \\begin{aligned} 3x + 2y - 3z &= 5 \\\\ 4x - 3y + 6z &= 1 \\\\ x - z &= 3 \\end{aligned} \\tag{2.10} $$ 可以用以下矩阵形式表示： $$ \\left[ \\begin{matrix} 3 & 2 & -3 \\\\ 4 & -3 & 6 \\\\ 1 & 0 & -1 \\end{matrix} \\right] \\left[ \\begin{matrix} x \\\\ y \\\\ z \\end{matrix} \\right] = \\left[ \\begin{matrix} 5 \\\\ 1 \\\\ 3 \\end{matrix} \\right] \\tag{2.11} $$ 在未知向量&lt;x,y,z&gt;前面的矩阵叫做系数矩阵，在等号右边的列向量叫做常数向量。常数向量不为0的线性方程组叫做非齐次方程组，常数向量为0叫做齐次方程组。 把系数矩阵和常数向量并置一起（称为增广矩阵），执行基本行变换，就可以得到线性方程组的解。 【定义2.3】 所谓基本行变换就是对一个矩阵执行以下三种变换之一： 两行相互交换； 一行和不为0的系数相乘； 一行与一个不为0的系数乘后加到另一行上。 方程(2.11)为例，写出增广矩阵： $$ \\left[ \\begin{array}{ccc|c} 3 & 2 & -3 & 5 \\\\ 4 & -3 & 6 & 1 \\\\ 1 & 0 & -1 & 3 \\end{array} \\right] \\tag{2.12} $$ 对线性方程组的增广矩阵进行的行变换不会影响线性方程组的解，只是使线性方程组更加容易计算（可以同步理解成，一般求方程组解的步骤，使用方程组互相带入化简，使得方程组最后较容易解出值）。 当用行变换求解一个线性方程组时，目标是把系数矩阵变换为它的最简形式。 【定义2.4】 当且仅当一个矩阵满足一下条件，称为最简形式： 每一个非0行，最左边的非0元素，即前导元素，必须为1； 每一个非0行均在全0行前面，或者说，全0行在矩阵底部； 如果一行前导元素在第j列，则其他行第j列的元素均为0； 对任意两个非0行 \\(i_{2}\\) 和 \\(i_{1}\\)，如果满足\\(i_{2} &gt; i_{1}\\)，并且相应的前导元素分别位于\\(j_{2}\\)和\\(j_{1}\\)列，则必然存在\\(j_{2} &gt; j_{1}\\)。 或者简单来说，对于最简形式的矩阵，前导元素是向下向右的趋势的，并且，包含前导元素的列只有一个1，其他元素都为0。 一个最简形式矩阵例子： $$ \\left[ \\begin{matrix} 1 & 0 & -3 & 0 \\\\ 0 & 1 & 2 & 0 \\\\ 0 & 0 & 0 & 1 \\\\ 0 & 0 & 0 & 0 \\end{matrix} \\right] \\tag{2.14} $$ 【算法2.6】 把一个线性方程组的 \\(n \\times (n+1)\\) 增广矩阵M变换为最简形式，以下每一步的M在逐渐更新，而不是保持原始状态： 下标i=1； 下标j=1，从第1列到第n列开始循环； 找到一个满足行号 \\(k \\geq i\\)，并且 \\(\\textbf{M}_{kj} \\neq 0\\) 的行，如果不存在，跳到步骤8； 如果 \\(k \\neq i\\)，交换第k行和第i行； 使矩阵M的元素(i, j)变为1：将第i行乘以 \\(1 / \\textbf{M}_{ij}\\)； 把第j列中除第i行之外的元素变为0：对于每一行r，\\(1 \\leq r \\leq n\\) 且 \\(r \\neq i\\)，将第i行乘 \\(-\\textbf{M}_{rj}\\)加到第r行上； i加1； 如果\\(j \\leq n\\)，j加1，跳到步骤3。 简单来说，就是每次找到第j列上的前导元素在哪一行，然后把这一行放在对应的位置上，让前导元素变1，再清除第j列上的其它元素，直到再找不到有前导元素的行，算法停止。 对于化简到最简形式后，如何判断方程组解的情况，有以下规律： 如果系数矩阵的最简形式是一个单位阵，方程组有唯一解； 如果有一行或多行全为0，方程组要么无解，要么有无穷多解； 如果某一行系数矩阵为0而常数向量不为0，则方程组无解。 3 逆矩阵对一个\\(n \\times n\\)的矩阵M而言，如果存在一个矩阵\\(M^{-1}\\)，使得 \\(\\textbf{M}\\textbf{M}^{-1}=\\textbf{M}^{-1}\\textbf{M}=\\textbf{I}\\)，则称矩阵M是可逆的，矩阵\\(M^{-1}\\)叫做M的逆矩阵。 并不是每个矩阵都可逆，没有逆矩阵的矩阵叫做奇异矩阵，例如任何一行或一列为0的矩阵就是奇异矩阵。 【定理2.9】 有一行或一列全为0的矩阵是不可逆的。 【定理2.10】 一个矩阵M是可逆的，当且仅当\\(M^{T}\\)是可逆的。 证明： 假设M是可逆的，则\\(M^{-1}\\)存在，所以有： $$ \\textbf{M}^{T}(\\textbf{M}^{-1})^{T} = (\\textbf{M}^{-1}\\textbf{M})^{T} = \\textbf{I}^{T} = \\textbf{I} \\tag{2.29} $$ 并且 $$ (\\textbf{M}^{-1})^{T}\\textbf{M}^{T} = (\\textbf{M}\\textbf{M}^{-1})^{T} = \\textbf{I}^{T} = \\textbf{I} \\tag{2.30} $$ 因此，\\((\\textbf{M}^{-1})^{T}\\)是 \\(\\textbf{M}^{T}\\)的逆矩阵。 类似，如果假设\\(\\textbf{M}^{T}\\)是可逆的，则\\((\\textbf{M}{T})^{-1}\\)存在： $$ \\textbf{M}[(\\textbf{M}^{T})^{-1}]^{T} = [(\\textbf{M}^{T})^{-1}\\textbf{M}^{T})]^{T} = \\textbf{I}^{T} = \\textbf{I} \\tag{2.31} $$ 而且 $$ [(\\textbf{M}^{T})^{-1}]^{T}\\textbf{M} = [(\\textbf{M}^{T}(\\textbf{M}^{T})^{-1})]^{T} = \\textbf{I}^{T} = \\textbf{I} \\tag{2.32} $$ 因此，\\([(\\textbf{M}^{T})^{-1}]^{T}\\)是M的逆矩阵。 【定理2.11】 如果F和G都是\\(n \\times n\\)的可逆矩阵，那么FG也是可逆的，并且 \\((\\textbf{F}\\textbf{G})^{-1}\\) = \\(\\textbf{G}^{-1}\\textbf{F}^{-1}\\)。 求矩阵最简形式的方法（算法2.6）也可以用来计算矩阵逆矩阵，为了计算\\(n \\times n\\)矩阵的逆矩阵，在矩阵的右边并接一个单位阵，以形成一个\\(n \\times 2n\\)的矩阵。 $$ \\left[ \\begin{array}{cccc|cccc} M_{11} & M_{12} & \\cdots & M_{1n} & 1 & 0 & \\cdots & 0 \\\\ M_{21} & M_{22} & \\cdots & M_{2n} & 0 & 1 & \\cdots & 0 \\\\ \\vdots & \\vdots & \\ddots & \\vdots & \\vdots & \\vdots & \\ddots & \\vdots \\\\ M_{n1} & M_{n2} & \\cdots & M_{nn} & 0 & 0 & \\cdots & 1 \\end{array} \\right] \\tag{2.34} $$ 对整个矩阵执行基本行变换操作，直到其左边的\\(n \\times n\\)矩阵变为单位阵，这时右边的\\(n \\times n\\)部分就是M的逆矩阵，如果左边无法化为单位矩阵，则该矩阵不可逆。 【定理2.14】 假设(n \\times n\\)矩阵 \\(M^{‘}\\)是(n \\times n\\)矩阵M进行基本变换后得到的矩阵，则有 \\(M^{‘}=EM\\)，其中E是对单位阵进行相同的基本变换的最终矩阵。 把单位阵经过行变换后得到的矩阵称为初等矩阵，如果为了把矩阵M变为单位阵而必须经过k次基本行变换，那么： $$ \\textbf{I} = \\textbf{E}_{k}\\textbf{E}_{k-1} \\cdots \\textbf{E}_{1}\\textbf{M} \\tag{2.47} $$ 其中矩阵 \\(\\textbf{E}_{1}, \\textbf{E}_{2}, \\cdots, \\textbf{E}_{k}\\)是单位阵对应的k次行变换的初等矩阵，也就是说，矩阵 \\(\\textbf{E}_{k}\\textbf{E}_{k-1} \\cdots \\textbf{E}_{1}\\)之间的积即为M的逆矩阵。 【定理2.15】 当且仅当矩阵M的行是一个线性无关向量集时，(n \\times n\\)矩阵M是可逆的。 4 行列式方阵的行列式得到的是一个标量，矩阵M的行列式记作\\(det \\textbf{M}\\)，行列式使用垂直线取代矩阵两侧的括号。 $$ det \\textbf{M} = \\left| \\begin{matrix} M_{11} & M_{12} & M_{13} \\\\ M_{21} & M_{22} & M_{23} \\\\ M_{31} & M_{32} & M_{33} \\end{matrix} \\right| \\tag{2.50} $$ \\(n \\times n\\)矩阵M的行列式的值由一个递推公式给出，用符号 \\(M^{|i, j|}\\)表示原始矩阵M中第i行和第j列删除后行程的 \\((n-1) \\times (n-1)\\)矩阵，用这种方法，行列式值可用以下方法计算： $$ det \\textbf{M} = \\sum_{i=1}^{n}(-1)^{i+k}M_{ik} det \\textbf{M}^{|i,k|} \\tag{2.53} $$ $$ det \\textbf{M} = \\sum_{i=1}^{n}(-1)^{k+j}M_{kj} det \\textbf{M}^{|k,j|} \\tag{2.54} $$ 其中k是满足条件 \\(1 \\leq k \\leq n\\)的任意常数。 二阶矩阵的行列式公式： $$ \\left| \\begin{matrix} a & b \\\\ c & d \\end{matrix} \\right| = ad - bc \\tag{2.55} $$ 三阶矩阵的行列式公式： $$ \\begin{aligned} \\left| \\begin{matrix} a_{11} & a_{12} & a_{13} \\\\ a_{21} & a_{22} & a_{23} \\\\ a_{31} & a_{32} & a_{33} \\end{matrix} \\right| = a_{11}det\\textbf{M}^{|1,1|} - a_{12}det\\textbf{M}^{|1,2|} + a_{13}det\\textbf{M}^{|1,3|} \\\\ = a_{11}(a_{22}a_{33}-a_{23}a_{32}) - a_{12}(a_{21}a_{33}-a_{23}a_{31}) + a_{13}(a_{21}a_{32}-a_{22}a_{31}) \\end{aligned} \\tag{2.56} $$ 【定理2.16】 执行基本变换对一个矩阵的行列式有以下性质： 两行交换，行列式取反； 矩阵一行乘比例系数a则行列式变为原来的a倍； 把一行的若干倍加到另一行对行列式没有影响。 【推论2.17】 如果矩阵有相同行，则行列式为0。 【定理2.18】 \\(n \\times n\\)矩阵M当且仅当 \\(det \\textbf{M} \\neq 0\\)时是可逆的。 【定理2.19】 对任意两个 \\(n \\times n\\)的矩阵F和G，有 \\(det\\textbf{F}\\textbf{G}=det\\textbf{F}det\\textbf{G}\\)。 Tips：初等矩阵乘积的行列式等于行列式的乘积。 【定理2.20】 假设F是 \\(n \\times n\\)矩阵，如果另一 \\(n \\times n\\)矩阵G的元素为： $$ G_{ij} = (-1)^{i + j} \\frac{det \\textbf{F}^{|j, i|}}{det \\textbf{F}} \\tag{2.62} $$ 那么 \\(\\textbf{G}=\\textbf{F}^{-1}\\)。 通过定理2.20可以推出图形学中经常用的几个逆矩阵计算公式主要是2阶和3阶的。 2阶方阵逆矩阵公式： $$ \\textbf{A}^{-1} = \\frac{1}{det \\textbf{A}} \\left[ \\begin{matrix} A_{22} & -A_{12}\\\\ -A_{21} & A_{11} \\end{matrix} \\right] \\tag{2.63} $$ 3阶方阵逆矩阵公式： $$ \\textbf{B}^{-1} = \\frac{1}{det \\textbf{B}} \\left[ \\begin{matrix} B_{22}B_{33}-B_{23}B_{32} & B_{13}B_{32}-B_{12}B_{33} & B_{12}B_{23}-B_{13}B_{22} \\\\ B_{23}B_{31}-B_{21}B_{33} & B_{11}B_{33}-B_{13}B_{31} & B_{13}B_{21}-B_{11}B_{23} \\\\ B_{21}B_{32}-B_{22}B_{31} & B_{12}B_{31}-B_{11}B_{32} & B_{11}B_{22}-B_{12}B_{21} \\end{matrix} \\right] $$ 5 特征值与特征向量对于可逆方阵，必然存在一个向量，当该向量与可逆方阵相乘时，向量只会发生大小变换而方向不变，即，对于n阶方阵M，存在着非0的n维向量 \\(\\textbf{V}_{1}, \\textbf{V}_{2}, \\cdots, \\textbf{V}_{n}\\)满足： $$ \\textbf{M}\\textbf{V}_{i} = \\lambda_{i}\\textbf{V}_{i} \\tag{2.65} $$ 其中比例系数 \\(\\lambda_{i}\\) 称为矩阵M的特征值，而向量 \\(\\textbf{V}_{i}\\)是对应特征值的特征向量。 对式（2.65）进行变换可得到矩阵的特征值： $$ (\\textbf{M}-\\lambda_{i}\\textbf{I})\\textbf{V}_{i} = \\textbf{0} \\tag{2.66} $$ 对于非0向量 \\(\\textbf{V}_{i}\\)，如果上式成立，矩阵 \\(\\textbf{M}-\\lambda_{i}\\textbf{I}\\)一定是奇异矩阵（不可逆），否则就可以对其求逆，得到: $$ \\textbf{V}_{i} = (\\textbf{M}-\\lambda_{i}\\textbf{I})^{-1}\\textbf{0} = \\textbf{0} \\tag{2.67} $$ 这个非0向量矛盾，所以矩阵 \\(\\textbf{M}-\\lambda_{i}\\textbf{I}\\)的行列式为0，因此可以通过： $$ det(\\textbf{M}-\\lambda\\textbf{I}) = 0 \\tag{2.68} $$ 计算出矩阵的特征值解，由2.68式得出的关于 \\(\\lambda\\)的n阶多项式叫做矩阵M的特征多项式，多项式的根就是矩阵M的特征值。 一旦矩阵的特征值求得，就可以代入式(2.66)，计算出相应的特征向量，因为矩阵 \\(\\textbf{M}-\\lambda_{i}\\textbf{I}\\) 是奇异的，所以简化形式至少有一行全为0，所以有无穷多解（比如特征向量的系数倍数向量也是特征向量），因此特征向量可以表示成任意常数的形式，如果有必要也可以取特征向量的长度为1。 通常，如果矩阵特征值是复数，则相应的特征向量也含有复数元素；确保有实数特征值以及相应的实数特征向量的矩阵是对称矩阵。 【定义2.23】 一个n阶方阵，当且仅当 对任意i和j均有 \\(M_{ij}=M_{ji}\\) 时是对称矩阵，也就是说如果矩阵元素关于主对角线对称，则该矩阵就成为对称矩阵。 【定理2.24】 矩阵元素为实数的对称矩阵的特征值也是实数。 【定理2.25】 对应于对称矩阵M的不同特征值的特征向量是正交的。 6 对角化对角矩阵（对称矩阵的特例），只在主对角线上有非0元素的矩阵。 给定方阵M，如果能找到一个矩阵A使得 \\(\\textbf{A}^{-1}\\textbf{M}\\textbf{A}\\) 是对角矩阵，那么就说矩阵A将矩阵M对角化了。 【定理2.26】 假设M是特征值为 \\(\\lambda_{1}, \\lambda_{2}, \\cdots, \\lambda_{n}\\)的n阶方阵，且与特征值对应的特征向量 \\(\\textbf{V}_{1}, \\textbf{V}_{2}, \\cdots, \\textbf{V}_{n}\\) 是一个线性无关集，则矩阵A： $$ A = [ \\textbf{V}_{1} \\textbf{V}_{2} \\cdots \\textbf{V}_{n} ] \\tag{2.82} $$ 可以将矩阵M对角化，而且 \\(\\textbf{A}^{-1}\\textbf{M}\\textbf{A}\\) 的主对角元素是矩阵M的特征值，即： $$ \\textbf{A}^{-1}\\textbf{M}\\textbf{A} = \\left[ \\begin{matrix} \\lambda_{1} & 0 & \\cdots & 0 \\\\ 0 & \\lambda_{2} & \\cdots & 0\\\\ \\vdots & \\vdots & \\ddots & \\vdots\\\\ 0 & 0 & \\cdots & \\lambda_{n} \\end{matrix} \\right] \\tag{2.83} $$ 相反，如果存在一个可逆矩阵A使得 \\(\\textbf{A}^{-1}\\textbf{M}\\textbf{A}\\) 是一个对角阵，则矩阵A的列必然是矩阵M的特征向量，而 \\(\\textbf{A}^{-1}\\textbf{M}\\textbf{A}\\) 的对角线元素则是矩阵M的特征值。","link":"/2020/12/01/3dmath-c2/"},{"title":"《剑指Offer》第2章笔记 树","text":"树的操作会涉及大量指针，因此与树相关的面试题都不太容易。 树的逻辑很简单： 除根节点之外，每个节点只有一个父节点，根节点没有父节点； 除叶节点之外，每个节点都有一个或多个子节点，叶节点没有子节点； 父节点和子节点之间用指针链接。 面试中大部分都是二叉树，在二叉树中每个节点最多只能有两个子节点。 二叉树中最重要的操作是如何遍历数结构，按照某种顺序访问树的所有节点，通常有几种遍历方式： 前序：父-&gt;左子-&gt;右子； 中序：左子-&gt;父-&gt;右子； 后序：左子-&gt;右子-&gt;父； 层序：从根节点层到叶节点层，按层输出，每一层按照从左到右输出。 二叉树中又有一些特例： 二叉搜索树：在二叉搜索树中，左子节点总是小于或等于父节点，右子节点总是大于或等于父节点，可以平均在O(logn)的时间内根据值在二叉树中查找节点； 堆：堆分为最大堆和最小堆，在最大堆中，根节点的值最大，最小堆中的根节点值最小（其他节点按子树递推），有很多需要快速找到最大值或最小值的问题都可以用堆来解决； 红黑树：把树中的节点定义为红、黑两种颜色，并通过规则确保从根节点到叶节点的最长路径的长度不超过最短路径的两倍；在C++的STL中，set、multiset、map、multimap等都是基于红黑树实现的。 面试题7：重建二叉树 输入二叉树的前序和中序遍历结果，重建该二叉树，假设输入的前序中序结构中都不含有重复的数字。 123456// 二叉树节点定义struct Node { int value; Node* left; Node* right;} 在前序遍历中，第一个数字总是树的根节点；但在中序遍历中，根节点的值在序列中间，左子树的值位于根节点左边，右子树的值位于根节点右边；所以对于一个子树，我们在前序中寻找其根节点（第一个出现的值），然后在中序中根据根节点的位置，把剩下的点分为左子树和右子树。 完整代码实现： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576#include &lt;iostream&gt;#include &lt;exception&gt;struct Node { int value; Node* left; Node* right;};Node* construct_core( int* po_start, int* po_end, int* io_start, int* io_end) { int root_value = po_start[0]; Node* root = new Node(); root-&gt;value = root_value; root-&gt;left = root-&gt;right = nullptr; if(po_start == po_end) { if(io_start == io_end &amp;&amp; *po_start == *io_start) { return root; } else { // Windows Ver Error std::logic_error ex(&quot;Invalid input&quot;); throw std::exception(ex); } } int* io_root = io_start; while(io_root &lt;= io_end &amp;&amp; *io_root != root_value) { io_root++; } if(io_root == io_end &amp;&amp; *io_root != root_value) { // Windows Ver Error std::logic_error ex(&quot;Invalid input&quot;); throw std::exception(ex); } int left_len = io_root - io_start; int* left_po_end = po_start + left_len; if(left_len &gt; 0) { root-&gt;left = construct_core(po_start+1, left_po_end, io_start, io_root-1); } if(left_len &lt; po_end - po_start) { root-&gt;right = construct_core(left_po_end + 1, po_end, io_root+1, io_end); } return root;}Node* construct(int* preodr, int* inodr, int len) { if(preodr == nullptr || inodr == nullptr || len &lt;= 0) { return nullptr; } else { return construct_core(preodr, preodr + len - 1, inodr, inodr + len - 1); }}void post_order_print(Node* node) { if(node != nullptr) { post_order_print(node-&gt;left); post_order_print(node-&gt;right); printf(&quot;%d &quot;, node-&gt;value); }}int main() { int preodr[8] = {1, 2, 4, 7, 3, 5, 6, 8}; int inodr[8] = {4, 7, 2, 1, 5, 3, 8, 6}; Node* root = construct(preodr, inodr, 8); post_order_print(root); // 7 4 2 5 8 6 3 1 return 0;} 面试题8：二叉树的下一个节点 给定二叉树和其中的一个节点，如何找出中序遍历序列的下一个节点？树节点除了有左右子节点指针，还有一个指向父节点的指针。 这类题目一般从各类情况具体分析入手： 如果节点有右子树，则下一个节点就是右子树中的最左子节点； 如果节点没有右子树： 如果该节点是父节点的左子节点，父节点就是下一个节点； 并且该节点是父节点的右子节点，按照中序遍历的逻辑，需要继续往上寻找，直到找到某一个节点A，这个节点A是A父节点的左子节点，如果不存在这样的节点，那就代表原节点为最后一个遍历节点了，没有下一个节点。 面试中遇到这种题，大概率只需要编写指定功能的函数部分，不需要编写完整的代码，所以需要对面试官询问具体的输入输出情况。 123456789101112131415161718192021222324252627282930313233343536#include &lt;iostream&gt;struct Node { int value; Node* left; Node* right; Node* parent;};Node* find_next(Node* node) { if(node == nullptr) { return nullptr; } Node* next = nullptr; if(node-&gt;right != nullptr) { // 右子树的最左子节点（不一定需要是叶节点） Node* temp = node-&gt;right; while(temp-&gt;left != nullptr) { temp = temp-&gt;left; } next = temp; } else if (node-&gt;parent != nullptr) { // 寻找满足条件的祖先节点 // 某个节点是其父节点的左子节点 Node* temp = node; Node* parent = node-&gt;parent; while(parent != nullptr &amp;&amp; temp == parent-&gt;right) { temp = parent; parent = parent-&gt;parent; } next = parent; } return next;}","link":"/2020/12/07/s2o-c2-tree/"},{"title":"《剑指Offer》第2章笔记 栈和队列","text":"栈：先进后出，队列：先进先出。 栈是一个非常常见的数据结构，在计算机领域被广泛应用，比如操作系统会给每个线程创建一个栈用来存储函数调用时各个函数的参数、返回地址以及临时变量等。栈的特点是后进先出。 在栈中通常需要O(n)时间才能找到栈最大或者最小的元素，如果想O(1)时间内找到则需要做特殊的设计。 队列是另一种很重要的数据结构，队列的特点是先进先出。 面试题9：用两个栈实现队列 使用栈实现队列的两个函数appendTail和deleteHead，分别完成在队列尾部插入节点和在队列头部删除节点的功能。 一个典型的队列定义： 123456789101112template&lt;typename T&gt; class CQueue { public: CQueue(void); ~CQueue(void); void appendTail(const T&amp; node); T deleteHead(); private: stack&lt;T&gt; stack1; stack&lt;T&gt; stack2;}; 至于这道题的解法，基于一个简单的原理，将一组数先进行依次进栈、再依次出栈入栈到另一个栈里，再全部进行出栈，就完成了一个简单的队列先进先出。但如果只是单纯的依赖这样的过程，无法极大程度地利用栈的空间（例如用于出栈deleteHead的栈满时，用于进栈appendTail其实还可以继续利用起来）。 定义stack1为入队栈，stack2为出队栈。 入队操作： 当stack1不满时，直接入栈； 当stack1满时： 如果stack2为空，将stack1中的元素依次出栈入栈stack2； 如果stack2中有元素，则无法入队； 出队操作： 当stack2中有元素是，直接出栈； 当stack2为空时： 如果stack1不为空，将stack1所有元素依次出栈入栈stack2，再出栈栈顶元素； 如果stack1为空，则队列为空，无法出队； 完整实现代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#include &lt;iostream&gt;#include &lt;stack&gt;#include &lt;exception&gt;template&lt;typename T&gt; class CQueue { public: // CQueue(void); // ~CQueue(void); void appendTail(const T&amp; node); T deleteHead(); private: std::stack&lt;T&gt; stack1; std::stack&lt;T&gt; stack2;};template&lt;typename T&gt; void CQueue&lt;T&gt;::appendTail(const T&amp; element) { // 不限制栈容量时，直接入栈 stack1.push(element);}template&lt;typename T&gt; T CQueue&lt;T&gt;::deleteHead() { if(stack2.size() &lt;= 0) { while(stack1.size() &gt; 0) { T&amp; data = stack1.top(); // Why use T&amp; stack1.pop(); stack2.push(data); } } if(stack2.size() == 0) { // Throw Empty Error std::logic_error ex(&quot;queue is empty&quot;); throw std::exception(ex); } T head = stack2.top(); stack2.pop(); return head;}int main() { CQueue&lt;int&gt; cqueue; for(int i = 0; i &lt; 5; i++) { cqueue.appendTail(i); } for(int i = 0; i &lt; 3; i++) { std::cout &lt;&lt; cqueue.deleteHead() &lt;&lt; &quot; &quot;; } for(int i = 5; i &lt; 10; i++) { cqueue.appendTail(i); } for(int i = 0; i &lt; 7; i++) { std::cout &lt;&lt; cqueue.deleteHead() &lt;&lt; &quot; &quot;; } return 0;} 相关题目：用两个队列实现一个栈。 简单分析一下思路，模仿入栈操作时，只能用使用入队操作，当需要出栈时，元素在队列尾部，只能将前面所有元素进行出队才能获取到，而出队剩下的元素就继续进入到第二个队列中。","link":"/2020/12/07/s2o-c2-stk-queue/"},{"title":"《实时渲染 4th》第1章笔记 导论","text":"实时渲染一般指计算机里的快速图像生成。 PS：原书《Real Time Rendering 4th》全英文，有些词翻译如果不够好还请见谅。 Tips：屏幕刷新率(refresh rate)和显示频率(display rate)在现在是有区别的； We will not be able to cover every topic in depth, so our goal is to present key concepts and terminology, explain the most robust and practical algorithms in the field, and provide pointers to the best places to go for more information. 虽然这本书没有覆盖到实时渲染涉及到的每一个主题，但本书的目的是呈现关键概念和术语、解释最鲁邦和实用的算法、提供深入了解这些内容的方向指引。 1 内容概览 第2章 图形渲染管线：The Graphics Rendering Pipeline，实时渲染的核心是通过什么样的步骤来将场景传达到显示上； 第3章 图形处理单元：The Graphics Processing Unit，现代GPU中一般通过一组计算单元(fixed-function and programmable units)来实现渲染管线； 第4章 变换：Transforms，变换是操作物体位置、方向、大小以及形状、控制摄像机位置和视角的基本工具； 第5章 着色基础：Shading Basics，着色一般指的是通过材质(Material)和光源(Light)来表现物体，还有一些相关的主题，例如抗锯齿（反走样 antialiasing）、透明处理以及Gamma矫正； 第6章 纹理：Texturing，纹理贴图用于在物体表面呈现纹理； 第7章 光影：Shadows，光影让场景更有真实情感，会介绍一些快速计算光影的流行算法； 第8章 光和颜色：Light and Color，讲解计算机是如何如何量化光和颜色，以及把这些量化转换成显示量纲的方法； 第9章 基于物理的着色：Physically Based Shading，基于物理的着色会更加接近真实； 第10章 局部光照：Local Illumination，主要介绍一些渲染复杂光源的算法，例如光源本身具有物理形状； 第11章 全局光照：Global Illumination，模拟光源和场景之间的交互的算法，进一步增加场景的真实度； 第12章 图像效果：Image-Space Effects，GPU擅长快速处理图像，首先介绍图像滤波(image filtering)和重投影(reprojection)技术，然后介绍一些流行的后期效果，例如镜头光晕(lens flares)、动态模糊(motion blur)以及景深(depth of field)； 第13章 几何之外：Beyond Polygons，三角形不一定总是最快或最真实地描述物体的方式，还有其他方式，例如图片(images)、点云(point clouds)、体素(voxels)等； 第14章 体渲染和透光渲染：Volumetric and Translucency Rendering，介绍体积材质(volumetric material)（例如云、烟、雾）的表达方式以及和光的交互，大到气象效果，小到头发渲染； 第15章 非真实渲染：Non-Photorealistic Rendering，主要介绍一些风格渲染，例如卡通渲染(cartoon shading)、水彩效果(watercoloreffects)； 第16章 几何技术：Polygonal Techniques，几何体数据的来源各种各样，如果需要又快又好地渲染，就需要进行一定处理，涉及到几何数据表达和压缩方法； 第17章 曲线和曲面：Curves and Curved Surfaces，复杂的表面表达提供的优势在于更好的在质量和速度中进行取舍，表达越简洁，曲面就越光滑； 第18章 管线优化：Pipeline Optimization，寻找渲染瓶颈来优化速度，涉及到一些多线程技术； 第19章 加速算法：Acceleration Algorithms，比快更快，Variousforms of culling and level of detail rendering are covered； 第20章 高效着色：Efficient Shading，越多的光源，渲染就越慢，在渲染前无法知道是否需要渲染会造成资源浪费，使用一些方法可以解决这些问题； 第21章 虚拟现实和增强现实：Virtual and Augmented Reality，这些领域有很多特定的技术难题，也有一些相应方法来高效快速的生成图像； 第22章 相交检测：Intersection Test Methods，深入介绍一些几何相交检测的高效算法； 第23章 图形硬件：Graphics Hardware，图形硬件的一些细节，例如色彩深度(color depth)、帧缓冲(framebuffers)和基础架构类型； 第24章 面向未来：The Future，Take a guess (we do)。 还有一些没有收录在实体书中，在realtimerendering.com上更新的章节： 碰撞检测：Collision Detection，The 3rd edition’s chapter on this subject has been fully updated, but could not fit in the bounds of the physical book； 实时光线追踪：Real-Time Ray Tracing，API support for this area was announced in March 2018, too late for inclusion in the book, so we wrote an additional chapter about the subject as a whole. 附录：Appendices，The two appendices, Some Linear Algebra and Trigonometry, also had to be cut from the physical book. 2 标记和定义2.1 数学标记 向量或者点通常用粗体小写字母表示，并且其内部组成一般写为： $$ \\textbf{v} = \\left( \\begin{matrix} v_{x} \\\\ v_{y} \\\\ v_{z} \\end{matrix} \\right) $$ 在图形学领域中一般用列向量的表达方式，有时候为了书面方便也会写成行向量。 书中使用到矩阵大多是 \\(2 \\times 2\\)，\\(3 \\times 3\\) 和\\(4 \\times 4\\)，以\\(3 \\times 3\\)矩阵为例，说明矩阵的表示方式： $$ \\textbf{M} = \\left( \\begin{matrix} m_{00} & m_{01} & m_{02} \\\\ m_{10} & m_{11} & m_{12} \\\\ m_{20} & m_{21} & m_{22} \\end{matrix} \\right) \\tag{1.1} $$ 有时候为了表达需求，会只关注行向量或者列向量的内容，矩阵也可以写为： $$ \\textbf{M} = \\left( \\begin{matrix} \\textbf{m}_{,0} & \\textbf{m}_{,1} & \\textbf{m}_{,2} \\end{matrix} \\right) = \\left( \\begin{matrix} \\textbf{m}_{0,}^{T} \\\\ \\textbf{m}_{1,}^{T} \\\\ \\textbf{m}_{2,}^{T} \\end{matrix} \\right) \\tag{1.2} $$ 其中 \\(\\textbf{m}_{,j}\\) 代表第j列向量，\\(\\textbf{m}_{i,}\\) 代表第i行向量。 平面的数学表示是 \\(\\pi:\\textbf{n}\\cdot\\textbf{x} + d = 0\\)，其中 \\(\\textbf{n}\\)是平面的法向量，\\(d\\)是标量，平面将空间分为两个子空间，正子空间是 \\(\\textbf{n}\\cdot\\textbf{x} + d &gt; 0\\)，相应的负子空间是 \\(\\textbf{n}\\cdot\\textbf{x} + d &lt; 0\\) 三角形通常用三个点来表示，例如有不共线的三点 \\(\\textbf{v}_{0}, \\textbf{v}_{1}, \\textbf{v}_{2}\\)，构成的三角形是 \\(\\bigtriangleup\\textbf{v}_{0}\\textbf{v}_{1}\\textbf{v}_{2}\\)。 大部分都应该是比较常见的，需要稍微特殊说明的几个： 主要用于二维向量，求二维向量的垂直向量，例如有 \\(\\textbf{v}=(v_{x}, v_{y})\\)，\\(\\textbf{v}^{\\perp}=(-v_{y}, v_{x})\\)； 将x映射为非负空间数，当其为负值时会变为0； 和8较为类似，映射到0-1空间中，大于1变为1，小于0变为0； binomial coefficients，二项式系数，\\(\\left(\\begin{matrix}n \\\\ k\\end{matrix}\\right) = \\frac{n!}{k!(n-k)!}\\)。 一般把 \\(x=0, y=0, z=0\\) 叫做 坐标平面(coordinateplanes)或者轴对齐平面(axis-aligned planes)，将轴 \\(\\textbf{e}_{x}=(1, 0, 0), \\textbf{e}_{y}=(0, 1, 0), \\textbf{e}_{z}=(0, 0, 1)\\)叫做主轴(main axes)或者主方向(main directions)，也分别叫做x轴(x-axis)，y轴(y-axis)和z轴(z-axis)。 C语言数学函数 atan2(y,x) 有时候被经常提及到，它是arctan(x)的一个拓展，主要区别在于 \\(-\\frac{\\pi}{2} &lt; arctan(x) &lt; \\frac{\\pi}{2}\\)，\\(0 \\lep atan2(y, x) &lt; 2\\pi\\)，一种常用操作是计算arctan(y/x)，但是当x=0时会出现除0问题（尽管可能本意是表达一个无穷大数，但C语言会报除0错误），而这时候使用atan2(y,x)可以避免这样的问题。 log(n)函数一般指的是自然数e为底数，而不是以10为底数。 默认情况下均使用右手坐标系。 颜色一般用一个三元向量表示，(red, green, blue)，各项的值都在[0,1]。 2.2 几何定义最原石的一些基础渲染元(basic rendering primitives, also called drawing primitives)，最常用的是点、线和三角形。 在本书中，一组几何体(a collection of geometric entities)通常叫做一个模型(model)或者对象(object)；场景(scene)指的是环境中一组需要渲染模型，场景一般也包括材质描述、光线以及视角定义。 也有些不是使用点、线和三角形这种基础渲染元表达的模型，例如点云、函数表达（贝塞尔曲线）。 2.3 Shading和Shader？本书中的 Shading 和 Shader 是两个截然不同但是又有关联的概念： 前者指的是计算机生成的视觉表达(computer-generated visual appearance)，例如shading model、shading equation以及toon shading这些概念原理； 后者指的是渲染系统中的一个可编程单元，例如vertex shader、shading language。 尽管他们用词形式上有一些混淆，但是要通过语境上下文来判断其指的是哪个概念（在书本以外可能会单独开一页来讲一些概念的区分）。","link":"/2020/12/09/rtr-c1/"},{"title":"11月的计划","text":"11月大概还剩下一周的时间，主要是在尝试起步学一些东西： 《剑指Offer》：大概前几章，简单过一下摸一下这本书的安排规律，每章尽量写一点浓缩知识点； 《3D游戏与计算机图形学中的数学方法》：之前把Games101课程简单过了一下，再通过刷这本书巩固一下基础的数学。 12月的初步规划： 《剑指Offer》； 《3D游戏与计算机图形学中的数学方法》； 《Fundamentals of Computer Graphics》 。 1月的初步规划： 《Effictive C++》； 《Real Time Rendering 4th》； 《游戏引擎架构》。","link":"/2020/11/19/plan-2020-11/"},{"title":"《3D图形的数学》第3章笔记 变换","text":"3D游戏开发过程中，通常需要以某种方式对向量进行变换。 通常用到的变换包括平移、缩放和旋转。 1 通用变换通常把 \\(n \\times n\\) 可逆矩阵M看成是一个从坐标系到另一个坐标系的变换矩阵。 M的列给出了坐标轴从原坐标系到新坐标系的映射；\\(M^{-1}\\)的列给出了坐标轴从新坐标系到原坐标系的映射。 PS：书上的上面两句话，可以尝试从M乘以一个坐标轴单位向量的结果角度来考量，也就理解M的列是如何对一个向量或者坐标的各个轴的处理的。 多个变换可以串联起来，也可以将多个变换矩阵的乘积用一个矩阵来表示，例如 \\(G(MP)=(GM)P\\)，其中G/M是变换矩阵，P是坐标或向量，先做M变换再做G变换的结果可以用一个(GM)矩阵来存储，这样可以对顶点做无数次的变换，不需要额外的存储空间和计算开销。 1.1 正交矩阵正交矩阵的转置等于其逆矩阵。 【定义3.1】 一个n阶可逆方阵M，当且仅当 \\(M^{-1}=M^{T}\\)时，M为正交矩阵。 【定理3.2】 如果向量组 \\(V_{1}, V_{2}, \\cdots, V_{n}\\)构成的一个正交向量集合，则以 \\(V_{j}, (1 \\leq j \\leq n)\\)作为第j列的n阶方阵是正交矩阵。 正交矩阵还有另外一个性质，用于变换向量时，正交矩阵不改变向量的长度和角度（一般指的是两个同样变换的向量夹角）。 【定理3.3】 如果n阶方阵M正交，则M具有保证长度和角度不变的特性。 Tips：证明可以先从不改变两个向量的内积入手，然后再说明对单个向量不改变长度，再推出不改变角度。 由于这样的特性，使用正交矩阵变换可以保持坐标系的整体结构，所以正交矩阵只能用于表示旋转和反射（在某一方向上将点镜像的运算）的组合。 1.2 手向性在三维空间中，由3D向量 \\(V_{1}, V_{2}, V_{3}\\) 构成的坐标系的基具有手向性。对于右手基，有 \\((V_{1} \\times V_{2}) \\cdot V_{3} &gt; 0\\)，即在右手坐标系中， \\(V_{1}, V_{2}\\)的叉积(右手法则下)的方向与 \\(V_{3}\\)的方向形成一个锐角，如果是一个正交规范的右手基，则有 \\(V_{1} \\times V_{2} = V_{3}\\)；若\\((V_{1} \\times V_{2}) \\cdot V_{3} &lt; 0\\)，那么是左手基。 进行奇数次的反射操作，会改变手向性，偶数次的反射相当与一次旋转。通过考查变换矩阵的行列式可以判定矩阵是否存在反射，若行列式为负，则存在反射，用其对任意基的向量进行变换操作后，基的手向性发生改变。如果行列式是正的，则不改变手向性。 另外，正交矩阵的行列式值只可能是1或-1，如果为1，则矩阵只有旋转；如果为-1，则表示旋转操作后再进行一次反射。 2 缩放变换用a作为系数缩放向量P，只需要计算 \\(P^{‘}=aP\\)，在三维空间中，运算也可以表示为和矩阵的乘积： $$ P^{'} = \\left[ \\begin{matrix} a & 0 & 0 \\\\ 0 & a & 0 \\\\ 0 & 0 & a \\end{matrix} \\right] \\left[ \\begin{matrix} P_{x} \\\\ P_{y} \\\\ P_{z} \\end{matrix} \\right] \\tag{3.8} $$ 这种缩放成为统一缩放（各个轴相同缩放系数），如果希望在x,y,z轴以不同的值缩放向量，可以改变对角线上的元素（不再是相同的一个a），这种缩放称为非统一缩放。 $$ P^{'} = \\left[ \\begin{matrix} a & 0 & 0 \\\\ 0 & b & 0 \\\\ 0 & 0 & c \\end{matrix} \\right] \\left[ \\begin{matrix} P_{x} \\\\ P_{y} \\\\ P_{z} \\end{matrix} \\right] \\tag{3.9} $$ 如果想在3个任意轴上进行非统一缩放，就要用到稍微复杂的缩放过程。假设以a,b,c为系数，在U,V,W轴方向上进行缩放，就需要先从坐标系(U,V,W)变换到坐标系(i,j,k) （这一步乘以[U V W]的逆矩阵变换到UVW为ijk坐标轴的空间中），然后在(i,j,k)坐标系中计算缩放（乘以缩放矩阵），最后再还原到(U,V,W)坐标系（乘以[U V W]矩阵变换到原本的ijk坐标轴空间中）。 $$ P^{'} = \\left[ \\begin{matrix} U_{x} & V_{x} & W_{x} \\\\ U_{y} & V_{y} & W_{y} \\\\ U_{z} & V_{z} & W_{z} \\end{matrix} \\right] \\left[ \\begin{matrix} a & 0 & 0 \\\\ 0 & b & 0 \\\\ 0 & 0 & c \\end{matrix} \\right] \\left[ \\begin{matrix} U_{x} & V_{x} & W_{x} \\\\ U_{y} & V_{y} & W_{y} \\\\ U_{z} & V_{z} & W_{z} \\end{matrix} \\right]^{-1} \\left[ \\begin{matrix} P_{x} \\\\ P_{y} \\\\ P_{z} \\end{matrix} \\right] \\tag{3.10} $$ Tips：这一段其实说的有点绕，但其实理解第一步就可以理解后面了，关于为什么是乘以逆矩阵，是因为(U,V,W)中的目标 \\(P^{uvw}\\) 有以下的表示方法： $$ P^{uvw}_{x} \\left[ \\begin{matrix} U_{x} \\\\ U_{y} \\\\ U_{z} \\end{matrix} \\right] + P^{uvw}_{y} \\left[ \\begin{matrix} W_{x} \\\\ W_{y} \\\\ W_{z} \\end{matrix} \\right] + P^{uvw}_{z} \\left[ \\begin{matrix} V_{x} \\\\ V_{y} \\\\ V_{z} \\end{matrix} \\right] \\\\ = \\left[ \\begin{matrix} U_{x} & V_{x} & W_{x} \\\\ U_{y} & V_{y} & W_{y} \\\\ U_{z} & V_{z} & W_{z} \\end{matrix} \\right] \\left[ \\begin{matrix} P^{uvw}_{x} \\\\ P^{uvw}_{y} \\\\ P^{uvw}_{z} \\end{matrix} \\right] = \\left[ \\begin{matrix} P_{x} \\\\ P_{y} \\\\ P_{z} \\end{matrix} \\right] $$ 所以要求得(U,V,W)坐标系下的坐标 \\(P^{uvw}\\) 就要用原坐标乘以矩阵[U V W]的逆矩阵： $$ \\left[ \\begin{matrix} P^{uvw}_{x} \\\\ P^{uvw}_{y} \\\\ P^{uvw}_{z} \\end{matrix} \\right] = \\left[ \\begin{matrix} U_{x} & V_{x} & W_{x} \\\\ U_{y} & V_{y} & W_{y} \\\\ U_{z} & V_{z} & W_{z} \\end{matrix} \\right]^{-1} \\left[ \\begin{matrix} P_{x} \\\\ P_{y} \\\\ P_{z} \\end{matrix} \\right] $$ 这也就解释了第一步为什么乘以的是逆矩阵，后面也就相同的方法来解释了。 3 旋转变换得到将坐标系绕x,y或z轴旋转 \\(\\theta\\)角的矩阵并不难，当A轴指向我们时，所看到的旋转时逆时针方向。 首先看一下二维空间旋转的通用公式，如图3.2所示，通过交换x和y坐标，并将新的x坐标取负，得到(-y,x)，就能够将位于xy平面线上的二维向量P进行90°的逆时针旋转。设旋转向量为Q，则有 \\( Q=&lt;-P_{y}, P_{x}&gt;\\)。向量P和Q组成了xy平面的一个正交基，因此xy平面的任意向量都可以用这两个向量的线性组合来表示。 如图3.3所示，任意向量P以 \\(\\theta\\)角旋转后所形成的二维向量 \\(P^{‘}\\)，都可以用分别平行于P和Q的分量来表示。 $$ P^{'} = Pcos\\theta + Qsin\\theta \\tag{3.11} $$ 带入Q的坐标计算，可以有： $$ \\begin{aligned} P^{'}_{x} &= P_{x}cos\\theta - P_{y}sin\\theta \\\\ P^{'}_{y} &= P_{y}cos\\theta + P_{x}sin\\theta \\end{aligned} \\tag{3.12} $$ 用矩阵改写则有： $$ P^{'} = \\left[ \\begin{matrix} cos\\theta & -sin\\theta \\\\ sin\\theta & cos\\theta \\end{matrix} \\right] P \\tag{3.13} $$ 将单位矩阵的第3行和第3列加入到等式3.13中的2D旋转矩阵，就可以扩展成3D空间中绕z轴的三维旋转，在旋转过程中z坐标保持不变，绕z轴旋转 \\(\\theta\\) 角度的旋转矩阵 \\(R_{z}(\\theta)\\)可以表示为： $$ R_{z}(\\theta) = \\left[ \\begin{matrix} cos\\theta & -sin\\theta & 0 \\\\ sin\\theta & cos\\theta & 0 \\\\ 0 & 0 & 1 \\end{matrix} \\right] \\tag{3.14} $$ 同样，可以分别得到绕x轴和绕y轴旋转\\theta角度的旋转矩阵 \\(R_{x}(\\theta)\\) 和 \\(R_{y}(\\theta)\\)： $$ \\begin{aligned} R_{x}(\\theta) = \\left[ \\begin{matrix} 1 & 0 & 0 \\\\ 0 & cos\\theta & -sin\\theta \\\\ 0 & sin\\theta & cos\\theta \\end{matrix} \\right] \\\\ R_{y}(\\theta) = \\left[ \\begin{matrix} cos\\theta & 0 & sin\\theta \\\\ 0 & 1 & 0 \\\\ -sin\\theta & 0 & cos\\theta \\end{matrix} \\right] \\end{aligned} \\tag{3.15} $$ 3.1 绕任意轴旋转如果如果希望将向量P绕一个任意轴旋转 \\(\\theta\\) 角，选定的任意轴以单位向量A表示，那么可以先将向量P分解为平行于A和垂直于A的分量。如图3.4所示，由于平行分量在旋转过程中保持不变，所以只需要计算垂直于A的分量的旋转。 A是一个单位向量，P在A上地投影为（公式1.18）： $$ proj_{A}P = \\frac{P \\cdot A}{A^{2}} A = (P \\cdot A)A \\tag{3.16} $$ P垂直于A的分量为（公式1.19）： $$ perp_{A} P = P - proj_{A} P = P - (P \\cdot A)A \\tag{3.17} $$ 将垂直于A的分量进行旋转，再加上平行分量，就得到最终的旋转结果。 垂直分量的旋转实在垂直于A轴的平面内进行的，平面中可以用垂直分量和垂直分量旋转90°所形成的向量组成一组正交基，就可以表达该平面内的任意向量，垂直分量旋转90°的向量可以用 \\(A \\times P\\) 得到。 用下面的公式表示 \\(perp_{A}P\\)旋转 \\(\\theta\\)角，即： $$ [P - (P \\cdot A)A]cos\\theta + (A \\times P)sin\\theta \\tag{3.18} $$ 再加上平行分量 \\(proj_{A}P\\)，就可以得到P绕A轴旋转的公式： $$ P^{'} = [P - (P \\cdot A)A]cos\\theta + (A \\times P)sin\\theta + (P \\cdot A)A \\\\ = Pcos\\theta + (A \\times P)sin\\theta + (P \\cdot A)A(1 - cos\\theta) \\tag{3.19} $$ 将其中的 \\(A \\times P\\)和 \\((P \\cdot A)A\\)替换为等价矩阵形式，就可以更加具体的表示出旋转矩阵 \\(R_{A}(\\theta)\\)，公式过于繁杂就不再赘述。 4 齐次坐标还有一个重要的变换是平移操作，在空间中平移坐标系，只需要简单地添加偏移向量，并不会影响坐标轴的方向和尺度，但这种矩阵无法用 \\(3 \\times 3\\)的矩阵来直接表示，需要加一个平移分量： $$ P^{'} = MP + T \\tag{3.22} $$ M为可逆变换矩阵，T是平移向量。 4.1 四维变换可以用一种统一的数学形式来简洁而优雅地表示这些变换（包含平移操作），为了做到这一点，需要将向量从三维扩展到四维，使用 \\(4 \\times 4\\)矩阵来表示变换操作，给3D点P增加一个坐标，并将这个扩展的第四坐标(称为w坐标)的值设为1。 构造一个 \\(4 \\times 4\\)变换矩阵F，F对应于变换矩阵M和3D平移变换T： $$ F = \\left[ \\begin{matrix} M & T \\\\ 0 & 1 \\end{matrix} \\right] = \\left[ \\begin{matrix} M_{11} & M_{12} & M_{13} & T_{x} \\\\ M_{21} & M_{22} & M_{23} & T_{y} \\\\ M_{31} & M_{32} & M_{33} & T_{z} \\\\ 0 & 0 & 0 & 1 \\end{matrix} \\right] \\tag{3.24} $$ 这个矩阵乘以向量 \\(P=&lt;P_{x}, P_{y}, P_{z}, 1&gt;\\) 就等效于公式3.22，同时结果w坐标保持为1. 4.2 点向量和方向向量Tips：书上把点坐标叫做点向量还是蛮奇怪的，就理解成点坐标就行了。 由于方向向量不会受平移变换的影响，所以在其扩展四维时，其w坐标设置为0（其实也可以从两个点坐标相减的角度理解，两个w相减就是0了），这个时候F矩阵中只有左上的 \\(3 \\times 3\\) 部分可以影响方向向量。 4.3 坐标的几何解释假设有一个四维点 \\(P=&lt;x, y, z, w&gt;\\)，其中坐标不为0，这里定义P在三维空间的映像，如果用 \\(\\widetilde{P}\\)表示P在 \\(w=1\\)的三维空间中的投影，\\(\\widetilde{P}\\)可以用下面的公式来表示： $$ \\widetilde{P} = \\tag{3.28} $$ 如图3.6所示（图中省略z轴为了方便表示），三维点 \\(\\widetilde{P}\\) 对应于连接点P与原点的直线和 \\(w=1\\)的平面的交点，从这一点可以知道，对四维向量P作任意系数乘积，其结果都对应于三维空间中一个相同的点，在第4章5节中详细讨论这种投影在三维图形中的重要性。 5 法向量的变换一个多边形模型的顶点除了需要表示空间位置外，还要包含一些附加信息，这些信息用来表示该顶点是如何融合到周围的曲面中的。一般情况下，顶点可能有切线向量和法线向量与之关联。当变换一个模型时，不但要变换顶点，同时还要对与顶点有关的向量进行变换。 可通过求两个顶点之间的差来计算切线向量，所以经过变换的切线向量可以表示为两个变换点的差。如果使用一个矩阵来变换顶点位置，也可以用这个矩阵来变换顶点的切向量。图3.7所示所示为用一个非正交矩阵M变换法向量N时发生的情况，变换后的法向量最终不垂直于变换后的表面。 因为切线方向和法线方向是垂直的，所以同一顶点的切向量T和法向量N必须满足等式 \\(N \\cdot T = 0\\)，并且必须保证变换后的切向量 \\(T^{‘}\\)和法向量 \\(N^{‘}\\)仍然满足等式，设变换矩阵为M，有 \\(T^{‘}=MT\\)，设变换N所需的矩阵为G，有： $$ N^{'} \\cdot T^{'} = (GN) \\cdot (MT) = 0 \\tag{3.29} $$ 经过简单的运算，可以得到： $$ (GN) \\cdot (MT) = (GN)^{T}(MT) = N^{T}G^{T}MT \\tag{3.30} $$ 由于 \\(N^{T}T=0\\)，如果 \\(G^{T}M=I\\)，则等式 \\(N^{T}G^{T}MT\\) 肯定成立。因此可以得出 \\(G=(M^{-1})^{T}\\)。可以看出，用变换点的矩阵的逆转置矩阵，就能正确地变换法向量，必须通过这种方式变换的向量称为协变向量，用矩阵M以通常方式变换的向量（点或切向量）称为逆变向量。 如果矩阵M是正交的，那么 \\(M^{-1}=M^{T}\\)，因此 \\((M^{-1})^{T}=M\\)，所以当M是正交矩阵时，法向量变换过程的求逆转置运算就可以避免，这一点适用于本章前面提到的当M等于旋转矩阵的情况。 6 四元数四元数是三维图像编程人员用来表示旋转的另一种数学形式。 在许多情况下，用四元数代替旋转矩阵会有很多的好处，因为四元数需要的存储空间更少，四元数之间的连接运算需要的算术运算更少，在产生平滑的三维动画时，用四元数更容易进行修改。 6.1 四元数数学四元数集合，被数学家们称为哈密顿四元数环(ring of Hamiltonian quaternions)，用H表示，可以理解为四维向量空间，空间中的元素q具有以下形式： $$ q = [w, x, y, z] = w + xi + yj + zk \\tag{3.31} $$ 四元数经常写为 \\(q=s+v\\)的形式，其中s表示数量部分，对应于q中的w分量，v表示向量部分，对应于q中的x,y,z分量。 四元数集合是复数集合的自然扩展，四元数的乘法服从分配率，并且虚部i,j,k之间的乘法服从下面的规则： $$ \\begin{aligned} i^{2} &= j^{2} = k^{2} = -1 \\\\ ij &= -ji = k \\\\ jk &= -kj = i \\\\ ki &= -ik = j \\end{aligned} \\tag{3.32} $$ 四元数式的乘法是不可交换的，因此运算要注意顺序。 两个四元数 \\(q_{1}=w_{1}+x_{1}i+y_{1}j+z_{1}k\\) 和 \\(q_{2}=w_{2}+x_{2}i+y_{2}j+z_{2}k\\) 的乘积 \\(q_{1}q_{2}\\) 为： $$ q_{1}q_{2} = \\\\ (w_{1}w_{2} - x_{1}x_{2} - y_{1}y_{2} - z_{1}z_{2}) + \\\\ (w_{1}x_{2} + x_{1}w_{2} + y_{1}z_{2} - z_{1}y_{1})i + \\\\ (w_{1}y_{2} - x_{1}z_{2} + y_{1}w_{2} + z_{1}x_{2})j + \\\\ (w_{1}z_{2} + x_{1}y_{2} - y_{1}x_{2} + z_{1}w_{2})k \\tag{3.33} $$ 如果写成数量-向量形式，则 \\(q_{1}=s_{1}+v_{1}\\) 和 \\(q_{2}=s_{2}+v_{2}\\) 的乘积可以写成如下形式： $$ q_{1}q_{2} = s_{1}s_{2} - v_{1} \\cdot v_{2} + s_{1}v_{2} + s_{2}v_{1} + v_{1} \\times v_{2} \\tag{3.34} $$ 和复数一样，四元数有共轭。 【定义3.4】 四元数 \\(q=s+v\\)的共轭，记为 \\(\\bar{q}\\)，定义为 \\(\\bar{q}=s-v\\)。 通过简单的运算，就可以发现q与其共轭 \\(\\bar{q}\\)的乘积等于q自身的点积，也就是等于q模的平方。 $$ q \\bar{q} = \\bar{q} q = q \\cdot q = ||q||^{2} = q^{2} \\tag{3.35} $$ 【定理3.5】 非零的四元数的逆，记为 \\(q^{-1}\\)，则有： $$ q^{-1} = \\frac{\\bar{q}}{q^{2}} \\tag{3.36} $$ 6.2 四元数的旋转三维空间的旋转可以理解为 \\(R^{3}\\) 到自身 的映射函数 \\(\\varphi\\)。由于\\(\\varphi\\)代表旋转，所以它必须包含长度、角度、旋转方向等信息。如果有： $$ ||\\varphi(P)||=||P|| \\tag{3.39} $$ 则长度保持不变。 如果对任意两个点 \\(P_{1}\\) 和 \\(P_{2}\\)有： $$ \\varphi(P_{1}) \\cdot \\varphi(P_{2}) = P_{1} \\cdot P_{2} \\tag{3.40} $$ 则从原点到两个点 \\(P_{1}\\) 和 \\(P_{2}\\)的连线所形成的夹角保持不变。 最后，如果： $$ \\varphi(P_{1}) \\times \\varphi(P_{2}) = \\varphi(P_{1} \\times P_{2}) \\tag{3.41} $$ 则手向性也保持不变。 如果满足条件 \\(\\varphi(s+v)=s+\\varphi(v)\\)，则函数 \\(\\varphi\\)可以扩展为H到自身的映射，这样就允许将公式(3.40)重写为： $$ \\varphi(P_{1}) \\cdot \\varphi(P_{2}) = \\varphi(P_{1} \\cdot P_{2}) \\tag{3.42} $$ 如果将 \\(P_{1}\\)和 \\(P_{2}\\)看成是数量部分为0的四元数，根据 \\(P_{1}P_{2} = -P_{1} \\cdot P_{2} + P_{1} \\times P_{2}\\)，就可以将等式(3.41)和(3.42)合并成一个等式，在该等式中可以保持角度不变和手向性不变，公式如下： $$ \\varphi(P_{1})\\varphi(P_{2}) = \\varphi(P_{1}P_{2}) \\tag{3.43} $$ 满足这种等式的函数 \\(\\varphi\\) 称为是同态的。 这一类函数可以用下面的公式给出： $$ \\varphi_{q}(P) = qPq^{-1} \\tag{3.44} $$ 其中q是一个非0的四元数，且满足等式(3.39)（长度不变）和(3.43)（角度不变、手向性不变），因此可以表示旋转的集合。 现在需要找到一个关于四元数q的公式，q对应于 \\(\\theta\\)角绕A轴的旋转。简单的计算表明 \\(\\varphi_{aq}=\\varphi_{q}\\) 适用于任何非零数量a，为了简单起见，只涉及单位四元数。设 \\(q=s+v\\) 是单位四元数，则 \\(q^{-1}=s-v\\)，对于给定的点P，有： $$ \\begin{aligned} qPq^{-1} &= (s + v)P(s - v) \\\\ &= (-v \\cdot P + sP + v \\times P)(s - v) \\\\ &= -sv \\cdot P + s^{2}P + sv \\times P + (v \\cdot P)v - sPv - (v \\times P)v \\\\ &= s^{2}P + 2sv \\times P + (v \\cdot P)v - v \\times P \\times v \\end{aligned} \\tag{3.47} $$ 对叉积 \\(v \\times P \\times v\\) 使用定理1.9(6)，这个等式就变为： $$ \\begin{aligned} v \\times (P \\times v) = v \\times P \\times v = v^{2}P - (v \\cdot P) v \\\\ qP^{-1}q = (s^{2}-v^{2})P + 2sv \\times P + 2(v \\cdot P)v \\end{aligned} \\tag{3.48} $$ 设 \\(v=tA\\)，其中A为单位向量，则上式可改写为： $$ qP^{-1}q = (s^{2}-v^{2})P + 2stA \\times P + 2t^{2}(A \\cdot P)A \\tag{3.49} $$ 比较等式(3.19)给出的绕任意轴旋转的公式，可以推出下面的等式： $$ P^{'} = [P - (P \\cdot A)A]cos\\theta + (A \\times P)sin\\theta + (P \\cdot A)A \\\\ = Pcos\\theta + (A \\times P)sin\\theta + (P \\cdot A)A(1 - cos\\theta) \\tag{3.19} $$ $$ \\begin{aligned} s^{2} - t^{2} &= cos\\theta \\\\ 2st &= sin\\theta \\\\ 2t^{2} &= 1 - cos\\theta \\end{aligned} \\tag{3.50} $$ 由第三个等式可以得出： $$ t = \\sqrt{\\frac{1-cos\\theta}{2}} = sin\\frac{\\theta}{2} \\tag{3.51} $$ 结合式(3.50)中第一和第三个等式，可以得出 \\(s^{2}+t^{2}=1\\)，因此可以肯定 \\(s=cos\\frac{\\theta}{2}\\)。 现在可以用下面的等式给出对应于 \\(\\theta\\)角绕A轴旋转的单位四元数q为： $$ q = cos\\frac{\\theta}{2} + Asin\\frac{\\theta}{2} \\tag{3.52} $$ 这里应注意：四元数q的任意数量乘积(特别是-q)表示的是相同的旋转，这是因为之前说的\\(\\varphi_{aq}=\\varphi_{q}\\) 适用于任何非零数量a。 $$ (aq)P(aq)^{-1} = aqP \\frac{q^{-1}}{a} = qP^{-1}q \\tag{3.53} $$ 两个四元数的乘积也可以表示一个旋转，乘积 \\(q_{1}q_{2}\\) 表示先以 \\(q_{2}\\)，后以 \\(q_{1}\\)进行旋转： $$ q_{1}(q_{2}Pq_{2}^{-1})q_{1}^{-1} = (q_{1}q_{2})P(q_{1}q_{2})^{-1} \\tag{3.54} $$ 可以将任意多的四元数结合起来，形成表示一系列旋转的一个四元数，将两个四元数相乘需要做16次乘法和加法运算，而两个 \\(3 \\times 3\\) 矩阵相乘需要27次这样的操作，因此当对物体进行多次旋转时，应用四元数可以获得较高的计算效率。 经常需要将一个四元数变成等价的 \\(3 \\times 3\\)旋转矩阵的形式。利用等式(1.25)和(1.20)，可以确定对应于四元数 \\(q = s + tA\\)的矩阵公式。 $$ P \\times Q = \\left[ \\begin{matrix} 0 & -P_{z} & P_{y} \\\\ P_{z} & 0 & -P_{x} \\\\ -P_{y} & P_{x} & 0 \\end{matrix} \\right] \\left[ \\begin{matrix} Q_{x} \\\\ Q_{y} \\\\ Q_{z} \\end{matrix} \\right] \\tag{1.25} $$ $$ proj_{Q} P = \\frac{1}{Q^{2}} \\left[ \\begin{matrix} Q_{x}^{2} & Q_{x}Q_{y} & Q_{x}Q_{z} \\\\ Q_{x}Q_{y} & Q_{y}^{2} & Q_{y}Q_{z} \\\\ Q_{x}Q_{z} & Q_{y}Q_{z} & Q_{z}^{2} \\end{matrix} \\right] \\left[ \\begin{matrix} P_{x} \\\\ P_{y} \\\\ P_{z} \\end{matrix} \\right] \\tag{1.20} $$ 然后将等式(3.49)改写成矩阵形式(和3.1节中用的技巧类似），由此可得： $$ qPq_{-1} = \\left[ \\begin{matrix} s^{2}-t^{2} & 0 & 0 \\\\ 0 & s^{2}-t^{2} & 0 \\\\ 0 & 0 & s^{2}-t^{2} \\end{matrix} \\right]P + \\\\ 2st\\left[ \\begin{matrix} 0 & -A_{z} & A_{y} \\\\ A_{z} & 0 & -A_{x} \\\\ -A_{y} & A_{x} & 0 \\end{matrix} \\right]P + \\\\ 2t^{2}\\left[ \\begin{matrix} A_{x}^{2} & A_{x}A_{y} & A_{x}A_{z} \\\\ A_{x}A_{y} & A_{y}^{2} & A_{y}A_{z} \\\\ A_{x}A_{z} & A_{y}A_{z} & A_{z}^{2} \\end{matrix} \\right]P \\tag{3.55} $$ 将四元数p写成四维向量 \\(q=&lt;w,x,y,z&gt;\\)，那么 \\(w=s, x=tA_{x}, y=tA_{y}, z=tA_{z}\\)，因此A是单位向量，所以 \\(x^{2}+y^{2}+z^{2} = t^{2}A^{2} = t^{2}\\)，以 \\(w,x,y,z\\)为分量，则公式(3.55)可以改写为： $$ qPq_{-1} = \\left[ \\begin{matrix} w^{2}-x^{2}-y^{2}-z^{2} & 0 & 0 \\\\ 0 & w^{2}-x^{2}-y^{2}-z^{2} & 0 \\\\ 0 & 0 & w^{2}-x^{2}-y^{2}-z^{2} \\end{matrix} \\right]P + \\\\ 2w\\left[ \\begin{matrix} 0 & -z & y \\\\ z & 0 & -x \\\\ -y & x & 0 \\end{matrix} \\right]P + \\\\ 2\\left[ \\begin{matrix} x^{2} & xy & xz \\\\ xy & y^{2} & yz \\\\ xz & yz & z^{2} \\end{matrix} \\right]P \\tag{3.56} $$ 因为q是单位四元数，满足 \\(w^{2} + x^{2} + y^{2} + z^{2} = 1\\)，所以有： $$ w^{2} - x^{2} - y^{2} - z^{2} = 1 - 2x^{2} - 2y^{2} - 2z^{2} \\tag{3.57} $$ 根据该等式，并结合前面的三个矩阵，可以得到用来计算矩阵 \\(R_{q}\\) 的公式，这里的 \\(R_{q}\\) 表示对应于四元数q的旋转矩阵，公式为： $$ R_{q} = \\left[ \\begin{matrix} 1-2y^{2}-2z^{2} & 2xy-2wz & 2xz+2wy \\\\ 2xy+2wz & 1-2x^{2}-2z^{2} & 2yz-2wx \\\\ 2xz-2wy & 2yz+2wx & 1-2x^{2}-2y^{2} \\end{matrix} \\right] \\tag{3.58} $$ 6.3 球形线性插值因为四元数是用向量表示的，所以很适合于插值运算。在产生一个物理动画的过程中，在产生位于两个预先计算的关键帧之间的中间过渡定位时，插值非常有用。 最简单的插值类型是线性插值，对于两个四元数 \\(q_{1}\\)和 \\(q_{2}\\)，线性插值后所得的四元数 \\(q_{t}\\)为： $$ q(t) = (1-t)q_{1} + tq_{2} \\tag{3.59} $$ 当t在0和1之间变化时，函数 \\(q(t)\\)在连接 \\(q_{1}\\)和 \\(q_{2}\\)的线段上平滑变化。 如上图所示，\\(q(t)\\)并不保持 \\(q_{1}\\)和 \\(q_{2}\\)的单位长度，但可以使用下面的函数在任意点位置对 \\(q(t)\\)进行重新规格化： $$ q(t)=\\frac{(1-t)q_{1} + tq_{2}}{||(1-t)q_{1} + tq_{2}||} \\tag{3.60} $$ 尽管线性插值是很有效的，但由等式(3.60)得出的函数 \\(q(t)\\)并没有以恒定的速率描绘 \\(q_{1}\\)和 \\(q_{2}\\)间的过渡弧线，这是线性插值的弊端。如下图所示，\\(q_{1},q_{2}\\)之间的角度变化速率在端点时相对较慢，在中间的地方最快。 我们希望找到一个函数 \\(q(t)\\)，用它对四元数 \\(q_{1}\\)和 \\(q_{2}\\)进行插值时，会保持其单位长度不变并且以恒定的速率扫过位于 \\(q_{1}\\)和 \\(q_{2}\\)之间的夹角。 如果 \\(q_{1}\\)和 \\(q_{2}\\)的夹角为 \\(\\theta\\)，那么这个函数将会产生一个四元数，该四元数在 \\(q(t)\\)和 \\(q_{1}\\)之间形成一个夹角 \\(\\theta t\\)，这里t在0在1之间取值。 如下图所示，四元数 \\(q(t)\\)位于连接 \\(q_{1}\\)和 \\(q_{2}\\)的弧上，与 \\(q_{1}\\)构成夹角 \\(\\theta t\\)，与 \\(q_{2}\\)构成夹角 \\(\\theta(1-t)\\)，可以将 \\(q(t)\\)写成： $$ q(t) = a(t)q_{1} + b(t)q_{2} \\tag{3.61} $$ 如图(a)所示，可以构造相似三角形来确定长度 \\(a(t)\\)，\\(q_{1}\\)到以原点和 \\(q_{2}\\)为端点的线段的垂直距离为 \\(||q_{1}||sin\\theta\\)，而 \\(q(t)\\)到该线段的垂直距离为 \\(||q(t)||sin(\\theta(1-t))\\)，根据相似三角形，可以由： Tips：书上说的这个相似三角形在图(a)中并不明显，是以角 \\(\\theta\\)为共同角，将边 \\(||q(t)||sin(\\theta(1-t))\\) 平移到左边，构成的一个小三角形。 $$ \\frac{a(t)}{||q(t)||sin(\\theta(1-t))} = \\frac{||q_{1}||}{||q||sin\\theta} $$ 所以有： $$ \\frac{a(t)}{||q_{1}||} = \\frac{||q(t)||sin(\\theta(1-t))}{||q||sin\\theta} \\tag{3.62} $$ 由于 \\(||q_{1}||=1\\)，\\(||q(t)||=1\\)，可以将上式简化为： $$ a(t) = \\frac{sin(\\theta(1-t))}{sin\\theta} \\tag{3.63} $$ 图(b)表示了求长度 \\(b(t)\\)的相同过程，有结果： $$ b(t) = \\frac{sin(\\theta t)}{sin\\theta} \\tag{3.64} $$ 可以将球型线性插值函数 \\(q(t)\\)定义如下： $$ q(t)= \\frac{sin(\\theta(1-t))}{sin\\theta}q_{1} + \\frac{sin(\\theta t)}{sin\\theta}q_{2} \\tag{3.65} $$ 这里的角 \\(\\theta\\) 为： $$ \\theta = arccos(q_{1} \\cdot q_{2}) \\tag{3.66} $$ \\(sin\\theta\\)计算： $$ sin\\theta = \\sqrt{1-(q_{1} \\cdot q_{2})^{2}} \\tag{3.67} $$ 因为四元数 \\(q\\) 和\\(-q\\)表示相同的旋转，所以选择四元数 \\(q_{1}\\)和 \\(q_{2}\\)的正负号时一般要满足 \\(q_{1} \\cdot q_{2} \\geq 0\\)，这样可以保证以最短路径的方式进行插值。","link":"/2020/12/12/3dmath-c3/"},{"title":"《剑指Offer》第2章笔记 算法和数据操作","text":"考算法的面试题也备受面试官青睐（老折磨人了）。 通常排序和查找是面试时考查算法的重点，准备的时候要重点掌握二分查找、归并排序和快速排序，要做到随时正确、完整地写出它们地代码。 二维数组上搜索路径的一些题目可以尝试用回溯法，通常回溯法适合用递归代码实现，如果面试官不允许递归实现，再尝试用栈来模拟递归过程。 如果是求解某个问题的最优解，并且问题可以分为子问题解决，就可以尝试用动态规划，如果在分解子问题中，满足一些特定条件就可以找到最优解，可以考虑用贪婪最优法。 1 递归和循环 递归的代码通常比循环更加简洁，但代价是效率不够高，并且还有递归栈层数限制； 在一些题目中简单的递归会增加不必要的重复计算； 应用动态规划解决问题时，大部分都是递归方法分析问题，有些问题会出现子问题重复计算，到时候会讨论如何用循环替换递归实现； 面试题10：斐波那契数列 题目一：求斐波那契数列的第n项，f(0) = 0, f(1) = 1, f(n) = f(n-1) + f(n-2)。 最简单的递归法就不在说明了，这里直接写一下不用重复计算的思路，当需要求解第n项时，需要求解前n-1项，通过观察可以发现从第2项开始计算，可以避免重复计算的问题。 123456789101112131415161718192021222324252627#include &lt;iostream&gt;#include &lt;algorithm&gt;const int max_n = 1000;// 如果不需要缓存，使用两个变量求解即可long long store[max_n];long long fibonacci(unsigned n) { if(n &gt;= max_n) { return -1; // Throw Error } else if (store[n] != -1) { return store[n]; } else { for(int i = 2; i &lt;= n; i++) { store[i] = store[i-1] + store[i-2]; } return store[n]; }}int main() { std::fill(&amp;store[0], &amp;store[max_n], -1); store[0] = 0; store[1] = 1; std::cout &lt;&lt; fibonacci(50) &lt;&lt; std::endl; return 0;} 书上还有一个O(logn)的算法，要使用到一个数学公式： $$ \\left[ \\begin{matrix} f(n) & f(n-1) \\\\ f(n-1) & f(n-2) \\end{matrix} \\right] = \\left[ \\begin{matrix} 1 & 1 \\\\ 1 & 0 \\end{matrix} \\right]^{n-1} $$ 公式可以用数学归纳法证明，问题就转换为如何求矩阵乘方，如果只是简单地从0开始循环，n次方需要n次元素，时间复杂度仍然是O(n)，并不比前面的方法快，但是其中的乘方有如下性质： $$ a^{n} = \\left\\{ \\begin{array}{rcl} a^{n/2} \\cdot a^{n/2}, & & n\\ is\\ even \\\\ a^{(n-1)/2} \\cdot a^{(n-1)/2} \\cdot a, & & n\\ is\\ odd \\end{array} \\right. $$ 从公式可以看出，如果想求得n次方，就要先求得n/2次方，再把n/2次方的结果平方一下即可，时间复杂度为O(logn)。 不过算法仅做了解，很少会这么去写，实现起来也比较复杂。 还有不少面试题可以看成是斐波那契数列的应用： 题目二：青蛙跳台阶问题。 一只青蛙一次可以跳上1级台阶，也可以跳上2级台阶，求该青蛙跳上一个n级的台阶总共有多少种跳法。 将问题看作是求解函数f(n)，当青蛙第1次跳1级，则下一次求解f(n-1)，如果青蛙第1次跳2级，则下一次求解f(n-2)，所以其实本质还是斐波那契数列f(n)=f(n-1)+f(n-2)。 2 查询和排序查询相对于排序较为简单，不外乎顺序查找、二分查找、哈希表查找和二叉排序树查找。在面试的时候，不管是用循环还是递归，面试官都期待应聘者能够信手拈来写出完整正确地二分查找代码，否则可能连继续面试的兴趣都没有。 排序比查找要复杂一点，面试官会经常要求应聘者比较 插入排序、冒泡排序、归并排序、快速排序等不同算法的优劣。 实现快速排序算法的关键在于先在数组中选择一个数字，接下来把数组中的数字分为两部分，比选择的数字小的数字移到数组左边，比选择的数字大的数字移到数组的右边（递增排序）。 （然后就是一段基本上在哪本书上都能看到的快速排序代码） 12345678910111213141516171819202122232425int partition(int data[], int len, int start, int end) { if(data == nullptr || len &lt;=0 || start &lt; 0 || end &gt;= len) { std::logic_error ex(&quot;Invalid Parameters&quot;); throw std::exception(ex); } int index = random_in_range(start, end); swap(&amp;data[index], &amp;data[end]); // end位置存储比较元素 int small = start - 1; // small用来指向存放小于比较元素的位置 for(index = start; index &lt; end; index++) { if(data[index] &lt; data[end]) { // 比比较元素小的就交换到small的地方 small++; if(small != index) { // 如果位置相同就没必要再交换了 swap(&amp;data[index], &amp;data[small]); } } } small++; swap(&amp;data[small], &amp;data[end]); // 比较元素也放回对应位置 return small; // 返回比较元素的位置，划分左右两个子数组} 上面是partition部分的代码，快速排序的其中一步，选择锚元素(比较元素)，将数组start-end区域的元素划分为两部分，一部分小于锚元素，另一部分大于锚元素。 完整的运行代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263#include &lt;iostream&gt;#include &lt;cstdlib&gt;#include &lt;ctime&gt;#include &lt;exception&gt;int random_in_range(int start, int end) { srand((unsigned)time(NULL)); return rand() % (end - start + 1) + start;}void swap(int* lhs, int* rhs) { int temp = *lhs; *lhs = *rhs; *rhs = temp;}int partition(int data[], int len, int start, int end) { if(data == nullptr || len &lt;=0 || start &lt; 0 || end &gt;= len) { std::logic_error ex(&quot;Invalid Parameters&quot;); throw std::exception(ex); } int index = random_in_range(start, end); swap(&amp;data[index], &amp;data[end]); // end位置存储比较元素 int small = start - 1; // small用来指向存放小于比较元素的位置 for(index = start; index &lt; end; index++) { if(data[index] &lt; data[end]) { // 比比较元素小的就交换到small的地方 small++; if(small != index) { // 如果位置相同就没必要再交换了 swap(&amp;data[index], &amp;data[small]); } } } small++; swap(&amp;data[small], &amp;data[end]); // 比较元素也放回对应位置 return small; // 返回比较元素的位置，划分左右两个子数组}void quick_sort(int data[], int len, int start, int end) { if(start == end) { return; // 单个元素，不用排序 } int index = partition(data, len, start, end); if(index &gt; start) { quick_sort(data, len, start, index-1); } if(index &lt; end) { quick_sort(data, len, start+1, end); }}int main() { int data[] = {9, 1, 2, 7, 5, 2, 3, 5, 4, 6}; quick_sort(data, 10, 0, 9); for(int i = 0; i &lt; 10; i++) { printf(&quot;%d &quot;, data[i]); } return 0;} partition函数除了可以用在快速排序中，还可以用来实现在长度n数组中查找第k大的数字，面试题39“数组中出现次数超过一半的数字”和面试题40“最小的k个数”都可以用这个函数来解决。 不同排序的适用场合也不尽相同，快速排序虽然总体的平均效率最好，但不是任何时候都是最优的算法（只是在平均效率上满足O(nlogn)，可以找出一些最坏的情况），所以在面试的时候，如果面试官要求实现一个排序算法，可以先问清楚这个排序应用的环境是什么、有哪些约束条件等等，得到足够多的信息之后再选择合适的排序算法。 面试题11：旋转数组的最小数字 把一个数组最开始的若干的元素搬到数组的末尾，称之为数组的旋转，输入一个递增排序的数组的一个旋转，输出旋转数组的最小元素。例如{3, 4, 5, 1, 2}是{1, 2, 3, 4, 5}的一个旋转，数组的最小值是1。 思路1：简单遍历数组求最小值（无论正序还是逆序），时间开销都是O(n)，大概率不是一个最优解； 思路2：递增排序的一个区间满足性质, 首元素一定小于尾元素，如果考虑到元素可以重复，即如果首元素大于等于尾元素，则该区间可能并不是非递减的。 思路3：思路2通过二分区间判断实现起来还是有一点复杂，还可以进一步地简化思路，每一次判断mid和start、end位置上元素大小关系，如果mid&gt;=start，证明mid位于前面的递增区间，下一步在mid-end中找最小元素；如果mid&lt;=end，证明mid位于后面的递增区间，下一步在start-mid中找最小元素。 按照思路3，start总是指向前面递增数组的元素、end总是指向后面递增数组的元素，当start和end中间没有其他元素时，end就指向后面递增元素的第一个，也就是最小的数字，这也是循环结束的条件。 123456789101112131415161718192021222324252627int min(int* numbers, int len) { if(numbers == nullptr || len &lt;= 0) { std::logic_error ex(&quot;Invalid parameters&quot;); throw std::exception(ex); } int index1 = 0; int index2 = len - 1; int index_mid = index1; while(numbers[index1] &gt;= numbers[index2]) { if(index2 - index1 == 1) { index_mid = index2; break; } index_mid = (index1 + index2) / 2; if(numbers[index_mid] &gt;= numbers[index1]) { // mid在前面的递增数组中，min在后面 index1 = index_mid; } else if(numbers[index_mid] &lt;= numbers[index2]) { // mid在后面的递增数组中，min在前面 index2 = index_mid; } } return numbers[index_mid];} 但上面的方法还有一些特殊情况没有考虑到： 如果只搬动了0个元素到后面，即排序数组本身，上面的方法就不再适用了，但因为此时数组中一个数字就是最小的数字，可以直接返回； 如果index1和index2指向的元素相等，甚至他们都和index_mid指向的元素想等时，应该如何处理呢？这个时候无法简单地判断出min在前面还是后面（参考下面图），所以只能采取简单的遍历法（如果是递归函数实现的话可以都向下计算然后比对最小值）。 完整代码实现： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#include &lt;iostream&gt;#include &lt;exception&gt;int min_in_order(int* numbers, int start, int end) { int min = numbers[start]; for(int i = start + 1; i &lt;= end; i++) { if(min &gt; numbers[i]) { min = numbers[i]; } } return min;}int min(int* numbers, int len) { if(numbers == nullptr || len &lt;= 0) { std::logic_error ex(&quot;Invalid parameters&quot;); throw std::exception(ex); } int index1 = 0; int index2 = len - 1; int index_mid = index1; while(numbers[index1] &gt;= numbers[index2]) { if(index2 - index1 == 1) { index_mid = index2; break; } index_mid = (index1 + index2) / 2; if(numbers[index1] == numbers[index2] &amp;&amp; numbers[index_mid] == numbers[index1]) { // index1 mid index2 均相等，顺序查找 return min_in_order(numbers, index1, index2); } else if(numbers[index_mid] &gt;= numbers[index1]) { // mid在前面的递增数组中，min在后面 index1 = index_mid; } else if(numbers[index_mid] &lt;= numbers[index2]) { // mid在后面的递增数组中，min在前面 index2 = index_mid; } } return numbers[index_mid];}int main() { int numbers[] = {3, 4, 5, 1, 2}; printf(&quot;%d\\n&quot;, min(numbers, 5)); // 1 int onumbers[] = {1, 1, 1, 0, 1}; printf(&quot;%d\\n&quot;, min(onumbers, 5)); // 0 return 0;} 3 回溯法回溯法可以看成蛮力法的升级，它从解决问题的每一步可能选项理选出一个可行的解决方法。回溯法非常适合由多个步骤组成的问题，并且每个步骤都有多个选项。 用回溯法解决的问题的所有选项可以形象地用树状结构表示。在某一步有n个可能的选项，该步骤可以看成是树状结构中的一个节点，每个选项看成树中节点连接线。树的叶节点对应对应着终结状态，如果在叶节点的状态满足题目的约束条件，则找到了一个可行的解决方案。 如果叶节点的状态不满足约束，则只好回溯到它的上一个节点再尝试其他的选项，如果上一个节点所有可能的选项都已经试过，找下一种可能选项时，需要再次回溯到上一个节点（依次类推）。如果所有节点的所有选项都已经尝试过仍然不能达到满足约束条件的终结状态，则该问题无解。 以面试题12来说明回溯法的应用方法。 面试题12：矩阵中的路径 设计一个函数，用来判断一个矩阵中是否存在一条包含某字符串所有字符的路径。路径可以从矩阵中的任意一格开始，每一步可以在矩阵中向左、右、上、下移动一格。如果一条路径经过了矩阵的某一格，那么该路径不能再次进入该格子。 用回溯法解决的典型题，首先在矩阵中任选一个格子作为路径的起点，然后尝试匹配字符串，如果位置字符匹配，则在临近格子中寻找下一步格子，重复上述过程，直到路径上所有字符都在矩阵中找到相应的位置。 由于回溯法的递归特性，路径可以被看成一个栈，当在矩阵中定位了路径中前n个字符位置之后，在与第n个字符对应的格子的周围都没有找到第n+1字符，这时候只好在路径上回到第n-1字符，重新定位第n个字符。 由于路径不能重复进入矩阵的格子，所以要定义和字符矩阵大小一样的布尔值矩阵，用来标识路径已经进入了哪些格子。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970#include &lt;iostream&gt;#include &lt;cstring&gt; // include memset()bool has_path_core(const char* matrix, int rows, int cols, int row, int col, const char* str, int&amp; path_len, bool* visited) { if(str[path_len] == '\\0') { // 前面的字符都找到相应位置了 return true; } bool has_path = false; if(row &gt;= 0 &amp;&amp; row &lt; rows &amp;&amp; col &gt;= 0 &amp;&amp; col &lt; cols &amp;&amp; matrix[row * cols + col] == str[path_len] &amp;&amp; !visited[row * cols + col]) { path_len++; visited[row*col + col] = true; has_path = has_path_core(matrix, rows, cols, row, col-1, str, path_len, visited) || has_path_core(matrix, rows, cols, row-1, col, str, path_len, visited) || has_path_core(matrix, rows, cols, row, col+1, str, path_len, visited) || has_path_core(matrix, rows, cols, row+1, col, str, path_len, visited); if(!has_path) { path_len--; visited[row * cols + col] = false; } } return has_path;}bool has_path(char* matrix, int rows, int cols, char* str) { if(matrix == nullptr || rows &lt; 1 || cols &lt; 1 || str == nullptr) { return false; } bool* visited = new bool[rows * cols]; memset(visited, 0, rows * cols); int path_len = 0; for(int row = 0; row &lt; rows; row++) { for(int col = 0; col &lt; cols; col++) { // 从点(row, col)出发去寻找path if(has_path_core(matrix, rows, cols, row, col, str, path_len, visited)) { return true; } } } delete[] visited; return false;}int main() { char matrix[12] = { 'a','b','t','g', 'c','f','c','s', 'j','d','e','h' }; char str1[10] = &quot;bfce&quot;; if(has_path(matrix, 3, 4, str1)) { std::cout &lt;&lt; str1 &lt;&lt; &quot; in matrxi.&quot; &lt;&lt; std::endl; } else { std::cout &lt;&lt; str1 &lt;&lt; &quot; not in matrxi.&quot; &lt;&lt; std::endl; } // bfce in matrxi. char str2[10] = &quot;abfb&quot;; if(has_path(matrix, 3, 4, str2)) { std::cout &lt;&lt; str2 &lt;&lt; &quot; in matrxi.&quot; &lt;&lt; std::endl; } else { std::cout &lt;&lt; str2 &lt;&lt; &quot; not in matrxi.&quot; &lt;&lt; std::endl; } // abfb not in matrxi. return 0;} 面试题13：机器人的运动范围 地上有一个m行n列的方格。一个机器人从(0,0)的格子开始移动，它每次可以向左、右、上、下移动一格，但不能进入行坐标和列坐标的数位之和大于k的格子。例如，当k为18时，机器人能进入方法(35, 37)，因为3+5+3+7=18，但不能进入方格(35, 38)，因为3+5+3+8=19，请问该机器人能够到达多少格子？ 机器人从(0,0)开始移动，准备进入(i,j)时，要检查坐标的数位来判断是否能够进入，如果能进入，再判断是否能进入4个相邻的格子（不包含已走格子）。 完整代码实现： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061#include &lt;iostream&gt;int get_digit_sum(int num) { int sum = 0; while(num &gt; 0) { sum += num % 10; num /= 10; } return sum;}bool check(int threshold, int rows, int cols, int row, int col, bool* visited) { if(row &gt;= 0 &amp;&amp; row &lt; rows &amp;&amp; col &gt;= 0 &amp;&amp; col &lt; cols &amp;&amp; get_digit_sum(row) + get_digit_sum(col) &lt;= threshold &amp;&amp; !visited[row * cols + col]) { return true; } return false;}int moving_count_core(int threshold, int rows, int cols, int row, int col, bool* visited) { int count = 0; // 检查当前是否可达 if(check(threshold, rows, cols, row, col, visited)) { visited[row * cols + col] = true; count = 1 + moving_count_core(threshold, rows, cols, row - 1, col, visited) + moving_count_core(threshold, rows, cols, row, col - 1, visited) + moving_count_core(threshold, rows, cols, row + 1, col, visited) + moving_count_core(threshold, rows, cols, row, col + 1, visited); } // 返回计数 return count;}int moving_count(int threshold, int rows, int cols) { if(threshold &lt; 0 || rows &lt;= 0 || cols &lt;= 0) { return 0; } bool *visited = new bool[rows * cols]; for(int i = 0; i &lt; rows * cols; i++) { visited[i] = false; } // 从(0, 0)出发，计数count int count = moving_count_core(threshold, rows, cols, 0, 0, visited); delete[] visited; return count;}int main() { std::cout &lt;&lt; moving_count(-1, 1, 1) &lt;&lt; std::endl; // 0 std::cout &lt;&lt; moving_count(0, 1, 1) &lt;&lt; std::endl; // 1 std::cout &lt;&lt; moving_count(12, 40, 40) &lt;&lt; std::endl; // 770 std::cout &lt;&lt; moving_count(18, 40, 40) &lt;&lt; std::endl; // 1484 return 0;} 4 动态规划与贪婪算法如果面试题是求一个问题的最优解(通常是求最大值或者最小值)，而且该问题能够被分解成若干个子问题，子问题之间还有重叠的更小子问题，就可以考虑用动态规划来解决这个问题。 在应用动态规划之前，要先分析是否能把大问题分解成小问题，分解后的每个小问题也存在最优解，如果把小问题的最优解组合起来能够得到整个问题的最优解，则可以应用动态规划来解决这个问题。 在一些题目情况中，相同子问题在分解大问题的过程中重复出现，为了避免重复求解相同子问题，可以用从下往上的顺序先计算小问题的最优解并存储下来，再以此为基础求取大问题的最优解。在应用动态规划解决问题的时候，我们总是从解决最小问题开始，并把已经解决的子问题的最优解存储下来（大部分题目一般用一维或者二维数组里），并把子问题的最优解组合起来逐步解决大的问题。 在应用动态规划时，每一步都面临若干个选择，在求解时只能把所有的可能尝试一遍，然后比较得出最优的选择。 贪婪算法和动态规划不一样，贪婪算法每一步都可以根据规则做出一个最优的选择，基于这个找到最优解，但贪婪算法需要证明每一步的选择是可以保证最后获得最优结果，有时候不要想当然的应用贪婪算法。 面试题14：剪绳子 给你一根长度为n的绳子，请把绳子剪成m段(m、n都是整数，n&gt;1并且m&gt;1)，每段绳子的长度记为k[0],k[1],...,k[m]，请问 k[0] x k[1] x ... x k[m]可能的最大乘积是多少？例如，当绳子的长度是8时，我们把它剪成长度分为2、3、3的三段，此时得到的最大乘积是18。 Tips：这道题里面的一个比较含糊不清的地方是对m的界定，有些题目中可能m也是一个输入量，指计算在这个m段限定条件下n长度绳子的最大结果值（基本上就是另一类题了），而在本书的这道题目中并没有将m看作一个单独的输入量，只是说明后续的计算流程用，在面试遇到这样的情况可以向面试官询问对m的作用界定。 思路1：暴力遍历，第一步有n-1种剪法，第二步有n-2种剪法，…，剪到底的话需要剪n步（每一步可以剪多个绳子），所以可以简单估算时间复杂度O(n^2)； 思路2：动态规划； 思路3：尝试用贪婪算法来解决。 先讲一下动态规划的解法。 首先定义函数f(n)为把长度为n的绳子剪成若干段后各段长度乘积的最大值。在剪第一刀时，有n-1中可能的选择，因此有f(n)=max(f(i) x f(n-i))，其中0&lt;i&lt;n。 这是一个从上至下的递归公式，递归会产生很多重复计算，所以一个更好的办法是按照从下而上的顺序计算，也就是说我们先得到f(2)、f(3)，再得到f(4)、f(5)，直到得到f(n)。比较容易得知f(1)=0、f(2)=1以及f(3)=2，之后就按照迭代公式计算，得到f(n)。 Tips：书上这个题目的解析里面，个人觉得有一点疏漏，f(k-1)的定义应该是在剪后的乘积最大和不剪的自身长度中的最大值，即f(k-1)=max({f(i) x f(k-i), k=1,2,...,n-1}), ，因为只有在计算f(n)的时候是必须要剪断的(因为m&gt;1)，而剩下的子段不是一定要剪断，所以f(k-1), k=1,2,...,n-1的计算方式不能完全照搬f(n)的公式，例如f(1)作为一个长度为1的子段，因为并不是一定要剪，所以其本身可以返回的最大长度是1，而不是0，否则对于一个长度为n的绳子，在剪为1长度和n-1长度的两个子段时，使用f(1)=0，就会导致计算的结果错误，因为在这个情况下是有最后的值的，而并不是0*f(n-1)=0，所以按照修正后的定义，当是子段的时候，f(1)=1，f(2)=2，f(3)=3，f(4)=4，f(5)=6，…，可以发现虽然在k&gt;3这部分定义修正没有意义，但对于k&lt;=3部分是有意义的。 完整实现代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243#include &lt;iostream&gt;int max_product_after_cutting_dyprog(int len) { if(len &lt; 2) { return 0; } if(len == 2) { return 1; } if(len == 3) { return 2; } // 循环替代递归，减少重复子任务，动态规划法 int* products = new int[len + 1]; products[0] = 0; // f(0)=0 products[1] = 1; // 修正定义的f(1)=1 products[2] = 2; // 修正定义的f(2)=2 products[3] = 3; // 修正定义的f(3)=3 int max = 0; for(int i = 4; i &lt;= len; i++) { max = 0; for(int j = 1; j &lt;= i/2; j++) { int product = products[j] * products[i - j]; if(max &lt; product) { max = product; } // products[i] = max; // 书上该行的位置，个人觉得没必要 } products[i] = max; // 个人意见的修正，虽然不影响结果 } max = products[len]; delete[] products; return max;}int main() { // 结果是36 std::cout &lt;&lt; max_product_after_cutting_dyprog(10) &lt;&lt; std::endl; return 0;} Tips：上面的代码除了调整过一行的位置以外，基本上没有修改，可以看到代码中对f(1)、f(2)和f(3)的定义都是符合我之前说的修正后的定义，而不是作者说明的什么f(1)=0、f(2)=1以及f(3)=2，所以也侧面证明之前我对定义的修正是正确的。 接着看一下贪婪算法的解法。 如果按照如下的策略来剪绳子，则得到的各段绳子的长度乘积最大，当n&gt;=5时，尽可能多地剪长度为3的绳子；当剩下的绳子长度为4时，把绳子剪成两段长度为2的绳子。 完整实现代码： 1234567891011121314151617181920212223242526272829303132#include &lt;iostream&gt;#include &lt;cmath&gt;int max_product_after_cutting_greedy(int len) { if(len &lt; 2) { return 0; } if(len == 2) { return 1; } if(len == 3) { return 2; } // 尽可能剪为长度为3的绳子段 int times_of_3 = len / 3; // 剩余长度为4时，不再减去3 if(len - times_of_3 * 3 == 1) { times_of_3 -= 1; } // 代表有多少个2段 int times_of_2 = (len - times_of_3 * 3) / 2; return (int)(pow(3, times_of_3) * pow(2, times_of_2));}int main() { // 结果是36，和动态规划法相同 std::cout &lt;&lt; max_product_after_cutting_greedy(10) &lt;&lt; std::endl; return 0;} 证明一些这种思路的正确性： 首先，当n&gt;=5时，我们可以证明2(n-2)&gt;n并且3(n-3)&gt;n（剪出一长度2子段或剪出一长度3子段），也就是说，当绳子剩下的长度大于等于5时，就把它剪成3或者2的子段，另外，n&gt;=5时，3(n-3)&gt;=2(n-2)，因此我们应该尽可能地多剪长度为3的绳子段（其实书上的这部分证明还并不够严谨，可以自行去严谨地证明）。 那么当长度为4时，可以简单推出最大的情况就是2*2或者不剪的4。 5 位运算位运算是把数字用二进制表示之后，对每一位上0或者1的运算，二进制及其位运算是现代计算机学科的基石，很多底层的技术都离不开位运算（都是基石了咋离得开嘛），因为与位运算相关的题目也经常出现在面试中。 在微软产品Excel中，用A表示第1列，B表示第2列，…，Z表示第26列，AA表示第27列，AB表示第28列，…，以此类推，写出一个函数，输入用字母表示的列号，输出第几列，这就是一个典型的进制转换题目。 位运算总共只有5种运算：与 &amp;、或 ||、异或 ^、左移&lt;&lt;和右移&gt;&gt;。 与、或和异或运算规律可以用下表进行总结： 左移运算法m &lt;&lt; n表示把m左移n位，在左移n位时，最左边的n位将被丢弃，同时在最右边补上n个0，比如： 1200001010 &lt;&lt; 2 = 0010100010001010 &lt;&lt; 3 = 01010000 右移运算符m &gt;&gt; n表示把m右移n位，在右移n位时，最右边的n位将被丢弃，但是在右移时处理最左边位的情形要稍微复杂一点： 如果数字是一个无符号数值，则用0填补最左边的n位； 如果数字是一个有符号数值，则用数字的符号位填补最左边的n位； 数字是正数，右移补0； 数字是负数，左移补1。 1200001010 &gt;&gt; 2 = 0000001010001010 &gt;&gt; 3 = 11110001 面试题15“二进制中1的个数”就是直接考查位运算的例子，而面试56“数组中数字出现的次数”、面试题65“不用加减乘除做加法”等都是根据位运算的特点来解决问题。 面试题15：二进制中1的个数 实现一个函数，输入一个整数，输出该数二进制表示中1的个数，例如，把9表示成二进制是1001，有2个1，所以输出2。 可能会引起死循环的解法：判断整数二进制最右边是否为1，然后进行右移一位再进行判断，直到整个整数变为0为止，至于如何判断一个整数的最右边是不是1，只要把整数和1做位与(&amp;)运算看结果是不是1就只知道了，这个方法的问题在于对于负数的处理会导致死循环，如果是负数，则右移会在首位补1，数字永远不会变为0，最后变为0xffffffff导致死循环； 常规解法：为了避免死循环，可以不右移输入的数字n，而转为左移用来校验的数字1，依次校验数字n的每一位是否为1； 常规解法的代码实现： 1234567891011121314151617181920#include &lt;iostream&gt;int number_of_1(int num) { int count = 0; unsigned int flag = 1; // unsigned int 才能采集到符号位 // 循环次数取决于操作系统中int的存储位数，一般是4字节，32位 while(flag) { // 1从左边溢出后，flag会变成0 if(num &amp; flag) { // 非0 即 该位有1 count++; } flag = flag &lt;&lt; 1; // 赋值更新 } return count;}int main() { std::cout &lt;&lt; number_of_1(255) &lt;&lt; std::endl; // 8 std::cout &lt;&lt; number_of_1(-1) &lt;&lt; std::endl; // 32 return 0;} 令人惊喜的解法：先分析一下把一个数减去1的情况，如果一个整数不等于0，则二进制中至少有一位是1，假设这个数最右边为1，则减1导致最后一位为0，其余位保持不变；假设最后一位是0，如果最右边的1位于第m位，则减一时，第m位由1变0，m位之后的所有0都变成1，m之前的所有位保持不变。根据这两种情况，可以发现把一个整数减1，都是把最右边的1变成0，如果右边有0，则所有0变成1，如果把一个整数和它减去1的结果做位与运算，相当于把最右边的1变成0。以1100为例，减1结果是1011，1100和1011做位运算，结果是1000，即相比于1100把最右边的1变成0。所以最后的思路是，把一个整数减1，再和原整数做与运算，就把最右边1变为0，那么一个二进制中有多少1就可以进行多少次这样的操作。 完整代码实现： 12345678910111213141516#include &lt;iostream&gt;int number_of_1_sp(int num) { int count = 0; while(num) { count++; num = (num - 1) &amp; num; } return count;}int main() { std::cout &lt;&lt; number_of_1_sp(255) &lt;&lt; std::endl; // 8 std::cout &lt;&lt; number_of_1_sp(-1) &lt;&lt; std::endl; // 32 return 0;","link":"/2020/12/20/s2o-c2-algorithm/"},{"title":"1月的计划","text":"距离2021的春招实习只有2个半月了，要开始争分夺秒了（唉，好想给女儿做二创啊）。 感觉前两个月因为各种各样的情况，看书写笔记的效率还是有点低（投入的时间确实也不够多），还有同时要看几本难啃的书确实不容易，之后要分清一下多个任务的主次了。 12月剩下时间的规划： 《剑指Offer》第3、4章，暂时不再写完整的博客了，只贴部分题目的完整实现代码； 《3D游戏与计算机图形学中的数学方法》第3、4、5章，暂时不再写完整博客，会先简单写一些重要知识点摘录（自己打公式太费时间了）； 《Real Time Rendering 4th》第2、3、4章，不再写完整博客，翻译还是有点费时费力，先看一遍过一下好了，主要作为3D数学方法那本书的知识补充。 1月的规划： 《剑指Offer》第5、6章，不写完整博客，只贴部分题目的完整实现代码； 《3D游戏与计算机图形学中的数学方法》第6-9章，暂时不再写完整博客，会先简单写一些重要知识点摘录； 《Real Time Rendering 4th》第5-11章，只读，不写博客； 《Effective C++》的55个条款，尽量都写写代码尝试实践，每一个其实都涉及到不少原本C++中的知识点，应该都要同步学习或者复习一下。 其实就算是真的完成了这么多阅读的任务，还是有很多知识盲区，比如Unity3D、UE4、OpenGL、DirectX、RTX系列技术这种。 2月的初步规划（除掉过年，可能只有大半月的时间）： 面试笔试题，稍微刷一点面试常见的算法题(尤其是mid和hard难度的)，数量控制在100题以内吧，找到用C++解题的手感； 引擎面试题，只能去收集各大厂引擎、渲染方面的面经贴，然后总结各种各样的点，有必要的话拓展去了解； OpenGL，估计至少要走一遍指南吧，代码都敲一敲； Unity3D入门和《Unity Shader 入门精要》，主要是了解Unity方面的相关知识； 各大厂的简历投递，别忘了投简历了，注意提前收集他们的时间。 3月的初步规划（基本上到了冲刺阶段了，剩下半个月时间）： 面试笔试题，每日做题的任务照常安排着走； 引擎面试题，继续看收集的那些面试问题，顺带复习一下以前的笔记； 《游戏引擎架构》，半个月简单刷一下这本书的大致内容，做到都有一定了解即可，当作知识广度阅读资料。","link":"/2020/12/23/plan-2021-01/"}],"tags":[{"name":"笔记","slug":"笔记","link":"/tags/%E7%AC%94%E8%AE%B0/"}],"categories":[{"name":"3D游戏与图形学的数学","slug":"3D游戏与图形学的数学","link":"/categories/3D%E6%B8%B8%E6%88%8F%E4%B8%8E%E5%9B%BE%E5%BD%A2%E5%AD%A6%E7%9A%84%E6%95%B0%E5%AD%A6/"},{"name":"计划-Flags","slug":"计划-Flags","link":"/categories/%E8%AE%A1%E5%88%92-Flags/"},{"name":"剑指Offer","slug":"剑指Offer","link":"/categories/%E5%89%91%E6%8C%87Offer/"},{"name":"Real Time Rendering 4th","slug":"Real-Time-Rendering-4th","link":"/categories/Real-Time-Rendering-4th/"}]}