{"pages":[{"title":"关于我","text":"一个普普通通程序员，专攻(自封)图形学、实时渲染以及游戏引擎，其他领域的例如机器学习、深度学习、数据挖掘、后端开发、前端开发之类的，也都多少懂一点点，出于兴趣学习。 日常就是学点喜欢的技术，写点喜欢的代码，闲的时候画点画。 博客主要用于记载一些阅读书籍的笔记心得，偶尔放一些用于当作品集的炫酷Demo。 联系方式： 日常联系: augbubbles@foxmail.com 工作相关: mi.work@outlook.com","link":"/about/index.html"}],"posts":[{"title":"《剑指Offer》第1章笔记","text":"第1章主要介绍的是几种面试方式的不同流程以及注意事项。 “…技术面试中的5个要素，是全书的大纲,…” 远程桌面面试 思考清楚再开始编码； 良好的代码命名和缩进对齐； 单元测试、断点调试。 面试的3个环节行为面试、技术面试、应聘者提问。 行为面试 自我介绍：30s-1min，介绍主要学习和工作经历； 项目经验：STAR模型描述项目经历； Situation：简短的项目背景； Task：自己完成的任务，注意区分“参与”和“负责”； Action：如何完成任务的，详细介绍自己完成任务的方式方法； Result：自己的贡献，尝试量化自己的产出，让人直接接收到你的成果。 掌握技能：注意区分“了解”、“熟悉”和“精通”； 了解：上过课、看过书，但没有做过实际项目，通常只建议有用的时候再写； 熟悉：通常的情况，指能够独立解决大部分问题； 精通：得心应手，能够轻松回答领域内的绝大多数问题。 为什么跳槽：尽量不说抱怨层面的原因，多从自我发展的角度阐述选择的理由。 技术面试平均1个小时的面试，技术面试会占据40-50分钟的时间。 总的来说面试官关注应聘者的5种素质： 扎实的基础知识：编程语言、数据结构和算法； 能写高质量的代码：代码鲁棒性，边界考虑（另外还需要注意代码规范或者风格）； 分析问题的思路清晰：从简单完备的思路出发，用各种方法来尝试优化，例如画图形象化，举例具象化，分解简单化； 能够优化时间、空间效率：熟知数据结构优缺点，熟练掌握常用算法； 学习、沟通、综合能力。 PS：5个要素分别对应本书的第2、3、4、5、6章节内容。 应聘者提问如果觉得面试后临时想比较困难，可以在面试前提前准备一些问题。 主要围绕公司、职位、项目等工作上的事情，不太适合问较远较模糊或者和工薪相关的问题（之后再和HR聊也可以）。","link":"/2020/11/24/s2o-c1/"},{"title":"《剑指Offer》第2章笔记 编程语言","text":"第2章主要围绕编程语言、数据结构和算法，介绍技术面所需要的“基础知识”。 编程语言书里代码都是用 C/C++/C# 实现的，后面分别从 C++ 和 C# 语言的角度来讲述其中一些被问道的细节点，这样的细节点因为篇幅限制，不可能都写进书里，所以还需要通过阅读对应编程语言的书籍来进阶了解，同时其他语言的使用者也可以从其中窥探到面试官在针对语言掌握的考量时，都是从什么样的角度出发的。 C++通常语言面试的问题有3种类型： 对于语言中概念的理解程度； 面对代码，分析运行结果（或错误）； 在上下文环境中，定义类型或实现函数。 作者推荐的几本C++书，根据自己的情况选择阅读顺序： 《Effective C++》：书中列举了C++经常出现的问题以及解决这些问题的技巧（大多是面试官比较喜欢问的方向），适合面试之前突击C++； 《C++ Primer》：人称C++全书，适合全面了解的时候阅读，也可以当作宝典查询； 《深度探索C++对象模型》：深度了解C++对象的内部机制，介绍很多较为底层的知识点； 《The C++ Programming Language》：C++圣经（大概），适合全面深入掌握C++。 下面通过一道面试题（第3种类型）来表现一下这类题目是如何考查语言知识点的。 面试题1：赋值运算符函数，如下为类型CMyString的声明，请为该类型添加赋值运算符函数。 123456789class CMyString { public: CMyString(char* pData=nullptr); CMyString(const CMyString&amp; str); ~CMyString(void); private: char* m_pData;}; Tips：赋值运算符主要负责变量在进行赋值 = 运算时，如何处理变量对象内部成员变化。 定义C++中的赋值运算符函数时，需要关注点有： 返回值类型声明为引用，函数结束前返回实例自身的引用，因为返回引用才允许连续赋值的情况，例如 str1 = str2 = str3，否则无法通过编译； 把传入的参数类型声明为常量引用，如果不是引用，形参到实参传递会调用一次复制构造函数（函数的传值引用），引用可以避免这样的开销；同时因为赋值运算并不会修改传入的实例的状态，所以应进一步加上 const 关键字； 释放实例自身已有的内存，主要在对象有动态分配内存情况下考虑，如果忘记在分配新内存前释放旧内存空间，程序旧出现了内存泄漏(memory leakge)，这块内存无法被回收使用（资源浪费、占用空间导致空间不够用）； 判断传入参数和当前实例(*this)是不是同一个实例，是则不进行赋值，如果不判断就直接赋值，在同一个实例情况下，会导致在还没有拷贝到传入参数（自己）的内存时，就释放自己的内存，这也就导致传入参数的内存被释放了（因为函数是传引用），最后找不到待赋值的内容。 经典解法： 123456789101112131415#include &lt;cstring&gt;CMyString&amp; CMyString::operator=(const CMyString&amp; str) { if(this == &amp;str) { // 对象的 this 是一个地址 return *this; // 传对象 而不是地址 } delete []m_pData; // 数组的释放方式 m_pData = nullptr; m_pData = new char[strlen(str.m_pData) + 1]; // 申请新空间，多的1位给'\\0' strcpy(m_pData, str.m_pData); // 复制 赋值 return *this;} 如果对自己有更高的要求，应该再进一步地考虑其中涉及到的问题。 前面的函数中，分配内存之前先释放了内存，如果在分配内存时，内存不足就会导致 new char 排除异常，m_pData将是一个空指针，并且无法回退到之前的结果，也就是说一旦赋值运算符内部抛出了异常，实例不再保持有效的状态（并不是原有的状态），这违背了异常安全性（Exception Safety）原则（正常情况下，如果抛出异常也不应该导致内容被错误操作）。 简单的方法是先用 new 分配新内容，再 delete 释放已有的； 更好的办法是创建一个临时实例，再交换临时实例和原来的实例。 12345678910#include &lt;cstring&gt;#include &lt;algorithm&gt;CMyString&amp; CMyString::operator=(const CMyString&amp; str) { if(this == &amp;str) { CMyString tmp(str); // 复制构造函数 std::swap(m_pData, tmp.m_pData); // 交换地址 } return *this;} 当 tmp 局部变量遇到 if 结束时，会自动调用它的析构函数，会把交换下来的 this 的 m_pData 所指向的内存释放掉；在新的代码中，在复制构造函数中分配内存，如果由于内存不足抛出异常时，由于此时还没有修改原来的实例状态，实例的状态依旧是有效的（原有的），也就保证了异常安全性。 完整代码（包含所有实现和测试）： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;class CMyString { public: CMyString(char* pData); // 第一个参数设定默认值会导致无法通过编译 CMyString(const CMyString&amp; str); ~CMyString(void); CMyString&amp; operator=(const CMyString&amp; str); // 赋值运算符函数声明 void print(void); // 标准输出函数 private: char* m_pData;};// 构造函数CMyString::CMyString(char* pData) { if(pData != nullptr) { m_pData = new char[strlen(pData) + 1]; strcpy(m_pData, pData); }}// 复制构造函数CMyString::CMyString(const CMyString&amp; str) { if(str.m_pData != nullptr) { m_pData = new char[strlen(str.m_pData) + 1]; strcpy(m_pData, str.m_pData); }}// 析构函数CMyString::~CMyString(void) { if(m_pData != nullptr) { delete []m_pData; m_pData = nullptr; }}void CMyString::print(void) { std::cout &lt;&lt; m_pData &lt;&lt; std::endl;}// 赋值运算符函数CMyString&amp; CMyString::operator=(const CMyString&amp; str) { if(this != &amp;str) { CMyString tmp(str); // 复制构造函数 std::swap(m_pData, tmp.m_pData); // 交换地址 } return *this;}int main() { // 测试CMyString CMyString str1(&quot;Sword&quot;); CMyString str2(&quot;2&quot;); CMyString str3(&quot;Offer&quot;); str1 = str2 = str3; str1.print(); // Offer str2.print(); // Offer str3.print(); // Offer return 0;} 如果完整的去实现上面这个题目，会引出一些非常容易忽略的细节问题（并且会导致严重错误），例如在初始化变量 str1 时，CMyString str1(&quot;Sword&quot;);，其中所传入的参数一般都是程序声明的字符串常量，如果在构造函数中简单地实现为： 1234// Mem ErrorCMyString::CMyString(char* pData) { m_pData = pData;} 就会导致赋值运算符函数中的析构函数调用过程发生错误，因为析构函数中的 delete []m_pData 的delete操作符只负责操作堆(Heap)中的内存区域(因为new只在堆里申请内存区域)，如果使用delete操作符去释放一个字符串常量指针所指向的区域，就会发生错误（大概是访问越界）。 所以在初始化时应该使用和delete对应的new操作，在堆中申请内存，再把传入参数的内容复制到其中。 123456CMyString::CMyString(char* pData) { if(pData != nullptr) { m_pData = new char[strlen(pData) + 1]; strcpy(m_pData, pData); }} C#因为还没怎么学C#的东西，C#的部分暂时跳过，记录一下推荐的书： 《Professional C#》：特点是附录中有描述C#和其他语言的区别； 《CLR Via C#》：深入介绍C#，对CLR和.NET进行剖析，可以方便理解装箱卸箱、垃圾回收、反射等概念。 面试题2：实现Singleton模式（单例模式） 暂时跳过。 涉及到设计模式的部分，列举一些可以参考阅读的资料： 《设计模式：C++常用设计模式》：https://refactoringguru.cn/design-patterns/cpp ； 《Head First 设计模式》：感觉是一本比较老的书，可能之后看看吧； 《Game Programming Patterns》：http://gameprogrammingpatterns.com/contents.html 。","link":"/2020/11/25/s2o-c2-lg/"},{"title":"《3D图形的数学》第1章笔记 向量","text":"对于成功的3D程序猿，掌握如何进行向量运算是一种基本的技能要求。 原书：《3D游戏与计算机图形学中的数学方法》 by Eric.Lengyel 1 向量的形式一个n维向量V可以表示为： $$ \\textbf{V} = < V_{1}, V_{2}, ... , V_{n} > \\tag{1.1} $$ 系数a和向量V的乘积可以定义为： $$ a\\textbf{V} = < aV_{1}, aV_{2}, ... , aV_{n} > \\tag{1.4} $$ 向量加减运算： $$ \\textbf{P} + \\textbf{Q} = < P_{1} + Q_{1}, P_{2} + Q_{2}, ... , P_{n} + Q_{n} > \\tag{1.5} $$ 【定理1.1】对于给定的任何两个系数a和b，以及任何三个向量P、Q和R，有以下运算规律： \\(\\textbf{P} + \\textbf{Q} = \\textbf{Q} + \\textbf{P}\\) \\((\\textbf{P} + \\textbf{Q}) + \\textbf{R} = \\textbf{P} + (\\textbf{Q} + \\textbf{R})\\) \\((ab)\\textbf{P} = a(b\\textbf{P})\\) \\(a(\\textbf{P} + \\textbf{Q}) = a\\textbf{P} + a\\textbf{Q}\\) \\((a + b)\\textbf{P} = a\\textbf{P} + b\\textbf{P}\\) n维向量V的模，||V||： $$ \\textbf{||V||} = \\sqrt{\\sum_{i=1}^{n} V_{i}^{2}} \\tag{1.6} $$ 模也称为向量的范数或者长度，模为1的向量称为单位向量。 设向量V表示一个三维点或方向，则公式(1.6)可以展开为： $$ \\textbf{||V||} = \\sqrt{V_{x}^{2} + V_{y}^{2} + V_{z}^{2}} \\tag{1.7} $$ 如果向量V至少有至少有一个非零分量，可以通过乘 \\(1/\\textbf{||V||}\\) 得到V方向上的一个单位向量，也叫做单位化、规格化。 【定理1.2】 对于任意给定系数a，任意的两个向量P和Q，有以下性质： \\( \\textbf{||P||} \\geq 0 \\) 当且仅当 \\( \\textbf{||P||}=&lt;0, 0, …, 0&gt; \\)时，\\( \\textbf{||P||}=0 \\) \\( \\textbf{||aP||}=|a|\\textbf{||P||} \\) \\( \\textbf{||P + Q||} \\leq \\textbf{||P||} + \\textbf{||Q||} \\) 其中的第4条，可以由三角不等式得到。 2 点积向量间的点积，也叫做数量积或内积，3D图形中经常用点积来度量两个向量指向的差异。 【定理1.3】 两个n维向量P和Q的点积，记作P·Q，即： $$ \\textbf{P} \\cdot \\textbf{Q} = \\sum_{i=1}^{n} P_{i}Q_{i} \\tag{1.9} $$ 向量的点积等于两个向量的对应分量乘积之和。 在三维空间中，有： $$ \\textbf{P} \\cdot \\textbf{Q} = P_{x}Q_{x} + P_{y}Q_{y} + P_{z}Q_{z} \\tag{1.10} $$ 【定理1.4】 对于给定的两个向量P和Q，点积满足公式： $$ \\textbf{P} \\cdot \\textbf{Q} = \\textbf{||P||}\\textbf{||Q||} cos \\alpha \\tag{1.12} $$ \\(\\alpha\\)是向量P和Q之间的夹角（详细的说是P和Q的起点、终点决定的平面夹角）。 Tips：定理1.4的证明要用到余弦定理，一个三角形有三条边\\(a,b,c\\)，\\(a,b\\)夹角是\\(\\alpha\\)时，三边满足等式关系\\(c^{2} = a^{2} + b^{2} - 2abcos\\alpha\\)。 定理1.4可以得出两个结论： 当且仅当 \\(\\textbf{P} \\cdot \\textbf{Q} = 0\\) 时， 向量P和向量Q相互垂直。点积为0的向量称为正交向量，零向量和任意向量正交； 点积正负号说明两个向量的方向情况，例如在看平面法线和平面外一点，可以查看点相对于平面的位置，是在法线同侧（点积为正）还是在不同侧（点积为负）。 【定理1.5】 对于任意给定系数a，任意的两个向量P和Q，有以下性质： \\( \\textbf{P} \\cdot \\textbf{Q} = \\textbf{Q} \\cdot \\textbf{P} \\) \\( (a\\textbf{P}) \\cdot \\textbf{Q} = a(\\textbf{P} \\cdot \\textbf{Q}) \\) \\( \\textbf{P} \\cdot (\\textbf{Q} + \\textbf{R}) = \\textbf{P} \\cdot \\textbf{Q} + \\textbf{P} \\cdot \\textbf{R} \\) \\( \\textbf{P} \\cdot \\textbf{P} = \\textbf{||P||}^{2} \\) \\( | \\textbf{P} \\cdot \\textbf{Q} | \\leq \\textbf{||P||} \\cdot \\textbf{||Q||} \\) 向量P在向量Q上的投影长度： $$ \\textbf{||P||}cos\\alpha = \\frac{\\textbf{P}\\cdot\\textbf{Q}}{\\textbf{||Q||}} \\tag{1.17} $$ 如果再乘以单位向量 \\( \\frac{\\textbf{Q}}{\\textbf{||Q||}} \\)，就可以得到具有该长度并且平行于Q的一个向量，即表示向量P到向量Q的投影，记作\\( proj_{\\textbf{Q}} \\textbf{P} \\)： $$ proj_{\\textbf{Q}}\\textbf{P} = \\frac{\\textbf{P} \\cdot \\textbf{Q}}{\\textbf{||Q||}^{2}} \\textbf{Q} \\tag{1.18} $$ P到Q的投影也可以看作是一个线性变换过程，所以可以表示为矩阵和向量乘积，三维情况下，\\( proj_{\\textbf{Q}} \\textbf{P} \\) 也可以用下面的公式计算： $$ proj_{\\textbf{Q}} \\textbf{P} = \\frac{1}{\\textbf{Q}^{2}} \\left[ \\begin{matrix} Q_{x}^{2} & Q_{x}Q_{y} & Q_{x}Q_{z} \\\\ Q_{x}Q_{y} & Q_{y}^{2} & Q_{y}Q_{z} \\\\ Q_{x}Q_{z} & Q_{y}Q_{z} & Q_{z}^{2} \\end{matrix} \\right] \\left[ \\begin{matrix} P_{x} \\\\ P_{y} \\\\ P_{z} \\end{matrix} \\right] \\tag{1.20} $$ 向量P相对于向量Q的垂直分量记作\\( perp_{\\textbf{Q}} \\textbf{P} \\)，可以用向量P减去投影分量得到垂直分量： $$ perp_{\\textbf{Q}} \\textbf{P} = \\textbf{P} - proj_{\\textbf{Q}} \\textbf{P} \\tag{1.19} $$ 3 叉积两个三维向量的叉积又称为向量积，结果是一个新的向量，这个向量垂直于原来的两个向量。 在3D图形学中，已知曲面上一点的两个不同方向的切向量，就可以通过求叉积得到曲面在该点的法向量。 【定义1.6】 两个3D向量P和Q的叉积记作 \\(\\textbf{P} \\times \\textbf{Q}\\)，结果向量为： $$ \\textbf{P} \\times \\textbf{Q} = < P_{y}Q_{z} - P_{z}Q_{y}, P_{z}Q_{x} - P_{x}Q_{z}, P_{x}Q_{y} - P_{y}Q_{x} > \\tag{1.21} $$ 便于记忆的一个工具是伪行列式： $$ \\textbf{P} \\times \\textbf{Q} = \\left| \\begin{matrix} i & j & k \\\\ P_{x} & P_{y} & P_{z} \\\\ Q_{x} & Q_{y} & Q_{z} \\end{matrix} \\right| \\tag{1.22} $$ 这里i,j,k是x,y,z轴的单位向量： $$ \\begin{aligned} \\textbf{i} &= \\\\ \\textbf{j} &= \\\\ \\textbf{k} &= \\end{aligned} \\tag{1.23} $$ 叉积\\(\\textbf{P} \\times \\textbf{Q}\\)也可以用线性变换的形式表示，变换矩阵派生于P，作用于Q： $$ \\textbf{P} \\times \\textbf{Q} = \\left[ \\begin{matrix} 0 & -P_{z} & P_{y} \\\\ P_{z} & 0 & -P_{x} \\\\ -P_{y} & P_{x} & 0 \\end{matrix} \\right] \\left[ \\begin{matrix} Q_{x} \\\\ Q_{y} \\\\ Q_{z} \\end{matrix} \\right] \\tag{1.25} $$ Tips：原书P7的公式(1.25)有疏漏，变换矩阵中出现了Q的分量。 对于任意给定的三个3D向量P、Q和R，等式 \\((\\textbf{P} \\times \\textbf{Q}) \\cdot \\textbf{R}\\) 的值可以通过伪行列式乘以R得到： $$ (\\textbf{P} \\times \\textbf{Q}) \\cdot \\textbf{R} = \\left| \\begin{matrix} R_{x} & R_{y} & R_{z} \\\\ P_{x} & P_{y} & P_{z} \\\\ Q_{x} & Q_{y} & Q_{z} \\end{matrix} \\right| = \\left| \\begin{matrix} P_{x} & P_{y} & P_{z} \\\\ Q_{x} & Q_{y} & Q_{z} \\\\ R_{x} & R_{y} & R_{z} \\end{matrix} \\right| \\tag{1.27} $$ Tips：行列式表达我在这里书写了两种表达形式，第一种是延续之前伪行列式的写法，只是将R替代了ijk的位置，第二种写法来自于书上，遵循PQR的出现次序的记忆法，两者的值根据初等变化法则是相等的。 如果P、Q和R中任何一个可以表示为其他两个向量的线性组合，则行列式的值为0（根据垂直法则和点积定理推导）。 【定理1.8】 对于给定的两个3D向量P和Q，叉积\\(\\textbf{P} \\times \\textbf{Q}\\)满足下面公式： $$ ||\\textbf{P} \\times \\textbf{Q}|| = \\textbf{||P||}\\textbf{||Q||}sin\\alpha \\tag{1.28} $$ \\(\\alpha\\)为P和Q的夹角。 由定理1.8可知，叉积\\(\\textbf{P} \\times \\textbf{Q}\\)的模等于由向量P和Q组成的平行四边形的面积。因此，一个三角形的顶点\\(V_{1}, V_{2}, V_{3}\\)，可以计算其面积A: $$ A = \\frac{1}{2} || (V_{2} - V_{1}) \\times (V_{3} - V_{1}) || \\tag{1.32} $$ 叉积得到的非零向量一定垂直于原本的两个向量，但满足要求的有两种方向，为了确定叉积方向，引入叉积遵循的右手法则。例如，使用右手手指指向P方向，手心朝向Q反向，则大拇指就是叉积\\(\\textbf{P} \\times \\textbf{Q}\\)的方向。 空间轴的单位向量ijk，按照圆形循环的方式排序，i在j之前，j在k之前，k在i之前，则这样的顺序叉积乘等于第三个向量： $$ \\begin{aligned} \\textbf{i} \\times \\textbf{j} &= \\textbf{k} \\\\ \\textbf{j} \\times \\textbf{k} &= \\textbf{i} \\\\ \\textbf{k} \\times \\textbf{i} &= \\textbf{j} \\end{aligned} \\tag{1.33} $$ 反之，按照相反的顺序相接的叉乘等于第三个向量的负值。 【定理1.9】 对于给定系数a，b和任意三个3D向量P、Q和R，有以下性质： \\( \\textbf{P} \\times \\textbf{Q} = - (\\textbf{Q} \\times \\textbf{P}) \\) \\( (a\\textbf{P}) \\times \\textbf{Q} = a(\\textbf{P} \\times \\textbf{Q}) \\) \\( \\textbf{P} \\times (\\textbf{Q} + \\textbf{R}) = \\textbf{P} \\times \\textbf{Q} + \\textbf{P} \\times \\textbf{R} \\) \\( \\textbf{P} \\times \\textbf{P} = \\textbf{0} = &lt;0, 0, 0&gt; \\) \\( (\\textbf{P} \\times \\textbf{Q}) \\cdot \\textbf{R} = (\\textbf{R} \\times \\textbf{P}) \\cdot \\textbf{Q} = (\\textbf{Q} \\times \\textbf{R}) \\cdot \\textbf{P} \\) （注意顺序，满足圆形循环） \\( \\textbf{P} \\times (\\textbf{Q} \\times \\textbf{P}) = \\textbf{P} \\times \\textbf{Q} \\times \\textbf{P} = \\textbf{P}^{2}\\textbf{Q} - (\\textbf{P} \\cdot \\textbf{Q}) \\textbf{P} \\) 前五条都比较容易证明，稍微说一下最后一条的证明方式： $$ \\begin{aligned} \\textbf{P} \\times (\\textbf{Q} \\times \\textbf{P}) &= \\textbf{P} \\times [-(\\textbf{P} \\times \\textbf{Q})] \\\\ &= [\\textbf{P} \\times -(\\textbf{P} \\times \\textbf{Q})] \\\\ &= -[-(\\textbf{P} \\times \\textbf{Q}) \\times \\textbf{P}] \\\\ &= (\\textbf{P} \\times \\textbf{Q}) \\times \\textbf{P} \\\\ &= \\textbf{P} \\times \\textbf{Q} \\times \\textbf{P} \\end{aligned} \\tag{1.35} $$ 后面的具体计算式，是通过对三个分量分别求值得到的结果，不再赘述。 由定理1.9可以得到 叉积不满足交换律和结合律。 4 向量空间【定理1.10】 向量空间是一个集合V，元素成为向量，下面定义向量空间中的加法和乘数，并介绍一些性质： V对于加法运算封闭； V对于乘数运算封闭； V中存在一个零元素 \\(\\textbf{0}\\)； V中任意向量P存在向量Q使其 \\( \\textbf{P} + \\textbf{Q} = \\textbf{0}\\)； 加法满足结合律； 乘数满足结合律； 乘数对于加法满足分配率，\\( a(\\textbf{P} + \\textbf{Q}) = a\\textbf{P} + a\\textbf{Q}\\)； 系数加法对于乘数满足分配率，\\( (a + b)\\textbf{P} = a\\textbf{P} + b\\textbf{P}\\)。 将由n元组组成的向量空间记作 \\(R^{n}\\)，比如三维的向量空间记作\\(R^{3}\\)。 每一个向量空间都可以由一组向量的线性组合来生成，生成向量空间的向量组成为基。 【定义1.11】 对于一组向量 {\\( \\textbf{e}_{1}, \\textbf{e}_{2}, …, \\textbf{e}_{n} \\)}，如果不存在这样一组实数 {\\(a_{1}, a_{2}, …, a_{n}\\)}，其中至少有一个 \\(a_{i}\\) 不为0，使得下式成立： $$ a_{1}\\textbf{e}_{1} + a_{2}\\textbf{e}_{2} + \\cdots + a_{n}\\textbf{e}_{n} = 0 \\tag{1.40} $$ 则称这组向量线性无关，否则称向量组线性相关。 一个n维向量空间可以由n个线性无关的向量组成的向量集合生成，这个向量组成为基。 【定义1.12】 向量空间V的基B是一个由n个线性无关的向量组成的集合，即 \\(\\textbf{B}\\)={\\(\\textbf{e}_{1}, \\textbf{e}_{2}, …, \\textbf{e}_{n} \\)}，对于向量空间V中的任意一个元素P，都存在一组实数使得： $$ \\textbf{P} = a_{1}\\textbf{e}_{1} + a_{2}\\textbf{e}_{2} + \\cdots + a_{n}\\textbf{e}_{n} \\tag{1.41} $$ 任意空间向量\\(R^{n}\\)都具有无限个基，对基的形式进行一些限定后，可以使基具有特定的性质。 【定义1.13】 对于向量空间的基\\(\\textbf{B}\\)={\\(\\textbf{e}_{1}, \\textbf{e}_{2}, …, \\textbf{e}_{n} \\)}，如果对于任意 \\(i \\neq j\\) 都有 \\(\\textbf{e}_{i} \\cdot \\textbf{e}_{j} = 0\\)，则该基为正交基。 【定理1.14】 对于给定的两个向量 \\(\\textbf{e}_{1}\\) 和 \\(\\textbf{e}_{2}\\)， 如果\\(\\textbf{e}_{1} \\cdot \\textbf{e}_{2} = 0\\)，则\\(\\textbf{e}_{1}\\) 和 \\(\\textbf{e}_{2}\\)线性无关。 对基的另一个形式限定就是基的所有向量都具有单位长度（更简单化了），引入Kronecker delta符号 \\(\\delta_{ij}\\)，定义如下： $$ \\delta_{ij} = \\left\\{ \\begin{aligned} 1, i&=j \\\\ 0, i&\\neq j \\end{aligned} \\right. \\tag{1.42} $$ 【定理1.15】 如果对于每一对 \\((i, j)\\) 有 \\(\\textbf{e}_{i} \\cdot \\textbf{e}_{j} = \\delta_{ij}\\)，则基 \\(\\beta\\)={\\(\\textbf{e}_{1}, \\textbf{e}_{2}, …, \\textbf{e}_{n} \\)}称为向量空间的正交规范基。 显然向量组{\\(\\textbf{i}, \\textbf{j}, \\textbf{k}\\)}是\\(R^{3}\\)的一个正交规范基。 有一个方法可以将具有n个线性无关向量的向量组转换为向量空间\\(R^{n}\\)的正交基，基本思想是减去向量在前面每个向量上的投影，结果肯定和前面所有的向量正交。 【定理1.16】 Gram-Schmidt 正交规范化： 对于由n个线性无关想了组成的向量组\\(\\textbf{B}\\)={\\(\\textbf{e}_{1}, \\textbf{e}_{2}, …, \\textbf{e}_{n} \\)}，算法可以产生向量组\\(\\beta\\)={\\(\\textbf{e}_{1}^{‘}, \\textbf{e}_{2}^{‘}, …, \\textbf{e}_{n}^{‘} \\)}，当 \\(i \\neq j\\)时，\\(\\textbf{e}_{i}^{i} \\cdot \\textbf{e}_{j}^{i} = 0\\)。 设 \\(\\textbf{e}_{1}^{‘} = \\textbf{e}_{1}\\)； 从i=2开始； 从\\(\\textbf{e}_{i}\\)中减去\\(\\textbf{e}_{i}\\)在向量\\(\\textbf{e}_{1}^{‘}, \\textbf{e}_{2}^{‘}, …, \\textbf{e}_{i-1}^{‘} \\)上地投影，结果为\\(\\textbf{e}_{i}^{‘}\\)，即 $$ \\textbf{e}_{i}^{'} = \\textbf{e}_{i} - \\sum_{k=1}^{i-1} proj_{\\textbf{e}_{k}} \\textbf{e}_{i} = \\textbf{e}_{i} - \\sum_{k=1}^{i-1} \\frac{\\textbf{e}_{i} \\cdot \\textbf{e}_{k}}{\\textbf{e}_{k}^{2}} \\textbf{e}_{k} \\tag{1.43} $$ 如果i &lt; n，i加1，重复步骤3。 如果需要进一步生成正交规范基，就对每个\\(\\textbf{e}_{i}^{‘}\\)进行规范化。","link":"/2020/11/27/3dmath-c1/"},{"title":"《剑指Offer》第2章笔记 数组","text":"数据结构是技术面的重点，主要围绕数组、字符串、链表、树、栈以及队列这几种常见的数据结构展开。 嗯，除了语言和算法以外的最重要的（废话）。 数组的一些特点（主要是指C/C++中的基础数组类型）： 连续的内存，按照顺序存储； 创建时需要指定数组的容量大小； O(1)时间读/写任何位置元素； 为了解决基础数组空间效率不高的问题，人们设计了动态数组，比如 C++ STL 中的 vector ，其中为了避免空间浪费，先为数组开辟小空间，当数据数目超过容量时，再重新分配一块更大的空间，把之间的数据复制到新的数组中，再把之前的内存释放（一般没有延续之前地址往后申请内存的操作，所以只能整块申请，然后再释放掉新的），但是这样就会带来内存空间申请和数据迁移的时间开销，因此使用动态数组要尽量减少改变数组容量大小的操作。 在C/C++中，数组和指针既相互关联又有区别。 声明一个数组时，数组的名字也是一个指针（不可修改的指针变量），该指针指向数组的第一个元素。需要注意的是，C/C++不会主动记录数组的大小，所以在访问数组元素时，程序要确保不会超过边界。 1234567891011121314151617int get_size(int data[]) { return sizeof(data);}Error: Cannot find module 'gulplog'int main() { int data1[] = {1, 2, 3, 4, 5}; int size1 = sizeof(data1); int* data2 = data1; int size2 = sizeof(data2); int size3 = get_size(data1); printf(&quot;%d, %d, %d&quot;, size1, size2, size3); // 20, 4, 4} 在上面的代码中： sizeof(data1) == 20：sizeof(data1)求数组的大小（字节数），data1包含5个整数，每个整数4字节，所以20字节； sizeof(data2) == 4：data2声明是指针，尽管指向了数组指针，但本质仍然是指针，在32位系统上，对任意指针求sizeof都是4(32位系统是4个字节的地址)； get_size(data1) == 4：在C/C++中，数组作为函数参数传递时，会退化为同类型的指针，尽管函数声明的是数组参数，但还是会退化为指针（语言概念特色），所以结果仍然是4。 面试题3 题目一：找出数组中重复的数字。 数组长度n，数字都在 0 - n-1 的范围内，数组中某些数字重复，但不知道有几个数字重复，请找出数组中任意一个重复数字；例如{2, 3, 1, 0, 2, 5, 3}，重复数字2或者3。 思路1：简单的排序再搜索就可以，但需要 O(nlogn) 的时间开销； 改进思路2：常用的一种优化思路是使用哈希表，从头到尾记录所有数字的出现次数，如果次数大于2就是重复的数字，时间开销降低到了 O(n) ，但凭空多了哈希表的 O(n) 开销； 大部分的人都能想到第二种方法，然后书的作者会介绍第三种方法： 数字都在0~n-1的范围内，如果数组不重复，则数字i出现在下标i的位置，如果重复，则某些位置有多个数字，同时有些位置没有数字。 但我觉得对这种方法的阐述，稍微有点凭空跳脱，没有和之前提到的前两种思路有任何延续，所以一时可能较于难以理解这里的思路，尤其是之后的算法流程。 我们可以延续之前的改进思路2，使用哈希表的优点是时间开销少，缺点是多了空间开销，那么进一步的优化思路是：如何减少空间上的开销？ 在已知数字出现在 0 ~ n-1 范围内时，哈希表的一种简单实现是位置i存储数字i的出现频率： 1234int array[5] = {1, 3, 3, 0, 2};int hash[5] = {0, 0, 0, 0, 0};... // for num in array to finish hashcout &lt;&lt; hash &lt;&lt; endl; // [1, 1, 1, 2, 0] 那么，你可以想到的一种优化思路是：原数组存储的数字在读取过一次后其实就没有作用了，所以在数字i被读取了之后，将它“自己的位置”作为哈希表的存储位，不就不需要额外的空间了么？ 更加细节地，在数字i被读取了过后，尽管它本身可能不在位置i上，可以把原本位置i的数字替换到当前的位置，最后我们使用位置i作为数字i的哈希表存储位，就完成了一步操作；对全数组的数字都执行这样的操作，就可以找出重复的数字了。 这个方法本质上是延续哈希表的思路，并且具体实现的方式你就会发现和作者提出的方法是一致的，所以我猜测作者的实质本意是将改进思路2的一种延续优化，但并没有在书中进行说明这种思路转变，稍微有点儿可惜。 PS：这样的改进思路在延续了简单哈希表实现的同时，也延续了这样的哈希表缺点，即无法处理0 ~ n-1 范围以外的数字情况。 从头到尾依次扫描数组中的每个数字，当扫描到位置i的数字m时，判断m==i： 如果相等，说明数字i在位置i上，继续执行； 如果不相等，将位置m上的数字交换到位置i上，位置m上放置了数字m，从位置i继续下一步判断；如果在交换之前发现，位置m上已经是数字m了，那么就说明数字m重复了，程序结束。 一个栗子： 12345678[1, 3, 3, 0, 2] // i=0[3, 1, 3, 0, 2] // i=0 1 on 1[0, 1, 3, 3, 2] // i=0 3 on 3[0, 1, 3, 3, 2] // i=0 0 on 0[0, 1, 3, 3, 2] // i=1 1 on 1[0, 1, 2, 3, 3] // i=2 2 on 2[0, 1, 2, 3, 3] // i=3 3 on 3[0, 1, 2, 3, 3] // i=4 3 already on 3, 3 repeat 完整代码实现： 123456789101112131415161718192021222324252627282930313233#include &lt;iostream&gt;int find_repeat(int array[], int len) { int i = 0; while(i &lt; len) { int m = array[i]; if(m != i) { if(array[m] != m) { // swap int temp = array[m]; array[m] = m; array[i] = temp; } else { return m; } } else { i++; } } return len;}int main() { int array[] = {1, 3, 3, 0, 2}; int len = sizeof(array) / sizeof(array[0]); int dup = find_repeat(array, len); if(dup == len) { printf(&quot;No Repeat Number\\n&quot;); } else { printf(&quot;Repeat Number: %d\\n&quot;, dup); } return 0;} 在其中还可以加上前一节提到的安全、边界等问题的考虑，在下面贴的作者的实现里面可以看到： 1234567891011121314151617181920212223242526bool duplicate(int array[], int len, int* dup) { // 考虑参数失效 if(array == nullptr || len &lt;= 0) { return false; } // 考虑超过边界 for(int i = 0; i &lt; len; i++) { if(array[i] &lt; 0 || array[i] &gt; len - 1) { return false; } } // 实现比较优雅 流程相同 for(int i = 0; i &lt; len; i++) { while(array[i] != i) { if(array[i] == array[array[i]]) { *dup = array[i]; return true; } // swap int temp = array[i]; array[i] = array[temp]; array[temp] = temp; } } return false;} 面试题3 题目二：不修改数组找出重复的数字。 在长度n+1的数组里的所有数字都在1~n的范围内，所以数组至少有一个数字是重复的。请找出数组中任意一个重复的数字，但不能修改输入的数组。 这一题虽然可以像题目一那样，只需要多开辟一个n+1长度的辅助数组，用来解决问题，但是这样就多了O(n)的空间开销。 一般在这种限定情况下，很难再和题目一一样做到时间、空间开销非常小的情况下完成任务，所以可以退一步，不需要缩减到O(n)时间，比如维持和快排复杂度O(nlogn)相同情况下，达成O(1)的空间开销也是一种优化的思路。 因为出发点不同，我们再次退回到最简单的方法： 没有额外的空间帮助记录时，就只能每次判断一个数字是否有重复，即判断n次，每次有n长度的遍历开销，也就是O(n^2)； 所以有两个优化的方向：（1）减少判断的次数n；（2）减少遍历长度n。 在没有额外信息辅助的情况下，优化（2）一般是很难做的（因为每个数只有遍历了全部才知道是否有重复），所以我们可以尝试优化（1）的部分。 最简单思路下，只有遍历了1~n的n个数在数组中的情况，才能知道谁重复了，我们可以用一些技巧来减少需要判断的次数。 其实非常巧妙，这条技巧就在题目中：“1~n范围内的数，在长度n+1的数组中必然存在一个重复”，这个命题成立的原因是，如果你遍历一次数组，统计1~n范围内数字的出现次数(n+1)，出现情况是大于n的（这里的n指1~n的这个范围长度），进一步地推广到一个普适命题“i~j范围内的数，在长度n+1的数组中，如果出现次数大于(j-i+1)，那必然存在重复”； 也就是意味着我们只用使用一次O(n)的遍历时间，就可以确定一个范围的数字是否存在重复。这样的性质可以让我们不断地缩小所需要判断的数字范围，这也就是时间开销上的优化。 具体地，我们可以联想到二分法： 一开始将范围1~n分为两部分，一半是1~m，另一半是m+1~n； 如果范围1~m的数字的统计次数大于m，则这个范围内有重复的数字；否则另一半m+1~n的区间里一定有包含重复的数字； 继续二分存在重复数字的范围，重复步骤； 直到确定到某个重复数字。 比如说题目给的例子{ 2, 3, 5, 4, 3, 2, 6, 7 }： [1-4]范围的数字出现5次，[5-7]范围的数字出现3次，重复在[1-4]; [1-2]范围的数字出现2次，[3-4]范围的数字出现3次，重复在[3-4]； [3]数字出现2次，[4]数字出现1次，重复数字是3。 然后简单分析一下时间复杂度，每次遍历统计的时间开销不变O(n)，因为数字范围二分，一共需要走O(logn)步，所以在O(nlogn)时间中可以找出重复数字。 完整代码实现： 123456789101112131415161718192021222324252627282930313233#include &lt;iostream&gt;bool is_repeat(int array[], int len, int start, int end) { int count = 0; for(int i = 0; i &lt; len; i++) { if(array[i] &lt;= end &amp;&amp; array[i] &gt;= start) { count += 1; } } return count &gt; (end - start + 1);}int find_repeat(int array[], int len) { int start = 1; int end = len-1; while(end != start) { int mid = (end + start) / 2; if(is_repeat(array, len, start, mid)) { end = mid; } else { start = mid+1; } } return start;}int main() { int array[] = {2, 3, 5, 4, 3, 2, 6, 7}; int len = sizeof(array) / sizeof(array[0]); int dup = find_repeat(array, len); printf(&quot;Repeat Number: %d\\n&quot;, dup); // 3 return 0;} Tips：上述代码没有考虑一些安全、边界问题，所以比较简短。 需要指出的一点是，上面的使用的这种方法不能保证找出所有重复的数字，例如其中的2也是重复数字，但是算法只找出了3，一个原因是因为只会检查其中一半范围，例如检查到前一半有重复的时候，就不会再检查后一半范围了，另一个原因是算法无法确定是其中一个数字出现2次还是几次。 面试题4：二维数组中的查找 在一个二维整数数组中，每一行从左到右递增，每一列从上到下递增，判断数组中是否含有指定数字。 例如： $$ \\begin{matrix} 1 & 2 & 8 & 9 \\\\ 2 & 4 & 9 & 12 \\\\ 4 & 7 & 10 & 13 \\\\ 6 & 8 & 11 & 15 \\end{matrix} $$ 当一个数和矩阵中间的一个数比较时，除了相等，还有两种情况： (a)当查询数字小于目标数字时，说明目标数字一定不会出现在左上角，剩下需要判断的区域在其右边和下边； (b)当查询数字大于目标数字时，说明目标数字一定不会出现在右下角，剩下需要判断的区域在其左边和上边。 当我们按照常规思路，尝试从(0,0)出发，向右下角进行搜索时，我们跳转到下一格只有通过2种方式，从上转移到下，和从左转移到右，如果我们把已遍历的位置称为“已知信息”，我们可以看到这种搜索方式，大部分“已知信息”都集中在左上部，这在比较出现的两种情况中，要么无法提供任何信息，要么只能提供重叠区域的信息，无法让转移确定下一次的方向。 所以为了避免“已知信息”的浪费，我们可以尝试从右上角(0, n-1)出发，向左下角进行搜索，这样会提供更多的信息，如果发生向下转移，代表上边没有比目标数更大的，如果发生向左转移，代表右边的数比目标数更大，所以导致更加明确的在左下角区域中搜索目标数。 完整代码实现： 1234567891011121314151617181920212223242526272829303132#include &lt;iostream&gt;bool find(int matrix[][4], int rows, int cols, int target) { int i = 0; int j = cols - 1; while(i &lt; rows &amp;&amp; j &gt;= 0) { if(matrix[i][j] &lt; target) { i++; } else if(matrix[i][j] &gt; target) { j--; } else { return true; } } return false;}int main() { int matrix[][4] = { {1, 2, 8, 9}, {2, 4, 9, 12}, {4, 7, 10, 13}, {6, 8, 11, 15} }; int target = 7; if(find(matrix, 4, 4, target)) { printf(&quot;Found!\\n&quot;); } else { printf(&quot;Not Found!\\n&quot;); } return 0;}","link":"/2020/11/26/s2o-c2-array/"},{"title":"《剑指Offer》第2章笔记 链表","text":"链表应该是面试时被提及最频繁的数据结构。 链表的结构很简单，它由指针把若干个节点连接成链状结构，链表的创建、插入节点、删除节点等操作都只需要20行左右的代码就能实现，代码量比较适合面试（哈希表、有向图等复杂的一个操作可能就需要很多代码）。 链表是一种动态数据结构，创建链表时，无须知道链表长度，插入节点时，只需要为新节点分配内存，然后调整指针的指向来确保新节点被链接到链表中；内存分配不是在创建链表时一次性完成的，而是每添加一个节点分配一次内存。 典型的单向链表节点定义： 1234struct Node { int value; Node* next;}; 往链表末尾添加一个节点： 1234567891011121314151617void add_to_tail(Node** phead, int value) { // 头结点是一个指针的指针 Node* pnew = new Node(); pnew-&gt;value = value; pnew-&gt;next = nullptr; if(*phead == nullptr) { // 创建头节点 *phead = pnew; } else { // 添加节点到尾部 Node* pnode = *phead; while(pnode-&gt;next != nullptr) { pnode = pnode-&gt;next; } pnode-&gt;next = pnew; }} 想要在链表中找到第i个节点，那我们只能从头结点开始遍历链表，时间效率为O(n)，而在数组中只需要O(1)的时间。 找到第一个含有某值节点并删除该节点的代码： 1234567891011121314151617181920212223242526272829void remove_node(Node** phead, int value) { if(phead==nullptr || *phead==nullptr) { return; } Node* p_delete = nullptr; if((*phead)-&gt;value == value) { // 头结点删除需要单独考虑操作 p_delete = *phead; *phead = (*phead)-&gt;next; } else { Node* pnode = *phead; // 寻找删除节点的前一个节点 while(pnode-&gt;next != nullptr &amp;&amp; pnode-&gt;next-&gt;value != value) { pnode = pnode-&gt;next; } if(pnode-&gt;next != nullptr &amp;&amp; pnode-&gt;next-&gt;value == value) { // 调整删除节点前一个节点的链接 p_delete = pnode-&gt;next; pnode-&gt;next = pnode-&gt;next-&gt;next; } } if(p_delete != nullptr) { delete p_delete; p_delete = nullptr; }} 一些特殊形式的链表也会被经常考到： 环形链表：链表末尾节点指向头结点（面试题62）； 双向链表：节点还有一个指向前一个节点的指针（面试题36）； 复杂链表：节点还有拥有指向任意节点的指针（面试题35）。 面试题6：从尾到头打印链表 输入一个链表的头节点，从尾到头反过来打印每个节点的值。 1234struct Node { int value; Node* next;}; Tips：如果打算修改输入数据，最好先问面试官是不是允许修改，这里假设面试官不能改变链表的结构。 这道题目需要先访问的节点后输出，可以想到使用栈这种数据结构，每次访问到节点，就压到栈中，输出的时候只需要循环出栈即可。 完整代码实现： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#include &lt;iostream&gt;#include &lt;stack&gt;struct Node { int value; Node* next;};void add_to_tail(Node** phead, int value) { // 头结点是一个指针的指针 Node* pnew = new Node(); pnew-&gt;value = value; pnew-&gt;next = nullptr; if(*phead == nullptr) { // 创建头节点 *phead = pnew; } else { // 添加节点到尾部 Node* pnode = *phead; while(pnode-&gt;next != nullptr) { pnode = pnode-&gt;next; } pnode-&gt;next = pnew; }}void reverse_print(Node** phead) { if(phead==nullptr || *phead==nullptr) { return; } std::stack&lt;Node*&gt; pstack; Node* pnode = *phead; while(pnode != nullptr) { pstack.push(pnode); pnode = pnode-&gt;next; } while(!pstack.empty()) { pnode = pstack.top(); printf(&quot;%d\\t&quot;, pnode-&gt;value); pstack.pop(); }}int main() { int values[] = {1, 2, 3, 4, 5}; Node** phead = new Node*; *phead = nullptr; for(int i = 0; i &lt; 5; i++) { add_to_tail(phead, values[i]); } reverse_print(phead); return 0;} 具体的实现中需要注意到的一个点是头节点的初始化，因为是指针的指针，所以需要先申请一个Node指针类型的指针，new Node*，然后再将头结点指向的节点设置为nullptr，这样才不会在访问时出错。 如果可以使用栈结构来实现，也可以考虑使用递归的方式实现，通过递归访问，只有在返回函数的时候再输出节点，就可以实现逆序输出。 12345678// 调用的时候要使用 *pheadvoid reverse_print_rec(Node* node) { if(node == nullptr) { return; } reverse_print_rec(node-&gt;next); printf(&quot;%d\\t&quot;, node-&gt;value);} 递归的代码相比于使用栈会简洁很多，但是使用递归是有代价的，函数递归使用的栈空间通常会有限制（比自己建立栈的空间要小），所以如果链表过于长可能会导致函数调用栈溢出。","link":"/2020/11/30/s2o-c2-linked/"},{"title":"《剑指Offer》第2章笔记 字符串","text":"字符串的使用频率非常高，为了优化，很多语言都对字符串做了特殊的规定。 C/C++中每个字符串都以字符 \\0 做为结尾，这样便于运行时判断字符数组的尾部，由于这个特点，字符串数组的长度比真实字符串长度要多1才可以，这样容易导致一些错误： 12char str[10];strcpy(str, &quot;0123456789&quot;); // Error 为了节省内存，C/C++把常量字符串放到一个单独的内存区域，当几个指针赋值给相同的常量字符串时，实际上会指向相同的内存地址。但用常量内存来初始化字符数组时，情况又有所不同了，看下面的例子： 12345678910111213int main() { char str1[] = &quot;hello world&quot;; char str2[] = &quot;hello world&quot;; char* str3 = &quot;hello world&quot;; char* str4 = &quot;hello world&quot;; printf(&quot;str1 =%p\\n&quot;, str1); // 0061fe04 printf(&quot;str2 =%p\\n&quot;, str2); // 0061fdf8 printf(&quot;str3 =%p\\n&quot;, str3); // 00409001 printf(&quot;str4 =%p\\n&quot;, str4); // 00409001 return 0;} str1和str2是两个字符数组，在初始化赋值时，运行时为为他们分配两个长度为12字节的内存空间，并把字符串赋值到数组中去（而不是直接拷贝字符串常量地址），所以他们的初始地址是不同的。 str3和str4是两个指针，不需要再分配内存来存储内容，只需要传递地址，所以他们就拷贝了同一个地址。 面试题5：替换空格 实现一个函数，把字符串的每个空格替换成%20，例如输入We are happy.，则输出We%20are%20happy.。 题目来自于网络编程中的URL特殊字符编码，有时候服务器不一定支持一些特殊字符URL，所以需要先将特殊转换成ASCII码的两位十六进制表示，比如空格的ASCII码是32，即十六进制的0x20，空格被替换成%20，比如#的ASCII码为35，十六进制0x23，在URL中被替换成%23。 一般有两种解决方向： 在原字符数组上进行处理； 申请新字符数组，将新内容写进去； 在面试过程中遇到这样的问题，如果确定题目中没有限定说明，可以向面试官进一步地问清楚应该考虑什么样的限定条件。 在这里我们假设（作者假设）面试官需要在原字符数组上替换，输入的字符串后面有足够多的内存空间。 我们仍然从最简思路入手： 思路1：在字符串中进行遍历，当碰到空格时，将空格替换为%20，由于替换的字符串比空格多2个字符，为了放入%20，所以要将后续的字符串后移两位，重复该操作直到字符串没有空格。 假设字符串长度n，对于每个空格字符，需要移动后面O(n)个字符，所以时间开销是O(n^2)。 显然这个方法过于简单，还不是最优解，观察可以发现，有些字符串被反复后移，但其实对于一个固定空格个数的字符串，这些字符串所应该处的最终位置我们是可以计算出来的，比如We are happy.中We前面没有空格，不需要向后移动，are前面有1个空格，所以字符串会被后移2位，happy.前面有2个空格，需要移动4位。 所以对于某些字符串其最终的位置反而是通过计算得到的，不需要反复的重复移动（拷贝字符串时间开销大）。 思路2：使用一个空格计数器，在移动字符串时，根据当前空格计数器来判断当前字符需要后移多少位，然后直接将字符移动到目标位置上，遇到空格时，根据计算的后移位置，直接顺序写入%20。时间开销因为只需要遍历一次字符串，所以是O(n)。 这样的思路还是有亿点点问题需要考虑，如果从头开始移动字符串，则后面的字符串还没有空出来时，就需要先移动后面的字符串，这样就导致问题变得稍微有点复杂，所以我们可以反过来，从尾部开始处理移动操作。 思路3：先遍历一次字符串，统计空格出现次数，计算最终字符串的长度，然后从尾部开始处理移动，申请两个指针，一个指向原字符位置，一个指向移动目标位置，当遇到普通字符时，直接转移，遇到空格时，在目标位置写入替换字符串。时间开销仍然是O(n)。 完整实现代码: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include &lt;iostream&gt;#include &lt;cstring&gt;bool replace(char* str, char* ori, char* rep) { if(str != nullptr &amp;&amp; ori != nullptr &amp;&amp; rep != nullptr &amp;&amp; strlen(str) &gt; 0 &amp;&amp; strlen(ori) &gt; 0 &amp;&amp; strlen(rep) &gt; 0) { int count = 0; int ori_len = strlen(ori); int rep_len = strlen(rep); for(int i = 0; i &lt; strlen(str); i++) { if(strncmp((str+i), ori, ori_len) == 0) { count++; } } if(count == 0) { return true; } char* po = str + strlen(str) + 1; char* pr = po + count * (rep_len - ori_len); while(po &gt;= str) { if(strncmp(po, ori, ori_len) == 0) { for(char* tmp = rep + (rep_len - 1); tmp &gt;= rep; tmp--) { *pr = *tmp; pr--; } po--; } else { *pr = *po; po--; pr--; } } return true; } else { return false; }}int main() { char str[100] = &quot;We are happy.&quot;; char ori[10] = &quot; &quot;; char rep[10] = &quot;%20&quot;; if(replace(str, ori, rep)) { printf(&quot;%s\\n&quot;, str); } else { printf(&quot;Error\\n&quot;); }} Tips：代码和原作者的实现有出入，实现了相对来说比较通用的字符串替换，但是方法以及代码仅仅只针对这道题目而言是有效的，还有非常多该题目以外的问题其实是没有考虑到的，例如需要被替换不是单个的空格而是多个空格甚至是任意字符、替换的字符串如果长度小于被替换字符串该怎么处理，等等（修改上述代码中的初始字符串即可看到结果会出现问题）；不过不在这里继续讨论，可以自行尝试思考。 拓展题练习题： 已排序的两个数组A1和A2，A1尾部有足够多的空间容纳A2，将A2的所有数组插入A1中，并且最终A1中所有数字是有序的。","link":"/2020/11/28/s2o-c2-string/"},{"title":"《3D图形的数学》第2章笔记 矩阵","text":"在三维变换中，矩阵运算是最常用的表达方式。 1 矩阵的性质一个 \\(n \\times m\\) 的矩阵M就是一个有n行和m列的数组，如果 \\(n = m\\) 则矩阵M是方阵，把矩阵M第j列的第i行元素（或者第i行第j列）记作 \\(M_{ij}\\)。 矩阵M的转置，记作 \\(\\textbf{M}^{T}\\)，是一个\\(m \\times n\\)矩阵，其中 \\(M_{ij}^{T} = M_{ji}\\)。 矩阵的数乘，或者叫标量乘积，和向量类似，是乘以矩阵的每个元素。 矩阵的加法，两个相同大小的矩阵，对应行列的元素相加。 矩阵的乘法，如果矩阵F的行数和矩阵G的列数相等，则矩阵F和G可以相乘，假设F是\\(n \\times m\\)的矩阵，G是\\(m \\times p\\)的矩阵，FG就是\\(n \\times p\\)的矩阵，FG在(i, j)位置上的元素可以表示为： $$ (\\textbf{F}\\textbf{G})_{ij} = \\sum_{k=1}^{m}F_{ik}G_{kj} = \\textbf{F}_{i*} \\cdot \\textbf{G}_{*j} \\tag{2.5} $$ 其实也可以看作是矩阵F的第i行和矩阵G的第j列元素之间的点积。 单位阵是\\(n \\times n\\)的矩阵，记作\\(\\textbf{I}_{n}\\)，对于\\(n \\times n\\)的矩阵M，有 \\( \\textbf{M} \\textbf{I}_{n}\\) = \\(\\textbf{I}_{n} \\textbf{M}\\) = \\(\\textbf{M}\\)。 $$ \\textbf{I}_{n} = \\left[ \\begin{matrix} 1 & 0 & \\cdots & 0 \\\\ 0 & 1 & \\cdots & 0 \\\\ \\vdots & \\vdots & \\ddots & \\vdots \\\\ 0 & 0 & \\cdots & 1 \\end{matrix} \\right] \\tag{2.6} $$ 因为单位阵尺寸由情况而定，所以通常把下标n去掉，记作 \\(\\textbf{I}\\)。 【定理2.1】 矩阵有以下性质： 矩阵加法满足交换律和结合律； 系数加法乘矩阵、系数乘矩阵加法，均满足分配率； 【定理2.2】 还具有以下性质： 系数乘矩阵先后不影响结果； 矩阵连乘，先后不影响结果； \\((\\textbf{F}\\textbf{G})^{T}=\\textbf{G}^{T}\\textbf{F}^{T}\\)。 2 线性方程组矩阵提供了一种有效并且简便的线性方程组表示法，例如线性方程组： $$ \\begin{aligned} 3x + 2y - 3z &= 5 \\\\ 4x - 3y + 6z &= 1 \\\\ x - z &= 3 \\end{aligned} \\tag{2.10} $$ 可以用以下矩阵形式表示： $$ \\left[ \\begin{matrix} 3 & 2 & -3 \\\\ 4 & -3 & 6 \\\\ 1 & 0 & -1 \\end{matrix} \\right] \\left[ \\begin{matrix} x \\\\ y \\\\ z \\end{matrix} \\right] = \\left[ \\begin{matrix} 5 \\\\ 1 \\\\ 3 \\end{matrix} \\right] \\tag{2.11} $$ 在未知向量&lt;x,y,z&gt;前面的矩阵叫做系数矩阵，在等号右边的列向量叫做常数向量。常数向量不为0的线性方程组叫做非齐次方程组，常数向量为0叫做齐次方程组。 把系数矩阵和常数向量并置一起（称为增广矩阵），执行基本行变换，就可以得到线性方程组的解。 【定义2.3】 所谓基本行变换就是对一个矩阵执行以下三种变换之一： 两行相互交换； 一行和不为0的系数相乘； 一行与一个不为0的系数乘后加到另一行上。 方程(2.11)为例，写出增广矩阵： $$ \\left[ \\begin{array}{ccc|c} 3 & 2 & -3 & 5 \\\\ 4 & -3 & 6 & 1 \\\\ 1 & 0 & -1 & 3 \\end{array} \\right] \\tag{2.12} $$ 对线性方程组的增广矩阵进行的行变换不会影响线性方程组的解，只是使线性方程组更加容易计算（可以同步理解成，一般求方程组解的步骤，使用方程组互相带入化简，使得方程组最后较容易解出值）。 当用行变换求解一个线性方程组时，目标是把系数矩阵变换为它的最简形式。 【定义2.4】 当且仅当一个矩阵满足一下条件，称为最简形式： 每一个非0行，最左边的非0元素，即前导元素，必须为1； 每一个非0行均在全0行前面，或者说，全0行在矩阵底部； 如果一行前导元素在第j列，则其他行第j列的元素均为0； 对任意两个非0行 \\(i_{2}\\) 和 \\(i_{1}\\)，如果满足\\(i_{2} &gt; i_{1}\\)，并且相应的前导元素分别位于\\(j_{2}\\)和\\(j_{1}\\)列，则必然存在\\(j_{2} &gt; j_{1}\\)。 或者简单来说，对于最简形式的矩阵，前导元素是向下向右的趋势的，并且，包含前导元素的列只有一个1，其他元素都为0。 一个最简形式矩阵例子： $$ \\left[ \\begin{matrix} 1 & 0 & -3 & 0 \\\\ 0 & 1 & 2 & 0 \\\\ 0 & 0 & 0 & 1 \\\\ 0 & 0 & 0 & 0 \\end{matrix} \\right] \\tag{2.14} $$ 【算法2.6】 把一个线性方程组的 \\(n \\times (n+1)\\) 增广矩阵M变换为最简形式，以下每一步的M在逐渐更新，而不是保持原始状态： 下标i=1； 下标j=1，从第1列到第n列开始循环； 找到一个满足行号 \\(k \\geq i\\)，并且 \\(\\textbf{M}_{kj} \\neq 0\\) 的行，如果不存在，跳到步骤8； 如果 \\(k \\neq i\\)，交换第k行和第i行； 使矩阵M的元素(i, j)变为1：将第i行乘以 \\(1 / \\textbf{M}_{ij}\\)； 把第j列中除第i行之外的元素变为0：对于每一行r，\\(1 \\leq r \\leq n\\) 且 \\(r \\neq i\\)，将第i行乘 \\(-\\textbf{M}_{rj}\\)加到第r行上； i加1； 如果\\(j \\leq n\\)，j加1，跳到步骤3。 简单来说，就是每次找到第j列上的前导元素在哪一行，然后把这一行放在对应的位置上，让前导元素变1，再清除第j列上的其它元素，直到再找不到有前导元素的行，算法停止。 对于化简到最简形式后，如何判断方程组解的情况，有以下规律： 如果系数矩阵的最简形式是一个单位阵，方程组有唯一解； 如果有一行或多行全为0，方程组要么无解，要么有无穷多解； 如果某一行系数矩阵为0而常数向量不为0，则方程组无解。 3 逆矩阵对一个\\(n \\times n\\)的矩阵M而言，如果存在一个矩阵\\(M^{-1}\\)，使得 \\(\\textbf{M}\\textbf{M}^{-1}=\\textbf{M}^{-1}\\textbf{M}=\\textbf{I}\\)，则称矩阵M是可逆的，矩阵\\(M^{-1}\\)叫做M的逆矩阵。 并不是每个矩阵都可逆，没有逆矩阵的矩阵叫做奇异矩阵，例如任何一行或一列为0的矩阵就是奇异矩阵。 【定理2.9】 有一行或一列全为0的矩阵是不可逆的。 【定理2.10】 一个矩阵M是可逆的，当且仅当\\(M^{T}\\)是可逆的。 证明： 假设M是可逆的，则\\(M^{-1}\\)存在，所以有： $$ \\textbf{M}^{T}(\\textbf{M}^{-1})^{T} = (\\textbf{M}^{-1}\\textbf{M})^{T} = \\textbf{I}^{T} = \\textbf{I} \\tag{2.29} $$ 并且 $$ (\\textbf{M}^{-1})^{T}\\textbf{M}^{T} = (\\textbf{M}\\textbf{M}^{-1})^{T} = \\textbf{I}^{T} = \\textbf{I} \\tag{2.30} $$ 因此，\\((\\textbf{M}^{-1})^{T}\\)是 \\(\\textbf{M}^{T}\\)的逆矩阵。 类似，如果假设\\(\\textbf{M}^{T}\\)是可逆的，则\\((\\textbf{M}{T})^{-1}\\)存在： $$ \\textbf{M}[(\\textbf{M}^{T})^{-1}]^{T} = [(\\textbf{M}^{T})^{-1}\\textbf{M}^{T})]^{T} = \\textbf{I}^{T} = \\textbf{I} \\tag{2.31} $$ 而且 $$ [(\\textbf{M}^{T})^{-1}]^{T}\\textbf{M} = [(\\textbf{M}^{T}(\\textbf{M}^{T})^{-1})]^{T} = \\textbf{I}^{T} = \\textbf{I} \\tag{2.32} $$ 因此，\\([(\\textbf{M}^{T})^{-1}]^{T}\\)是M的逆矩阵。 【定理2.11】 如果F和G都是\\(n \\times n\\)的可逆矩阵，那么FG也是可逆的，并且 \\((\\textbf{F}\\textbf{G})^{-1}\\) = \\(\\textbf{G}^{-1}\\textbf{F}^{-1}\\)。 求矩阵最简形式的方法（算法2.6）也可以用来计算矩阵逆矩阵，为了计算\\(n \\times n\\)矩阵的逆矩阵，在矩阵的右边并接一个单位阵，以形成一个\\(n \\times 2n\\)的矩阵。 $$ \\left[ \\begin{array}{cccc|cccc} M_{11} & M_{12} & \\cdots & M_{1n} & 1 & 0 & \\cdots & 0 \\\\ M_{21} & M_{22} & \\cdots & M_{2n} & 0 & 1 & \\cdots & 0 \\\\ \\vdots & \\vdots & \\ddots & \\vdots & \\vdots & \\vdots & \\ddots & \\vdots \\\\ M_{n1} & M_{n2} & \\cdots & M_{nn} & 0 & 0 & \\cdots & 1 \\end{array} \\right] \\tag{2.34} $$ 对整个矩阵执行基本行变换操作，直到其左边的\\(n \\times n\\)矩阵变为单位阵，这时右边的\\(n \\times n\\)部分就是M的逆矩阵，如果左边无法化为单位矩阵，则该矩阵不可逆。 【定理2.14】 假设(n \\times n\\)矩阵 \\(M^{‘}\\)是(n \\times n\\)矩阵M进行基本变换后得到的矩阵，则有 \\(M^{‘}=EM\\)，其中E是对单位阵进行相同的基本变换的最终矩阵。 把单位阵经过行变换后得到的矩阵称为初等矩阵，如果为了把矩阵M变为单位阵而必须经过k次基本行变换，那么： $$ \\textbf{I} = \\textbf{E}_{k}\\textbf{E}_{k-1} \\cdots \\textbf{E}_{1}\\textbf{M} \\tag{2.47} $$ 其中矩阵 \\(\\textbf{E}_{1}, \\textbf{E}_{2}, \\cdots, \\textbf{E}_{k}\\)是单位阵对应的k次行变换的初等矩阵，也就是说，矩阵 \\(\\textbf{E}_{k}\\textbf{E}_{k-1} \\cdots \\textbf{E}_{1}\\)之间的积即为M的逆矩阵。 【定理2.15】 当且仅当矩阵M的行是一个线性无关向量集时，(n \\times n\\)矩阵M是可逆的。 4 行列式方阵的行列式得到的是一个标量，矩阵M的行列式记作\\(det \\textbf{M}\\)，行列式使用垂直线取代矩阵两侧的括号。 $$ det \\textbf{M} = \\left| \\begin{matrix} M_{11} & M_{12} & M_{13} \\\\ M_{21} & M_{22} & M_{23} \\\\ M_{31} & M_{32} & M_{33} \\end{matrix} \\right| \\tag{2.50} $$ \\(n \\times n\\)矩阵M的行列式的值由一个递推公式给出，用符号 \\(M^{|i, j|}\\)表示原始矩阵M中第i行和第j列删除后行程的 \\((n-1) \\times (n-1)\\)矩阵，用这种方法，行列式值可用以下方法计算： $$ det \\textbf{M} = \\sum_{i=1}^{n}(-1)^{i+k}M_{ik} det \\textbf{M}^{|i,k|} \\tag{2.53} $$ $$ det \\textbf{M} = \\sum_{i=1}^{n}(-1)^{k+j}M_{kj} det \\textbf{M}^{|k,j|} \\tag{2.54} $$ 其中k是满足条件 \\(1 \\leq k \\leq n\\)的任意常数。 二阶矩阵的行列式公式： $$ \\left| \\begin{matrix} a & b \\\\ c & d \\end{matrix} \\right| = ad - bc \\tag{2.55} $$ 三阶矩阵的行列式公式： $$ \\begin{aligned} \\left| \\begin{matrix} a_{11} & a_{12} & a_{13} \\\\ a_{21} & a_{22} & a_{23} \\\\ a_{31} & a_{32} & a_{33} \\end{matrix} \\right| = a_{11}det\\textbf{M}^{|1,1|} - a_{12}det\\textbf{M}^{|1,2|} + a_{13}det\\textbf{M}^{|1,3|} \\\\ = a_{11}(a_{22}a_{33}-a_{23}a_{32}) - a_{12}(a_{21}a_{33}-a_{23}a_{31}) + a_{13}(a_{21}a_{32}-a_{22}a_{31}) \\end{aligned} \\tag{2.56} $$ 【定理2.16】 执行基本变换对一个矩阵的行列式有以下性质： 两行交换，行列式取反； 矩阵一行乘比例系数a则行列式变为原来的a倍； 把一行的若干倍加到另一行对行列式没有影响。 【推论2.17】 如果矩阵有相同行，则行列式为0。 【定理2.18】 \\(n \\times n\\)矩阵M当且仅当 \\(det \\textbf{M} \\neq 0\\)时是可逆的。 【定理2.19】 对任意两个 \\(n \\times n\\)的矩阵F和G，有 \\(det\\textbf{F}\\textbf{G}=det\\textbf{F}det\\textbf{G}\\)。 Tips：初等矩阵乘积的行列式等于行列式的乘积。 【定理2.20】 假设F是 \\(n \\times n\\)矩阵，如果另一 \\(n \\times n\\)矩阵G的元素为： $$ G_{ij} = (-1)^{i + j} \\frac{det \\textbf{F}^{|j, i|}}{det \\textbf{F}} \\tag{2.62} $$ 那么 \\(\\textbf{G}=\\textbf{F}^{-1}\\)。 通过定理2.20可以推出图形学中经常用的几个逆矩阵计算公式主要是2阶和3阶的。 2阶方阵逆矩阵公式： $$ \\textbf{A}^{-1} = \\frac{1}{det \\textbf{A}} \\left[ \\begin{matrix} A_{22} & -A_{12}\\\\ -A_{21} & A_{11} \\end{matrix} \\right] \\tag{2.63} $$ 3阶方阵逆矩阵公式： $$ \\textbf{B}^{-1} = \\frac{1}{det \\textbf{B}} \\left[ \\begin{matrix} B_{22}B_{33}-B_{23}B_{32} & B_{13}B_{32}-B_{12}B_{33} & B_{12}B_{23}-B_{13}B_{22} \\\\ B_{23}B_{31}-B_{21}B_{33} & B_{11}B_{33}-B_{13}B_{31} & B_{13}B_{21}-B_{11}B_{23} \\\\ B_{21}B_{32}-B_{22}B_{31} & B_{12}B_{31}-B_{11}B_{32} & B_{11}B_{22}-B_{12}B_{21} \\end{matrix} \\right] $$ 5 特征值与特征向量对于可逆方阵，必然存在一个向量，当该向量与可逆方阵相乘时，向量只会发生大小变换而方向不变，即，对于n阶方阵M，存在着非0的n维向量 \\(\\textbf{V}_{1}, \\textbf{V}_{2}, \\cdots, \\textbf{V}_{n}\\)满足： $$ \\textbf{M}\\textbf{V}_{i} = \\lambda_{i}\\textbf{V}_{i} \\tag{2.65} $$ 其中比例系数 \\(\\lambda_{i}\\) 称为矩阵M的特征值，而向量 \\(\\textbf{V}_{i}\\)是对应特征值的特征向量。 对式（2.65）进行变换可得到矩阵的特征值： $$ (\\textbf{M}-\\lambda_{i}\\textbf{I})\\textbf{V}_{i} = \\textbf{0} \\tag{2.66} $$ 对于非0向量 \\(\\textbf{V}_{i}\\)，如果上式成立，矩阵 \\(\\textbf{M}-\\lambda_{i}\\textbf{I}\\)一定是奇异矩阵（不可逆），否则就可以对其求逆，得到: $$ \\textbf{V}_{i} = (\\textbf{M}-\\lambda_{i}\\textbf{I})^{-1}\\textbf{0} = \\textbf{0} \\tag{2.67} $$ 这个非0向量矛盾，所以矩阵 \\(\\textbf{M}-\\lambda_{i}\\textbf{I}\\)的行列式为0，因此可以通过： $$ det(\\textbf{M}-\\lambda\\textbf{I}) = 0 \\tag{2.68} $$ 计算出矩阵的特征值解，由2.68式得出的关于 \\(\\lambda\\)的n阶多项式叫做矩阵M的特征多项式，多项式的根就是矩阵M的特征值。 一旦矩阵的特征值求得，就可以代入式(2.66)，计算出相应的特征向量，因为矩阵 \\(\\textbf{M}-\\lambda_{i}\\textbf{I}\\) 是奇异的，所以简化形式至少有一行全为0，所以有无穷多解（比如特征向量的系数倍数向量也是特征向量），因此特征向量可以表示成任意常数的形式，如果有必要也可以取特征向量的长度为1。 通常，如果矩阵特征值是复数，则相应的特征向量也含有复数元素；确保有实数特征值以及相应的实数特征向量的矩阵是对称矩阵。 【定义2.23】 一个n阶方阵，当且仅当 对任意i和j均有 \\(M_{ij}=M_{ji}\\) 时是对称矩阵，也就是说如果矩阵元素关于主对角线对称，则该矩阵就成为对称矩阵。 【定理2.24】 矩阵元素为实数的对称矩阵的特征值也是实数。 【定理2.25】 对应于对称矩阵M的不同特征值的特征向量是正交的。 6 对角化对角矩阵（对称矩阵的特例），只在主对角线上有非0元素的矩阵。 给定方阵M，如果能找到一个矩阵A使得 \\(\\textbf{A}^{-1}\\textbf{M}\\textbf{A}\\) 是对角矩阵，那么就说矩阵A将矩阵M对角化了。 【定理2.26】 假设M是特征值为 \\(\\lambda_{1}, \\lambda_{2}, \\cdots, \\lambda_{n}\\)的n阶方阵，且与特征值对应的特征向量 \\(\\textbf{V}_{1}, \\textbf{V}_{2}, \\cdots, \\textbf{V}_{n}\\) 是一个线性无关集，则矩阵A： $$ A = [ \\textbf{V}_{1} \\textbf{V}_{2} \\cdots \\textbf{V}_{n} ] \\tag{2.82} $$ 可以将矩阵M对角化，而且 \\(\\textbf{A}^{-1}\\textbf{M}\\textbf{A}\\) 的主对角元素是矩阵M的特征值，即： $$ \\textbf{A}^{-1}\\textbf{M}\\textbf{A} = \\left[ \\begin{matrix} \\lambda_{1} & 0 & \\cdots & 0 \\\\ 0 & \\lambda_{2} & \\cdots & 0\\\\ \\vdots & \\vdots & \\ddots & \\vdots\\\\ 0 & 0 & \\cdots & \\lambda_{n} \\end{matrix} \\right] \\tag{2.83} $$ 相反，如果存在一个可逆矩阵A使得 \\(\\textbf{A}^{-1}\\textbf{M}\\textbf{A}\\) 是一个对角阵，则矩阵A的列必然是矩阵M的特征向量，而 \\(\\textbf{A}^{-1}\\textbf{M}\\textbf{A}\\) 的对角线元素则是矩阵M的特征值。","link":"/2020/12/01/3dmath-c2/"},{"title":"《剑指Offer》第2章笔记 树","text":"树的操作会涉及大量指针，因此与树相关的面试题都不太容易。 树的逻辑很简单： 除根节点之外，每个节点只有一个父节点，根节点没有父节点； 除叶节点之外，每个节点都有一个或多个子节点，叶节点没有子节点； 父节点和子节点之间用指针链接。 面试中大部分都是二叉树，在二叉树中每个节点最多只能有两个子节点。 二叉树中最重要的操作是如何遍历数结构，按照某种顺序访问树的所有节点，通常有几种遍历方式： 前序：父-&gt;左子-&gt;右子； 中序：左子-&gt;父-&gt;右子； 后序：左子-&gt;右子-&gt;父； 层序：从根节点层到叶节点层，按层输出，每一层按照从左到右输出。 二叉树中又有一些特例： 二叉搜索树：在二叉搜索树中，左子节点总是小于或等于父节点，右子节点总是大于或等于父节点，可以平均在O(logn)的时间内根据值在二叉树中查找节点； 堆：堆分为最大堆和最小堆，在最大堆中，根节点的值最大，最小堆中的根节点值最小（其他节点按子树递推），有很多需要快速找到最大值或最小值的问题都可以用堆来解决； 红黑树：把树中的节点定义为红、黑两种颜色，并通过规则确保从根节点到叶节点的最长路径的长度不超过最短路径的两倍；在C++的STL中，set、multiset、map、multimap等都是基于红黑树实现的。 面试题7：重建二叉树 输入二叉树的前序和中序遍历结果，重建该二叉树，假设输入的前序中序结构中都不含有重复的数字。 123456// 二叉树节点定义struct Node { int value; Node* left; Node* right;} 在前序遍历中，第一个数字总是树的根节点；但在中序遍历中，根节点的值在序列中间，左子树的值位于根节点左边，右子树的值位于根节点右边；所以对于一个子树，我们在前序中寻找其根节点（第一个出现的值），然后在中序中根据根节点的位置，把剩下的点分为左子树和右子树。 完整代码实现： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576#include &lt;iostream&gt;#include &lt;exception&gt;struct Node { int value; Node* left; Node* right;};Node* construct_core( int* po_start, int* po_end, int* io_start, int* io_end) { int root_value = po_start[0]; Node* root = new Node(); root-&gt;value = root_value; root-&gt;left = root-&gt;right = nullptr; if(po_start == po_end) { if(io_start == io_end &amp;&amp; *po_start == *io_start) { return root; } else { // Windows Ver Error std::logic_error ex(&quot;Invalid input&quot;); throw std::exception(ex); } } int* io_root = io_start; while(io_root &lt;= io_end &amp;&amp; *io_root != root_value) { io_root++; } if(io_root == io_end &amp;&amp; *io_root != root_value) { // Windows Ver Error std::logic_error ex(&quot;Invalid input&quot;); throw std::exception(ex); } int left_len = io_root - io_start; int* left_po_end = po_start + left_len; if(left_len &gt; 0) { root-&gt;left = construct_core(po_start+1, left_po_end, io_start, io_root-1); } if(left_len &lt; po_end - po_start) { root-&gt;right = construct_core(left_po_end + 1, po_end, io_root+1, io_end); } return root;}Node* construct(int* preodr, int* inodr, int len) { if(preodr == nullptr || inodr == nullptr || len &lt;= 0) { return nullptr; } else { return construct_core(preodr, preodr + len - 1, inodr, inodr + len - 1); }}void post_order_print(Node* node) { if(node != nullptr) { post_order_print(node-&gt;left); post_order_print(node-&gt;right); printf(&quot;%d &quot;, node-&gt;value); }}int main() { int preodr[8] = {1, 2, 4, 7, 3, 5, 6, 8}; int inodr[8] = {4, 7, 2, 1, 5, 3, 8, 6}; Node* root = construct(preodr, inodr, 8); post_order_print(root); // 7 4 2 5 8 6 3 1 return 0;} 面试题8：二叉树的下一个节点 给定二叉树和其中的一个节点，如何找出中序遍历序列的下一个节点？树节点除了有左右子节点指针，还有一个指向父节点的指针。 这类题目一般从各类情况具体分析入手： 如果节点有右子树，则下一个节点就是右子树中的最左子节点； 如果节点没有右子树： 如果该节点是父节点的左子节点，父节点就是下一个节点； 并且该节点是父节点的右子节点，按照中序遍历的逻辑，需要继续往上寻找，直到找到某一个节点A，这个节点A是A父节点的左子节点，如果不存在这样的节点，那就代表原节点为最后一个遍历节点了，没有下一个节点。 面试中遇到这种题，大概率只需要编写指定功能的函数部分，不需要编写完整的代码，所以需要对面试官询问具体的输入输出情况。 123456789101112131415161718192021222324252627282930313233343536#include &lt;iostream&gt;struct Node { int value; Node* left; Node* right; Node* parent;};Node* find_next(Node* node) { if(node == nullptr) { return nullptr; } Node* next = nullptr; if(node-&gt;right != nullptr) { // 右子树的最左子节点（不一定需要是叶节点） Node* temp = node-&gt;right; while(temp-&gt;left != nullptr) { temp = temp-&gt;left; } next = temp; } else if (node-&gt;parent != nullptr) { // 寻找满足条件的祖先节点 // 某个节点是其父节点的左子节点 Node* temp = node; Node* parent = node-&gt;parent; while(parent != nullptr &amp;&amp; temp == parent-&gt;right) { temp = parent; parent = parent-&gt;parent; } next = parent; } return next;}","link":"/2020/12/07/s2o-c2-tree/"},{"title":"《剑指Offer》第2章笔记 栈和队列","text":"栈：先进后出，队列：先进先出。 栈是一个非常常见的数据结构，在计算机领域被广泛应用，比如操作系统会给每个线程创建一个栈用来存储函数调用时各个函数的参数、返回地址以及临时变量等。栈的特点是后进先出。 在栈中通常需要O(n)时间才能找到栈最大或者最小的元素，如果想O(1)时间内找到则需要做特殊的设计。 队列是另一种很重要的数据结构，队列的特点是先进先出。 面试题9：用两个栈实现队列 使用栈实现队列的两个函数appendTail和deleteHead，分别完成在队列尾部插入节点和在队列头部删除节点的功能。 一个典型的队列定义： 123456789101112template&lt;typename T&gt; class CQueue { public: CQueue(void); ~CQueue(void); void appendTail(const T&amp; node); T deleteHead(); private: stack&lt;T&gt; stack1; stack&lt;T&gt; stack2;}; 至于这道题的解法，基于一个简单的原理，将一组数先进行依次进栈、再依次出栈入栈到另一个栈里，再全部进行出栈，就完成了一个简单的队列先进先出。但如果只是单纯的依赖这样的过程，无法极大程度地利用栈的空间（例如用于出栈deleteHead的栈满时，用于进栈appendTail其实还可以继续利用起来）。 定义stack1为入队栈，stack2为出队栈。 入队操作： 当stack1不满时，直接入栈； 当stack1满时： 如果stack2为空，将stack1中的元素依次出栈入栈stack2； 如果stack2中有元素，则无法入队； 出队操作： 当stack2中有元素是，直接出栈； 当stack2为空时： 如果stack1不为空，将stack1所有元素依次出栈入栈stack2，再出栈栈顶元素； 如果stack1为空，则队列为空，无法出队； 完整实现代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#include &lt;iostream&gt;#include &lt;stack&gt;#include &lt;exception&gt;template&lt;typename T&gt; class CQueue { public: // CQueue(void); // ~CQueue(void); void appendTail(const T&amp; node); T deleteHead(); private: std::stack&lt;T&gt; stack1; std::stack&lt;T&gt; stack2;};template&lt;typename T&gt; void CQueue&lt;T&gt;::appendTail(const T&amp; element) { // 不限制栈容量时，直接入栈 stack1.push(element);}template&lt;typename T&gt; T CQueue&lt;T&gt;::deleteHead() { if(stack2.size() &lt;= 0) { while(stack1.size() &gt; 0) { T&amp; data = stack1.top(); // Why use T&amp; stack1.pop(); stack2.push(data); } } if(stack2.size() == 0) { // Throw Empty Error std::logic_error ex(&quot;queue is empty&quot;); throw std::exception(ex); } T head = stack2.top(); stack2.pop(); return head;}int main() { CQueue&lt;int&gt; cqueue; for(int i = 0; i &lt; 5; i++) { cqueue.appendTail(i); } for(int i = 0; i &lt; 3; i++) { std::cout &lt;&lt; cqueue.deleteHead() &lt;&lt; &quot; &quot;; } for(int i = 5; i &lt; 10; i++) { cqueue.appendTail(i); } for(int i = 0; i &lt; 7; i++) { std::cout &lt;&lt; cqueue.deleteHead() &lt;&lt; &quot; &quot;; } return 0;} 相关题目：用两个队列实现一个栈。 简单分析一下思路，模仿入栈操作时，只能用使用入队操作，当需要出栈时，元素在队列尾部，只能将前面所有元素进行出队才能获取到，而出队剩下的元素就继续进入到第二个队列中。","link":"/2020/12/07/s2o-c2-stk-queue/"},{"title":"《实时渲染 4th》第1章笔记 导论","text":"实时渲染一般指计算机里的快速图像生成。 PS：原书《Real Time Rendering 4th》全英文，有些词翻译如果不够好还请见谅。 Tips：屏幕刷新率(refresh rate)和显示频率(display rate)在现在是有区别的； We will not be able to cover every topic in depth, so our goal is to present key concepts and terminology, explain the most robust and practical algorithms in the field, and provide pointers to the best places to go for more information. 虽然这本书没有覆盖到实时渲染涉及到的每一个主题，但本书的目的是呈现关键概念和术语、解释最鲁邦和实用的算法、提供深入了解这些内容的方向指引。 1 内容概览 第2章 图形渲染管线：The Graphics Rendering Pipeline，实时渲染的核心是通过什么样的步骤来将场景传达到显示上； 第3章 图形处理单元：The Graphics Processing Unit，现代GPU中一般通过一组计算单元(fixed-function and programmable units)来实现渲染管线； 第4章 变换：Transforms，变换是操作物体位置、方向、大小以及形状、控制摄像机位置和视角的基本工具； 第5章 着色基础：Shading Basics，着色一般指的是通过材质(Material)和光源(Light)来表现物体，还有一些相关的主题，例如抗锯齿（反走样 antialiasing）、透明处理以及Gamma矫正； 第6章 纹理：Texturing，纹理贴图用于在物体表面呈现纹理； 第7章 光影：Shadows，光影让场景更有真实情感，会介绍一些快速计算光影的流行算法； 第8章 光和颜色：Light and Color，讲解计算机是如何如何量化光和颜色，以及把这些量化转换成显示量纲的方法； 第9章 基于物理的着色：Physically Based Shading，基于物理的着色会更加接近真实； 第10章 局部光照：Local Illumination，主要介绍一些渲染复杂光源的算法，例如光源本身具有物理形状； 第11章 全局光照：Global Illumination，模拟光源和场景之间的交互的算法，进一步增加场景的真实度； 第12章 图像效果：Image-Space Effects，GPU擅长快速处理图像，首先介绍图像滤波(image filtering)和重投影(reprojection)技术，然后介绍一些流行的后期效果，例如镜头光晕(lens flares)、动态模糊(motion blur)以及景深(depth of field)； 第13章 几何之外：Beyond Polygons，三角形不一定总是最快或最真实地描述物体的方式，还有其他方式，例如图片(images)、点云(point clouds)、体素(voxels)等； 第14章 体渲染和透光渲染：Volumetric and Translucency Rendering，介绍体积材质(volumetric material)（例如云、烟、雾）的表达方式以及和光的交互，大到气象效果，小到头发渲染； 第15章 非真实渲染：Non-Photorealistic Rendering，主要介绍一些风格渲染，例如卡通渲染(cartoon shading)、水彩效果(watercoloreffects)； 第16章 几何技术：Polygonal Techniques，几何体数据的来源各种各样，如果需要又快又好地渲染，就需要进行一定处理，涉及到几何数据表达和压缩方法； 第17章 曲线和曲面：Curves and Curved Surfaces，复杂的表面表达提供的优势在于更好的在质量和速度中进行取舍，表达越简洁，曲面就越光滑； 第18章 管线优化：Pipeline Optimization，寻找渲染瓶颈来优化速度，涉及到一些多线程技术； 第19章 加速算法：Acceleration Algorithms，比快更快，Variousforms of culling and level of detail rendering are covered； 第20章 高效着色：Efficient Shading，越多的光源，渲染就越慢，在渲染前无法知道是否需要渲染会造成资源浪费，使用一些方法可以解决这些问题； 第21章 虚拟现实和增强现实：Virtual and Augmented Reality，这些领域有很多特定的技术难题，也有一些相应方法来高效快速的生成图像； 第22章 相交检测：Intersection Test Methods，深入介绍一些几何相交检测的高效算法； 第23章 图形硬件：Graphics Hardware，图形硬件的一些细节，例如色彩深度(color depth)、帧缓冲(framebuffers)和基础架构类型； 第24章 面向未来：The Future，Take a guess (we do)。 还有一些没有收录在实体书中，在realtimerendering.com上更新的章节： 碰撞检测：Collision Detection，The 3rd edition’s chapter on this subject has been fully updated, but could not fit in the bounds of the physical book； 实时光线追踪：Real-Time Ray Tracing，API support for this area was announced in March 2018, too late for inclusion in the book, so we wrote an additional chapter about the subject as a whole. 附录：Appendices，The two appendices, Some Linear Algebra and Trigonometry, also had to be cut from the physical book. 2 标记和定义2.1 数学标记 向量或者点通常用粗体小写字母表示，并且其内部组成一般写为： $$ \\textbf{v} = \\left( \\begin{matrix} v_{x} \\\\ v_{y} \\\\ v_{z} \\end{matrix} \\right) $$ 在图形学领域中一般用列向量的表达方式，有时候为了书面方便也会写成行向量。 书中使用到矩阵大多是 \\(2 \\times 2\\)，\\(3 \\times 3\\) 和\\(4 \\times 4\\)，以\\(3 \\times 3\\)矩阵为例，说明矩阵的表示方式： $$ \\textbf{M} = \\left( \\begin{matrix} m_{00} & m_{01} & m_{02} \\\\ m_{10} & m_{11} & m_{12} \\\\ m_{20} & m_{21} & m_{22} \\end{matrix} \\right) \\tag{1.1} $$ 有时候为了表达需求，会只关注行向量或者列向量的内容，矩阵也可以写为： $$ \\textbf{M} = \\left( \\begin{matrix} \\textbf{m}_{,0} & \\textbf{m}_{,1} & \\textbf{m}_{,2} \\end{matrix} \\right) = \\left( \\begin{matrix} \\textbf{m}_{0,}^{T} \\\\ \\textbf{m}_{1,}^{T} \\\\ \\textbf{m}_{2,}^{T} \\end{matrix} \\right) \\tag{1.2} $$ 其中 \\(\\textbf{m}_{,j}\\) 代表第j列向量，\\(\\textbf{m}_{i,}\\) 代表第i行向量。 平面的数学表示是 \\(\\pi:\\textbf{n}\\cdot\\textbf{x} + d = 0\\)，其中 \\(\\textbf{n}\\)是平面的法向量，\\(d\\)是标量，平面将空间分为两个子空间，正子空间是 \\(\\textbf{n}\\cdot\\textbf{x} + d &gt; 0\\)，相应的负子空间是 \\(\\textbf{n}\\cdot\\textbf{x} + d &lt; 0\\) 三角形通常用三个点来表示，例如有不共线的三点 \\(\\textbf{v}_{0}, \\textbf{v}_{1}, \\textbf{v}_{2}\\)，构成的三角形是 \\(\\bigtriangleup\\textbf{v}_{0}\\textbf{v}_{1}\\textbf{v}_{2}\\)。 大部分都应该是比较常见的，需要稍微特殊说明的几个： 主要用于二维向量，求二维向量的垂直向量，例如有 \\(\\textbf{v}=(v_{x}, v_{y})\\)，\\(\\textbf{v}^{\\perp}=(-v_{y}, v_{x})\\)； 将x映射为非负空间数，当其为负值时会变为0； 和8较为类似，映射到0-1空间中，大于1变为1，小于0变为0； binomial coefficients，二项式系数，\\(\\left(\\begin{matrix}n \\\\ k\\end{matrix}\\right) = \\frac{n!}{k!(n-k)!}\\)。 一般把 \\(x=0, y=0, z=0\\) 叫做 坐标平面(coordinateplanes)或者轴对齐平面(axis-aligned planes)，将轴 \\(\\textbf{e}_{x}=(1, 0, 0), \\textbf{e}_{y}=(0, 1, 0), \\textbf{e}_{z}=(0, 0, 1)\\)叫做主轴(main axes)或者主方向(main directions)，也分别叫做x轴(x-axis)，y轴(y-axis)和z轴(z-axis)。 C语言数学函数 atan2(y,x) 有时候被经常提及到，它是arctan(x)的一个拓展，主要区别在于 \\(-\\frac{\\pi}{2} &lt; arctan(x) &lt; \\frac{\\pi}{2}\\)，\\(0 \\lep atan2(y, x) &lt; 2\\pi\\)，一种常用操作是计算arctan(y/x)，但是当x=0时会出现除0问题（尽管可能本意是表达一个无穷大数，但C语言会报除0错误），而这时候使用atan2(y,x)可以避免这样的问题。 log(n)函数一般指的是自然数e为底数，而不是以10为底数。 默认情况下均使用右手坐标系。 颜色一般用一个三元向量表示，(red, green, blue)，各项的值都在[0,1]。 2.2 几何定义最原石的一些基础渲染元(basic rendering primitives, also called drawing primitives)，最常用的是点、线和三角形。 在本书中，一组几何体(a collection of geometric entities)通常叫做一个模型(model)或者对象(object)；场景(scene)指的是环境中一组需要渲染模型，场景一般也包括材质描述、光线以及视角定义。 也有些不是使用点、线和三角形这种基础渲染元表达的模型，例如点云、函数表达（贝塞尔曲线）。 2.3 Shading和Shader？本书中的 Shading 和 Shader 是两个截然不同但是又有关联的概念： 前者指的是计算机生成的视觉表达(computer-generated visual appearance)，例如shading model、shading equation以及toon shading这些概念原理； 后者指的是渲染系统中的一个可编程单元，例如vertex shader、shading language。 尽管他们用词形式上有一些混淆，但是要通过语境上下文来判断其指的是哪个概念（在书本以外可能会单独开一页来讲一些概念的区分）。","link":"/2020/12/09/rtr-c1/"},{"title":"11月的计划","text":"11月大概还剩下一周的时间，主要是在尝试起步学一些东西： 《剑指Offer》：大概前几章，简单过一下摸一下这本书的安排规律，每章尽量写一点浓缩知识点； 《3D游戏与计算机图形学中的数学方法》：之前把Games101课程简单过了一下，再通过刷这本书巩固一下基础的数学。 12月的初步规划： 《剑指Offer》； 《3D游戏与计算机图形学中的数学方法》； 《Fundamentals of Computer Graphics》 。 1月的初步规划： 《Effictive C++》； 《Real Time Rendering 4th》； 《游戏引擎架构》。","link":"/2020/11/19/plan-2020-11/"},{"title":"《3D图形的数学》第3章笔记 变换","text":"3D游戏开发过程中，通常需要以某种方式对向量进行变换。 通常用到的变换包括平移、缩放和旋转。 1 通用变换通常把 \\(n \\times n\\) 可逆矩阵M看成是一个从坐标系到另一个坐标系的变换矩阵。 M的列给出了坐标轴从原坐标系到新坐标系的映射；\\(M^{-1}\\)的列给出了坐标轴从新坐标系到原坐标系的映射。 PS：书上的上面两句话，可以尝试从M乘以一个坐标轴单位向量的结果角度来考量，也就理解M的列是如何对一个向量或者坐标的各个轴的处理的。 多个变换可以串联起来，也可以将多个变换矩阵的乘积用一个矩阵来表示，例如 \\(G(MP)=(GM)P\\)，其中G/M是变换矩阵，P是坐标或向量，先做M变换再做G变换的结果可以用一个(GM)矩阵来存储，这样可以对顶点做无数次的变换，不需要额外的存储空间和计算开销。 1.1 正交矩阵正交矩阵的转置等于其逆矩阵。 【定义3.1】 一个n阶可逆方阵M，当且仅当 \\(M^{-1}=M^{T}\\)时，M为正交矩阵。 【定理3.2】 如果向量组 \\(V_{1}, V_{2}, \\cdots, V_{n}\\)构成的一个正交向量集合，则以 \\(V_{j}, (1 \\leq j \\leq n)\\)作为第j列的n阶方阵是正交矩阵。 正交矩阵还有另外一个性质，用于变换向量时，正交矩阵不改变向量的长度和角度（一般指的是两个同样变换的向量夹角）。 【定理3.3】 如果n阶方阵M正交，则M具有保证长度和角度不变的特性。 Tips：证明可以先从不改变两个向量的内积入手，然后再说明对单个向量不改变长度，再推出不改变角度。 由于这样的特性，使用正交矩阵变换可以保持坐标系的整体结构，所以正交矩阵只能用于表示旋转和反射（在某一方向上将点镜像的运算）的组合。 1.2 手向性在三维空间中，由3D向量 \\(V_{1}, V_{2}, V_{3}\\) 构成的坐标系的基具有手向性。对于右手基，有 \\((V_{1} \\times V_{2}) \\cdot V_{3} &gt; 0\\)，即在右手坐标系中， \\(V_{1}, V_{2}\\)的叉积(右手法则下)的方向与 \\(V_{3}\\)的方向形成一个锐角，如果是一个正交规范的右手基，则有 \\(V_{1} \\times V_{2} = V_{3}\\)；若\\((V_{1} \\times V_{2}) \\cdot V_{3} &lt; 0\\)，那么是左手基。 进行奇数次的反射操作，会改变手向性，偶数次的反射相当与一次旋转。通过考查变换矩阵的行列式可以判定矩阵是否存在反射，若行列式为负，则存在反射，用其对任意基的向量进行变换操作后，基的手向性发生改变。如果行列式是正的，则不改变手向性。 另外，正交矩阵的行列式值只可能是1或-1，如果为1，则矩阵只有旋转；如果为-1，则表示旋转操作后再进行一次反射。 2 缩放变换用a作为系数缩放向量P，只需要计算 \\(P^{‘}=aP\\)，在三维空间中，运算也可以表示为和矩阵的乘积： $$ P^{'} = \\left[ \\begin{matrix} a & 0 & 0 \\\\ 0 & a & 0 \\\\ 0 & 0 & a \\end{matrix} \\right] \\left[ \\begin{matrix} P_{x} \\\\ P_{y} \\\\ P_{z} \\end{matrix} \\right] \\tag{3.8} $$ 这种缩放成为统一缩放（各个轴相同缩放系数），如果希望在x,y,z轴以不同的值缩放向量，可以改变对角线上的元素（不再是相同的一个a），这种缩放称为非统一缩放。 $$ P^{'} = \\left[ \\begin{matrix} a & 0 & 0 \\\\ 0 & b & 0 \\\\ 0 & 0 & c \\end{matrix} \\right] \\left[ \\begin{matrix} P_{x} \\\\ P_{y} \\\\ P_{z} \\end{matrix} \\right] \\tag{3.9} $$ 如果想在3个任意轴上进行非统一缩放，就要用到稍微复杂的缩放过程。假设以a,b,c为系数，在U,V,W轴方向上进行缩放，就需要先从坐标系(U,V,W)变换到坐标系(i,j,k) （这一步乘以[U V W]的逆矩阵变换到UVW为ijk坐标轴的空间中），然后在(i,j,k)坐标系中计算缩放（乘以缩放矩阵），最后再还原到(U,V,W)坐标系（乘以[U V W]矩阵变换到原本的ijk坐标轴空间中）。 $$ P^{'} = \\left[ \\begin{matrix} U_{x} & V_{x} & W_{x} \\\\ U_{y} & V_{y} & W_{y} \\\\ U_{z} & V_{z} & W_{z} \\end{matrix} \\right] \\left[ \\begin{matrix} a & 0 & 0 \\\\ 0 & b & 0 \\\\ 0 & 0 & c \\end{matrix} \\right] \\left[ \\begin{matrix} U_{x} & V_{x} & W_{x} \\\\ U_{y} & V_{y} & W_{y} \\\\ U_{z} & V_{z} & W_{z} \\end{matrix} \\right]^{-1} \\left[ \\begin{matrix} P_{x} \\\\ P_{y} \\\\ P_{z} \\end{matrix} \\right] \\tag{3.10} $$ Tips：这一段其实说的有点绕，但其实理解第一步就可以理解后面了，关于为什么是乘以逆矩阵，是因为(U,V,W)中的目标 \\(P^{uvw}\\) 有以下的表示方法： $$ P^{uvw}_{x} \\left[ \\begin{matrix} U_{x} \\\\ U_{y} \\\\ U_{z} \\end{matrix} \\right] + P^{uvw}_{y} \\left[ \\begin{matrix} W_{x} \\\\ W_{y} \\\\ W_{z} \\end{matrix} \\right] + P^{uvw}_{z} \\left[ \\begin{matrix} V_{x} \\\\ V_{y} \\\\ V_{z} \\end{matrix} \\right] \\\\ = \\left[ \\begin{matrix} U_{x} & V_{x} & W_{x} \\\\ U_{y} & V_{y} & W_{y} \\\\ U_{z} & V_{z} & W_{z} \\end{matrix} \\right] \\left[ \\begin{matrix} P^{uvw}_{x} \\\\ P^{uvw}_{y} \\\\ P^{uvw}_{z} \\end{matrix} \\right] = \\left[ \\begin{matrix} P_{x} \\\\ P_{y} \\\\ P_{z} \\end{matrix} \\right] $$ 所以要求得(U,V,W)坐标系下的坐标 \\(P^{uvw}\\) 就要用原坐标乘以矩阵[U V W]的逆矩阵： $$ \\left[ \\begin{matrix} P^{uvw}_{x} \\\\ P^{uvw}_{y} \\\\ P^{uvw}_{z} \\end{matrix} \\right] = \\left[ \\begin{matrix} U_{x} & V_{x} & W_{x} \\\\ U_{y} & V_{y} & W_{y} \\\\ U_{z} & V_{z} & W_{z} \\end{matrix} \\right]^{-1} \\left[ \\begin{matrix} P_{x} \\\\ P_{y} \\\\ P_{z} \\end{matrix} \\right] $$ 这也就解释了第一步为什么乘以的是逆矩阵，后面也就相同的方法来解释了。 3 旋转变换得到将坐标系绕x,y或z轴旋转 \\(\\theta\\)角的矩阵并不难，当A轴指向我们时，所看到的旋转时逆时针方向。 首先看一下二维空间旋转的通用公式，如图3.2所示，通过交换x和y坐标，并将新的x坐标取负，得到(-y,x)，就能够将位于xy平面线上的二维向量P进行90°的逆时针旋转。设旋转向量为Q，则有 \\( Q=&lt;-P_{y}, P_{x}&gt;\\)。向量P和Q组成了xy平面的一个正交基，因此xy平面的任意向量都可以用这两个向量的线性组合来表示。 如图3.3所示，任意向量P以 \\(\\theta\\)角旋转后所形成的二维向量 \\(P^{‘}\\)，都可以用分别平行于P和Q的分量来表示。 $$ P^{'} = Pcos\\theta + Qsin\\theta \\tag{3.11} $$ 带入Q的坐标计算，可以有： $$ \\begin{aligned} P^{'}_{x} &= P_{x}cos\\theta - P_{y}sin\\theta \\\\ P^{'}_{y} &= P_{y}cos\\theta + P_{x}sin\\theta \\end{aligned} \\tag{3.12} $$ 用矩阵改写则有： $$ P^{'} = \\left[ \\begin{matrix} cos\\theta & -sin\\theta \\\\ sin\\theta & cos\\theta \\end{matrix} \\right] P \\tag{3.13} $$ 将单位矩阵的第3行和第3列加入到等式3.13中的2D旋转矩阵，就可以扩展成3D空间中绕z轴的三维旋转，在旋转过程中z坐标保持不变，绕z轴旋转 \\(\\theta\\) 角度的旋转矩阵 \\(R_{z}(\\theta)\\)可以表示为： $$ R_{z}(\\theta) = \\left[ \\begin{matrix} cos\\theta & -sin\\theta & 0 \\\\ sin\\theta & cos\\theta & 0 \\\\ 0 & 0 & 1 \\end{matrix} \\right] \\tag{3.14} $$ 同样，可以分别得到绕x轴和绕y轴旋转\\theta角度的旋转矩阵 \\(R_{x}(\\theta)\\) 和 \\(R_{y}(\\theta)\\)： $$ \\begin{aligned} R_{x}(\\theta) = \\left[ \\begin{matrix} 1 & 0 & 0 \\\\ 0 & cos\\theta & -sin\\theta \\\\ 0 & sin\\theta & cos\\theta \\end{matrix} \\right] \\\\ R_{y}(\\theta) = \\left[ \\begin{matrix} cos\\theta & 0 & sin\\theta \\\\ 0 & 1 & 0 \\\\ -sin\\theta & 0 & cos\\theta \\end{matrix} \\right] \\end{aligned} \\tag{3.15} $$ 3.1 绕任意轴旋转如果如果希望将向量P绕一个任意轴旋转 \\(\\theta\\) 角，选定的任意轴以单位向量A表示，那么可以先将向量P分解为平行于A和垂直于A的分量。如图3.4所示，由于平行分量在旋转过程中保持不变，所以只需要计算垂直于A的分量的旋转。 A是一个单位向量，P在A上地投影为（公式1.18）： $$ proj_{A}P = \\frac{P \\cdot A}{A^{2}} A = (P \\cdot A)A \\tag{3.16} $$ P垂直于A的分量为（公式1.19）： $$ perp_{A} P = P - proj_{A} P = P - (P \\cdot A)A \\tag{3.17} $$ 将垂直于A的分量进行旋转，再加上平行分量，就得到最终的旋转结果。 垂直分量的旋转实在垂直于A轴的平面内进行的，平面中可以用垂直分量和垂直分量旋转90°所形成的向量组成一组正交基，就可以表达该平面内的任意向量，垂直分量旋转90°的向量可以用 \\(A \\times P\\) 得到。 用下面的公式表示 \\(perp_{A}P\\)旋转 \\(\\theta\\)角，即： $$ [P - (P \\cdot A)A]cos\\theta + (A \\times P)sin\\theta \\tag{3.18} $$ 再加上平行分量 \\(proj_{A}P\\)，就可以得到P绕A轴旋转的公式： $$ P^{'} = [P - (P \\cdot A)A]cos\\theta + (A \\times P)sin\\theta + (P \\cdot A)A \\\\ = Pcos\\theta + (A \\times P)sin\\theta + (P \\cdot A)A(1 - cos\\theta) \\tag{3.19} $$ 将其中的 \\(A \\times P\\)和 \\((P \\cdot A)A\\)替换为等价矩阵形式，就可以更加具体的表示出旋转矩阵 \\(R_{A}(\\theta)\\)，公式过于繁杂就不再赘述。 4 齐次坐标还有一个重要的变换是平移操作，在空间中平移坐标系，只需要简单地添加偏移向量，并不会影响坐标轴的方向和尺度，但这种矩阵无法用 \\(3 \\times 3\\)的矩阵来直接表示，需要加一个平移分量： $$ P^{'} = MP + T \\tag{3.22} $$ M为可逆变换矩阵，T是平移向量。 4.1 四维变换可以用一种统一的数学形式来简洁而优雅地表示这些变换（包含平移操作），为了做到这一点，需要将向量从三维扩展到四维，使用 \\(4 \\times 4\\)矩阵来表示变换操作，给3D点P增加一个坐标，并将这个扩展的第四坐标(称为w坐标)的值设为1。 构造一个 \\(4 \\times 4\\)变换矩阵F，F对应于变换矩阵M和3D平移变换T： $$ F = \\left[ \\begin{matrix} M & T \\\\ 0 & 1 \\end{matrix} \\right] = \\left[ \\begin{matrix} M_{11} & M_{12} & M_{13} & T_{x} \\\\ M_{21} & M_{22} & M_{23} & T_{y} \\\\ M_{31} & M_{32} & M_{33} & T_{z} \\\\ 0 & 0 & 0 & 1 \\end{matrix} \\right] \\tag{3.24} $$ 这个矩阵乘以向量 \\(P=&lt;P_{x}, P_{y}, P_{z}, 1&gt;\\) 就等效于公式3.22，同时结果w坐标保持为1. 4.2 点向量和方向向量Tips：书上把点坐标叫做点向量还是蛮奇怪的，就理解成点坐标就行了。 由于方向向量不会受平移变换的影响，所以在其扩展四维时，其w坐标设置为0（其实也可以从两个点坐标相减的角度理解，两个w相减就是0了），这个时候F矩阵中只有左上的 \\(3 \\times 3\\) 部分可以影响方向向量。 4.3 坐标的几何解释假设有一个四维点 \\(P=&lt;x, y, z, w&gt;\\)，其中坐标不为0，这里定义P在三维空间的映像，如果用 \\(\\widetilde{P}\\)表示P在 \\(w=1\\)的三维空间中的投影，\\(\\widetilde{P}\\)可以用下面的公式来表示： $$ \\widetilde{P} = \\tag{3.28} $$ 如图3.6所示（图中省略z轴为了方便表示），三维点 \\(\\widetilde{P}\\) 对应于连接点P与原点的直线和 \\(w=1\\)的平面的交点，从这一点可以知道，对四维向量P作任意系数乘积，其结果都对应于三维空间中一个相同的点，在第4章5节中详细讨论这种投影在三维图形中的重要性。 5 法向量的变换一个多边形模型的顶点除了需要表示空间位置外，还要包含一些附加信息，这些信息用来表示该顶点是如何融合到周围的曲面中的。一般情况下，顶点可能有切线向量和法线向量与之关联。当变换一个模型时，不但要变换顶点，同时还要对与顶点有关的向量进行变换。 可通过求两个顶点之间的差来计算切线向量，所以经过变换的切线向量可以表示为两个变换点的差。如果使用一个矩阵来变换顶点位置，也可以用这个矩阵来变换顶点的切向量。图3.7所示所示为用一个非正交矩阵M变换法向量N时发生的情况，变换后的法向量最终不垂直于变换后的表面。 因为切线方向和法线方向是垂直的，所以同一顶点的切向量T和法向量N必须满足等式 \\(N \\cdot T = 0\\)，并且必须保证变换后的切向量 \\(T^{‘}\\)和法向量 \\(N^{‘}\\)仍然满足等式，设变换矩阵为M，有 \\(T^{‘}=MT\\)，设变换N所需的矩阵为G，有： $$ N^{'} \\cdot T^{'} = (GN) \\cdot (MT) = 0 \\tag{3.29} $$ 经过简单的运算，可以得到： $$ (GN) \\cdot (MT) = (GN)^{T}(MT) = N^{T}G^{T}MT \\tag{3.30} $$ 由于 \\(N^{T}T=0\\)，如果 \\(G^{T}M=I\\)，则等式 \\(N^{T}G^{T}MT\\) 肯定成立。因此可以得出 \\(G=(M^{-1})^{T}\\)。可以看出，用变换点的矩阵的逆转置矩阵，就能正确地变换法向量，必须通过这种方式变换的向量称为协变向量，用矩阵M以通常方式变换的向量（点或切向量）称为逆变向量。 如果矩阵M是正交的，那么 \\(M^{-1}=M^{T}\\)，因此 \\((M^{-1})^{T}=M\\)，所以当M是正交矩阵时，法向量变换过程的求逆转置运算就可以避免，这一点适用于本章前面提到的当M等于旋转矩阵的情况。 6 四元数四元数是三维图像编程人员用来表示旋转的另一种数学形式。 在许多情况下，用四元数代替旋转矩阵会有很多的好处，因为四元数需要的存储空间更少，四元数之间的连接运算需要的算术运算更少，在产生平滑的三维动画时，用四元数更容易进行修改。 6.1 四元数数学四元数集合，被数学家们称为哈密顿四元数环(ring of Hamiltonian quaternions)，用H表示，可以理解为四维向量空间，空间中的元素q具有以下形式： $$ q = [w, x, y, z] = w + xi + yj + zk \\tag{3.31} $$ 四元数经常写为 \\(q=s+v\\)的形式，其中s表示数量部分，对应于q中的w分量，v表示向量部分，对应于q中的x,y,z分量。 四元数集合是复数集合的自然扩展，四元数的乘法服从分配率，并且虚部i,j,k之间的乘法服从下面的规则： $$ \\begin{aligned} i^{2} &= j^{2} = k^{2} = -1 \\\\ ij &= -ji = k \\\\ jk &= -kj = i \\\\ ki &= -ik = j \\end{aligned} \\tag{3.32} $$ 四元数式的乘法是不可交换的，因此运算要注意顺序。 两个四元数 \\(q_{1}=w_{1}+x_{1}i+y_{1}j+z_{1}k\\) 和 \\(q_{2}=w_{2}+x_{2}i+y_{2}j+z_{2}k\\) 的乘积 \\(q_{1}q_{2}\\) 为： $$ q_{1}q_{2} = \\\\ (w_{1}w_{2} - x_{1}x_{2} - y_{1}y_{2} - z_{1}z_{2}) + \\\\ (w_{1}x_{2} + x_{1}w_{2} + y_{1}z_{2} - z_{1}y_{1})i + \\\\ (w_{1}y_{2} - x_{1}z_{2} + y_{1}w_{2} + z_{1}x_{2})j + \\\\ (w_{1}z_{2} + x_{1}y_{2} - y_{1}x_{2} + z_{1}w_{2})k \\tag{3.33} $$ 如果写成数量-向量形式，则 \\(q_{1}=s_{1}+v_{1}\\) 和 \\(q_{2}=s_{2}+v_{2}\\) 的乘积可以写成如下形式： $$ q_{1}q_{2} = s_{1}s_{2} - v_{1} \\cdot v_{2} + s_{1}v_{2} + s_{2}v_{1} + v_{1} \\times v_{2} \\tag{3.34} $$ 和复数一样，四元数有共轭。 【定义3.4】 四元数 \\(q=s+v\\)的共轭，记为 \\(\\bar{q}\\)，定义为 \\(\\bar{q}=s-v\\)。 通过简单的运算，就可以发现q与其共轭 \\(\\bar{q}\\)的乘积等于q自身的点积，也就是等于q模的平方。 $$ q \\bar{q} = \\bar{q} q = q \\cdot q = ||q||^{2} = q^{2} \\tag{3.35} $$ 【定理3.5】 非零的四元数的逆，记为 \\(q^{-1}\\)，则有： $$ q^{-1} = \\frac{\\bar{q}}{q^{2}} \\tag{3.36} $$ 6.2 四元数的旋转三维空间的旋转可以理解为 \\(R^{3}\\) 到自身 的映射函数 \\(\\varphi\\)。由于\\(\\varphi\\)代表旋转，所以它必须包含长度、角度、旋转方向等信息。如果有： $$ ||\\varphi(P)||=||P|| \\tag{3.39} $$ 则长度保持不变。 如果对任意两个点 \\(P_{1}\\) 和 \\(P_{2}\\)有： $$ \\varphi(P_{1}) \\cdot \\varphi(P_{2}) = P_{1} \\cdot P_{2} \\tag{3.40} $$ 则从原点到两个点 \\(P_{1}\\) 和 \\(P_{2}\\)的连线所形成的夹角保持不变。 最后，如果： $$ \\varphi(P_{1}) \\times \\varphi(P_{2}) = \\varphi(P_{1} \\times P_{2}) \\tag{3.41} $$ 则手向性也保持不变。 如果满足条件 \\(\\varphi(s+v)=s+\\varphi(v)\\)，则函数 \\(\\varphi\\)可以扩展为H到自身的映射，这样就允许将公式(3.40)重写为： $$ \\varphi(P_{1}) \\cdot \\varphi(P_{2}) = \\varphi(P_{1} \\cdot P_{2}) \\tag{3.42} $$ 如果将 \\(P_{1}\\)和 \\(P_{2}\\)看成是数量部分为0的四元数，根据 \\(P_{1}P_{2} = -P_{1} \\cdot P_{2} + P_{1} \\times P_{2}\\)，就可以将等式(3.41)和(3.42)合并成一个等式，在该等式中可以保持角度不变和手向性不变，公式如下： $$ \\varphi(P_{1})\\varphi(P_{2}) = \\varphi(P_{1}P_{2}) \\tag{3.43} $$ 满足这种等式的函数 \\(\\varphi\\) 称为是同态的。 这一类函数可以用下面的公式给出： $$ \\varphi_{q}(P) = qPq^{-1} \\tag{3.44} $$ 其中q是一个非0的四元数，且满足等式(3.39)（长度不变）和(3.43)（角度不变、手向性不变），因此可以表示旋转的集合。 现在需要找到一个关于四元数q的公式，q对应于 \\(\\theta\\)角绕A轴的旋转。简单的计算表明 \\(\\varphi_{aq}=\\varphi_{q}\\) 适用于任何非零数量a，为了简单起见，只涉及单位四元数。设 \\(q=s+v\\) 是单位四元数，则 \\(q^{-1}=s-v\\)，对于给定的点P，有： $$ \\begin{aligned} qPq^{-1} &= (s + v)P(s - v) \\\\ &= (-v \\cdot P + sP + v \\times P)(s - v) \\\\ &= -sv \\cdot P + s^{2}P + sv \\times P + (v \\cdot P)v - sPv - (v \\times P)v \\\\ &= s^{2}P + 2sv \\times P + (v \\cdot P)v - v \\times P \\times v \\end{aligned} \\tag{3.47} $$ 对叉积 \\(v \\times P \\times v\\) 使用定理1.9(6)，这个等式就变为： $$ \\begin{aligned} v \\times (P \\times v) = v \\times P \\times v = v^{2}P - (v \\cdot P) v \\\\ qP^{-1}q = (s^{2}-v^{2})P + 2sv \\times P + 2(v \\cdot P)v \\end{aligned} \\tag{3.48} $$ 设 \\(v=tA\\)，其中A为单位向量，则上式可改写为： $$ qP^{-1}q = (s^{2}-v^{2})P + 2stA \\times P + 2t^{2}(A \\cdot P)A \\tag{3.49} $$ 比较等式(3.19)给出的绕任意轴旋转的公式，可以推出下面的等式： $$ P^{'} = [P - (P \\cdot A)A]cos\\theta + (A \\times P)sin\\theta + (P \\cdot A)A \\\\ = Pcos\\theta + (A \\times P)sin\\theta + (P \\cdot A)A(1 - cos\\theta) \\tag{3.19} $$ $$ \\begin{aligned} s^{2} - t^{2} &= cos\\theta \\\\ 2st &= sin\\theta \\\\ 2t^{2} &= 1 - cos\\theta \\end{aligned} \\tag{3.50} $$ 由第三个等式可以得出： $$ t = \\sqrt{\\frac{1-cos\\theta}{2}} = sin\\frac{\\theta}{2} \\tag{3.51} $$ 结合式(3.50)中第一和第三个等式，可以得出 \\(s^{2}+t^{2}=1\\)，因此可以肯定 \\(s=cos\\frac{\\theta}{2}\\)。 现在可以用下面的等式给出对应于 \\(\\theta\\)角绕A轴旋转的单位四元数q为： $$ q = cos\\frac{\\theta}{2} + Asin\\frac{\\theta}{2} \\tag{3.52} $$ 这里应注意：四元数q的任意数量乘积(特别是-q)表示的是相同的旋转，这是因为之前说的\\(\\varphi_{aq}=\\varphi_{q}\\) 适用于任何非零数量a。 $$ (aq)P(aq)^{-1} = aqP \\frac{q^{-1}}{a} = qP^{-1}q \\tag{3.53} $$ 两个四元数的乘积也可以表示一个旋转，乘积 \\(q_{1}q_{2}\\) 表示先以 \\(q_{2}\\)，后以 \\(q_{1}\\)进行旋转： $$ q_{1}(q_{2}Pq_{2}^{-1})q_{1}^{-1} = (q_{1}q_{2})P(q_{1}q_{2})^{-1} \\tag{3.54} $$ 可以将任意多的四元数结合起来，形成表示一系列旋转的一个四元数，将两个四元数相乘需要做16次乘法和加法运算，而两个 \\(3 \\times 3\\) 矩阵相乘需要27次这样的操作，因此当对物体进行多次旋转时，应用四元数可以获得较高的计算效率。 经常需要将一个四元数变成等价的 \\(3 \\times 3\\)旋转矩阵的形式。利用等式(1.25)和(1.20)，可以确定对应于四元数 \\(q = s + tA\\)的矩阵公式。 $$ P \\times Q = \\left[ \\begin{matrix} 0 & -P_{z} & P_{y} \\\\ P_{z} & 0 & -P_{x} \\\\ -P_{y} & P_{x} & 0 \\end{matrix} \\right] \\left[ \\begin{matrix} Q_{x} \\\\ Q_{y} \\\\ Q_{z} \\end{matrix} \\right] \\tag{1.25} $$ $$ proj_{Q} P = \\frac{1}{Q^{2}} \\left[ \\begin{matrix} Q_{x}^{2} & Q_{x}Q_{y} & Q_{x}Q_{z} \\\\ Q_{x}Q_{y} & Q_{y}^{2} & Q_{y}Q_{z} \\\\ Q_{x}Q_{z} & Q_{y}Q_{z} & Q_{z}^{2} \\end{matrix} \\right] \\left[ \\begin{matrix} P_{x} \\\\ P_{y} \\\\ P_{z} \\end{matrix} \\right] \\tag{1.20} $$ 然后将等式(3.49)改写成矩阵形式(和3.1节中用的技巧类似），由此可得： $$ qPq_{-1} = \\left[ \\begin{matrix} s^{2}-t^{2} & 0 & 0 \\\\ 0 & s^{2}-t^{2} & 0 \\\\ 0 & 0 & s^{2}-t^{2} \\end{matrix} \\right]P + \\\\ 2st\\left[ \\begin{matrix} 0 & -A_{z} & A_{y} \\\\ A_{z} & 0 & -A_{x} \\\\ -A_{y} & A_{x} & 0 \\end{matrix} \\right]P + \\\\ 2t^{2}\\left[ \\begin{matrix} A_{x}^{2} & A_{x}A_{y} & A_{x}A_{z} \\\\ A_{x}A_{y} & A_{y}^{2} & A_{y}A_{z} \\\\ A_{x}A_{z} & A_{y}A_{z} & A_{z}^{2} \\end{matrix} \\right]P \\tag{3.55} $$ 将四元数p写成四维向量 \\(q=&lt;w,x,y,z&gt;\\)，那么 \\(w=s, x=tA_{x}, y=tA_{y}, z=tA_{z}\\)，因此A是单位向量，所以 \\(x^{2}+y^{2}+z^{2} = t^{2}A^{2} = t^{2}\\)，以 \\(w,x,y,z\\)为分量，则公式(3.55)可以改写为： $$ qPq_{-1} = \\left[ \\begin{matrix} w^{2}-x^{2}-y^{2}-z^{2} & 0 & 0 \\\\ 0 & w^{2}-x^{2}-y^{2}-z^{2} & 0 \\\\ 0 & 0 & w^{2}-x^{2}-y^{2}-z^{2} \\end{matrix} \\right]P + \\\\ 2w\\left[ \\begin{matrix} 0 & -z & y \\\\ z & 0 & -x \\\\ -y & x & 0 \\end{matrix} \\right]P + \\\\ 2\\left[ \\begin{matrix} x^{2} & xy & xz \\\\ xy & y^{2} & yz \\\\ xz & yz & z^{2} \\end{matrix} \\right]P \\tag{3.56} $$ 因为q是单位四元数，满足 \\(w^{2} + x^{2} + y^{2} + z^{2} = 1\\)，所以有： $$ w^{2} - x^{2} - y^{2} - z^{2} = 1 - 2x^{2} - 2y^{2} - 2z^{2} \\tag{3.57} $$ 根据该等式，并结合前面的三个矩阵，可以得到用来计算矩阵 \\(R_{q}\\) 的公式，这里的 \\(R_{q}\\) 表示对应于四元数q的旋转矩阵，公式为： $$ R_{q} = \\left[ \\begin{matrix} 1-2y^{2}-2z^{2} & 2xy-2wz & 2xz+2wy \\\\ 2xy+2wz & 1-2x^{2}-2z^{2} & 2yz-2wx \\\\ 2xz-2wy & 2yz+2wx & 1-2x^{2}-2y^{2} \\end{matrix} \\right] \\tag{3.58} $$ 6.3 球形线性插值因为四元数是用向量表示的，所以很适合于插值运算。在产生一个物理动画的过程中，在产生位于两个预先计算的关键帧之间的中间过渡定位时，插值非常有用。 最简单的插值类型是线性插值，对于两个四元数 \\(q_{1}\\)和 \\(q_{2}\\)，线性插值后所得的四元数 \\(q_{t}\\)为： $$ q(t) = (1-t)q_{1} + tq_{2} \\tag{3.59} $$ 当t在0和1之间变化时，函数 \\(q(t)\\)在连接 \\(q_{1}\\)和 \\(q_{2}\\)的线段上平滑变化。 如上图所示，\\(q(t)\\)并不保持 \\(q_{1}\\)和 \\(q_{2}\\)的单位长度，但可以使用下面的函数在任意点位置对 \\(q(t)\\)进行重新规格化： $$ q(t)=\\frac{(1-t)q_{1} + tq_{2}}{||(1-t)q_{1} + tq_{2}||} \\tag{3.60} $$ 尽管线性插值是很有效的，但由等式(3.60)得出的函数 \\(q(t)\\)并没有以恒定的速率描绘 \\(q_{1}\\)和 \\(q_{2}\\)间的过渡弧线，这是线性插值的弊端。如下图所示，\\(q_{1},q_{2}\\)之间的角度变化速率在端点时相对较慢，在中间的地方最快。 我们希望找到一个函数 \\(q(t)\\)，用它对四元数 \\(q_{1}\\)和 \\(q_{2}\\)进行插值时，会保持其单位长度不变并且以恒定的速率扫过位于 \\(q_{1}\\)和 \\(q_{2}\\)之间的夹角。 如果 \\(q_{1}\\)和 \\(q_{2}\\)的夹角为 \\(\\theta\\)，那么这个函数将会产生一个四元数，该四元数在 \\(q(t)\\)和 \\(q_{1}\\)之间形成一个夹角 \\(\\theta t\\)，这里t在0在1之间取值。 如下图所示，四元数 \\(q(t)\\)位于连接 \\(q_{1}\\)和 \\(q_{2}\\)的弧上，与 \\(q_{1}\\)构成夹角 \\(\\theta t\\)，与 \\(q_{2}\\)构成夹角 \\(\\theta(1-t)\\)，可以将 \\(q(t)\\)写成： $$ q(t) = a(t)q_{1} + b(t)q_{2} \\tag{3.61} $$ 如图(a)所示，可以构造相似三角形来确定长度 \\(a(t)\\)，\\(q_{1}\\)到以原点和 \\(q_{2}\\)为端点的线段的垂直距离为 \\(||q_{1}||sin\\theta\\)，而 \\(q(t)\\)到该线段的垂直距离为 \\(||q(t)||sin(\\theta(1-t))\\)，根据相似三角形，可以由： Tips：书上说的这个相似三角形在图(a)中并不明显，是以角 \\(\\theta\\)为共同角，将边 \\(||q(t)||sin(\\theta(1-t))\\) 平移到左边，构成的一个小三角形。 $$ \\frac{a(t)}{||q(t)||sin(\\theta(1-t))} = \\frac{||q_{1}||}{||q||sin\\theta} $$ 所以有： $$ \\frac{a(t)}{||q_{1}||} = \\frac{||q(t)||sin(\\theta(1-t))}{||q||sin\\theta} \\tag{3.62} $$ 由于 \\(||q_{1}||=1\\)，\\(||q(t)||=1\\)，可以将上式简化为： $$ a(t) = \\frac{sin(\\theta(1-t))}{sin\\theta} \\tag{3.63} $$ 图(b)表示了求长度 \\(b(t)\\)的相同过程，有结果： $$ b(t) = \\frac{sin(\\theta t)}{sin\\theta} \\tag{3.64} $$ 可以将球型线性插值函数 \\(q(t)\\)定义如下： $$ q(t)= \\frac{sin(\\theta(1-t))}{sin\\theta}q_{1} + \\frac{sin(\\theta t)}{sin\\theta}q_{2} \\tag{3.65} $$ 这里的角 \\(\\theta\\) 为： $$ \\theta = arccos(q_{1} \\cdot q_{2}) \\tag{3.66} $$ \\(sin\\theta\\)计算： $$ sin\\theta = \\sqrt{1-(q_{1} \\cdot q_{2})^{2}} \\tag{3.67} $$ 因为四元数 \\(q\\) 和\\(-q\\)表示相同的旋转，所以选择四元数 \\(q_{1}\\)和 \\(q_{2}\\)的正负号时一般要满足 \\(q_{1} \\cdot q_{2} \\geq 0\\)，这样可以保证以最短路径的方式进行插值。","link":"/2020/12/12/3dmath-c3/"},{"title":"《剑指Offer》第2章笔记 算法和数据操作","text":"考算法的面试题也备受面试官青睐（老折磨人了）。 通常排序和查找是面试时考查算法的重点，准备的时候要重点掌握二分查找、归并排序和快速排序，要做到随时正确、完整地写出它们地代码。 二维数组上搜索路径的一些题目可以尝试用回溯法，通常回溯法适合用递归代码实现，如果面试官不允许递归实现，再尝试用栈来模拟递归过程。 如果是求解某个问题的最优解，并且问题可以分为子问题解决，就可以尝试用动态规划，如果在分解子问题中，满足一些特定条件就可以找到最优解，可以考虑用贪婪最优法。 1 递归和循环 递归的代码通常比循环更加简洁，但代价是效率不够高，并且还有递归栈层数限制； 在一些题目中简单的递归会增加不必要的重复计算； 应用动态规划解决问题时，大部分都是递归方法分析问题，有些问题会出现子问题重复计算，到时候会讨论如何用循环替换递归实现； 面试题10：斐波那契数列 题目一：求斐波那契数列的第n项，f(0) = 0, f(1) = 1, f(n) = f(n-1) + f(n-2)。 最简单的递归法就不在说明了，这里直接写一下不用重复计算的思路，当需要求解第n项时，需要求解前n-1项，通过观察可以发现从第2项开始计算，可以避免重复计算的问题。 123456789101112131415161718192021222324252627#include &lt;iostream&gt;#include &lt;algorithm&gt;const int max_n = 1000;// 如果不需要缓存，使用两个变量求解即可long long store[max_n];long long fibonacci(unsigned n) { if(n &gt;= max_n) { return -1; // Throw Error } else if (store[n] != -1) { return store[n]; } else { for(int i = 2; i &lt;= n; i++) { store[i] = store[i-1] + store[i-2]; } return store[n]; }}int main() { std::fill(&amp;store[0], &amp;store[max_n], -1); store[0] = 0; store[1] = 1; std::cout &lt;&lt; fibonacci(50) &lt;&lt; std::endl; return 0;} 书上还有一个O(logn)的算法，要使用到一个数学公式： $$ \\left[ \\begin{matrix} f(n) & f(n-1) \\\\ f(n-1) & f(n-2) \\end{matrix} \\right] = \\left[ \\begin{matrix} 1 & 1 \\\\ 1 & 0 \\end{matrix} \\right]^{n-1} $$ 公式可以用数学归纳法证明，问题就转换为如何求矩阵乘方，如果只是简单地从0开始循环，n次方需要n次元素，时间复杂度仍然是O(n)，并不比前面的方法快，但是其中的乘方有如下性质： $$ a^{n} = \\left\\{ \\begin{array}{rcl} a^{n/2} \\cdot a^{n/2}, & & n\\ is\\ even \\\\ a^{(n-1)/2} \\cdot a^{(n-1)/2} \\cdot a, & & n\\ is\\ odd \\end{array} \\right. $$ 从公式可以看出，如果想求得n次方，就要先求得n/2次方，再把n/2次方的结果平方一下即可，时间复杂度为O(logn)。 不过算法仅做了解，很少会这么去写，实现起来也比较复杂。 还有不少面试题可以看成是斐波那契数列的应用： 题目二：青蛙跳台阶问题。 一只青蛙一次可以跳上1级台阶，也可以跳上2级台阶，求该青蛙跳上一个n级的台阶总共有多少种跳法。 将问题看作是求解函数f(n)，当青蛙第1次跳1级，则下一次求解f(n-1)，如果青蛙第1次跳2级，则下一次求解f(n-2)，所以其实本质还是斐波那契数列f(n)=f(n-1)+f(n-2)。 2 查询和排序查询相对于排序较为简单，不外乎顺序查找、二分查找、哈希表查找和二叉排序树查找。在面试的时候，不管是用循环还是递归，面试官都期待应聘者能够信手拈来写出完整正确地二分查找代码，否则可能连继续面试的兴趣都没有。 排序比查找要复杂一点，面试官会经常要求应聘者比较 插入排序、冒泡排序、归并排序、快速排序等不同算法的优劣。 实现快速排序算法的关键在于先在数组中选择一个数字，接下来把数组中的数字分为两部分，比选择的数字小的数字移到数组左边，比选择的数字大的数字移到数组的右边（递增排序）。 （然后就是一段基本上在哪本书上都能看到的快速排序代码） 12345678910111213141516171819202122232425int partition(int data[], int len, int start, int end) { if(data == nullptr || len &lt;=0 || start &lt; 0 || end &gt;= len) { std::logic_error ex(&quot;Invalid Parameters&quot;); throw std::exception(ex); } int index = random_in_range(start, end); swap(&amp;data[index], &amp;data[end]); // end位置存储比较元素 int small = start - 1; // small用来指向存放小于比较元素的位置 for(index = start; index &lt; end; index++) { if(data[index] &lt; data[end]) { // 比比较元素小的就交换到small的地方 small++; if(small != index) { // 如果位置相同就没必要再交换了 swap(&amp;data[index], &amp;data[small]); } } } small++; swap(&amp;data[small], &amp;data[end]); // 比较元素也放回对应位置 return small; // 返回比较元素的位置，划分左右两个子数组} 上面是partition部分的代码，快速排序的其中一步，选择锚元素(比较元素)，将数组start-end区域的元素划分为两部分，一部分小于锚元素，另一部分大于锚元素。 完整的运行代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263#include &lt;iostream&gt;#include &lt;cstdlib&gt;#include &lt;ctime&gt;#include &lt;exception&gt;int random_in_range(int start, int end) { srand((unsigned)time(NULL)); return rand() % (end - start + 1) + start;}void swap(int* lhs, int* rhs) { int temp = *lhs; *lhs = *rhs; *rhs = temp;}int partition(int data[], int len, int start, int end) { if(data == nullptr || len &lt;=0 || start &lt; 0 || end &gt;= len) { std::logic_error ex(&quot;Invalid Parameters&quot;); throw std::exception(ex); } int index = random_in_range(start, end); swap(&amp;data[index], &amp;data[end]); // end位置存储比较元素 int small = start - 1; // small用来指向存放小于比较元素的位置 for(index = start; index &lt; end; index++) { if(data[index] &lt; data[end]) { // 比比较元素小的就交换到small的地方 small++; if(small != index) { // 如果位置相同就没必要再交换了 swap(&amp;data[index], &amp;data[small]); } } } small++; swap(&amp;data[small], &amp;data[end]); // 比较元素也放回对应位置 return small; // 返回比较元素的位置，划分左右两个子数组}void quick_sort(int data[], int len, int start, int end) { if(start == end) { return; // 单个元素，不用排序 } int index = partition(data, len, start, end); if(index &gt; start) { quick_sort(data, len, start, index-1); } if(index &lt; end) { quick_sort(data, len, start+1, end); }}int main() { int data[] = {9, 1, 2, 7, 5, 2, 3, 5, 4, 6}; quick_sort(data, 10, 0, 9); for(int i = 0; i &lt; 10; i++) { printf(&quot;%d &quot;, data[i]); } return 0;} partition函数除了可以用在快速排序中，还可以用来实现在长度n数组中查找第k大的数字，面试题39“数组中出现次数超过一半的数字”和面试题40“最小的k个数”都可以用这个函数来解决。 不同排序的适用场合也不尽相同，快速排序虽然总体的平均效率最好，但不是任何时候都是最优的算法（只是在平均效率上满足O(nlogn)，可以找出一些最坏的情况），所以在面试的时候，如果面试官要求实现一个排序算法，可以先问清楚这个排序应用的环境是什么、有哪些约束条件等等，得到足够多的信息之后再选择合适的排序算法。 面试题11：旋转数组的最小数字 把一个数组最开始的若干的元素搬到数组的末尾，称之为数组的旋转，输入一个递增排序的数组的一个旋转，输出旋转数组的最小元素。例如{3, 4, 5, 1, 2}是{1, 2, 3, 4, 5}的一个旋转，数组的最小值是1。 思路1：简单遍历数组求最小值（无论正序还是逆序），时间开销都是O(n)，大概率不是一个最优解； 思路2：递增排序的一个区间满足性质, 首元素一定小于尾元素，如果考虑到元素可以重复，即如果首元素大于等于尾元素，则该区间可能并不是非递减的。 思路3：思路2通过二分区间判断实现起来还是有一点复杂，还可以进一步地简化思路，每一次判断mid和start、end位置上元素大小关系，如果mid&gt;=start，证明mid位于前面的递增区间，下一步在mid-end中找最小元素；如果mid&lt;=end，证明mid位于后面的递增区间，下一步在start-mid中找最小元素。 按照思路3，start总是指向前面递增数组的元素、end总是指向后面递增数组的元素，当start和end中间没有其他元素时，end就指向后面递增元素的第一个，也就是最小的数字，这也是循环结束的条件。 123456789101112131415161718192021222324252627int min(int* numbers, int len) { if(numbers == nullptr || len &lt;= 0) { std::logic_error ex(&quot;Invalid parameters&quot;); throw std::exception(ex); } int index1 = 0; int index2 = len - 1; int index_mid = index1; while(numbers[index1] &gt;= numbers[index2]) { if(index2 - index1 == 1) { index_mid = index2; break; } index_mid = (index1 + index2) / 2; if(numbers[index_mid] &gt;= numbers[index1]) { // mid在前面的递增数组中，min在后面 index1 = index_mid; } else if(numbers[index_mid] &lt;= numbers[index2]) { // mid在后面的递增数组中，min在前面 index2 = index_mid; } } return numbers[index_mid];} 但上面的方法还有一些特殊情况没有考虑到： 如果只搬动了0个元素到后面，即排序数组本身，上面的方法就不再适用了，但因为此时数组中一个数字就是最小的数字，可以直接返回； 如果index1和index2指向的元素相等，甚至他们都和index_mid指向的元素想等时，应该如何处理呢？这个时候无法简单地判断出min在前面还是后面（参考下面图），所以只能采取简单的遍历法（如果是递归函数实现的话可以都向下计算然后比对最小值）。 完整代码实现： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#include &lt;iostream&gt;#include &lt;exception&gt;int min_in_order(int* numbers, int start, int end) { int min = numbers[start]; for(int i = start + 1; i &lt;= end; i++) { if(min &gt; numbers[i]) { min = numbers[i]; } } return min;}int min(int* numbers, int len) { if(numbers == nullptr || len &lt;= 0) { std::logic_error ex(&quot;Invalid parameters&quot;); throw std::exception(ex); } int index1 = 0; int index2 = len - 1; int index_mid = index1; while(numbers[index1] &gt;= numbers[index2]) { if(index2 - index1 == 1) { index_mid = index2; break; } index_mid = (index1 + index2) / 2; if(numbers[index1] == numbers[index2] &amp;&amp; numbers[index_mid] == numbers[index1]) { // index1 mid index2 均相等，顺序查找 return min_in_order(numbers, index1, index2); } else if(numbers[index_mid] &gt;= numbers[index1]) { // mid在前面的递增数组中，min在后面 index1 = index_mid; } else if(numbers[index_mid] &lt;= numbers[index2]) { // mid在后面的递增数组中，min在前面 index2 = index_mid; } } return numbers[index_mid];}int main() { int numbers[] = {3, 4, 5, 1, 2}; printf(&quot;%d\\n&quot;, min(numbers, 5)); // 1 int onumbers[] = {1, 1, 1, 0, 1}; printf(&quot;%d\\n&quot;, min(onumbers, 5)); // 0 return 0;} 3 回溯法回溯法可以看成蛮力法的升级，它从解决问题的每一步可能选项理选出一个可行的解决方法。回溯法非常适合由多个步骤组成的问题，并且每个步骤都有多个选项。 用回溯法解决的问题的所有选项可以形象地用树状结构表示。在某一步有n个可能的选项，该步骤可以看成是树状结构中的一个节点，每个选项看成树中节点连接线。树的叶节点对应对应着终结状态，如果在叶节点的状态满足题目的约束条件，则找到了一个可行的解决方案。 如果叶节点的状态不满足约束，则只好回溯到它的上一个节点再尝试其他的选项，如果上一个节点所有可能的选项都已经试过，找下一种可能选项时，需要再次回溯到上一个节点（依次类推）。如果所有节点的所有选项都已经尝试过仍然不能达到满足约束条件的终结状态，则该问题无解。 以面试题12来说明回溯法的应用方法。 面试题12：矩阵中的路径 设计一个函数，用来判断一个矩阵中是否存在一条包含某字符串所有字符的路径。路径可以从矩阵中的任意一格开始，每一步可以在矩阵中向左、右、上、下移动一格。如果一条路径经过了矩阵的某一格，那么该路径不能再次进入该格子。 用回溯法解决的典型题，首先在矩阵中任选一个格子作为路径的起点，然后尝试匹配字符串，如果位置字符匹配，则在临近格子中寻找下一步格子，重复上述过程，直到路径上所有字符都在矩阵中找到相应的位置。 由于回溯法的递归特性，路径可以被看成一个栈，当在矩阵中定位了路径中前n个字符位置之后，在与第n个字符对应的格子的周围都没有找到第n+1字符，这时候只好在路径上回到第n-1字符，重新定位第n个字符。 由于路径不能重复进入矩阵的格子，所以要定义和字符矩阵大小一样的布尔值矩阵，用来标识路径已经进入了哪些格子。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970#include &lt;iostream&gt;#include &lt;cstring&gt; // include memset()bool has_path_core(const char* matrix, int rows, int cols, int row, int col, const char* str, int&amp; path_len, bool* visited) { if(str[path_len] == '\\0') { // 前面的字符都找到相应位置了 return true; } bool has_path = false; if(row &gt;= 0 &amp;&amp; row &lt; rows &amp;&amp; col &gt;= 0 &amp;&amp; col &lt; cols &amp;&amp; matrix[row * cols + col] == str[path_len] &amp;&amp; !visited[row * cols + col]) { path_len++; visited[row*col + col] = true; has_path = has_path_core(matrix, rows, cols, row, col-1, str, path_len, visited) || has_path_core(matrix, rows, cols, row-1, col, str, path_len, visited) || has_path_core(matrix, rows, cols, row, col+1, str, path_len, visited) || has_path_core(matrix, rows, cols, row+1, col, str, path_len, visited); if(!has_path) { path_len--; visited[row * cols + col] = false; } } return has_path;}bool has_path(char* matrix, int rows, int cols, char* str) { if(matrix == nullptr || rows &lt; 1 || cols &lt; 1 || str == nullptr) { return false; } bool* visited = new bool[rows * cols]; memset(visited, 0, rows * cols); int path_len = 0; for(int row = 0; row &lt; rows; row++) { for(int col = 0; col &lt; cols; col++) { // 从点(row, col)出发去寻找path if(has_path_core(matrix, rows, cols, row, col, str, path_len, visited)) { return true; } } } delete[] visited; return false;}int main() { char matrix[12] = { 'a','b','t','g', 'c','f','c','s', 'j','d','e','h' }; char str1[10] = &quot;bfce&quot;; if(has_path(matrix, 3, 4, str1)) { std::cout &lt;&lt; str1 &lt;&lt; &quot; in matrxi.&quot; &lt;&lt; std::endl; } else { std::cout &lt;&lt; str1 &lt;&lt; &quot; not in matrxi.&quot; &lt;&lt; std::endl; } // bfce in matrxi. char str2[10] = &quot;abfb&quot;; if(has_path(matrix, 3, 4, str2)) { std::cout &lt;&lt; str2 &lt;&lt; &quot; in matrxi.&quot; &lt;&lt; std::endl; } else { std::cout &lt;&lt; str2 &lt;&lt; &quot; not in matrxi.&quot; &lt;&lt; std::endl; } // abfb not in matrxi. return 0;} 面试题13：机器人的运动范围 地上有一个m行n列的方格。一个机器人从(0,0)的格子开始移动，它每次可以向左、右、上、下移动一格，但不能进入行坐标和列坐标的数位之和大于k的格子。例如，当k为18时，机器人能进入方法(35, 37)，因为3+5+3+7=18，但不能进入方格(35, 38)，因为3+5+3+8=19，请问该机器人能够到达多少格子？ 机器人从(0,0)开始移动，准备进入(i,j)时，要检查坐标的数位来判断是否能够进入，如果能进入，再判断是否能进入4个相邻的格子（不包含已走格子）。 完整代码实现： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061#include &lt;iostream&gt;int get_digit_sum(int num) { int sum = 0; while(num &gt; 0) { sum += num % 10; num /= 10; } return sum;}bool check(int threshold, int rows, int cols, int row, int col, bool* visited) { if(row &gt;= 0 &amp;&amp; row &lt; rows &amp;&amp; col &gt;= 0 &amp;&amp; col &lt; cols &amp;&amp; get_digit_sum(row) + get_digit_sum(col) &lt;= threshold &amp;&amp; !visited[row * cols + col]) { return true; } return false;}int moving_count_core(int threshold, int rows, int cols, int row, int col, bool* visited) { int count = 0; // 检查当前是否可达 if(check(threshold, rows, cols, row, col, visited)) { visited[row * cols + col] = true; count = 1 + moving_count_core(threshold, rows, cols, row - 1, col, visited) + moving_count_core(threshold, rows, cols, row, col - 1, visited) + moving_count_core(threshold, rows, cols, row + 1, col, visited) + moving_count_core(threshold, rows, cols, row, col + 1, visited); } // 返回计数 return count;}int moving_count(int threshold, int rows, int cols) { if(threshold &lt; 0 || rows &lt;= 0 || cols &lt;= 0) { return 0; } bool *visited = new bool[rows * cols]; for(int i = 0; i &lt; rows * cols; i++) { visited[i] = false; } // 从(0, 0)出发，计数count int count = moving_count_core(threshold, rows, cols, 0, 0, visited); delete[] visited; return count;}int main() { std::cout &lt;&lt; moving_count(-1, 1, 1) &lt;&lt; std::endl; // 0 std::cout &lt;&lt; moving_count(0, 1, 1) &lt;&lt; std::endl; // 1 std::cout &lt;&lt; moving_count(12, 40, 40) &lt;&lt; std::endl; // 770 std::cout &lt;&lt; moving_count(18, 40, 40) &lt;&lt; std::endl; // 1484 return 0;} 4 动态规划与贪婪算法如果面试题是求一个问题的最优解(通常是求最大值或者最小值)，而且该问题能够被分解成若干个子问题，子问题之间还有重叠的更小子问题，就可以考虑用动态规划来解决这个问题。 在应用动态规划之前，要先分析是否能把大问题分解成小问题，分解后的每个小问题也存在最优解，如果把小问题的最优解组合起来能够得到整个问题的最优解，则可以应用动态规划来解决这个问题。 在一些题目情况中，相同子问题在分解大问题的过程中重复出现，为了避免重复求解相同子问题，可以用从下往上的顺序先计算小问题的最优解并存储下来，再以此为基础求取大问题的最优解。在应用动态规划解决问题的时候，我们总是从解决最小问题开始，并把已经解决的子问题的最优解存储下来（大部分题目一般用一维或者二维数组里），并把子问题的最优解组合起来逐步解决大的问题。 在应用动态规划时，每一步都面临若干个选择，在求解时只能把所有的可能尝试一遍，然后比较得出最优的选择。 贪婪算法和动态规划不一样，贪婪算法每一步都可以根据规则做出一个最优的选择，基于这个找到最优解，但贪婪算法需要证明每一步的选择是可以保证最后获得最优结果，有时候不要想当然的应用贪婪算法。 面试题14：剪绳子 给你一根长度为n的绳子，请把绳子剪成m段(m、n都是整数，n&gt;1并且m&gt;1)，每段绳子的长度记为k[0],k[1],...,k[m]，请问 k[0] x k[1] x ... x k[m]可能的最大乘积是多少？例如，当绳子的长度是8时，我们把它剪成长度分为2、3、3的三段，此时得到的最大乘积是18。 Tips：这道题里面的一个比较含糊不清的地方是对m的界定，有些题目中可能m也是一个输入量，指计算在这个m段限定条件下n长度绳子的最大结果值（基本上就是另一类题了），而在本书的这道题目中并没有将m看作一个单独的输入量，只是说明后续的计算流程用，在面试遇到这样的情况可以向面试官询问对m的作用界定。 思路1：暴力遍历，第一步有n-1种剪法，第二步有n-2种剪法，…，剪到底的话需要剪n步（每一步可以剪多个绳子），所以可以简单估算时间复杂度O(n^2)； 思路2：动态规划； 思路3：尝试用贪婪算法来解决。 先讲一下动态规划的解法。 首先定义函数f(n)为把长度为n的绳子剪成若干段后各段长度乘积的最大值。在剪第一刀时，有n-1中可能的选择，因此有f(n)=max(f(i) x f(n-i))，其中0&lt;i&lt;n。 这是一个从上至下的递归公式，递归会产生很多重复计算，所以一个更好的办法是按照从下而上的顺序计算，也就是说我们先得到f(2)、f(3)，再得到f(4)、f(5)，直到得到f(n)。比较容易得知f(1)=0、f(2)=1以及f(3)=2，之后就按照迭代公式计算，得到f(n)。 Tips：书上这个题目的解析里面，个人觉得有一点疏漏，f(k-1)的定义应该是在剪后的乘积最大和不剪的自身长度中的最大值，即f(k-1)=max({f(i) x f(k-i), k=1,2,...,n-1}), ，因为只有在计算f(n)的时候是必须要剪断的(因为m&gt;1)，而剩下的子段不是一定要剪断，所以f(k-1), k=1,2,...,n-1的计算方式不能完全照搬f(n)的公式，例如f(1)作为一个长度为1的子段，因为并不是一定要剪，所以其本身可以返回的最大长度是1，而不是0，否则对于一个长度为n的绳子，在剪为1长度和n-1长度的两个子段时，使用f(1)=0，就会导致计算的结果错误，因为在这个情况下是有最后的值的，而并不是0*f(n-1)=0，所以按照修正后的定义，当是子段的时候，f(1)=1，f(2)=2，f(3)=3，f(4)=4，f(5)=6，…，可以发现虽然在k&gt;3这部分定义修正没有意义，但对于k&lt;=3部分是有意义的。 完整实现代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243#include &lt;iostream&gt;int max_product_after_cutting_dyprog(int len) { if(len &lt; 2) { return 0; } if(len == 2) { return 1; } if(len == 3) { return 2; } // 循环替代递归，减少重复子任务，动态规划法 int* products = new int[len + 1]; products[0] = 0; // f(0)=0 products[1] = 1; // 修正定义的f(1)=1 products[2] = 2; // 修正定义的f(2)=2 products[3] = 3; // 修正定义的f(3)=3 int max = 0; for(int i = 4; i &lt;= len; i++) { max = 0; for(int j = 1; j &lt;= i/2; j++) { int product = products[j] * products[i - j]; if(max &lt; product) { max = product; } // products[i] = max; // 书上该行的位置，个人觉得没必要 } products[i] = max; // 个人意见的修正，虽然不影响结果 } max = products[len]; delete[] products; return max;}int main() { // 结果是36 std::cout &lt;&lt; max_product_after_cutting_dyprog(10) &lt;&lt; std::endl; return 0;} Tips：上面的代码除了调整过一行的位置以外，基本上没有修改，可以看到代码中对f(1)、f(2)和f(3)的定义都是符合我之前说的修正后的定义，而不是作者说明的什么f(1)=0、f(2)=1以及f(3)=2，所以也侧面证明之前我对定义的修正是正确的。 接着看一下贪婪算法的解法。 如果按照如下的策略来剪绳子，则得到的各段绳子的长度乘积最大，当n&gt;=5时，尽可能多地剪长度为3的绳子；当剩下的绳子长度为4时，把绳子剪成两段长度为2的绳子。 完整实现代码： 1234567891011121314151617181920212223242526272829303132#include &lt;iostream&gt;#include &lt;cmath&gt;int max_product_after_cutting_greedy(int len) { if(len &lt; 2) { return 0; } if(len == 2) { return 1; } if(len == 3) { return 2; } // 尽可能剪为长度为3的绳子段 int times_of_3 = len / 3; // 剩余长度为4时，不再减去3 if(len - times_of_3 * 3 == 1) { times_of_3 -= 1; } // 代表有多少个2段 int times_of_2 = (len - times_of_3 * 3) / 2; return (int)(pow(3, times_of_3) * pow(2, times_of_2));}int main() { // 结果是36，和动态规划法相同 std::cout &lt;&lt; max_product_after_cutting_greedy(10) &lt;&lt; std::endl; return 0;} 证明一些这种思路的正确性： 首先，当n&gt;=5时，我们可以证明2(n-2)&gt;n并且3(n-3)&gt;n（剪出一长度2子段或剪出一长度3子段），也就是说，当绳子剩下的长度大于等于5时，就把它剪成3或者2的子段，另外，n&gt;=5时，3(n-3)&gt;=2(n-2)，因此我们应该尽可能地多剪长度为3的绳子段（其实书上的这部分证明还并不够严谨，可以自行去严谨地证明）。 那么当长度为4时，可以简单推出最大的情况就是2*2或者不剪的4。 5 位运算位运算是把数字用二进制表示之后，对每一位上0或者1的运算，二进制及其位运算是现代计算机学科的基石，很多底层的技术都离不开位运算（都是基石了咋离得开嘛），因为与位运算相关的题目也经常出现在面试中。 在微软产品Excel中，用A表示第1列，B表示第2列，…，Z表示第26列，AA表示第27列，AB表示第28列，…，以此类推，写出一个函数，输入用字母表示的列号，输出第几列，这就是一个典型的进制转换题目。 位运算总共只有5种运算：与 &amp;、或 ||、异或 ^、左移&lt;&lt;和右移&gt;&gt;。 与、或和异或运算规律可以用下表进行总结： 左移运算法m &lt;&lt; n表示把m左移n位，在左移n位时，最左边的n位将被丢弃，同时在最右边补上n个0，比如： 1200001010 &lt;&lt; 2 = 0010100010001010 &lt;&lt; 3 = 01010000 右移运算符m &gt;&gt; n表示把m右移n位，在右移n位时，最右边的n位将被丢弃，但是在右移时处理最左边位的情形要稍微复杂一点： 如果数字是一个无符号数值，则用0填补最左边的n位； 如果数字是一个有符号数值，则用数字的符号位填补最左边的n位； 数字是正数，右移补0； 数字是负数，左移补1。 1200001010 &gt;&gt; 2 = 0000001010001010 &gt;&gt; 3 = 11110001 面试题15“二进制中1的个数”就是直接考查位运算的例子，而面试56“数组中数字出现的次数”、面试题65“不用加减乘除做加法”等都是根据位运算的特点来解决问题。 面试题15：二进制中1的个数 实现一个函数，输入一个整数，输出该数二进制表示中1的个数，例如，把9表示成二进制是1001，有2个1，所以输出2。 可能会引起死循环的解法：判断整数二进制最右边是否为1，然后进行右移一位再进行判断，直到整个整数变为0为止，至于如何判断一个整数的最右边是不是1，只要把整数和1做位与(&amp;)运算看结果是不是1就只知道了，这个方法的问题在于对于负数的处理会导致死循环，如果是负数，则右移会在首位补1，数字永远不会变为0，最后变为0xffffffff导致死循环； 常规解法：为了避免死循环，可以不右移输入的数字n，而转为左移用来校验的数字1，依次校验数字n的每一位是否为1； 常规解法的代码实现： 1234567891011121314151617181920#include &lt;iostream&gt;int number_of_1(int num) { int count = 0; unsigned int flag = 1; // unsigned int 才能采集到符号位 // 循环次数取决于操作系统中int的存储位数，一般是4字节，32位 while(flag) { // 1从左边溢出后，flag会变成0 if(num &amp; flag) { // 非0 即 该位有1 count++; } flag = flag &lt;&lt; 1; // 赋值更新 } return count;}int main() { std::cout &lt;&lt; number_of_1(255) &lt;&lt; std::endl; // 8 std::cout &lt;&lt; number_of_1(-1) &lt;&lt; std::endl; // 32 return 0;} 令人惊喜的解法：先分析一下把一个数减去1的情况，如果一个整数不等于0，则二进制中至少有一位是1，假设这个数最右边为1，则减1导致最后一位为0，其余位保持不变；假设最后一位是0，如果最右边的1位于第m位，则减一时，第m位由1变0，m位之后的所有0都变成1，m之前的所有位保持不变。根据这两种情况，可以发现把一个整数减1，都是把最右边的1变成0，如果右边有0，则所有0变成1，如果把一个整数和它减去1的结果做位与运算，相当于把最右边的1变成0。以1100为例，减1结果是1011，1100和1011做位运算，结果是1000，即相比于1100把最右边的1变成0。所以最后的思路是，把一个整数减1，再和原整数做与运算，就把最右边1变为0，那么一个二进制中有多少1就可以进行多少次这样的操作。 完整代码实现： 12345678910111213141516#include &lt;iostream&gt;int number_of_1_sp(int num) { int count = 0; while(num) { count++; num = (num - 1) &amp; num; } return count;}int main() { std::cout &lt;&lt; number_of_1_sp(255) &lt;&lt; std::endl; // 8 std::cout &lt;&lt; number_of_1_sp(-1) &lt;&lt; std::endl; // 32 return 0;","link":"/2020/12/20/s2o-c2-algorithm/"},{"title":"1月的计划","text":"距离2021的春招实习只有2个半月了，要开始争分夺秒了（唉，好想给女儿做二创啊）。 感觉前两个月因为各种各样的情况，看书写笔记的效率还是有点低（投入的时间确实也不够多），还有同时要看几本难啃的书确实不容易，之后要分清一下多个任务的主次了。 12月剩下时间的规划： 《剑指Offer》第3、4章，暂时不再写完整的博客了，只贴部分题目的完整实现代码； 《3D游戏与计算机图形学中的数学方法》第4、5、6章，暂时不再写完整博客，会先简单写一些重要知识点摘录（自己打公式太费时间了）； 《Real Time Rendering 4th》第2、3、4章，不再写完整博客，翻译还是有点费时费力，先看一遍过一下好了，主要作为3D数学方法那本书的知识补充。 1月的规划： 《剑指Offer》第5、6章，不写完整博客，只贴部分题目的完整实现代码； 《3D游戏与计算机图形学中的数学方法》第6-9章，暂时不再写完整博客，会先简单写一些重要知识点摘录； 《Real Time Rendering 4th》第5-11章，只读，不写博客； 《Effective C++》的55个条款，尽量都写写代码尝试实践，每一个其实都涉及到不少原本C++中的知识点，应该都要同步学习或者复习一下。 其实就算是真的完成了这么多阅读的任务，还是有很多知识盲区，比如Unity3D、UE4、OpenGL、DirectX、RTX系列技术这种。 2月的初步规划（除掉过年，可能只有大半月的时间）： 面试笔试题，稍微刷一点面试常见的算法题(尤其是mid和hard难度的)，数量控制在100题以内吧，找到用C++解题的手感； 引擎面试题，只能去收集各大厂引擎、渲染方面的面经贴，然后总结各种各样的点，有必要的话拓展去了解； OpenGL，估计至少要走一遍指南吧，代码都敲一敲； Unity3D入门和《Unity Shader 入门精要》，主要是了解Unity方面的相关知识； 各大厂的简历投递，别忘了投简历了，注意提前收集他们的时间。 3月的初步规划（基本上到了冲刺阶段了，剩下半个月时间）： 面试笔试题，每日做题的任务照常安排着走； 引擎面试题，继续看收集的那些面试问题，顺带复习一下以前的笔记； 《游戏引擎架构》，半个月简单刷一下这本书的大致内容，做到都有一定了解即可，当作知识广度阅读资料。","link":"/2020/12/23/plan-2021-01/"},{"title":"《剑指Offer》第3章笔记 高质量代码 P1","text":"除了程序代码的正确性，经常我们还要关注它的鲁棒性。 1 面试官谈代码质量 “一般会考查应聘人员对代码的容错处理能力，对一些特别的输入会询问应聘人员是否考虑、如何处理。不能容忍代码只是针对一种假想的‘正常值’进行处理，不考虑异常状况，也不考虑资源的回收等问题。” —— 殷焰（支付宝，高级安全测试工程师） “如果是因为粗心犯错，则可以原谅，因为毕竟面试的时候会紧张；不能容忍的是，该掌握的知识点却没有掌握，而且提醒了还不知道。” —— 马凌洲（Autodesk，软件开发经理） “最不能容忍功能错误，忽略边界情况。” —— 尹彦（英特尔，软件工程师） “如果一个程序员连变量、函数命名都毫无章法，解决一个具体问题都找不到一个最合适的数据结构，那么这会让面试官对他的印象大打折扣，因为这只能说明他程序写得太少，不够熟悉。” —— 吴斌（英伟达，图形设计师） “我会从程序的正确性和鲁棒性两方面检验代码的质量。会关注对输入参数的检查、处理错误和异常的方式、命名方式等。对于没有工作经验的学生，程序正确性之外的错误基本都能容忍，但经过提示后希望能够很快解决。对于有工作经验的人，不能容忍考虑不周到，有明显的鲁棒性错误。” —— 田超（微软，SDE ||） 2 代码的规范性面试官会根据应聘者写出的代码来决定是否录用他，如果应聘者代码写的不够规范，影响面试官阅读代码的兴致，那么面试官就会默默地减去几分。书写、布局和命名都决定着代码的规范性。 首先，清晰的规范的代码书写。写的慢一点也可以，把字母、数字、符号写清楚。 其次，清晰的规范的代码布局。缩进、对齐的一些布局格式要注意统一。 最后，合理的规范的代码命名。建议在写代码时，用完整的英文单词组合命名变量和函数。比如函数传入一个二叉树的根节点作为参数，则可以把该参数命名为BinaryTreeNode* pRoot，不用觉得这样多写字母会麻烦，如果一眼能看出变量、函数的用途，应聘者就能避免搞混淆而犯一些低级错误（除了循环量i,j,k这种，其他都要注意），同时合理的命名也能让面试官一眼读懂代码的意图。 3 代码的完整性面试官会通过检查代码是否完整来考查应聘者的思维是否全面，一般会检查代码是否完成了基本功能、输入边界值是否能得到正确地输出、是否对各种不合规范的非法输入做出了合理的错误处理。 3.1 3个方面确保完整性咕咕待更。 3.2 3种错误处理的方法咕咕待更。 3.3 面试题 16-21 面试题16：数值的整数次方。 实现函数double Power(double base, int exponent)，求base的exponent次方，不得使用库函数，不需要考虑大数问题（只考虑结果在double的表达范围）。 完整实现代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#include &lt;iostream&gt;bool g_invalid_input = false;double eps = 1e-8;double equal(double lhs, double rhs) { double big = (lhs &gt; rhs)?lhs:rhs; double small = (big != lhs)?lhs:rhs; return (big - small) &lt;= eps;}double power_with_unsigned_exp(double base, unsigned int exp) { // exp只为正数，内部只关心几次方的计算 if(exp == 0) { return 1; } else if(exp == 1) { return base; } else { // 考虑用递归数学公式来加速幂计算 // exp &gt;&gt; 1，int右移1位，等价于除以2向下取整，优化计算速度 double result = power_with_unsigned_exp(base, exp &gt;&gt; 1); result *= result; if(exp &amp; 0x1 == 1) { // 判断是否为奇数，这种方式比 % 2 == 0，速度更快 result *= base; } return result; }}double power(double base, int exp) { // 考虑exp 为正、为负、为0的情况 g_invalid_input = false; // 初始化全局变量 if(equal(base, 0.0) &amp;&amp; exp &lt; 0) { g_invalid_input = true; // 也可以考虑其他错误处理方式 return 0.0; } unsigned int abs_exp = (unsigned int)((exp &lt; 0)?-exp:exp); double result = power_with_unsigned_exp(base, abs_exp); return (exp &lt; 0)?(1.0 / result):(result);}int main() { std::cout &lt;&lt; power(2, 4) &lt;&lt; std::endl; // 16 std::cout &lt;&lt; power(10, 5) &lt;&lt; std::endl; // 100000 std::cout &lt;&lt; power(13, -2) &lt;&lt; std::endl; // 0.00591716 std::cout &lt;&lt; power(0, 0) &lt;&lt; std::endl; // 1 return 0;} 面试题17：打印从1到最大的n位数。 输入数字n，按顺序打印出1到最大的n位十进制数。比如输入3，从1、2、3一直打印到最大的3位数999。 用字符串模拟大数加法进位的方式： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667#include &lt;iostream&gt;#include &lt;cstring&gt;void print(char* number) { // 对于前面的空0，不再打印 int len = strlen(number); bool begin = false; for(int i = 0; i &lt; len; i++) { if(!begin &amp;&amp; number[i] == '0') { continue; } else if(!begin &amp;&amp; number[i] != '0') { begin = true; } printf(&quot;%c&quot;, number[i]); } printf(&quot;\\n&quot;);}bool increment(char* number) { bool is_overflow = false; int carry = 0; // 进位量 int len = strlen(number); // 模拟加法进位 for(int i = len - 1; i &gt;= 0; i--) { int sum = number[i] - '0' + carry; if(i == len - 1) { // 末位加1 increment sum++; } if(sum &gt;= 10) { if(i == 0) { // 已经在最高位，进位就溢出了 is_overflow = true; } else { carry = 1; sum -= 10; number[i] = '0' + sum; } } else { number[i] = '0' + sum; carry = 0; break; } } return is_overflow;}void print_1_to_n_max(int n) { if(n &lt;= 0) { return; } char* number = new char[n + 1]; // 多一位给结尾符 \\0 memset(number, '0', n); number[n] = '\\0'; while(!increment(number)) { print(number); } delete[] number;}int main() { print_1_to_n_max(3); return 0;} 还可以考虑用全排列的方式，就不用再考虑进位的问题，代码就简洁了很多： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include &lt;iostream&gt;#include &lt;cstring&gt;void print(char* number) { // 对于前面的空0，不再打印 int len = strlen(number); bool begin = false; for(int i = 0; i &lt; len; i++) { if(!begin &amp;&amp; number[i] == '0') { continue; } else if(!begin &amp;&amp; number[i] != '0') { begin = true; } printf(&quot;%c&quot;, number[i]); } if(begin == true) { printf(&quot;\\n&quot;); // 修正部分，不打印全0的情况 }}void print_1_to_n_max_rec(char* number, int len, int index) { if(index == len) { print(number); return; } for(int i = 0; i &lt; 10; i++) { number[index] = i + '0'; print_1_to_n_max_rec(number, len, index + 1); }}void print_1_to_n_max_permutation(int n) { if(n &lt;= 0) { return; } char* number = new char[n + 1]; memset(number, '0', n); number[n] = '\\0'; print_1_to_n_max_rec(number, n, 0); delete[] number;}int main() { print_1_to_n_max_permutation(3); return 0;} 不过全排列的方法有一个容易忽略的漏洞，就算按照书上的代码运行，会出现一个多余的打印情况print(&quot;000&quot;)，这是因为这是全排列的起点，而想修改全排列的起点为001还稍微有点麻烦，这个时候你会发现其实print并不会把000打印出来，但是会多打印一个\\n换行，所以只要简单修改一下print，让其只在非000的情况下才换行，这样看起来我们的输出起点就是1了。 面试题18：删除链表的节点。 题目一：在O(1)的时间内删除链表节点。 给定单向链表的头指针和一个节点指针，定义一个函数在O(1)时间内删除该节点。链表节点与函数的定义如下： 123456struct node { int value; node* pnext;};void delete_node(node** phead, node* pdelete); 完整实现代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687#include &lt;iostream&gt;struct node { int value; node* pnext;};node* init_node(int value) { node* pnode = new node; pnode-&gt;value = value; pnode-&gt;pnext = nullptr; return pnode;}void insert_node(node** phead, node* pnode) { if(*phead == nullptr) { *phead = pnode; return; } node* temp = *phead; while(temp-&gt;pnext != nullptr) { temp = temp-&gt;pnext; } temp-&gt;pnext = pnode;}void delete_node(node** phead, node* pdelete) { if(!phead || !pdelete) { return; } if(pdelete-&gt;pnext != nullptr) { // 删除非尾节点，拷贝节点 node* pnext = pdelete-&gt;pnext; pdelete-&gt;value = pnext-&gt;value; pdelete-&gt;pnext = pnext-&gt;pnext; // 删除节点 delete pnext; pnext = nullptr; } else if(*phead == pdelete) { // 删除尾节点，并且链表只有一个节点 delete pdelete; pdelete = nullptr; *phead = nullptr; } else { // 删除尾节点，只能从头找起 node* pnode = *phead; while(pnode-&gt;pnext != pdelete) { pnode = pnode-&gt;pnext; } pnode-&gt;pnext = nullptr; delete pdelete; pdelete = nullptr; }}void print(node** phead) { if(*phead == nullptr) { return; } node* pnode = *phead; printf(&quot;%d &quot;, pnode-&gt;value); while(pnode-&gt;pnext != nullptr) { pnode = pnode-&gt;pnext; printf(&quot;%d &quot;, pnode-&gt;value); } printf(&quot;\\n&quot;);}int main() { node** phead = new node*; *phead = nullptr; node** node_list = new node*[10]; for(int i = 0; i &lt; 10; i++) { node* new_node = init_node(i); node_list[i] = new_node; insert_node(phead, new_node); } print(phead); // 0 1 2 3 4 5 6 7 8 9 // 删除头节点 delete_node(phead, node_list[0]); // 删除尾节点 delete_node(phead, node_list[9]); // 删除中间节点 delete_node(phead, node_list[5]); print(phead); // 1 2 3 4 6 7 8 return 0;} 这段代码有三个需要讨论的地方： 关于时间复杂度，如果是尾节点，则需要O(n)时间，如果是非尾节点，则需要O(1)时间，平均情况下[(n-1)*O(1) + O(n)]/n = O(1)，这也是书上说明的情况，但如果你真的要较真，你说：“我就是尾节点也想做到O(1)时间，可不可以？” 我说当然可以，再细想一下尾节点需要O(n)的原因，因为我们没有办法知道它的前一个节点是什么，那整个链表里面有没有什么地方是可以让我们保留一个额外的指针的地方呢？当然有，那就是尾节点没有利用起来的pnext，如果你将尾节点的pnext指向它的前一个节点，那自然删除也只需要O(1)时间了，当然这会影响到一些其他过程，例如判断达到尾节点的方式就和以往的pnode-&gt;pnext == nullptr不同了，但方法终归是可行的，尤其是如果面试官再进一步问是否还可以更优化时； 上述代码仍然不是完美代码，主要是指的完整性上，因为它基于一个假设：要删除的节点的确在链表中，需要O(n)的时间才能判断链表中是否包含某一个节点（不借助其他数据结构情况下），受到题目的O(1)时间限制，所以这部分就没有再考虑了，可以和面试官进行说明； 代码中用来删除节点的部分，用了一个保存节点的node_list数组，但这个数组中的节点情况并不会一直地和链表的节点情况保持一致，因为方法中涉及到了节点的拷贝，取决于删除的情况，数组i位置保存节点的value很有可能并不是i，也有可能链表中i值的节点还在，而node_list中i位置的指针已经被设置为nullptr。 题目二：删除链表中重复的节点。 在一个排序的链表中，如何删除重复的节点？ PS：这道题在书上的图3.4应该是打印出错了，初始链表的几个节点都没有打全，总之就是链表中重复的节只保留一个。另外，注意题目中的已排序条件。 123456struct node { int value; node* pnext;};void delete_duplication(node** phead); 完整实现代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960#include &lt;iostream&gt;struct node { int value; node* pnext;};node* init_node(int value) { ... }; // 和上面代码的相同void insert_node(node** phead, node* pnode) { ... }; // 和上面代码的相同void print(node** phead) { ... }; // 和上面代码的相同void delete_duplication(node** phead) { if(phead == nullptr || *phead == nullptr) { return; } node* pprenode = nullptr; node* pnode = *phead; while(pnode != nullptr) { node* pnext = pnode-&gt;pnext; bool need_delete = false; if(pnext != nullptr &amp;&amp; pnext-&gt;value == pnode-&gt;value) { need_delete = true; } pprenode = pnode; // 修改的代码 if(!need_delete) { // pprenode = pnode; // 原代码 pnode = pnode-&gt;pnext; } else { int value = pnode-&gt;value; node* ptobedel = pnext; // 修改的代码 // node* ptobedel = pnode; // 原代码 while(ptobedel != nullptr &amp;&amp; ptobedel-&gt;value == value) { pnext = ptobedel-&gt;pnext; delete ptobedel; ptobedel = nullptr; ptobedel = pnext; } if(pprenode == nullptr) { *phead = pnext; } else { pprenode-&gt;pnext = pnext; } pnode = pnext; } }}int main() { node** phead = new node*; *phead = nullptr; for(int i = 0; i &lt; 10; i++) { node* new_node = init_node(i / 2); insert_node(phead, new_node); } print(phead); // 0 0 1 1 2 2 3 3 4 4 delete_duplication(phead); print(phead); // 0 1 2 3 4 return 0;} init_node、insert_node以及print函数均和18题题目一的代码相同，不再赘述。 PS：需要说明的一点是，书上的delete_duplication代码和我这里所写的代码有细微差别，原因是对原题目的理解偏差问题，如果原题目所说的删除重复的节点不需要留下一个被重复的节点（即一个都不留），则看上面代码的原代码部分，如果是需要保留一个节点，就看修改后的部分。 面试题19：正则表达式匹配 题目：请实现一个函数用来匹配包含 . 和 * 的正则表达式。模式中的字符 . 表示任意一个字符，而 * 表示它前面的字符可以出现任意次（含0次），匹配是指字符串的所有字符匹配整个模式，例如，字符串 &quot;aaa&quot; 与模式 a.a 和 ab*ac*a 匹配，但与 aa.a 和 ab*a 均不匹配。 遇到字符时，和模式串的对应字符进行比较： 如果是普通字符，则直接比较匹配，后移指针； 如果是 .，匹配任意字符，后移指针； 如果发现字符的下一位是 *，就有两种情况了： 如果是再匹配一次的情况，先检验是否匹配，如果匹配，则字符串指针后移，匹配串指针不后移；如果不匹配，则只能考虑将匹配串指针后移两位(跳过*)； 如果是不再匹配一次的情况，匹配串指针后移两位（跳过*）； 两种情况都要考虑到，所以需要用到递归来判断其中一个分支是否可行。 完整实现代码： 12345678910111213141516171819202122232425262728293031323334353637#include &lt;iostream&gt;bool match_core(char* str, char* pattern) { printf(&quot;%c %c \\n&quot;, *str, *pattern); if(*str == '\\0' &amp;&amp; *pattern == '\\0') { return true; } if(*str != '\\0' &amp;&amp; *pattern == '\\0') { return false; } if(*(pattern + 1) == '*') { if((*pattern == '.' &amp;&amp; *str != '\\0') || *str == *pattern) { return match_core(str + 1, pattern) || match_core(str, pattern + 2); } else { return match_core(str, pattern + 2); } } else if((*pattern == '.' &amp;&amp; *str != '\\0') || *str == *pattern) { return match_core(str + 1, pattern + 1); } else { return false; }}bool match(char* str, char* pattern) { if(str == nullptr || pattern == nullptr) { return false; } return match_core(str, pattern);}int main() { char str[100] = &quot;aaa&quot;; char pattern[100] = &quot;ab*ac*a&quot;; printf(&quot;Match? %s \\n&quot;, match(str, pattern) ? &quot;true&quot; : &quot;false&quot;); return 0;} 上面代码中，需要注意的一个点是，对于匹配串的字符是.时，不能只是简单的只看匹配串，还要看被匹配串是否有字符可以匹配，所以不能只是简单地写为if(*pattern == '.' || ...)，应该写为if((*pattern == '.' &amp;&amp; *str != '\\0') || ...)，如果忽略这个细节，你不会在题目提供的几个输入输出上发现问题，但如果你多尝试其他的输入输出，尤其是当匹配串为.*(匹配任意字符)，你会发现结果是错误的。 面试题20：表示数值的字符串 实现一个函数用来判断字符串是否表示数值（包括整数和小数），例如字符串&quot;+100&quot;、&quot;5e2&quot;、&quot;-123&quot;、&quot;3.1416&quot;及&quot;-1E-16&quot;都表示数值，但&quot;12e&quot;、&quot;1a3.14&quot;、&quot;1.2.3&quot;、&quot;+-5&quot;及&quot;12e+5.4&quot;都不是。 表示数值的字符串遵循模式 A[.[B]][e|EC] 或者 .B[e|EC]，其中A为数值的整数部分，B紧跟小数点为数值的小数部分，C紧跟着e或者E为数值的指数部分。A和C都是可能以+或者-开头的0~9的数位串，B也是0~9的数位串，但前面不能有正负号。 完整实现代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263#include &lt;iostream&gt;bool scan_unsigned_inter(const char** str) { const char* before = *str; while(**str != '\\0' &amp;&amp; **str &gt;= '0' &amp;&amp; **str &lt;= '9') { (*str)++; } return *str &gt; before;}bool scan_integer(const char** str) { if(**str == '+' || **str == '-') { (*str)++; } return scan_unsigned_inter(str);}bool is_numberic(const char* str) { if(str == nullptr) { return false; } // A[.[B]][e|EC] 或者 .B[e|EC] // 检查A部分 bool a_is_numeric = scan_integer(&amp;str); bool b_is_numeric = true; // 如果碰到小数点，检查B部分 if(*str == '.') { str++; b_is_numeric = scan_unsigned_inter(&amp;str); } bool c_is_numeric = true; // 如果碰到e或E，检查C部分 if(*str == 'e' || *str == 'E') { str++; c_is_numeric = scan_integer(&amp;str); } bool all_scan = (*str == '\\0'); // (A || B) &amp;&amp; C &amp;&amp; End return (a_is_numeric || b_is_numeric) &amp;&amp; c_is_numeric &amp;&amp; all_scan;}void print_is_numberic(const char* str) { printf(&quot;%s %s\\n&quot;, str, is_numberic(str)?&quot;yes&quot;:&quot;no&quot;);}int main() { print_is_numberic(&quot;+100&quot;); // +100 yes print_is_numberic(&quot;5e2&quot;); // 5e2 yes print_is_numberic(&quot;-123&quot;); // -123 yes print_is_numberic(&quot;3.1416&quot;); // 3.1416 yes print_is_numberic(&quot;-1E-16&quot;); // -1E-16 yes print_is_numberic(&quot;12e&quot;); // 12e no print_is_numberic(&quot;1a3.14&quot;); // 1a3.14 no print_is_numberic(&quot;1.2.3&quot;); // 1.2.3 no print_is_numberic(&quot;+-5&quot;); // +-5 no print_is_numberic(&quot;12e+5.4&quot;); // 12e+5.4 no return 0;} 上面代码中需要注意的一个点是，书上原代码中是把各部分判断拆开计算逻辑合并的，但是我为了更加直观地写出其中逻辑思路，将各部分的判断都留到了最后，最后我们如果稍微一疏忽，容易就写成A || B &amp;&amp; C &amp;&amp; End，在C++中，逻辑运算符的结合反向是从左到右的，所以有可能你会把这种写法理解成(A || B) &amp;&amp; C &amp;&amp; End，但是，逻辑运算符之间的优先级顺序是，! &gt; &amp;&amp; &gt; ||，这会导致计算结果等价于A || (B &amp;&amp; C &amp;&amp; End)，即只要A==true就会判定为数字，这当然不正确的，所以要得到正确的结果，应该显式的写为(A || B) &amp;&amp; C &amp;&amp; End，避免计算错误。 面试题21：调整数组顺序使奇数位于偶数前面 输入一个整数数组，实现一个函数来调整该数组中数字的顺序，使得所有奇数位于数组的前半部分，所有偶数位于数组的后半部分。 针对这道题的最优解法，在数组头尾设置两个指针，依次开始向中间扫描，如果左指针遇到偶数则停下，右指针遇到奇数则停下，然后交换两个指针指向的内容，直到两个指针相遇，算法停止，最后结果满足题目要求。 完整实现代码： 123456789101112131415161718192021222324252627282930313233343536#include &lt;iostream&gt;void reorder_odd_even(int* array, unsigned int len) { if(array == nullptr || len == 0) { return; } int* pleft = array; int* pright = array + len - 1; while(pleft &lt; pright) { // 左指针遇到偶数停 while(pleft &lt; pright &amp;&amp; (*pleft &amp; 0x1) != 0) { pleft++; } // 右指针遇到奇数停 while(pleft &lt; pright &amp;&amp; (*pright &amp; 0x1) == 0) { pright--; } int temp = *pleft; *pleft = *pright; *pright = temp; }}int main() { int array[10] = {0, 2, 9, 1, 6, 5, 8, 7, 3, 4}; reorder_odd_even(array, 10); for(int i = 0; i &lt; 10; i++) { printf(&quot;%d &quot;, array[i]); } // 3 7 9 1 5 6 8 2 0 4 return 0;} 可扩展的解法，不固定其中的判别逻辑，可以将任意两类定义的数据进行这样的前后分离： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#include &lt;iostream&gt;// 这里用到的是一个函数指针，将一个函数传给另一个函数内部使用void reorder(int* array, unsigned int len, bool (*func)(int)) { if(array == nullptr || len == 0) { return; } int* pleft = array; int* pright = array + len - 1; while(pleft &lt; pright) { // 左指针遇到偶数停 while(pleft &lt; pright &amp;&amp; !func(*pleft)) { pleft++; } // 右指针遇到奇数停 while(pleft &lt; pright &amp;&amp; func(*pright)) { pright--; } int temp = *pleft; *pleft = *pright; *pright = temp; }}bool is_even(int n) { return (n &amp; 0x1) == 0;}bool is_odd(int n) { return (n &amp; 0x1) != 0;}int main() { int array[10] = {0, 2, 9, 1, 6, 5, 8, 7, 3, 4}; reorder(array, 10, is_even); for(int i = 0; i &lt; 10; i++) { printf(&quot;%d &quot;, array[i]); } // 3 7 9 1 5 6 8 2 0 4 printf(&quot;\\n&quot;); reorder(array, 10, is_odd); for(int i = 0; i &lt; 10; i++) { printf(&quot;%d &quot;, array[i]); } // 4 0 2 8 6 5 1 9 7 3 return 0;} 4 代码的鲁棒性请到《第3章笔记 高质量代码 P2》阅读这部分内容。","link":"/2020/12/30/s2o-c3-part1/"},{"title":"《剑指Offer》第3章笔记 高质量代码 P2","text":"鲁棒是英文Robust的音译，有时也翻译成健壮性。 1、2、3 章节请到《第3章笔记 高质量代码 P1》阅读这部分内容。 4 代码的鲁棒性提高代码的鲁棒性的有效途径是进行防御性编程。防御性编程是一种编程习惯，是指预见在什么地方可能会出现问题，并为这些可能出现的问题制定处理方式。 在面试时，最简单也是最实用的防御性变成就是在函数入口添加代码以验证用户输入是否符合要求。通常面试要求的是写一两个函数，我们需要格外关注这些函数的输入参数。当然并不是所有与鲁棒性相关的问题都是检查输入的参数这么简单，有时候要关注稍微隐含一点的逻辑中，可能会发生的潜在问题。 面试题22-26 面试题22：链表中倒数第K个节点 输入一个链表，输出该链表中倒数第k个节点。这里的k从1开始计数，即链表的尾节点是倒数第1个节点。如，一个链表有6个节点，从头节点开始，他们的值依次是1、2、3、4、5、6，这个链表的倒数第3个节点是值为4的节点。链表节点定义如下： 1234struct node { int value; node* pnext;}; 这里面需要考虑到的一个问题是，虽然输入的数据是k是正常的整数，但还要考虑链表中是否有大于等于k个的节点。思路就是简单的用两个间隔距离为k-1的指针来解决。 完整代码实现： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#include &lt;iostream&gt;struct node { int value; node* pnext;};node* init_node(int value) { ... }void insert_node(node** phead, node* pnode) { ... }void print(node** phead) { ... }node* find_k_to_tail(node** phead, unsigned int k) { if(phead == nullptr || *phead == nullptr || k == 0) { return nullptr; } node* left = *phead; node* right = *phead; for(int i = 0; i &lt; k-1 &amp;&amp; right != nullptr; i++) { right = right-&gt;pnext; } if(right == nullptr) { return nullptr; } while(right-&gt;pnext != nullptr) { right = right-&gt;pnext; left = left-&gt;pnext; } return left;}int main() { node** phead = new node*; *phead = nullptr; node** node_list = new node*[10]; for(int i = 0; i &lt; 10; i++) { node* new_node = init_node(i); node_list[i] = new_node; insert_node(phead, new_node); } print(phead); // 0 1 2 3 4 5 6 7 8 9 node* first_node = find_k_to_tail(phead, 10); printf(&quot;first node: %d\\n&quot;, first_node-&gt;value); // first node: 0 node* last_second_node = find_k_to_tail(phead, 2); printf(&quot;last second node: %d\\n&quot;, last_second_node-&gt;value); // last second node: 8 node* last_node = find_k_to_tail(phead, 1); printf(&quot;last node: %d\\n&quot;, last_node-&gt;value); // last node: 9 return 0;} 面试题23：链表中环的入口节点 如果一个链表包含环，如何找出环的入口节点？例如，在如下图所示的链表中，环的入口节点是节点3。 如何确定链表有环？两个指针，一个1次1步，一个1次2步，如果1次2步的指针“追上了”1次1步的指针，则代表有环，如果指针遇到nullptr则无环； 如果有环，如何确定环的入口在哪？假设我们知道环里面节点的个数为4，则可以用两个指针，第一个指针先走4步（到达图中第5个节点），第二指针从1开始，同时开始移动，当两个指针相遇时（图中会相遇在第3个节点），即是环的入口节点； 问题从“判断环的入口在哪”转换成了“如何判断一个环里有多少个节点？”；判断环里有多少个节点可以用第一步中的结果，固定一个指针，移动一个指针，当两个指针又相遇时，则可以计数出环中的节点个数。 完整代码实现： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687#include &lt;iostream&gt;struct node { int value; node* pnext;};node* init_node(int value) { ... }void insert_node(node** phead, node* pnode) { ... }void print(node** phead) { ... }node* meeting_node(node** phead) { if(phead == nullptr || *phead == nullptr) { return nullptr; } node* pslow = (*phead)-&gt;pnext; node* pfast = pslow-&gt;pnext; while(pfast != nullptr &amp;&amp; pfast != pslow) { pslow = pslow-&gt;pnext; pfast = pfast-&gt;pnext; if(pfast != nullptr) { pfast = pfast-&gt;pnext; } } if(pfast == nullptr) { return nullptr; } else { return pfast; }}node* find_loop_entry(node** phead) { node* mnode = meeting_node(phead); if(mnode == nullptr) { // 无环或输入数据错误 return nullptr; } // 得到环中的节点数目 int nodes_in_loop = 1; node* pnode1 = mnode; while(pnode1-&gt;pnext != mnode) { pnode1 = pnode1-&gt;pnext; nodes_in_loop++; } // 移动pnode1，次数为欢中节点数目 pnode1 = *phead; for(int i = 0; i &lt; nodes_in_loop; i++) { pnode1 = pnode1-&gt;pnext; } node* pnode2 = *phead; // 再同时移动pnode1和pnode2 while(pnode1 != pnode2) { pnode1 = pnode1-&gt;pnext; pnode2 = pnode2-&gt;pnext; } return pnode1;}int main() { node** phead = new node*; *phead = nullptr; node** node_list = new node*[6]; for(int i = 0; i &lt; 6; i++) { node* new_node = init_node(i+1); node_list[i] = new_node; insert_node(phead, new_node); } print(phead); // 1 2 3 4 5 6 if(find_loop_entry(phead) == nullptr) { printf(&quot;No loop yet.\\n&quot;); } // 尾节点指向第3个节点 node_list[5]-&gt;pnext = node_list[2]; node* loop_entry = find_loop_entry(phead); if(loop_entry == nullptr) { printf(&quot;No loop, Error.\\n&quot;); } else { printf(&quot;Loop entry at %d.\\n&quot;, loop_entry-&gt;value); // Loop entry at 3. } return 0;} 面试题24：反转链表 定义一个函数，输入一个链表的头节点，反转该链表并输出反转后链表的头节点，链表节点定义如下： 1234struct node { int value; node* pnext;}; 思路就是新建一个头结点，在遍历链表的时候，不断的把节点插入到新链表的头节点，最后完成倒序。 完整实现代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include &lt;iostream&gt;struct node { int value; node* pnext;};node* init_node(int value) { ... }void insert_node(node** phead, node* pnode) { ... }void print(node** phead) { ... }void reverse(node** phead) { if(phead == nullptr || *phead == nullptr) { return; } node** new_phead = new node*; *new_phead = nullptr; node* pnode = *phead; while(pnode != nullptr) { *phead = pnode-&gt;pnext; if(*new_phead == nullptr) { pnode-&gt;pnext = nullptr; *new_phead = pnode; } else { pnode-&gt;pnext = *new_phead; *new_phead = pnode; } pnode = *phead; } *phead = *new_phead; *new_phead = nullptr; delete new_phead;}int main() { node** phead = new node*; *phead = nullptr; node** node_list = new node*[10]; for(int i = 0; i &lt; 10; i++) { node* new_node = init_node(i+1); node_list[i] = new_node; insert_node(phead, new_node); } print(phead); // 1 2 3 4 5 6 7 8 9 10 reverse(phead); print(phead); // 10 9 8 7 6 5 4 3 2 1 return 0;} 面试题25：合并两个排序的链表。 输入两个递增排序的链表，合并这两个链表并使新链表中的节点仍然是递增排序的。 思路也没有很复杂，就是不断比较头结点大小，然后插入新链表的尾部，不过要注意一些实现细节，例如其中一个链表提前为空后的插入方法、算法结束判断、输入的各种可能性。 完整实现代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778#include &lt;iostream&gt;struct node { int value; node* pnext;};node* init_node(int value) { ... }void insert_node(node** phead, node* pnode) { ... }void print(node** phead) { ... }node** order_merge(node** phead1, node** phead2) { if(phead1 == nullptr || *phead1 == nullptr) { return phead2; } else if(phead2 == nullptr || *phead2 == nullptr) { return phead1; } node** phead; *phead = nullptr; node* pnode = nullptr; node* temp = nullptr; while(*phead1 != nullptr &amp;&amp; *phead2 != nullptr) { if((*phead1)-&gt;value &lt;= (*phead2)-&gt;value) { temp = *phead1; *phead1 = temp-&gt;pnext; } else { temp = *phead2; *phead2 = temp-&gt;pnext; } if(*phead == nullptr) { *phead = temp; pnode = *phead; } else { pnode-&gt;pnext = temp; pnode = temp; } } while(*phead1 != nullptr) { pnode-&gt;pnext = *phead1; pnode = pnode-&gt;pnext; *phead1 = (*phead1)-&gt;pnext; } while(*phead2 != nullptr) { pnode-&gt;pnext = *phead2; pnode = pnode-&gt;pnext; *phead2 = (*phead2)-&gt;pnext; } pnode-&gt;pnext = nullptr; pnode = nullptr; temp = nullptr; delete pnode; delete temp; return phead;}int main() { node** phead1 = new node*; node** phead2 = new node*; *phead1 = nullptr; *phead2 = nullptr; for(int i = 0; i &lt; 4; i++) { node* new_node1 = init_node(i * 2); node* new_node2 = init_node(i * 2 + 1); insert_node(phead1, new_node1); insert_node(phead2, new_node2); } print(phead1); // 0 2 4 6 print(phead2); // 1 3 5 7 node** phead3 = order_merge(phead1, phead2); print(phead3); // 0 1 2 3 4 5 6 7 return 0;} 书上写的是递归版本，但是这里考虑到时间效率优化（其实是没想到），就写成循环实现了，会稍微长一点点。 面试题26：树的子结构 输入两颗二叉树A和B，判断B是不是A的子结构。二叉树节点定义： 12345struct node { double value; node* pleft; node* pright;}; 关于子结构的定义，如下图中的两棵二叉树，A中有一部分子树的结构和B是一样的，所以B是A的子结构。 第一步在树A中查找与根节点的值一样的节点，实际上是树的遍历； 判断树A中以R为根节点的子树是不是和树B具有相同的结构。 完整实现代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768#include &lt;iostream&gt;struct node { double value; node* pleft; node* pright;};node* init_node(double value) { ... }node* init_a_tree() { ... }node* init_b_tree() { ... }const double eps = 1e-7;bool equal(double d1, double d2) { if((d1 - d2) &gt; -eps &amp;&amp; (d1 - d2) &lt; eps) { return true; } else { return false; }}bool does_tree1_have_tree2(node* proot1, node* proot2) { if(proot2 == nullptr) { return true; } if(proot1 == nullptr) { return false; } if(!equal(proot1-&gt;value, proot2-&gt;value)) { return false; } // 检查左子树 bool left_result = does_tree1_have_tree2(proot1-&gt;pleft, proot2-&gt;pleft); // 检查右子树 bool right_result = does_tree1_have_tree2(proot1-&gt;pright, proot2-&gt;pright); return left_result &amp;&amp; right_result;}bool is_sub_tree(node* proot1, node* proot2) { bool result = false; if(proot1 != nullptr &amp;&amp; proot2 != nullptr) { if(equal(proot1-&gt;value, proot2-&gt;value)) { // 检查根节点是否为B树子结构 result = does_tree1_have_tree2(proot1, proot2); } if(!result) { // 检查左子树是否为B树子结构 result = is_sub_tree(proot1-&gt;pleft, proot2); } if(!result) { // 检查右子树是否为B树子结构 result = is_sub_tree(proot1-&gt;pright, proot2); } } return result;}int main() { node* tree_a = init_a_tree(); node* tree_b = init_b_tree(); if(is_sub_tree(tree_a, tree_b)) { printf(&quot;Tree A has Tree B.\\n&quot;); } else { printf(&quot;Tree A does not have Tree B.\\n&quot;); } return 0;} 需要注意地方有两个，一个是在使用指针前一定要先对其进行判断，另一个是注意题目给的value类型是double，在判断相等时不能只是简单地使用==，要使用精度阈值的判断方法fabs(n1 - n2) &lt; eps。","link":"/2021/01/01/s2o-c3-part2/"},{"title":"《剑指Offer》第4章笔记 解题的思路 P1","text":"写代码之前理思路，举例子和画图都是很好的办法。 1 面试官谈面试思路一些大佬说的话。 咕咕待更。 2 画图让抽象问题形象化画图是在面试过程中应聘者用来帮助自己分析、推理的常用手段。很多面试题很抽象，不容易找到解决办法。这时不妨画出一些与题目相关的图形，借以辅助自己观察和思考。图形能使抽象的问题具体化、形象化，说不定通过几幅图形就能找到规律，从而找到问题的解决方案。 有不少与数据结构相关的问题，比如二叉树、二维数组、链表等问题，都可以采用画图的方法来分析。 面试的时候，需要向面试官解释自己的思路，对于复杂的问题，应聘者光用言语未必能够说清楚，这个时候也可以画出几幅图形，一边看着图形一边讲解。 面试题27-29 面试题27：二叉树的镜像。 完成一个函数，输入一棵二叉树，函数输出它的镜像。二叉树节点定义： 12345struct node { int value; node* pleft; node* pright;}; 画出一个镜像的二叉树后，观察可以发现只要简单地从上到下地交换每个节点的左右节点即可。 完整实现代码： 12345678910111213141516171819202122232425262728293031323334#include &lt;iostream&gt;struct node { int value; node* pleft; node* pright;};node* init_node(int value) { ... }node* init_tree() { ... }void in_order_print(node* pnode) { ... }void mirror_recursively(node* pnode) { if(pnode == nullptr) { return; } node* temp = pnode-&gt;pleft; pnode-&gt;pleft = pnode-&gt;pright; pnode-&gt;pright = temp; mirror_recursively(pnode-&gt;pleft); mirror_recursively(pnode-&gt;pright);}int main() { node* tree = init_tree(); in_order_print(tree); printf(&quot;\\n&quot;); mirror_recursively(tree); in_order_print(tree); printf(&quot;\\n&quot;); return 0;} 如果不使用递归，而是使用循环实现的话，可以考虑用一个队列来实现点的从上到下遍历的模拟，每访问一个节点，交换完毕后，将左右子节点加入到队列中，每次从队列中取出一个节点进行交换子节点操作，直到所有节点被处理完毕。 面试题28：对称的二叉树。 请实现一个函数，用来判断一棵二叉树是不是对称的。如果一棵二叉树和它的镜像一样，那么它是对称的。 完整实现代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445#include &lt;iostream&gt;struct node { int value; node* pleft; node* pright;};node* init_node(int value) { ... }node* init_tree() { ... }bool is_symmetrical(node* pnode1, node* pnode2) { if(pnode1 == nullptr &amp;&amp; pnode2 == nullptr) { return true; } if(pnode1 == nullptr || pnode2 == nullptr) { return false; } if(pnode1-&gt;value == pnode2-&gt;value) { bool lr_result = is_symmetrical(pnode1-&gt;pleft, pnode2-&gt;pright); bool rl_result = is_symmetrical(pnode1-&gt;pright, pnode2-&gt;pleft); return lr_result &amp;&amp; rl_result; } else { return false; }}bool is_symmetrical(node* proot) { if(proot == nullptr) { return true; } return is_symmetrical(proot-&gt;pleft, proot-&gt;pright); // 或者可以写为 虽然会多一倍计算过程 但代码精简到一行，有点抽象 // return is_symmetrical(proot, proot);}int main() { node* tree = init_tree(); if(is_symmetrical(tree)) { printf(&quot;Tree is symmetrical.\\n&quot;); } else { printf(&quot;Tree is not symmetrical.\\n&quot;); } return 0;} 面试题29：顺时针打印矩阵。 输入一个矩阵，按照从外向里以顺时针的顺序依次打印出每一个数字。例如，如果输入如下矩阵，则依次打印数字1、2、3、4、8、12、16、15、15、13、9、5、6、7、11、10。 完整实现代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566#include &lt;iostream&gt;void print_matrix_clockwise(int** matrix, int rows, int cols) { if(matrix == nullptr || rows &lt;= 0 || cols &lt;= 0) { return; } int up = 0, bottom = rows-1, left = 0, right = cols-1; int i, j; while(up &lt; bottom &amp;&amp; left &lt; right) { // 从左到右打印 i = up; for(j = left; j &lt;= right; j++) { printf(&quot;%d &quot;, matrix[i][j]); } up++; // 从上到下打印 j = right; for(i = up; i &lt;= bottom; i++) { printf(&quot;%d &quot;, matrix[i][j]); } right--; // 从右到左打印 i = bottom; for(j = right; j &gt;= left; j--) { printf(&quot;%d &quot;, matrix[i][j]); } bottom--; // 从下到上打印 j = left; for(i = bottom; i &gt;= up; i--) { printf(&quot;%d &quot;, matrix[i][j]); } left++; } // 当列数或行数是奇数时 // 会出现多余一列或者一行的情况 if(rows &amp; 0x1 == 1 || cols &amp; 0x1 == 1) { // 最后一列 if(up &lt; bottom) { j = left; for(i = up; i &lt;= bottom; i++) { printf(&quot;%d &quot;, matrix[i][j]); } } // 最后一行 if(left &lt; right) { i = up; for(j = left; j &lt;= right; j++) { printf(&quot;%d &quot;, matrix[i][j]); } } }}int main() { int rows = 4, cols = 4; int** matrix = new int*[rows]; for(int i = 0; i &lt; rows; i++) { matrix[i] = new int[cols]; for(int j = 0; j &lt; cols; j++) { matrix[i][j] = i * 4 + j + 1; } } print_matrix_clockwise((int**)matrix, rows, cols); return 0;} 在实现完整代码的时候，其中需要注意的一个问题是，二维数组的传参问题，如果想像题目一样传指针的方式传参，就需要在主函数使用动态数组的申请方式，用普通的声明方式int matrix[][]再强转(int**)matrix虽说可以传入到函数中，但访问数组会发生错误（原因暂时没有去细究了，应该和内存段的访问相关）。 3 举例让抽象问题具体化包含面试题30-34。 请到《第4章笔记 高质量代码 P2》阅读这部分内容。 4 分解让复杂问题简单化包含面试题35-38。 请到《第4章笔记 高质量代码 P3》阅读这部分内容。","link":"/2021/01/01/s2o-c4-part1/"},{"title":"《剑指Offer》第4章笔记 解题的思路 P2","text":"一眼看不出问题的隐藏规律时，说不定能通过举例来发现。 1、2 章节包含面试题27-29。 请到《第4章笔记 解题的思路 P1》阅读这部分内容。 3 举例让抽象问题具体化和上一节画图的方法一样，我们也可以借助举例模拟的方法来思考分析复杂的问题。当一眼看不出问题中隐藏的规律时，可以试着用一两个具体的例子模拟操作的过程，说不定能通过具体的例子找到抽象的规律。 具体的例子也可以帮助我们向面试官解释算法思路，也能帮助我们确保代码的质量，举出来的例子可以当作测试用例检验代码的正确性。 面试题 30-34 面试题30：包含min函数的栈。 定义栈的数据结构，在该类型中实现一个能够得到栈的最小元素的min函数，在该栈中，调用min、push、pop的时间复杂度都是O(1)。 这道题容易曲解成是对这一组元素的排序，就容易陷入到一个思维陷阱，开始怀疑是怎么在O(n)时间内做到对这些元素的排序的（常用的排序也需要O(nlogn)的时间），其实多举几个例子可以发现，这个过程并不完全等价于是对一组元素的排序，栈的min值是有条件性的，取决于栈中到底有什么样的元素，以及这些元素的入栈顺序，所以用一个相同长度的栈，来存储一个元素入栈后，栈的min值是多少，就可以同步地在O(1)时间里实现min的获取。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162#include &lt;iostream&gt;const int max_len = 100;struct MinStack { int stack[max_len]; int min_stack[max_len]; int anchor = -1; void push(int elem) { if(anchor &lt; max_len - 1) { stack[anchor + 1] = elem; if(anchor == -1 || min_stack[anchor] &gt; elem) { min_stack[anchor + 1] = elem; } else { min_stack[anchor + 1] = min_stack[anchor]; } anchor++; } else { // throw error } } int pop() { if(anchor &gt;= 0) { anchor--; return stack[anchor + 1]; } else { // throw error return - 1; } } int min() { if(anchor &gt;= 0) { return min_stack[anchor]; } else { // throw error return -1; } }};int main() { MinStack min_stack; for(int i = 0; i &lt; 4; i++) { min_stack.push(4 - i); printf(&quot;After push %d, min=%d\\n&quot;, 4 - i, min_stack.min()); } // After push 4, min=4 // After push 3, min=3 // After push 2, min=2 // After push 1, min=1 for(int i = 0; i &lt; 4; i++) { int pop = min_stack.pop(); printf(&quot;After pop %d, min=%d\\n&quot;, pop, min_stack.min()); } // After pop 1, min=2 // After pop 2, min=3 // After pop 3, min=4 // After pop 4, min=-1} 面试题31：栈的压入、弹出序列。 输入两个整数序列，第一个序列表示栈的压入顺序，请判断第二个序列是否为该栈的弹出顺序。假设压入栈的所有数字均不相等，例如{1,2,3,4,5}是某栈的压栈序列，序列{4,5,3,2,1}是该栈的对应一个弹出序列，但{4,3,5,1,2}就不可能是该压栈的弹出序列。 PS：题目其实说的蛮含糊的，只要理解一个关键点就好了，它指的是执行一系列压栈和弹出操作，并不是先只压栈然后再只弹出，所以一个入栈顺序为{1,2,3,4,5}，出栈顺序也可能是{1,2,3,4,5}（进一个就出一个）。 比较直观的方法就是用一个栈来模拟整个流程，看这个流程是否能匹配上压栈和弹出的顺序。 每次压栈结束后，就检查剩余的出栈顺序，如果下一个出栈的元素就栈顶的元素就出栈，并且循环检查，直到无法再出栈。如果入栈都结束后，出栈顺序或者栈内不为空，则表示出栈顺序有错误。 完整实现代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#include &lt;iostream&gt;#include &lt;stack&gt;bool is_pop_order(const int* ppush, const int* ppop, int len) { bool possible = false; if(ppush != nullptr &amp;&amp; ppop != nullptr &amp;&amp; len &gt; 0) { const int* pnext_push = ppush; const int* pnext_pop = ppop; std::stack&lt;int&gt; stack; while(pnext_pop - ppop &lt; len) { while(stack.empty() || stack.top() != *pnext_pop) { // 元素压栈 if(pnext_push - ppush == len) { break; // 元素全部已入栈 } stack.push(*pnext_push); pnext_push++; } while(!stack.empty() &amp;&amp; stack.top() == *pnext_pop) { // 元素出栈 stack.pop(); pnext_pop++; } if(pnext_push - ppush == len &amp;&amp; pnext_pop - ppop != len) { // 入栈已空，但出栈还未空，不是正确的出栈顺序 break; } } if(stack.empty() &amp;&amp; pnext_pop - ppop == len) { possible = true; } } return possible;}void test(const int* ppush, const int* ppop, int len) { printf(&quot;%s\\n&quot;, is_pop_order(ppush, ppop, len)?&quot;yes&quot;:&quot;no&quot;);}int main() { int push_order[5] = {1,2,3,4,5}; int pop_order1[5] = {4,5,3,2,1}; int pop_order2[5] = {4,3,5,1,2}; int pop_order3[5] = {1,2,3,4,5}; int pop_order4[5] = {5,4,3,2,1}; test(push_order, pop_order1, 5); // yes test(push_order, pop_order2, 5); // no test(push_order, pop_order3, 5); // yes test(push_order, pop_order4, 5); // yes return 0;} 面试题32：从上到下打印二叉树。 题目一：不分行从上到下打印，同一层按照从左到右的顺序打印，节点定义： 12345struct node { int value; node* pleft; node* pright;} 思路就是之前有提到过的层序遍历了，使用队列的数据结构来辅助遍历。 完整实现代码： 12345678910111213141516171819202122232425262728293031323334353637#include &lt;iostream&gt;#include &lt;queue&gt;struct node { int value; node* pleft; node* pright;};node* init_node(int value) { ... }node* init_tree() { ... }void level_order_traversal(node* proot) { if(proot == nullptr) { return; } std::queue&lt;node*&gt; q; q.push(proot); node* pnode; while(!q.empty()) { pnode = q.front(); printf(&quot;%d &quot;, pnode-&gt;value); if(pnode-&gt;pleft != nullptr) { q.push(pnode-&gt;pleft); } if(pnode-&gt;pright != nullptr) { q.push(pnode-&gt;pright); } q.pop(); }}int main() { node* proot = init_tree(); level_order_traversal(proot); return 0;} PS：书上代码用的队列是deque双端队列，不是很明白作者的用意，这里我就直接用普通队列queue了。 题目二：分行从上到下打印二叉树，每一层打印到一行，例如： 12386 105 7 9 11 队列除了保存节点顺序，还要保存一个层数，在题目一代码基础上进行稍微的修改。 123456789101112131415161718192021222324252627282930313233343536373839404142434445#include &lt;iostream&gt;#include &lt;queue&gt;#include &lt;utility&gt; // use std::pair#include &lt;tuple&gt; // use std::tiestruct node { int value; node* pleft; node* pright;};node* init_node(int value) { ... }node* init_tree() { ... }void level_order_traversal(node* proot) { if(proot == nullptr) { return; } std::queue&lt;std::pair&lt;node*, int&gt;&gt; q; q.push(std::make_pair(proot, 1)); node* pnode; int level; int last_level = 1; while(!q.empty()) { std::tie(pnode, level) = q.front(); if(level &gt; last_level) { printf(&quot;\\n&quot;); last_level = level; } printf(&quot;%d\\t&quot;, pnode-&gt;value); if(pnode-&gt;pleft != nullptr) { q.push(std::make_pair(pnode-&gt;pleft, level + 1)); } if(pnode-&gt;pright != nullptr) { q.push(std::make_pair(pnode-&gt;pright, level + 1)); } q.pop(); }}int main() { node* proot = init_tree(); level_order_traversal(proot); return 0;} 书上代码把逻辑拆分的有点复杂，不够简洁，所以就用自己的方式来写了，在队列的节点中嵌入了节点的层数，用一个变量last_level来保存上一次打印节点的层数，如果发现已经到了下一层，就先输出一个换行，逻辑上更加简洁。 题目三：之字形打印二叉树，第一行按照从左到右顺序，第二行按照从右到左顺序，第三行从左到右，依次类推。 可以简单地理解为，奇数行照常顺序打印，而偶数行需要逆向打印，所以可以简单地给偶数行添加一个栈结构，先全部压栈，再出栈打印，其他流程照旧，即可实现题目的要求，在题目二的代码基础上稍加修改即可。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364#include &lt;iostream&gt;#include &lt;queue&gt;#include &lt;utility&gt;#include &lt;tuple&gt;#include &lt;stack&gt;struct node { int value; node* pleft; node* pright;};node* init_node(int value) { ... }node* init_tree() { ... }void level_order_traversal_zigzag(node* proot) { if(proot == nullptr) { return; } std::queue&lt;std::pair&lt;node*, int&gt;&gt; q; std::stack&lt;int&gt; print_stack; q.push(std::make_pair(proot, 1)); node* pnode; int level; int last_level = 1; while(!q.empty()) { std::tie(pnode, level) = q.front(); if(level &gt; last_level) { if(level &amp; 0x1 == 1) { while(!print_stack.empty()) { printf(&quot;%d\\t&quot;, print_stack.top()); print_stack.pop(); } } printf(&quot;\\n&quot;); last_level = level; } if(level &amp; 0x1 == 1) { // 奇数行直接输出 printf(&quot;%d\\t&quot;, pnode-&gt;value); } else { // 偶数行先压栈 print_stack.push(pnode-&gt;value); } if(pnode-&gt;pleft != nullptr) { q.push(std::make_pair(pnode-&gt;pleft, level + 1)); } if(pnode-&gt;pright != nullptr) { q.push(std::make_pair(pnode-&gt;pright, level + 1)); } q.pop(); } // 最后一层是偶数层时， 需要继续清空输出 while(!print_stack.empty()) { printf(&quot;%d\\t&quot;, print_stack.top()); print_stack.pop(); }}int main() { node* proot = init_tree(); level_order_traversal_zigzag(proot); return 0;} 书上的代码逻辑稍微复杂一点，要用两个栈来完成两层的循环之字输出，理解起来稍微比较难，所以我就只是简单地在题目二的基础上进行修改了，逻辑上理解起来更加方便。 面试题33：二叉搜索树的后序遍历序列。 输入一个整数数组，判断该数组是不是某二叉搜索树的后序遍历结果。如果是则返回true，否则返回false。假设输入的数组的任意两个数字互不相同，如，{5,7,6,9,11,10,8}，则返回true，因为整数序列是下图的二叉搜索树的后序遍历结果，如果输入{7,4,6,5}，则返回false，无法找到这样的二叉搜索树。 后序遍历的特点在于最后访问根节点，所以对于一个树（或子树）的后续遍历序列，根节点都是最后一个数，另外，对于二叉搜索树的一个节点，其左子树的节点都小于该节点，右子树的节点都大于该节点，在遍历序列上体现就是前一部分大于节点值，后一部分小于节点值。所以解题的思路就是递归地去分解后续遍历序列，不断的去验证各个节点子树对应的后续遍历是否满足二叉搜索树的特性即可。 完整实现代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include &lt;iostream&gt;bool is_post_order(int sequence[], int start, int end) { if(sequence == nullptr || start &gt; end) { return false; } if(start == end) { return true; } int pstart, pend; for(pstart = start; pstart &lt; end; pstart++) { if(sequence[pstart] &gt; sequence[end]) { pstart--; break; } } for(pend = end - 1; pend &gt;= start; pend--) { if(sequence[pend] &lt; sequence[end]) { pend++; break; } } if(pstart == pend) { // 全偏树，此时所有节点都大于或小于子树根节点 return is_post_order(sequence, start, end-1); } else if(pstart + 1 == pend) { // 左子树都小于节点，右子树都大于节点 bool bleft = is_post_order(sequence, start, pstart); bool bright = is_post_order(sequence, pend, end-1); return bleft &amp;&amp; bright; } else { // 不满足要求 return false; }}void test(int sequence[], int start, int end) { printf(&quot;%s\\n&quot;, is_post_order(sequence, start, end)?&quot;yes&quot;:&quot;no&quot;);}int main() { int sequence1[] = { 5,6,7,9,11,10,8 }; int sequence2[] = { 7,4,6,5 }; test(sequence1, 0, 6); // yes test(sequence2, 0, 3); // no return 0;} 比较细致地考虑的话，要记得把全偏树的情况考虑到，此时根节点前面的所有节点都属于一个子树，而不是还是分左子树和右子树。 面试题34：二叉树中和为某一值的路径。 输入一棵二叉树和一个整数，打印出二叉树中节点值的和为输入整数的所有路径。从树的根节点开始往下一直到叶节点所经过的节点形成一条路径。二叉树节点的定义如下： 12345struct node { int value; node* pleft; node* pright;} 直观的方法应该就是递归地往下遍历所有情况，到叶节点的时候计算路径上的节点和，如果和等于输入的整数，则输出路径。 完整实现代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344#include &lt;iostream&gt;#include &lt;vector&gt;struct node { int value; node* pleft; node* pright;};node* init_node(int value) { ... }node* init_tree() { ... }std::vector&lt;node*&gt; path; // 存储路径void find_path(node* pnode, int sum, int expect_sum) { if(pnode == nullptr) { return; } if(pnode-&gt;pleft == nullptr &amp;&amp; pnode-&gt;pright == nullptr &amp;&amp; sum + pnode-&gt;value == expect_sum) { // 满足要求，输出节点 path.push_back(pnode); for(int i = 0; i &lt; path.size(); i++) { printf(&quot;%d &quot;, path[i]-&gt;value); } printf(&quot;\\n&quot;); path.pop_back(); return; } path.push_back(pnode); if(pnode-&gt;pleft != nullptr) { find_path(pnode-&gt;pleft, sum + pnode-&gt;value, expect_sum); } if(pnode-&gt;pright != nullptr) { find_path(pnode-&gt;pright, sum + pnode-&gt;value, expect_sum); } path.pop_back();}int main() { node* tree = init_tree(); find_path(tree, 0, 22); return 0;} 这道题可能会联想到提前剪枝的优化，例如当还没有到叶节点时，发现和已经大于了期望值的和，此时提前停止往下查询的操作叫做剪枝，但需要注意的是本题目中并没有限定节点的值value一定是正数(类型也是int而非unsigned int)，可以出现途中和大于期望值和，所以本题不能用这样的剪枝优化方法。 4 分解让复杂问题简单化包含面试题35-38。 请到《第4章笔记 高质量代码 P3》阅读这部分内容。","link":"/2021/01/02/s2o-c4-part2/"},{"title":"《剑指Offer》第4章笔记 解题的思路 P3","text":"遇到复杂的问题，可以尝试将大问题分解为若干小问题。 1、2 章节包含面试题27-29。 请到《第4章笔记 解题的思路 P1》阅读这部分内容。 3 章节包含面试题30-34。 请到《第4章笔记 高质量代码 P2》阅读这部分内容。 4 分解让复杂问题简单化在面试中，当我们遇到复杂的大问题的时候，如果能够先把大问题分解成若干个简单地小问题，然后再逐个解决这些小问题，则可能也会容易很多。 在计算机领域有一类算法叫分治法，即“分而治之”，把分解后的小问题各个解决，然后把小问题的解决方案结合起来解决大问题。 面试题35-38 面试题35：复杂链表的复制。 实现函数ComplexListNode* clone(ComplexListNode* phead)，复制一个复杂链表。在复杂链表中，每个节点除了有一个pnext指针指向下一个节点，还有一个psibling指针指向链表中的任意节点或者nullptr。节点定义如下： 12345struct ComplexListNode { int value; ComplexListNode* pnext; ComplexListNode* psibling;}; 直观地思路是先复制整个链表，然后使用一个辅助存储空间来存储节点间的映射关系，例如用一个哈希表来存储&lt;节点、克隆节点&gt;的映射关系，这样在建立psibling关系时十分有用，时间开销也可以做到O(n)； 进一步地，可以不用借助辅助的空间来存储节点对应关系，例如直接先将克隆节点挂靠在原节点后面，用这种方式来替代哈希表，同时也可以方便地建立psibling关系，这种方法对应的缺陷是过程中会对原数据结构进行修改，如果外部程序允许，则可以这样操作（在一些并行程序中可能会出现问题）。 完整实现代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970#include &lt;iostream&gt;struct ComplexListNode { int value; ComplexListNode* pnext; ComplexListNode* psibling;};ComplexListNode* init_node(int value) { ... }ComplexListNode* init_list() { ... }ComplexListNode* clone(ComplexListNode* phead) { if(phead == nullptr) { return nullptr; } ComplexListNode* pnode = phead; // 克隆节点 while(pnode != nullptr) { ComplexListNode* pclone = init_node(pnode-&gt;value); pclone-&gt;pnext = pnode-&gt;pnext; pnode-&gt;pnext = pclone; pnode = pclone-&gt;pnext; } pnode = phead; // 建立克隆节点的sibling关系 while(pnode != nullptr) { if(pnode-&gt;psibling != nullptr) { ComplexListNode* psibling = pnode-&gt;psibling; ComplexListNode* pclone = pnode-&gt;pnext; pclone-&gt;psibling = psibling-&gt;pnext; } pnode = pnode-&gt;pnext-&gt;pnext; } ComplexListNode* pclone_head = nullptr; ComplexListNode* ptemp = nullptr; pnode = phead; // 从链表中分离出克隆节点 while(pnode != nullptr) { if(pclone_head == nullptr) { pclone_head = pnode-&gt;pnext; } else { ptemp-&gt;pnext = pnode-&gt;pnext; } ptemp = pnode-&gt;pnext; pnode-&gt;pnext = ptemp-&gt;pnext; ptemp-&gt;pnext = nullptr; pnode = pnode-&gt;pnext; } return pclone_head;}void print(ComplexListNode* phead) { ComplexListNode* pnode = phead; while(pnode != nullptr) { printf(&quot;%d&quot;, pnode-&gt;value); if(pnode-&gt;psibling != nullptr) { printf(&quot;-&gt;%d&quot;, pnode-&gt;psibling-&gt;value); } printf(&quot;\\n&quot;); pnode = pnode-&gt;pnext; }}int main() { ComplexListNode* phead = init_list(); ComplexListNode* pclone = clone(phead); print(phead); print(pclone); return 0;} 面试题36：二叉搜索树与双向链表。 输入一棵二叉搜索树，将该二叉搜索树转换成一个排序的双向链表。要求不能创建任何新的节点，只能调整树中节点指针的指向。比如，输入图4.15中左边的二叉搜索树，则输出转换之后的排序双向链表。二叉树节点定义如下： 12345struct node { int value; node* pleft; node* pright;}; 稍微观察就可以发现，对于单个的一个节点（子树），转换为双向链表时，只需要将其左子树的最大节点和其右子树的最小节点传分别链接到两个对应指针上，递归地处理其左子树和右子树，就可以得到最终的结果。 完整实现代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465#include &lt;iostream&gt;struct node { int value; node* pleft; node* pright;};node* init_node(int value) { ... }node* init_tree() { ... }void tree_to_list_core(node* proot, node** max, node** min) { if(proot == nullptr) { return; } node *lmax, *lmin, *rmax, *rmin; lmax = lmin = rmax = rmin = nullptr; tree_to_list_core(proot-&gt;pleft, &amp;lmax, &amp;lmin); tree_to_list_core(proot-&gt;pright, &amp;rmax, &amp;rmin); *max = rmax?rmax:proot; // 确定头节点(最小节点) *min = lmin?lmin:proot; // 确定尾节点(最大节点) if(lmax != nullptr) { lmax-&gt;pright = proot; } proot-&gt;pleft = lmax; if(rmin != nullptr) { rmin-&gt;pleft = proot; } proot-&gt;pright = rmin;}void tree_to_list(node* proot, node** max, node** min) { if(proot == nullptr) { return; } tree_to_list_core(proot, max, min);}void dual_print(node* phead, node* ptail) { // 顺序打印 node* pnode = phead; printf(&quot;Min -&gt; Max: &quot;); while(pnode != nullptr) { printf(&quot;%d &quot;, pnode-&gt;value); pnode = pnode-&gt;pright; } printf(&quot;\\n&quot;); // 逆序打印 pnode = ptail; printf(&quot;Max -&gt; Min: &quot;); while(pnode != nullptr) { printf(&quot;%d &quot;, pnode-&gt;value); pnode = pnode-&gt;pleft; } printf(&quot;\\n&quot;);}int main() { node* proot = init_tree(); node *phead, *ptail; phead = ptail = nullptr; tree_to_list(proot, &amp;ptail, &amp;phead); dual_print(phead, ptail); return 0;} 书上使用的方法是，在中序遍历的同时，在函数参数中加上一个已构建链表的尾节点，逐步地向尾部挂链节点，这样的方法个人逻辑上理解起来有点绕，所以我自己写的时候，对函数的定义是要同时确定重构建链表的头节点和尾节点，这样逻辑构建上感觉会更加清晰一点，并且最后可以直接返回双向链表的头节点和尾节点，无需再去重新遍历寻找，核心算法的时间效率上和书上代码并没有太大区别。 面试题37：序列化二叉树。 请实现两个函数，分别用来序列化和反序列化二叉树。 PS：序列化(Serialization)指的是将对象的状态信息转换为可以存储或传输的形式的过程，反序列化则是通过序列化信息来重建对应状态的对象。 之前的面试题7“重建二叉树”，我们知道可以从前序遍历和中序遍历构造出一棵（也是唯一的）二叉树。受启发，可能可以尝试把一棵二叉树序列化成一个前序和一个中序，然后反序列通过两个序列重构出原二叉树。 但这样的思路有两个问题： 这种方法要求二叉树不能有数值重复的节点（如果有重复的节点，在确定根节点时会出现歧义）； 只有两个序列中所有数据都读出来后才能开始反序列化，如果两个遍历数据只能从一个流中读取，那么可能要等待较长时间。 实际上，如果二叉树的序列化是从根节点开始的，那么相应的反序列化在根节点的数值读出来的时候就可以开始了。因此，可以根据前序遍历的顺序来序列化二叉树，在二叉树碰到nullptr时，转化为一个特殊的字符(比如$)，另外节点的数值要用一个特殊字符(比如,)隔开。 完整代码实现： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768#include &lt;iostream&gt;struct node { int value; node* pleft; node* pright;};node* init_node(int value) { ... }node* init_tree() { ... }void serialize(node* proot, char*&amp; stream) { if(proot == nullptr) { *stream = '$'; *(stream + 1) = ','; *(stream + 2) = '\\0'; stream += 2; return; } *stream = '0' + proot-&gt;value; *(stream + 1) = ','; *(stream + 2) = '\\0'; stream += 2; serialize(proot-&gt;pleft, stream); serialize(proot-&gt;pright, stream);}bool read_stream(char*&amp; stream, int* number) { if(*stream &lt;= '9' &amp;&amp; *stream &gt;= '0') { *number = *stream - '0'; stream += 2; return true; } else { stream += 2; return false; }}void deserialize(node** proot, char*&amp; stream) { int number; if(read_stream(stream, &amp;number)) { *proot = init_node(number); deserialize(&amp;((*proot)-&gt;pleft), stream); deserialize(&amp;((*proot)-&gt;pright), stream); }}void preorder_traversal(node* proot) { if(proot == nullptr) { return; } printf(&quot;%d &quot;, proot-&gt;value); preorder_traversal(proot-&gt;pleft); preorder_traversal(proot-&gt;pright);}int main() { node* proot = init_tree(); char* stream = new char[100]; char* pchar = stream; serialize(proot, pchar); printf(&quot;%s\\n&quot;, stream); node* new_proot = nullptr; pchar = stream; deserialize(&amp;proot, pchar); preorder_traversal(proot); return 0;} 这里利用了先序遍历的节点顺序特性，使用中序或者后序就无法实现这样的效果，算是一种特殊的技巧吧，用$替代空指针nullptr，在先序遍历的同时确定之后重建的顺序。序列化中一些需要注意的细节，比如使用的替代字符$是否在节点value范围中，要使用间隔符,将值隔开，避免节点值产生混淆错误。 面试题38：字符串的排列。 输入一个字符串，打印出该字符串中字符的所有排列。例如，输入字符串abc，则打印由字符a、b、c所能排列出的所有字符串abc、acb、bac、bca、cab和cba。 基础思路是使用递归来完成，例如确定一个字符后，只需要知道剩下字符串的全排列即可，在第i层递归时，从还未选择的字符中确定一个字符在输出的第i个位置，遍历所有可能性，也就是全排列的实现方式。 完整实现代码： 12345678910111213141516171819202122232425262728293031323334#include &lt;iostream&gt;#include &lt;cstring&gt;void permutation(char* string, bool* choose, int len, char* output, int olen) { if(olen == len) { *(output + olen) = '\\0'; printf(&quot;%s\\n&quot;, output); } for(int i = 0; i &lt; len; i++) { if(!choose[i]) { *(output + olen) = string[i]; choose[i] = true; permutation(string, choose, len, output, olen + 1); choose[i] = false; } }}void permutation(char* string) { if(string == nullptr) { return; } int len = strlen(string); char* output = new char[len + 1]; output[0] = '\\0'; bool* choose = new bool[len]; memset(choose, 0, sizeof(choose)); permutation(string, choose, len, output, 0);}int main() { char* string = &quot;abc&quot;; permutation(string);} 书上的代码是通过交换原字符串中各字符的位置来实现的，自己写代码时为了确保字符串本身不被修改，所以使用了一个bool* choose数组来记录被选中的字符位置，以及char* output来记录字符的顺序（用以最后的输出）。 5 总结 图形使抽象的问题形象化。 举例使抽象的问题具体化。 分解使复杂的问题易解化。","link":"/2021/01/03/s2o-c4-part3/"},{"title":"《剑指Offer》第5章笔记 优化效率","text":"时间与空间，是算法永恒的话题。 1 面试官谈效率大佬们说的名言名句。 咕咕待更。 2 时间效率面试官除了考查应聘者的编程能力，还关注应聘者有没有不断优化效率、追求完美的态度和能力。 首先，我们的编程习惯对代码的时间效率有很大影响。比如C/C++程序员要养成采用引用（或指针）传递复杂类型参数的习惯。如果采用值传递的方式，则从形参到实参会产生一次复制操作，这样的复制大部分时候是多余的，应该尽量避免。再比如，C#中做多次字符串的拼接操作，尽量不要用多次String的+运算符来拼接字符串，因为这样会产生很多String的临时实例，造成时间和空间的浪费，更好的办法是用StringBuilder的Append方法来完成字符串的拼接。如果我们平时不太注意这些影响代码效率的细节，没有养成好的编码习惯，写出的代码可能会让面试官大失所望。 其次，即使同一个算法用循环和递归两种思路实现的时间效率可能会大不一样。递归的本质是把一个大的复杂问题分解成两个或者多个小的简单问题。如果小问题有相互重叠的部分，那么直接用递归实现虽然代码显得很简洁，但时间效率可能会非常差，对于这种题目，可以用递归地思路来分析，写代码的时候可以基于循环实现，并且用数组来保存中间结果，绝大部分动态规划算法的分析和代码实现都是分这两个步骤完成的。 再次，代码的时间效率还能体现应聘者对数据结构和算法功底的掌握程度。同样是查找，如果是顺序查找则需要O(n)的时间；如果输入的是排序的数组则只需要O(logn)的时间；如果事先已经构造好了哈希表，那么查找在O(1)时间内就能完成。 最后，应聘者在面试的时候要展示敏捷的思维能力和追求完美的激情，这些对最终的面试结果也有很重要的影响。 面试题 39-48 面试题39：数组中出现次数超过一半的数字。 数组中有一个数字出现的次数超过数组长度的一半，请找出这个数字。例如，输入一个长度为9的数组{1,2,3,2,2,2,5,4,2}。由于数字2在数组中出现了5次，超过数组长度的一半，因此输出2。 解法一：基于Partition函数的时间复杂度为O(n)的算法。 数组中有一个数字出现的次数超过了数组长度的一半，如果这个数组排序，那么排序之后位于数组中间的数字，一定就是那个出现次数超过数组长度一半的数字。这个数字就是统计学上的中位数，即长度为n的数组中第n/2大的数字。我们有成熟的时间复杂度为O(n)的算法得到数组中任意第k大的数字。 这种算法受快速排序算法的启发。在随机快速排序算法中，先在数组中随机选择一个数字，然后调整数组中数字的顺序，使得比选中的数字小的数字都排在它的左边，比选中的数字大的数字都排在它的右边。如果这个选中的数字下标刚好是n/2，则这个数字就是数组的中位数；如果下标大于n/2，那么中位数应该在它的左边，接着在它的左边找；如果下标小于n/2，中位数在它的右边，接着在它的右边找。这是一个典型的递归过程。 完整实现代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091#include &lt;iostream&gt;int partition(int* numbers, int len, int start, int end) { if(start == end) { return start; } int anchor = numbers[end]; int left = start; int right = end - 1; while(left &lt; right) { while(numbers[left] &lt; anchor &amp;&amp; left &lt; right) { left++; } while(numbers[right] &gt;= anchor &amp;&amp; left &lt; right) { right--; } if(left != right) { int temp = numbers[left]; numbers[left] = numbers[right]; numbers[right] = temp; } } if(left != end - 1 || numbers[left] &gt; anchor) { int temp = numbers[left]; numbers[left] = numbers[end]; numbers[end] = temp; } else { left = end; } return left;}bool g_input_invalid = false;bool check_array(int* numbers, int len) { g_input_invalid = false; if(numbers == nullptr || len &lt;= 0) { g_input_invalid = true; } return g_input_invalid;}bool check_more_than_half(int* numbers, int len, int number) { int times = 0; for(int i = 0; i &lt; len; i++) { if(numbers[i] == number) { times++; } } bool is_more_than_half = true; if(times * 2 &lt;= len) { g_input_invalid = true; is_more_than_half = false; } return is_more_than_half;}int more_than_half_num(int* numbers, int len) { if(check_array(numbers, len)) { return 0; } int middle = len &gt;&gt; 1; int start = 0; int end = len - 1; int index = partition(numbers, len, start, end); while(index != middle) { if(index &gt; middle) { end = index - 1; index = partition(numbers, len, start, end); } else { start = index + 1; index = partition(numbers, len, start, end); } } int result = numbers[middle]; if(!check_more_than_half(numbers, len, result)) { result = 0; } return result;}int main() { int numbers[] = { 1, 2, 3, 2, 2, 2, 5, 4, 2 }; int result = more_than_half_num(numbers, 9); if(g_input_invalid) { printf(&quot;Invalid input.\\n&quot;); } else { printf(&quot;Result: %d\\n&quot;, result); } return 0;} 在面试的时候，除了完成基本功能，还要考虑一些无效的输入。如果函数的输入参数是一个指针（数组在参数传递的时候退化为指针），就要考虑这个指针可能为nullptr。代码中的check_array用来判断输入的数组是不是无效的。check_more_than_half用来检验输入的数组中，是不是这个数字出现次数大于长度一半，用全局变量g_input_invalid来表示输入无效的情况。 解法二：根据数组特点找出时间复杂度为O(n)的算法。 从另一个角度来解决这个问题。数组中有一个数字出现的次数超过数组长度的一半，也就是说它出现的次数比其他所有数字出现的和还要多。因此，考虑在遍历数组的时候保存两个值，一个是数组中的一个数字，另一个是次数。当遍历到下一个数字时，如果下一个数字和之前保存的数字相同，则次数加1；如果下一个数字和之前保存的不同，则次数减1；如果次数为0，则保存下一个数字，并把次数设1。由于要找的数字出现的次数比其他所有出现的次数之和还要多，那么要找的数字肯定是最后一次把次数设为1对应的数字。 完整实现代码： 1234567891011121314151617181920212223242526272829303132333435363738#include &lt;iostream&gt;bool g_input_invalid = false;bool check_array(int* numbers, int len) { ... }bool check_more_than_half(int* numbers, int len, int number) { ... }int more_than_half_num(int* numbers, int len) { if(check_array(numbers, len)) { return 0; } int result = numbers[0]; int times = 1; for(int i = 0; i &lt; len; i++) { if(times == 0) { result = numbers[i]; times = 1; } else if(numbers[i] == result) { times++; } else { times--; } } if(!check_more_than_half(numbers, len, result)) { result = 0; } return result;}int main() { int numbers[] = { 1, 2, 3, 2, 2, 2, 5, 4, 2 }; int result = more_than_half_num(numbers, 9); if(g_input_invalid) { printf(&quot;Invalid input.\\n&quot;); } else { printf(&quot;Result: %d\\n&quot;, result); } return 0;} 两种解法算法的时间复杂度都是O(n)，在第一种解法中，需要交换数组中数字的顺序，这就会修改输入的数组，而在面试的时候需要尝试和面试官讨论，明确需求，如果说不能修改输入的数组，就只能采用第二种解法了。 面试题40：最小的K个数。 输入n个整数，找出其中最小的k个数，例如，输入4,5,1,6,2,7,3,8这8个数字，则最小的4个数字是1,2,3,4。 最简单直观的解法就是进行k次数组遍历，每一次找出一个相对最小值，时间复杂度O(nk)，代码比较简单就不再写了，主要讲两种优化的思路。 解法一：时间复杂度为O(n)的算法，只有当我们可以修改输入的数组时可用。 同样可以基于partition函数来解决这个问题。如果基于数组的第k个数字来调整，使得比第k个数字小的所有数字都位于数组的左边，比第k个数大的所有数字都位于数组的右边。这样，位于数组中左边的k个数字就是最小的k个数字（k个数字不一定是排序的）。 完整实现代码： 123456789101112131415161718192021222324252627282930313233343536#include &lt;iostream&gt;int partition(int* numbers, int len, int start, int end) { ... }void find_k_min(int* input, int n, int* output, int k) { if(input == nullptr || output == nullptr || k &gt; n || n &lt;= 0 || k &lt;= 0) { return; } int start = 0; int end = n - 1; int index = partition(input, n, start, end); while(index != k - 1) { if(index &gt; k - 1) { end = index - 1; index = partition(input, n, start, end); } else { start = index + 1; index = partition(input, n, start, end); } } for(int i = 0; i &lt; k; i++) { output[i] = input[i]; }}int main() { int input[] = { 4,5,1,6,2,7,3,8 }; int n = 8; int k = 4; int* output = new int[k]; find_k_min(input, n, output, k); for(int i = 0; i &lt; k; i++) { printf(&quot;%d &quot;, output[i]); } return 0;} 如果面试官要求不能修改输入的数组，那么就只能另辟蹊径。 解法二：时间复杂度为O(nlogk)的算法，特别适合处理海量数据。 先创建一个大小为k的数据容器来存储最小的k个数字，接下来每次从输入的n个整数中读入一个数。如果容器中少于k个，则直接把这次读入的整数放入容器中；如果容器已经有k个了，此时比较读入的数字和容器中最大的数字，如果读入的更小，就插入容器，删除掉最大的。 如果用一棵二叉树（堆）来实现容器，那么就能在O(logk)时间内完成一个序列的最大值构建（O(1)的时间得到最大值，O(logk)时间完成删除和插入操作），对于n个输入数字，总的时间效率是O(nlogk)。 从头实现一个最大堆需要一定的代码，面试的几十分钟内很难完成，我们可以借助STL提供的一些数据结构，例如set或者multiset（区别是后者可以重复），如果面试官不反对使用STL，就可以直接拿来用，根据这道题的需求，使用multiset更加合适一点。 完整实现代码： 123456789101112131415161718192021222324252627282930313233343536373839404142#include &lt;iostream&gt;#include &lt;set&gt;// std::greater 代表递减排序 最大的在begintypedef std::multiset&lt;int, std::greater&lt;int&gt;&gt; int_set;typedef std::multiset&lt;int, std::greater&lt;int&gt;&gt;::iterator int_set_iter;void find_k_min(int* input, int n, int* output, int k) { if(input == nullptr || output == nullptr || k &gt; n || n &lt;= 0 || k &lt;= 0) { return; } int_set set; for(int i = 0; i &lt; n; i++) { if(set.size() &lt; k) { set.insert(input[i]); } else { int_set_iter iter = set.begin(); if(*iter &gt; input[i]) { set.erase(iter); set.insert(input[i]); } } } int_set_iter iter = set.begin(); for(int i = 0; i &lt; k; i++) { output[i] = *iter; iter++; }}int main() { int input[] = { 4,5,1,6,2,7,3,8 }; int n = 8; int k = 4; int* output = new int[k]; find_k_min(input, n, output, k); for(int i = 0; i &lt; k; i++) { printf(&quot;%d &quot;, output[i]); } return 0;} 第一种基于函数partition的第一种解法平均时间复杂度是O(n)，比第二种解法要快，但同时也有限制，比如会修改输入的数组（开O(n)空间虽然可以解决，但是有额外的空间代价）。 第二种基于最大堆容器的解法虽然慢，但一是没有修改输入的数据，二是算法适合海量数据的处理，因为第二种方法不用一次性将全部数据都读入到内存中，而第一种方法只有全部读入才能计算。 面试题41：数据流中的中位数。 如何得到一个数据流的中位数？如果从数据流读出的数据是奇数个，那么中位数就是所有值排序之后位于中间的数值；如果从数据流中读取偶数个数值，那么中位数是排序之后两个数的平均值。 数据是从一个数据流中读出来的，因而数据的数目随着时间的变化而增加，如果用一个数据容器来保存从流中读出来的数据，则当有新的数据从流中读出来，这些数据就插入数据容器（所以中位数是一个不断在变化的值，和容器的状态相关）。 那么可以考虑用几种不同的数据结构来作为容器： 数组：没有排序，可以使用partition找出数组的中位数，输入复杂度O(1)，找数中位数O(n)； 排序数组：O(logn)时间搜索，但需要O(n)时间来插入，得到中位数的时间是O(1)； 排序链表：O(n)时间插入，定义两个指针来指向链表中间的节点（不断调整的开销O(1)），所以找出中位数只需要O(1)； AVL树：O(logn)时间插入一个新节点，用O(1)时间得到所有节点的中位数，虽然AVL效率很高，但是大部分编程语言的函数库都没有实现这个数据结构，自己在短时间内实现也很麻烦； 最大堆+最小堆：以把中位数定义为将数组分为两个部分，前一部分小于中位数，后一部分大于中位数，所以其实我们不需要前后部分一定要完整地排序，我们只需要得到前一部分的最大值和后一部分的最小值，所以可以用最大堆来组织前一部分，用最小堆组织后一部分，让两部分的大小接近相等，插入时间O(logn)，得到中位数的时间O(1)。 基于STL中的函数push_heap、pop_heap及vector实现堆。比较仿函数less和greater分别用来实现最大堆和最小堆。 完整实现代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182#include &lt;iostream&gt;#include &lt;algorithm&gt; // push_heap/pop_heap/less/greater#include &lt;vector&gt;#include &lt;exception&gt;template&lt;typename T&gt; class DynamicArray { public: void insert(T num) { if(((min.size() + max.size()) &amp; 1) == 0) { // 已经有偶数个，但有可能是0 if(max.size() &gt; 0 &amp;&amp; num &lt; max[0]) { // 如果这个数比最大堆的堆顶元素小，要先放进最大堆 max.push_back(num); // 构建堆 std::push_heap(max.begin(), max.end(), std::less&lt;T&gt;()); // 拿出堆顶元素 num = max[0]; // pop_head，将堆顶元素放在后面 std::pop_heap(max.begin(), max.end(), std::less&lt;T&gt;()); // 元素出堆 max.pop_back(); } // 元素进最小堆 min.push_back(num); std::push_heap(min.begin(), min.end(), std::greater&lt;T&gt;()); } else { // 已经有奇数个 if(min.size() &gt; 0 &amp;&amp; min[0] &lt; num) { // 如果这个数比最小堆的堆顶元素大，要先放进最小堆 min.push_back(num); // 构建堆 std::push_heap(min.begin(), min.end(), std::greater&lt;T&gt;()); // 拿出堆顶元素 num = min[0]; // 堆顶元素放在后面 std::pop_heap(min.begin(), min.end(), std::greater&lt;T&gt;()); // 元素出堆 min.pop_back(); } // 元素进最大堆 max.push_back(num); std::push_heap(max.begin(), max.end(), std::less&lt;T&gt;()); } } T get_median() { int size = min.size() + max.size(); if(size == 0) { // throw error std::logic_error ex(&quot;Empty!&quot;); throw std::exception(ex); } T median = 0; if((size &amp; 1) == 1) { median = min[0]; // 偶数的时候进最小堆，所以奇数时最小堆会多一个 } else { median = (min[0] + max[0]) / 2; } return median; } private: std::vector&lt;T&gt; min; std::vector&lt;T&gt; max;};void stream_median(int* stream, int n) { if(stream == nullptr || n &lt;= 0) { return; } DynamicArray&lt;int&gt; darray; // 注意模板类的声明使用方法 for(int i = 0; i &lt; n; i++) { darray.insert(stream[i]); printf(&quot;Read index=%d, median=%d\\n&quot;, i, darray.get_median()); }}int main() { int stream[] = { 1,2,3,4,5,6,7,8,9,10,0,1,2,3,4,5,6,7,8,9}; stream_median(stream, 20); return 0;} 其中使用到了代码里不常用的模板类，如果面试题有说明具体的数据类型，也可以直接用那个数据类型，而不是使用模板类。 其中使用到的几个和堆相关的函数进行一下说明，以后可能会用到： make_heap(begin, end, comp)：虽然在这里没有用到，但还是说明一下，将一个数组(vector)的指定部分([begin,end))进行堆排序，堆顶元素放在第一个位置，默认使用的comp是less&lt;T&gt;，即最大元素放在第一个位置（最大堆），greater&lt;T&gt;为最小元素放在第一个位置（最小堆）； push_heap(begin, end, comp)：一般在调用前，把一个新元素放在数组的尾部(vec.push_back(elm))，然后再调用函数对插入尾部的元素做堆排序； pop_heap(begin, end, comp)：将堆顶元素移动到数组尾部，同时将剩下的元素重新构造成堆结构； sort_heap(begin, end, comp)：将一个堆做排序，最终成为一个有序的序列，前提条件是输入的数组范围本身是一个对应comp的堆，如果comp是less&lt;T&gt;，最大堆最终序列是一个递增序列（大的在后面），如果是greater&lt;T&gt;，最小堆最终序列是一个递减序列（小的在后面）； 面试题42：连续子数组的最大和。 输入一个整型数组，数组里有正数也有负数。数组中的一个或连续多个整数组成一个子数组。求所有子数组的和的最大值（就是和最大的那个子数组的和值是多少），要求时间复杂度O(n)；例如，输入的数组为{1,-2,3,10,-4,7,2,-5}，和最大的子数组为{3,10,-4,7,2}，因此输出为该子数组的和18。 最简单直观的暴力遍历法就不说了（时间O(n^2)），只说优化的解决方案。 解法一：举例分析数组的规律。 从头开始往后加可以分析其中的规律，例如从某一步从i开始向后累加和，到j之前如果和已经为负数了，那么对于j而言，如果再加上前面这前j-i个位置的数字肯定不会比j自身要大，所以要计算从j开始的可能最大子数组和，就不用再加上前j-i位置的数字，重新从j开始求子数组和；同时求和的过程中，不断的更新记录的最大和。 完整实现代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243#include &lt;iostream&gt;#include &lt;limits.h&gt; // INT_MIN INT_MAXbool g_invalid_input = false;bool check_input(int* data, int len) { g_invalid_input = false; if(data == nullptr || len &lt;= 0) { g_invalid_input = true; return false; } else { return true; }}int find_max_sub_sum(int* data, int len) { if(!check_input(data, len)) { return 0; } int max_sum = INT_MIN; int sum = 0; for(int i = 0; i &lt; len; i++) { if(sum &lt; 0) { sum = 0; } sum += data[i]; if(max_sum &lt; sum) { max_sum = sum; } } return max_sum;}int main() { int data[] = {1, -2, 3, 10, -4, 7, 2, -5}; int result = find_max_sub_sum(data, 8); if(g_invalid_input) { printf(&quot;Invalid input.\\n&quot;); } else { printf(&quot;Max sum: %d\\n&quot;, result); // 18 } return 0;} 解法二：动态规划法。 如果用函数f(i)表示以第i个数字结尾的子数组（即必须包含这个尾元素）的最大和，那么我们需要求出max{f(i)}, 0&lt;=i&lt;=n，可以用如下递归公式来求f(i)： 其实公式的意义和解法一的思路是相同的，不过表达形式不同，代码就不再写一遍了。 面试题43：1~n整数中1出现的次数。 输入一个整数n，求1~n这n个整数的十进制表示中1出现的次数，例如，输入12，1~12这些整数中包含1的数字有1、10、11和12，1一共出现了5次。 简单地方法就不再写了，主要写一下书上的优化方法（其实还蛮不好理解的），直接看书上举的例子吧。 例如1~21345，首先拆成1~1345和1346~21345，前者可以递归地调用1~n； 1346~21345必然会包含10000~19999（因为21345的顶位2大于1），所以顶位上出现的1的个数有10^4个；如果定位小于1，即只包括1346~11345或者说10000~11345这部分，顶位的1个数就只有1346+1个； 1346~21345数完顶位后，开始计数其他位的1个数，此时分为两组1346~11345,11346~21345，这样分的目的是，1346~11345的后4位x1346~x1345整好覆盖了4位数的所有情况0~9999，所以只需要其中一位固定1，其他位任选0~9，就可以得到该位上的1个数，所以对于一组1346~11345有4*10^3个，11346~21345同理4*10^3个，所以一共2*4*10^3个； 最后将递归求解的1~1345计数，和1346~21345顶位计数和其他位技术相加，就得到最后的结果。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061#include &lt;iostream&gt;#include &lt;cstring&gt;int pow_base_10(unsigned int n) { int result = 1; for(unsigned int i = 0; i &lt; n; i++) { result *= 10; } return result;}int count_1(const char* str_n) { if(!str_n || *str_n &lt; '0' || *str_n &gt; '9' || *str_n == '\\0') { return 0; } int first = *str_n - '0'; unsigned int len = (unsigned int)strlen(str_n); if(len == 1 &amp;&amp; first == 0) { return 0; } if(len == 1 &amp;&amp; first &gt; 0) { return 1; } // 假设str_n是 21345 // num_first_digit 是数字10000~19999的第一位中的数目 int num_first_digit = 0; if(first &gt; 1) { // 无论first有多大，只要大于1 // 就包含10000~19999这些数（目前的例子下） // 所以目前的顶位出现的1的数量有 10^(len-1)个 num_first_digit = pow_base_10(len - 1); } else if(first == 1) { // 如果fisrt位1，就是10000~11345这种情况 // 这个时候就有1345+1个1出现在顶位上 num_first_digit = atoi(str_n + 1) + 1; } // 1346~21345除了在顶位之外的数位上1的情况 // 最高位是2，所以分成两段 1346~11345 11346~21345 // 每一段剩下的4位数字中，选择其中一位是1，其余三位可以在0~9数字中选择 // 根据排列组合有 2 * 4 * 10^3 int num_other_digit = first * (len - 1) * pow_base_10(len - 2); // 1~1345的1的数目 int num_rec = count_1(str_n + 1); return num_first_digit + num_other_digit + num_rec;}int count_1_from_1_to_n(int n) { if(n &lt; 1) { return 0; } char str_n[50]; sprintf(str_n, &quot;%d&quot;, n); return count_1(str_n);}int main() { printf(&quot;1~%d have %d '1'\\n&quot;, 12, count_1_from_1_to_n(12)); printf(&quot;1~%d have %d '1'\\n&quot;, 21345, count_1_from_1_to_n(21345)); return 0;} 最基础的思路需要O(nlogn)的时间，优化后的思路只需要O(logn)，所以要快得多。 面试题44：数字序列中某一位的数字。 数字以0123456789101112131415...的格式，序列化到一个字符序列中。在这个序列中，第5位(从0开始计数)是5，第13位是1，第19位是4，等等。写一个函数，求任意第n位对应的数字。 直接的方法就是从0开始逐一地枚举每个数组，每枚举一个数字时，求该数字是几位数，并把位数累加，如果位数只和小于或等于输入的n，则继续枚举下一个数字，当累加位数大于n时，第n位数字一定在这个数字里，我们再从该数字中找出对应的一位。 这样的方法还不够优化，其实是可以有规律地一段段跳过的，例如寻找第1001位： 0~9一共10个字符，1001&gt;10，在后面的字符中寻找第991位； 10~99一共180(90*2)个字符，991&gt;180，在后面的字符中寻找第881位； 100~999一共2700(900*3)个字符，881&lt;2700，所以第n位一定是100~999中间的某个数，由于811=270*3+1，意味着第881位是从100开始的第270个数字(370)的中间1位，即7。 完整代码实现： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#include&lt;iostream&gt;#include&lt;cmath&gt; // std::pow// 得到为m位数字总共有多少个// 例如m=2，返回(10~99)一共90个// m=3，返回(100~999)一共900个int count_of_integers(int digits) { if(digits == 1) { return 10; } int count = (int) std::pow(10, digits - 1); return 9 * count;}// 得到在m位数字中，第一个数字int begin_num(int digits) { if(digits == 1) { return 0; } return (int) std::pow(10, digits - 1);}// 得到在m位数字中，第n位到是什么int digit_at_n(int n, int digits) { // 例如370 = 100 + 881 / 3 int number = begin_num(digits) + n / digits; // 例如1 = 3 - 881 % 3 // from right 是为了之后求数的时候直接从底位开始 int n_from_right = digits - n % digits; for(int i = 1; i &lt; n_from_right; i++) { number /= 10; } return number % 10;}int digit_at_n(int n) { if(n &lt; 0) { return -1; } int digits = 1; while(true) { int numbers = count_of_integers(digits); if(n &lt; numbers * digits) { return digit_at_n(n, digits); } n -= digits * numbers; digits++; } return -1;}int main() { printf(&quot;%d\\n&quot;, digit_at_n(0)); printf(&quot;%d\\n&quot;, digit_at_n(1000)); printf(&quot;%d\\n&quot;, digit_at_n(1001)); printf(&quot;%d\\n&quot;, digit_at_n(1002)); return 0;} 面试题45：把数组排成最小的数。 输入一个正整数数组，把数组里所有数字拼接起来排成一个数，打印能拼接出的所有数字中最小的一个。例如，输入{3,32,321}，则打印出这3个数字能排成的最小数字321323。 基础的思路是全排列，然后找出最小的，时间开销一般是O(n!)，优化的思路也不会很复杂，比如就单看两个数nn和mm，他们两个如何拼接可以最小，也就是比较nnmm和mmnn，那么当整个数组都是前一个数在前面的情况下可以让两个数的结果最小，顺序拼接的结果自然也是最小的（即不会出现比这个结果还小的结果），所以最后问题变成利用这种规则去对数组进行排序。 完整实现代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#include &lt;iostream&gt;#include &lt;algorithm&gt; // sort#include &lt;cstring&gt; // strcpy strcmp strcatbool g_invalid_input = false;bool check_data(int* data, int len) { g_invalid_input = false; if(data == nullptr || len &lt;= 0) { g_invalid_input = true; return false; } // 校验是否都是正整数 for(int i = 0; i &lt; len; i++) { if(data[i] &lt;= 0) { g_invalid_input = true; return false; } } return true;}const int MAX_INT_LEN = 10;// 申请两个全局字符数组，避免排序函数中反复申请，浪费时间char* g_str_comb1 = new char[MAX_INT_LEN * 2 + 1];char* g_str_comb2 = new char[MAX_INT_LEN * 2 + 1];bool compare(const char* num1, const char* num2){ strcpy(g_str_comb1, num1); strcat(g_str_comb1, num2); strcpy(g_str_comb2, num2); strcat(g_str_comb2, num1); return strcmp(g_str_comb1, g_str_comb2) == -1;}void min_concat(int* data, int len) { if(!check_data(data, len)) { return; } // 其实还要考虑两个int相连有可能会超过int表示范围 // 所以转用字符串可能更合适，同时也不会修改原数据的顺序 char** str_data = new char*[len]; for(int i = 0; i &lt; len; i++) { str_data[i] = new char[MAX_INT_LEN + 1]; sprintf(str_data[i], &quot;%d&quot;, data[i]); } std::sort(str_data, str_data + len, compare); for(int i = 0; i &lt; len; i++) { printf(&quot;%s&quot;, str_data[i]); delete[] str_data[i]; } delete[] str_data;}int main() { int data[] = {3, 32, 321, 8, 44, 1, 143}; min_concat(data, 7);} 代码中需要注意的一个地方是，如果直接用数字排序的方式，可能会在比较nnmm和mmnn时，这种拼接结果超出int的表示范围，而导致错误结果，所以可能出现大数的情况，要注意用字符串来替代处理。另外书上的代码在校验输入的时候，漏掉了对数组的是否是正整数的判断，上面代码也补上了，并且书上代码使用的排序方法是qsort，个人建议使用sort，一般情况下更加效率和便利。 书上有细致的讲，如何去证明这样的方法的正确性（比较规则的三个角度，自反性(aa = aa)、对称性(a&lt;b =&gt; ab&lt;ba, ba&gt;ab, =&gt; b&gt;a)以及传递性(a&lt;b,b&lt;c =&gt; ab&lt;ba, bc&lt;cb =&gt; ac&lt;ca)，和反证法，假设结果不是最小的，存在一个更小的，然后去推出假设不成立），尤其是当面试官问到的时候，也要能够说出缘由来，这里就不再复述了。 面试题46：把数字翻译成字符串。 给定一个数字，按照如下规则把它翻译成字符串：0翻译成a，1翻译成b，…，11翻译成l，…，25翻译成z。一个数字可能有多个翻译。例如12258有5种不同的翻译，分别是bccfi、bwf1、bczi、mcfi和mzi。实现一个函数，用来计算一个数字有多少种不同的翻译方法。 直观的递归方法是，12258可以拆解为求解2258和258两个子问题，其中有可分支的条件是c1==1 || (c1==2 &amp;&amp; c2 &lt;= 5)，否则只能单线往下求解。 单纯递归完整代码： 1234567891011121314151617181920212223242526272829303132#include &lt;iostream&gt;const int MAX_INT_LEN = 10;int kinds_of_encode(const char* str_num) { if(*str_num == '\\0') { return 1; } char c1 = *str_num, c2 = *(str_num + 1); if(c1 == '1' || (c1 == '2' &amp;&amp; c2 &lt;= '5')) { return kinds_of_encode(str_num + 1) + kinds_of_encode(str_num + 2); } else { return kinds_of_encode(str_num + 1); }}int kinds_of_encode(int num) { if(num &lt; 0) { return 0; } // 用字符数组来处理更加方便一点 char* str_num = new char[MAX_INT_LEN + 1]; sprintf(str_num, &quot;%d&quot;, num); int result = kinds_of_encode(str_num); delete[] str_num; return result;}int main() { printf(&quot;%d\\n&quot;, kinds_of_encode(12258)); // 5 return 0;} 尽管看起来很简洁，但是这并不是最优的代码，例如2258和258两个子问题，2258会继续分支出258和58，在这一步258子问题被反复求解了，导致了计算的浪费。递归是从最大的问题开始自上而下的解决，其实我们也可以从最小的子问题开始自下而上的解决，来消除重复子问题。 也就是说，从数字的末尾开始，从右到左翻译，并计算不同翻译的数目。 完整实现代码： 123456789101112131415161718192021222324252627282930313233#include &lt;iostream&gt;#include &lt;cstring&gt;int kinds_of_encode(int num) { if(num &lt; 0) { return 0; } // 从右向左翻译，避免重复子问题 char* str_num = new char[MAX_INT_LEN + 1]; sprintf(str_num, &quot;%d&quot;, num); int len = strlen(str_num); int* results = new int[len]; results[len - 1] = 1; char c1, c2; for(int i = len - 2; i &gt;= 0; i--) { c1 = *(str_num + i); c2 = *(str_num + i + 1); if(c1 == '1' || (c1 == '2' &amp;&amp; c2 &lt;= '5')) { results[i] = results[i + 1] + results[i + 2]; } else { results[i] = results[i + 1]; } } int result = results[0]; delete[] str_num; delete[] results; return result;}int main() { printf(&quot;%d\\n&quot;, kinds_of_encode(12258)); // 5 return 0;} 面试题47：礼物的最大价值。 在一个m x n的棋盘的每一格都放有一个礼物，每个礼物都有一定的价值（价值大于0）。可以从棋盘的左上角开始拿格子里的礼物，并每次向右或向下移动一格，直到到达棋盘的右下角。给定一个棋盘以及礼物价值，请问最多能拿到多少价值的礼物？ 例如，下面的棋盘中，如果沿着带下划线的数字线路（1、12、5、7、7、16、5），那么我们能拿到最大价值为53的礼物。 定义f(i,j)为到达坐标(i,j)的格子时，能拿到的礼物总和的最大值，我们有两种途径来到达坐标为(i,j)的格子，通过格子(i-1,j)左侧或者(i,j-1)上侧，所以f(i,j)=max(f(i-1,j), f(i,j-1)) + gift[i,j]，gift[i,j]表示坐标(i,j)的格子里礼物的价值。 典型的动态规划问题，定义一个辅助二维数组，数组中(i,j)表示到达该格子时，能拿到的礼物价值总和的最大值。 完整实现代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243#include &lt;iostream&gt;#include &lt;algorithm&gt;int max_gift_value(int** values, int rows, int cols) { if(values == nullptr || *values == nullptr || rows &lt;= 0 || cols &lt;= 0) { return 0; } int** max_values = new int*[rows]; for(int i = 0; i &lt; rows; i++) { max_values[i] = new int[cols]; } for(int i = 0; i &lt; rows; i++) { for(int j = 0; j &lt; cols; j++) { int left = 0, up = 0; if(i &gt; 0) { up = max_values[i - 1][j]; } if(j &gt; 0) { left = max_values[i][j - 1]; } int value = *((int *)values + cols * i + j); max_values[i][j] = std::max(left, up) + value; } } int max_value = max_values[rows-1][cols-1]; for(int i = 0; i &lt; rows; i++) { delete[] max_values[i]; } delete[] max_values; return max_value;}int main() { int rows = 4, cols = 4; int values[4][4] = { {1, 10, 3, 8}, {12, 2, 9, 6}, {5, 7, 4, 11}, {3, 7, 16, 5} }; printf(&quot;Max gift value: %d&quot;, max_gift_value((int**)values, rows, cols)); return 0;} 考虑进一步的优化（主要是空间上），前面我们提到，到达坐标为(i,j)的格子时，最大价值依赖于(i,j-1)左侧和(i-1,j)上侧两个格子，因为此第i-2行及更上面的所有格子礼物的最大价值实际没有保存的必要。我们可以用一个一维数组来替代前面代码中的二维数组max_values，一维数组的长度为cols。 优化之后的代码： 12345678910111213141516171819202122int max_gift_value(int** values, int rows, int cols) { if(values == nullptr || *values == nullptr || rows &lt;= 0 || cols &lt;= 0) { return 0; } int* max_values = new int[rows]; // 修改为一维数组 for(int i = 0; i &lt; rows; i++) { for(int j = 0; j &lt; cols; j++) { int left = 0, up = 0; if(i &gt; 0) { up = max_values[j]; // 此时j位置保存的为上一行的数据 } if(j &gt; 0) { left = max_values[j - 1]; // 此时j-1位置已经是该行的数据 } int value = *((int *)values + cols * i + j); max_values[j] = std::max(left, up) + value; // 更新j为该行的数据 } } int max_value = max_values[cols-1]; delete[] max_values; return max_value;} 面试题48：最长不含重复字符的子字符串。 请从字符串中找出一个最长的不包含重复字符的子字符串，计算该最长子字符串的长度。假设字符串中只包含a~z。例如arabcacfr中，最长的不包含重复字符的子字符串是acfr，长度是4(还有子串rabc)。 这道题其实和之前的最大子数组和（面试题42）的思路有异曲同工之妙，同样有两种方法，一种是通过规律观察，另一种就是书上讲的动态规划法。首先讲一下这类“连续子串的最大/小”问题的一种规律解法，申明两个指针从头开始，头指针指向子串的头部，尾指针指向子串的尾部，尾指针每一步都向后移动一尾，同时根据移动后尾指针访问的状况（以及结合之前的值）来判断如何移动头指针。在本题目中，约束条件是不包含重复字符，也就是说当尾指针访问到一个重复字符时，就要调整头指针移向下一个不会让子串出现重复字符的位置（也就是跳到下一个满足约束的子串），记录过程中子串的最大长度，最后返回最大长度，时间复杂度O(n)。 完整实现代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243#include &lt;iostream&gt;#include &lt;map&gt;#include &lt;cstring&gt;int longest_substr_no_dup(char* str) { if(str == nullptr || strlen(str) == 0) { return 0; } std::map&lt;char, bool&gt; char_map; // 初始化map for(int i = 0; i &lt; 26; i++) { char_map['a'+i] = false; } char* start = str; char* end = str; int len = 0; int max_len = 0; for(int i = 0; i &lt; strlen(str); i++) { if(!char_map[*end]) { // 没有遇到重复字符，子串长度+1 len++; max_len = (max_len &lt; len) ? len : max_len; char_map[*end] = true; end++; } else { // 直到start遇到该重复字符为止 while(*start != *end) { char_map[*start] = false; start++; len--; } start++; char_map[*end] = true; end++; } } return max_len;}int main() { char* str = &quot;arabcacfr&quot;; printf(&quot;%s longest substr no dup: %d&quot;, str, longest_substr_no_dup(str));} 代码中使用到了std::map&lt;char, bool&gt;来记录当前子串的字符出现情况，也可以自行建立一个bool数组实现记录。 然后再看一下书上的动态规划思路（其实和面试题42的动态规划解法也类似），定义f(i)表示以第i个字符结尾的不包含重复字符的子串的最长长度。如果是从左到右的计算顺序，当我们计算f(i)的时候f(i-1)已经被计算出了。 如果第i个字符没有出现过，那么f(i)=f(i-1)+1； 如果第i个字符之前已经出现过了，要先计算第i个字符和它上次出现在字符串中位置的距离，记为d，接着要分两种情况： 如果d &lt;= f(i-1)，此时第i个字符上次出现在f(i-1)对应的最长子字符串之中，因此f(i)=d； 如果d &gt; f(i-1)，此时第i个字符上次出现在f(i-1)对应的最长子字符串之前，因此仍然有f(i)=f(i-1)+1。 完整实现代码： 1234567891011121314151617181920212223242526272829int longest_substr_no_dup(char* str) { if(str == nullptr || strlen(str) == 0) { return 0; } int len = 0; int max_len = 0; int str_len = strlen(str); int* position = new int[26]; // 存储每个字符上次出现的下标 for(int i = 0; i &lt; 26; i++) { position[i] = -1; } for(int i = 0; i &lt; str_len; i++) { int prev_index = position[*(str+i) - 'a']; if(prev_index &lt; 0 || i - prev_index &gt; len) { len++; } else { if(len &gt; max_len) { max_len = len; } len = i - prev_index; } position[*(str+i) - 'a'] = i; } if(len &gt; max_len) { max_len = len; } delete position; return max_len;} 3 时间与空间的平衡由于内存的容量增加迅速，在软件开发的过程中我们允许以牺牲一定的空间为代价来优化时间性能，以尽可能地缩短软件的响应时间。这就是我们通常所说的“以空间换时间”。 在面试的时候，如果我们分配少量的辅助空间来保存计算的中间结果以提高时间效率，则通常是可以被接受的。 但“空间换时间”并不一定都是可行的，面试的时候要具体问题具体分析，也就是对时间和空间的平衡考量。 面试题 49-52 面试题49：丑数。 把只包含因子2、3和5的数称作丑数(Ugly Number）。求按从小到大的顺序的第1500个丑数。例如6、8都是丑数，但14不是。习惯上把1当作第1个丑数。 判断一个数是不是丑数的方法，就是依次除以因数2、3、5，每一个因数都是无法再除了再除下一个因数，如果三个因数都除尽了，剩下的为1，则为丑数，否则不是丑数，简单实现的判别函数： 123456789101112bool is_ugly(int number) { while(number % 2 == 0) { number /= 2; } while(number % 3 == 0) { number /= 3; } while(number % 5 == 0) { number /= 5; } return (number == 1) ? true : false;} 每个数依次的判别是不是丑数肯定是不够高效的。 优化思路：创建数组保存已找到的丑数，用空间换时间的解法。 根据丑数的定义，丑数应该是另一个丑数乘以2、3或者5的结果（1除外），因此，我们可以创建一个数组，里面数字是排好序的丑数，每个丑数都是前面的丑数乘以2、3或者5得到的。 这种思路的关键在于怎么确保数组里面的丑数排好序。假设数组已有若干个排好序的丑数，把最大的丑数记为M，分析如何生成下一个丑数。下一个丑数肯定是前面某一个丑数乘以2、3或者5得到的，并且我们仅仅需要第一个大于M的丑数，也不用去乘以前方的所有丑数，其中一定有一个丑数满足一个条件，他是从小到大的第一个乘以2会大于M的丑数，记为T_2，类似的有T_3、T_5，每一次我们只需要在T_2 * 2和T_3 * 3和T_5 * 5中找到较小的一个即可（并且要更新所有T）。 完整实现代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344#include &lt;iostream&gt;int min(int num1, int num2, int num3) { int min = (num1 &lt; num2) ? num1 : num2; min = (min &lt; num3) ? min : num3; return min;}int ugly_num_at_n(int n) { if(n &lt;= 0) { return 0; } int *ugly_nums = new int[n]; ugly_nums[0] = 1; int next_ugly_index = 1; int* pt2 = ugly_nums; int* pt3 = ugly_nums; int* pt5 = ugly_nums; while(next_ugly_index &lt; n) { int min_num = min(*pt2 * 2, *pt3 * 3, *pt5 * 5); ugly_nums[next_ugly_index] = min_num; while(*pt2 * 2 &lt;= min_num) { pt2++; } while(*pt3 * 3 &lt;= min_num) { pt3++; } while(*pt5 * 5 &lt;= min_num) { pt5++; } next_ugly_index++; } int ugly = ugly_nums[n - 1]; delete[] ugly_nums; return ugly;}int main() { printf(&quot;Ugly Num at %d is %d\\n&quot;, 1500, ugly_num_at_n(1500)); // 859963392 printf(&quot;Ugly Num at %d is %d\\n&quot;, 5, ugly_num_at_n(5)); // 5 printf(&quot;Ugly Num at %d is %d\\n&quot;, 1, ugly_num_at_n(1)); // 1} 面试题50：第一次只出现一次的字符。 题目一：字符串中第一个只出现一次的字符。 在字符串中找出第一个只出现一次的字符。如输入abaccdeff，则输出b。 直接的思路是每次都比较一个字符是否在其后面出现，这种思路的时间复杂度是O(n^2)，效率不够高，可以考虑用空间换时间。如果我们可以统计每个字符出现的次数，可能就会变得简单的多，一般也用哈希表来解决这种问题。 哈希表是一种比较复杂的数据结构，C++标准模板库中的map和unordered_map实现了哈希表的功能，可以直接用。由于本题的特殊性，我们其实只需要一个非常简单的哈希表就能满足要求，因此我们可以考虑实现一个简单的哈希表。字符(char)是一个长度为8(bit)的数据类型，因此总共有256种可能性。我们创建一个长度为256的数组，每个字母根据其ASCII码值作为数组的下标对应数组的一个数组，而数组中存储的是每个字符出现的次数。这样我们就创建了一个大小为256、以字符ASCII码为键值的哈希表。 第一次扫描时，更新一个字符的出现次数需要时间O(1)，总共O(n)；第二次扫描时，寻找第一个出现次数为1的字符，时间也是O(n)。同时我们需要一个辅助数组，大小是1KB，由于数组大小是一个常数，因此认为这种算法的空间复杂度是O(1)。 完整实现代码： 12345678910111213141516171819202122232425262728293031#include &lt;iostream&gt;char first_unique_char(char* str) { if(str == nullptr) { return '\\0'; } const int TABLE_SIZE = 256; unsigned int hash_table[TABLE_SIZE]; for(unsigned int i = 0; i &lt; TABLE_SIZE; i++) { hash_table[i] = 0; } char* pchar = str; while(*pchar != '\\0') { hash_table[*pchar]++; pchar++; } pchar = str; while(*pchar != '\\0') { if(hash_table[*pchar] == 1) { return *pchar; } pchar++; } return '\\0';}int main() { char* str = &quot;abaccdeff&quot;; printf(&quot;First unique char of %s is %c&quot;, str, first_unique_char(str)); return 0;} 题目二：字符流中第一个只出现一次的字符。 实现一个函数，用来找出字符流中第一个只出现一次的字符。例如，字符流只读出go时，第一个只出现一次的字符是g；当读出google时，第一个只出现一次的字符时l。 可以定义一个数据容器来保存字符在字符流中的位置。当一个字符第一次从字符流读出来时，把位置保存在数据容器中。当字符再次从字符流中读取时，这时把它在容器中保存的值更新为一个特殊值（如负数）。而在查找第一个只出现一次的字符时，只需要遍历容器，找到最小的位置即可。 完整实现代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#include &lt;iostream&gt;#include &lt;limits.h&gt;class CharStatistics { public: CharStatistics(): index(0) { for(int i = 0; i &lt; 256; i++) { occurrence[i] = -1; } } void insert(char ch) { if(occurrence[ch] == -1) { occurrence[ch] = index; } else if(occurrence[ch] &gt;= 0) { occurrence[ch] = -2; } index++; } char first_unique_char() { char ch = '\\0'; int min_index = INT_MAX; for(int i = 0; i &lt; 256; i++) { if(occurrence[i] &gt;= 0 &amp;&amp; occurrence[i] &lt; min_index) { ch = (char)i; min_index = occurrence[i]; } } return ch; } private: // occurrence[i] : A char with ASCII value i; // occurrence[i] = -1 : not found yet // occurrence[i] = -2 : have been found for mutlple times // occurrence[i] &gt;= 0 : have been found only once int occurrence[256]; int index;};int main() { CharStatistics char_statistics; char* stream = &quot;google&quot;; for(int i = 0; i &lt; 6; i++) { char_statistics.insert(stream[i]); printf(&quot;After insert %c, first unique char is %c\\n&quot;, stream[i], char_statistics.first_unique_char()); } return 0;} 面试题51：数组中的逆序对。 在数组中的两个数字，如果前面一个数字大于后面的数字，则这两个数字组成一个逆序对。输入一个数组，求出这个数组中的逆序对的总数。例如，数组{7,5,6,4}中，一共有5个逆序对，分别是(7,5)、(7,6)、(7,4)、(5,4)和(6,4)。 (a) P1指向的数字大于P2指向的数字（先比较最大的），表示数组中存在逆序对，把逆序对数目加2（后一个子数组的长度），并把7复制到辅助数组，向前移动P1和P3； (b) P1指向的数字小于P2指向的数字，没有逆序对。把P2指向的数字复制到辅助数组，并向前移动P2和P3； (c) P1指向的数字大于P2指向的数字，存在逆序对，把逆序对数目加1（后一个子数组的剩余长度），把5复制到辅助数组，想前移动P1和P3； (…) 直到只剩一个元素，复制到辅助数组，结束合并，开始下一次相邻数组的合并。 过程有点类似与归并排序，不过为了统计逆序对，从尾部开始合并。 完整实现代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#include &lt;iostream&gt;int inverse_pair_core(int* data, int* copy, int start, int end) { if(start == end) { copy[start] == data[start]; return 0; } int len = (end - start) / 2; // 注意这里交换了copy和data的位置，实现了交替使用 // 一次合并排序的结果保存在data中 int left = inverse_pair_core(copy, data, start, start + len); int right = inverse_pair_core(copy, data, start + len + 1, end); int i = start + len; int j = end; int index_copy = end; int count = 0; while(i &gt;= start &amp;&amp; j &gt;= start + len + 1) { if(data[i] &gt; data[j]) { // 前面的大于后面的 copy[index_copy--] = data[i--]; count += j - start - len; } else { // 前面的小于后面的 copy[index_copy--] = data[j--]; } } // 拷贝剩余的 while(i &gt;= start) { copy[index_copy--] = data[i--]; } while(j &gt;= start + len + 1) { copy[index_copy--] = data[j--]; } return left + right + count;}int inverse_pair(int* data, int len) { if(data == nullptr || len &lt;= 0) { return 0; } int* copy = new int[len]; for(int i = 0; i &lt; len; i++) { copy[i] = data[i]; } int count = inverse_pair_core(data, copy, 0, len - 1); delete[] copy; return count;}int main() { int data[] = {7,5,6,4}; printf(&quot;Data have %d inverse pair.\\n&quot;, inverse_pair(data, 4)); return 0;} 归并排序的时间复杂度是O(nlogn)，比直观方法的O(n^2)要快，但同时归并需要一个长度为n的辅助数组，所以用了O(n)的空间来换时间效率的提升。 面试题52：两个链表的第一个公共节点。 输入两个链表，找出他们的第一个公共节点。链表节点定义如下： 1234struct node { int key; node* pnext;} 其实有之前题目的铺垫，这里蛮容易想到根据两个链不同长度来调整起始指针的位置，调整起始后的两个指针，同步移动，当相遇时就是两个链表的公共节点，时间复杂度O(m+n)，m和n是两个链表的长度。 完整实现代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#include &lt;iostream&gt;struct node { int key; node* pnext;};node* init_node(int key) { ... }void init_list(node** pphead1, node** pphead2) { ... }int get_list_len(node* phead) { unsigned int len = 0; node* pnode = phead; while(pnode != nullptr) { len++; pnode = pnode-&gt;pnext; } return len;}node* find_first_common_node(node* phead1, node* phead2) { unsigned int len1 = get_list_len(phead1); unsigned int len2 = get_list_len(phead2); if(len1 == 0 || len2 == 0) { return nullptr; } int len_diff = len1 - len2; node* plong_list = phead1; node* pshort_list = phead2; if(len2 &gt; len1) { len_diff = len2 - len1; plong_list = phead2; pshort_list = phead1; } for(int i = 0; i &lt; len_diff; i++) { plong_list = plong_list-&gt;pnext; } while(plong_list != nullptr &amp;&amp; pshort_list != nullptr &amp;&amp; plong_list != pshort_list) { plong_list = plong_list-&gt;pnext; pshort_list = pshort_list-&gt;pnext; } return plong_list;}int main() { node* phead1; node* phead2; init_list(&amp;phead1, &amp;phead2); node* first_common_node = find_first_common_node(phead1, phead2); printf(&quot;First common node is %d\\n&quot;, first_common_node-&gt;key); return 0;} 书上还提到了一种方法，非常的巧妙，尤其是在这种需要在单向链表反向查找时，可以使用一个栈来实现逆向查询，例如在本题中，如果我们可以从两个链表的尾节点开始逆向查找，那么最后一个相同的节点，也就是第一个公共节点，可以使用两个栈来实现这个过程，时间开销O(m+n)，空间开销O(m+n)。 1234567891011121314151617181920212223node* find_first_common_node(node* phead1, node* phead2) { if(phead1 == nullptr || phead2 == nullptr) { return nullptr; } std::vector&lt;node*&gt; stk1, stk2; while(phead1 != nullptr) { stk1.push_back(phead1); phead1 = phead1-&gt;pnext; } while(phead2 != nullptr) { stk2.push_back(phead2); phead2 = phead2-&gt;pnext; } node* common_node = nullptr; while(!stk1.empty() &amp;&amp; !stk2.empty()) { if(stk1[stk1.size() - 1] == stk2[stk2.size() - 1]) { common_node = stk1[stk1.size() - 1]; } stk1.pop_back(); stk2.pop_back(); } return common_node;} 后一种方法虽然多了一个O(m+n)的空间开销，但是在一些单纯链表方法不能方便解决的时候，也不妨是一种构思的思路。 4 总结编程面试时，面试官通常对时间复杂度和空间复杂度都会有要求，并且一般情况下面试官更加关注时间复杂度。 降低时间复杂度的第一种方法是改用更加高效的算法；第二种方法是用空间换时间。 以空间换时间并不一定都是可行的方案，还要注意辅助空间的大小，消耗空间过大也是得不偿失的。","link":"/2021/01/11/s2o-c5-optimize/"},{"title":"《剑指Offer》第6章笔记 各项能力","text":"沟通和学习能力是面试中关键的考查点。 1 面试官谈能力大佬们说的名言名句。 咕咕待更。 2 沟通能力和学习能力 沟通能力 随着软件、系统功能越来越复杂，开发团队的规模也随之扩张，开发者、测试者和项目经理之间的沟通交流也变得越来越重要。也正因如此，很多公司在面试的时候都会注意考查应聘者的沟通能力。这邀请应聘者无论是在介绍项目经验还是在介绍解题思路的时候，都需要逻辑清晰明了，语言详略得当，表述的时候重点突出、观点明确。 学习能力 计算机是一门更新速度很快的学科，每年都有新的技术不断涌现。因此，作为从业人员需要具备很强的学习能力，否则时间一长就会跟不上技术进步的步伐，也正是因为这个原因，IT公司在面试的时候，都会重视考查应聘者的学习能力。只有具备很强的学习能力及学习愿望的人，才能不断完善自己的知识结构，不断学习新的先进技术，让自己的职业生涯保持长久的生命力。 通常面试官有两种方法考查应聘者的学习能力。第一种方法是询问应聘者最近在看什么书或者在做什么项目、从中学到了哪些新技术。面试官可以用这个问题了解应聘者的学习愿望和学习能力。第二种方法是抛出一个新概念，接下来观察应聘者能不能在短时间内理解这个新概念并解决相关的问题。当面试官提出新概念时，他期待应聘者能够通过思考、提问、再思考的过程，理解它们并最终解决问题。 善于学习、沟通的人也善于提问 面试官提出一个新概念，应聘者没有听说过它，于是他在已有的理解基础上提出进一步地问题，在得到面试官答复之后，思考再提问，几个来回之后掌握了这个概念。这个过程就能体现应聘者的学习能力。建议应聘者在面试过程中遇到不明白的地方多提问，这样可以表现自己态度积极、求知欲望强烈（但是一些行业领域基础的东西不知道还是蛮尴尬的hhh）。 有些面试官故意一开始不把题目描述清楚，让题目存在一定的二义性，他期待应聘者可以一步步通过提问来弄明白题目的要求，这也是在考查应聘者的沟通能力（因为实际工作中也是这样的）。 3 知识迁移能力所谓学习能力，很重要的一点就是根据已经掌握的知识、技术，能够迅速学习、理解新的技术并运用到实际工作中去。大部分新的技术都不是凭空产生的，而是在已有技术的基础上发展起来的。这就要求我们能够把对已有技术的理解迁移到学习新技术的过程中去，也就是要具备很强的知识迁移能力。 面试官考查应聘者知识迁移能力的一种方法是把经典的问题稍作变换。这时候面试官期待应聘者能够找到和经典问题的联系，并从中受到启发，把解决经典问题的思路迁移过来解决新的问题。另一种方法是先问一个简单地问题，在应聘者答完简单地问题后，再追问一个相关的同时难度也更大的问题。这时候面试官希望应聘者能够总结前面解决简单问题的经验，把前面的思路、方法迁移过来。 知识迁移能力的一种通俗的说法是“举一反三”的能力。面试题是刷不完的，不可能把所有的面试题都准备一遍，因此更重要的是每做一道面试题的时候，都要总结这道题的解法有什么特点，有哪些思路是可以应用到同类型的题目中去的。 面试题53-59 面试题53：在排序数组中查找数字。 题目一：数字在排序数组中出现的次数。 统计一个数字在排序数组中出现的次数，例如，输入排序数组{1,2,3,3,3,3,4,5}和3，由于3在这个数组中出现了4次，因此输出4。 最普通的遍历法时间复杂度O(n)，所以优化方法的时间复杂度肯定要优于O(n)。可以考虑用二分法方式寻找该数字的第一个位置和最后一个位置，然后就可以计算出出现次数了。在二分法时，首先找到有这个数的区间，当mid为寻找的目标数时，如果是寻找第一个位置，则看其左边是不是同样的数，如果是则在左侧继续寻找第一个位置，如果不是则mid就是第一个位置，寻找最后一个位置原理类似。 完整实现代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465#include &lt;iostream&gt;int find_head(int* data, int start, int end, int target) { if(start == end) { if(data[start] == target) { return start; } else { return -1; } } int mid = (start + end) / 2; if(data[mid] == target) { if(mid == 0 || data[mid-1] != target) { return mid; } else { return find_head(data, start, mid-1, target); } } else if(data[mid] &lt; target) { return find_head(data, mid+1, end, target); } else { return find_head(data, start, mid-1, target); }}int find_tail(int* data, int start, int end, int target) { if(start == end) { if(data[start] == target) { return start; } else { return -1; } } int mid = (start + end) / 2; if(data[mid] == target) { if(mid == end || data[mid+1] != target) { return mid; } else { return find_tail(data, mid+1, end, target); } } else if(data[mid] &lt; target) { return find_tail(data, mid+1, end, target); } else { return find_tail(data, start, mid-1, target); }}int counts_in_order(int* data, int len, int target) { if(data == nullptr || len &lt;= 0) { return 0; } int head = find_head(data, 0, len-1, target); int tail = find_tail(data, 0, len-1, target); if(head == -1 || tail == -1) { return 0; } else { return tail - head + 1; }}int main() { int data[] = {1,2,3,3,3,3,4,5}; printf(&quot;Count:%d\\n&quot;, counts_in_order(data, 8, 3)); return 0;} 代码中，find_head、find_tail都是二分查找算法在数组中查找数字，时间复杂度都是O(logn)，因此总的时间复杂度也是O(logn)。 题目二：0~n-1中缺失的数字。 一个长度n-1的递增排序数组中，所有数字都是唯一的，并且每个数字都在范围0~n-1中，在范围0~n-1内的n个数字中有且只有一个数字不在数组中，请找出这个数字。 最简单的方法是遍历数组求和，用0~n-1的总和n(n-1)/2相减就可以得到缺失的数字，但时间复杂度O(n)，可以观察n-1长度的数组，如果缺失了第i个数，由于排序的性质，对任意的i&lt;j第j个数会在j-1位置上，即不满足j在第j个位置上，所以问题转换为，找出第一个值和下标不相等的元素，利用二分法查找即可。 完整实现代码： 12345678910111213141516171819202122232425262728293031323334#include &lt;iostream&gt;int find_miss_num(int* data, int start, int end) { if(start == end) { if(data[start] != start) { return start; } else { return -1; } } int mid = (start + end) / 2; if(data[mid] != mid) { if(mid == start || data[mid-1] == mid-1) { return mid; } else { return find_miss_num(data, start, mid - 1); } } else { return find_miss_num(data, mid + 1, end); }}int find_miss_num(int* data, int len) { if(data == nullptr || len &lt;= 0) { return -1; } return find_miss_num(data, 0, len-1);}int main() { int data[] = {0, 2, 3, 4, 5, 6, 7, 8, 9}; printf(&quot;Miss is %d\\n&quot;, find_miss_num(data, 9)); return 0;} 题目三：数组中数值和下标相等的元素。 假设一个单调递增的数组里的每个元素都是整数并且唯一。请实现一个函数，找出数组中任意一个数值等于其下标的元素。例如，在数组{-3,-1,1,3,5}中，数字3和它的下标相等。 以{-3,-1,1,3,5}和{0,1,2,3,4}为例来分析，可以发现规律，3的左边都是value &lt; index，3的右边都是value &gt; index，根据这一点来判断二分查找的下一个位置。 完整实现代码： 1234567891011121314151617181920212223242526272829303132#include &lt;iostream&gt;int find_index_eq_value(int* data, int start, int end) { if(start == end) { if(data[start] == start) { return start; } else { return -1; } } int mid = (start + end) / 2; if(data[mid] == mid) { return mid; } else if(data[mid] &lt; mid) { return find_index_eq_value(data, mid + 1, end); } else { return find_index_eq_value(data, start, mid - 1); }}int find_index_eq_value(int* data, int len) { if(data == nullptr || len &lt;= 0) { return -1; } return find_index_eq_value(data, 0, len-1);}int main() { int data[] = {-3, -1, 1, 3, 5}; printf(&quot;Result: %d\\n&quot;, find_index_eq_value(data, 5)); return 0;} 面试题54：二叉搜索树的第K大节点。 给定一棵二叉搜索树，请找出其中第K大的节点。例如在下图中的二叉搜索树，按节点数值大小顺序，第3大节点的值是4。 书上的方法是直接简单的用二叉搜索树的性质，中序遍历即树中节点的递增排序，在中序遍历中找到第K大的节点。 完整实现代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243#include &lt;iostream&gt;struct node { int value; node* pleft; node* pright;};node* init_node(int value) { ... }node* init_tree() { ... }node* find_kth_in_tree_core(node* proot, unsigned int&amp; k) { node* target = nullptr; // 中序遍历 if(proot-&gt;pleft != nullptr) { target = find_kth_in_tree_core(proot-&gt;pleft, k); } if(target == nullptr) { // 没有在左子树中找到第k大 if(k == 1) { target = proot; } // 继续减少k k--; } if(target == nullptr &amp;&amp; proot-&gt;pright != nullptr) { target = find_kth_in_tree_core(proot-&gt;pright, k); } return target;}node* find_kth_in_tree(node* proot, unsigned int k) { if(proot == nullptr || k == 0) { return nullptr; } return find_kth_in_tree_core(proot, k);}int main() { node* proot = init_tree(); printf(&quot;%dth node is: %d&quot;, 3, find_kth_in_tree(proot, 3)-&gt;value); return 0;} 面试题55：二叉树的深度。 题目一：二叉树的深度。 输入一棵二叉树的根节点，求该树的深度。从根节点到叶节点一次经过的节点（含根、叶节点）形成树的一条路径，最长路径的长度为树的深度。 节点定义如下： 12345struct node { int value; node* pleft; node* pright;}; 思路比较简单，就是节点的深度等于左右子树的最大深度+1，递归地实现即可。 完整实现代码： 12345678910111213141516171819202122232425#include &lt;iostream&gt;struct node { int value; node* pleft; node* pright;};node* init_node(int value) { ... }node* init_tree() { ... }int tree_depth(node* proot) { if(proot == nullptr) { return 0; } int left_depth = tree_depth(proot-&gt;pleft); int right_depth = tree_depth(proot-&gt;pright); return (left_depth &gt; right_depth) ? (left_depth + 1) : (right_depth + 1);}int main() { node* proot = init_tree(); printf(&quot;Tree depth:%d\\n&quot;, tree_depth(proot)); return 0;} 题目二：平衡二叉树。 输入一棵二叉树的根节点，判断该树是不是平衡二叉树。如果某二叉树中任意节点的左、右子树的深度相差不超过1，那么它就是一棵平衡二叉树。例如，下图就是一颗平衡二叉树。 在题目一的基础上，在每个节点上一边判断是否平衡，同时一边返回他们的深度，如果是先检查深度，再去检查子树是否平衡，就会频繁多次的访问子节点，导致时间上的浪费。 完整实现代码： 123456789101112131415161718192021222324252627282930313233343536373839404142#include &lt;iostream&gt;struct node { int value; node* pleft; node* pright;};node* init_node(int value) { ... }node* init_tree() { ... }bool is_balanced(node* proot, int* pdepth) { if(proot == nullptr) { *pdepth = 0; return true; } int left, right; if(is_balanced(proot-&gt;pleft, &amp;left) &amp;&amp; is_balanced(proot-&gt;pright, &amp;right)) { int diff = left - right; if(diff &lt;= 1 &amp;&amp; diff &gt;= -1) { *pdepth = 1 + (left &gt; right ? left : right); return true; } } return false;}bool is_balanced(node* proot) { int depth = 0; return is_balanced(proot, &amp;depth);}int main() { node* proot = init_tree(); if(is_balanced(proot)) { printf(&quot;Is Balanced.\\n&quot;); } else { printf(&quot;Is Not Balanced.\\n&quot;); } return 0;} 面试题56：数组中数字出现的次数。 题目一：数组中只出现一次的两个数字。 一个整型数组里除两个数字之外，其他数字都出现了两次。请写程序找出这两个只出现一次的数字。要求时间复杂度是O(n)，空间复杂度是O(1)。 这个题常规思路很难解决，需要使用到两个相同的数的异或为0这种知识点，首先把问题分解为在一个整数数组中，除了一个数字之外，其他都出现两次的一个子问题，对于这个子问题的求解方式是对所有数进行异或操作，最后结果数就是出现一次的数字（其中使用到了异或操作的交换律以及结合律，这里不再证明）。 再回到原始问题，看看有没有相同的思路。还是从头到尾异或每个数字，结果是两个只出现一次的数字的异或结果，因为其他数字都出现两次，在异或中全部抵消了。由于这两个数字不一样，所以异或的结果肯定不为0，至少有一位是1（这代表这两个数，一个在该位上为1，一个在该位上为0），我们在结果数字中找到第一个为1的位的位置，记为第n位。现在我们以第n位是不是1位标准把原数组中的数字分为两个子数组，第一个子数组中每个数字的第n位都是1，第二个子数组中每个数字的第n位都是0，这样两个不同的数字就分到了两个数组中，并且相同的数字一定会被分到一个数组中，也就拆分成了两个可以解决的子问题了。 完整实现代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#include &lt;iostream&gt;// 找到从右边数起的第一个1位（方便一点）unsigned int find_first_1_bit(int num) { int index = 0; while((num &amp; 1) == 0 &amp;&amp; index &lt; 8 * sizeof(int)) { num = num &gt;&gt; 1; index++; } return index;}bool is_bit_1(int num, unsigned int index) { num = num &gt;&gt; index; // 直接右移 return (num &amp; 1);}bool g_invalid_input = false;void find_nums_appear_once(int data[], int len, int* num1, int* num2) { g_invalid_input = false; if(data == nullptr || len &lt; 2 || len % 2 != 0) { g_invalid_input = true; return; } int xor_result = 0; // 异或初始值0 for(int i = 0; i &lt; len; i++) { xor_result ^= data[i]; } unsigned int index_of_1 = find_first_1_bit(xor_result); // 这里直接用一次O(n)来遍历，并不是显式地分为两个部分 // 而是直接地根据位的情况来选择性异或，最后结果也一样 *num1 = *num2 = 0; for(int i = 0; i &lt; len; i++) { if(is_bit_1(data[i], index_of_1)) { *num1 ^= data[i]; } else { *num2 ^= data[i]; } }}int main() { int data[] = {1, 1, 2, 2, 3, 4, 4, 5, 5, 3}; int num1 = 0, num2 = 0; find_nums_appear_once(data, 10, &amp;num1, &amp;num2); if(g_invalid_input) { printf(&quot;Error: Invalid Input.\\n&quot;); } else { printf(&quot;Num1: %d, Num2: %d\\n&quot;, num1, num2); } return 0;} 题目二：数组中唯一只出现一次的数字。 在一个数组中除一个数字只出现一次之外，其他数字都出现了三次。请找出那个只出现一次的数字。 如果一个数字出现三次，那么它的二进制表示的每一位（0或者1）也出现3次，如果把所有出现三次的数字的二进制表示的每一位分别都加起来，那么每一位的和都能被3整除。这样我们把数组中所有数字的二进制表示的每一位都加起来。如果某一位的和能被3整除，那么那个只出现一次的数字的二进制表示中对应的那一位就是0，否则是1。 完整实现代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include &lt;iostream&gt;bool g_invalid_input = false;int find_num_appear_once(int data[], int len) { g_invalid_input = false; if(data == nullptr || len &lt;= 0 || len % 3 != 1) { g_invalid_input = true; return 0; } // 0 是最高位， 31 是最低位 // 注意int的最高位是符号位，这里连同符号位一起处理了 int bit_sum[32] = { 0 }; for(int i = 0; i &lt; len; i++) { int bit_mask = 1; for(int j = 31; j &gt;= 0; j--) { int bit = data[i] &amp; bit_mask; if(bit != 0) { bit_sum[j]++; } // 这里是基于bit_mask=1的左移 bit_mask = bit_mask &lt;&lt; 1; } } // 这里使用的还原法是基于位移操作的 // 要比使用2幂级更加高效，同时符号位处理也更加自然 int result = 0; for(int i = 0; i &lt; 32; ++i) { result = result &lt;&lt; 1; // 先左移，空出最低位 result += bit_sum[i] % 3; // 载入当前最低位 } return result;}int main() { int data[] = {1, 1, 1, -2, -2, -2, -100, 4, 4, 4, 5, 5, 5}; int result = find_num_appear_once(data, 13); if(g_invalid_input) { printf(&quot;Error: Invalid Input.\\n&quot;); } else { printf(&quot;Result: %d\\n&quot;, result); } return 0;} 这种方法同样只需要O(n)的时间以及O(1)的空间，相比于其他方法有更好的时间效率(例如用排序需要O(logn))，同时也不会有多余的空间开销(例如用哈希表，需要额外的O(n)空间)。 面试题57：和为s的数字。 题目一：和为s的两个数字。 输入一个递增排序的数组和一个数字s，在数组中查找两个数，使得它们的和正好是s。如果有多对数字的和等于s，则输出任意一对即可。 PS：在面试的时候，很重要的一点是应聘者要表现出很快的反应能力。只要想到一种方法，应聘者就可以马上告诉面试官（仅限于面谈形式的），即使这种方法不一定是最好的。 根据已排序数组的特性，当指定数组中的两个数字时： 如果两个数字的和小于s，需要一个更大的数字，这个时候可以在较小数字的右侧**或者是较大数字的右侧**去寻找； 如果两个数字的和大于s，需要一个更小的数字，这个时候可以在较小数字的左侧**或者是较大数字的左侧**去寻找； 如果两个数字的和等于s，则找到两个满足要求的数字。 仅仅分析到这里是还不够的，如果每个位置都要考虑两种情况，最后的复杂度会是O(2^n)，在这种去情况时，可以考虑固定一个方向寻找，并且要能够覆盖到所有情况，例如本题中，可以初始化一头一尾两个指针，如果和小于s，移动头指针向右，如果和大于s，移动头指针向左，这样可以遍历到所有情况。 PS：为什么说这样可以遍历到所有情况？对于每一个头指针指向的数字，你不能在当前尾指针的右侧找到一个更适合的数（都是大于s）；对于每一个尾指针指向的数字，你不能在当前头指针的左侧找到一个更适合的数（都是小于s），所以这样逐步缩小范围，同时也考虑到了所有情况。 完整实现代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243#include &lt;iostream&gt;int g_invalid_input = false;int find_nums_with_sum(int data[], int len, int sum, int* num1, int* num2) { g_invalid_input = false; bool found = false; if(data == nullptr || len &lt; 2 || !num1 || !num2) { g_invalid_input = true; return found; } int head = 0; int tail = len - 1; while(head &lt; tail) { // 使用了long long来存储 long long cur_sum = data[head] + data[tail]; if(cur_sum == sum) { *num1 = data[head]; *num2 = data[tail]; found = true; break; } else if(cur_sum &gt; sum) { tail--; } else { head++; } } return found;}int main() { int data[] = {1, 2, 4, 7, 11, 15}; int num1, num2; if(find_nums_with_sum(data, 6, 15, &amp;num1, &amp;num2)) { printf(&quot;Found! Num1: %d, Num2: %d\\n&quot;, num1, num2); } else if(g_invalid_input) { printf(&quot;Error: Invalid Input.\\n&quot;); } else { printf(&quot;Not Found!\\n&quot;); } return 0;} 题目二：和为s的连续正数序列。 输入一个正数s，打印出所有和为s的连续正数序列（至少含有两个数）。例如，输入15，由于1+2+3+4+5=4+5+6+7=7+8=15，所以打印出3个连续序列1~5、4~6、7~8。 和题目一思路类似。 完整实现代码： 12345678910111213141516171819202122232425262728#include &lt;iostream&gt;void find_seqs_with_sum(int sum) { if(sum &lt;= 0) { return; } int head = 1; int tail = 2; int cur_sum = head + tail; while(!(head == tail - 1 &amp;&amp; cur_sum &gt; sum)) { if(cur_sum == sum) { printf(&quot;%d~%d\\n&quot;, head, tail); cur_sum -= head; head++; } else if(cur_sum &gt; sum) { cur_sum -= head; head++; } else { tail++; cur_sum += tail; } }}int main() { find_seqs_with_sum(15); return 0;} 面试题58：翻转字符串。 题目一：翻转单词顺序。 输入一个英语句子，翻转句子中单词的顺序，但单词内字符的顺序不变。简单起见，标点符号和字幕一样处理。例如输入I am a student.，则输出student. a am I. 普通方法的思路也不是特别难，不过这里说一下书上的两次翻转字符串的解法： 第一步翻转句子中所有的字符； 第二步翻转每个单词中的字符的顺序，就得到了最终结果。 完整实现代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#include &lt;iostream&gt;void reverse(char* pstart, char* pend) { if(pstart == nullptr || pend == nullptr) { return; } while(pstart &lt; pend) { char temp = *pstart; *pstart = *pend; *pend = temp; pstart++; pend--; }}void str_reverse(char* str) { if(str == nullptr) { return; } char* pstart = str; char* pend = str; while(*pend != '\\0') { pend++; } pend--; reverse(pstart, pend); pstart = pend = str; while(*pstart != '\\0') { if(*pstart == ' ') { pstart++; pend++; } else if(*pend == ' ' || *pend == '\\0') { reverse(pstart, pend - 1); pstart = pend; } else { pend++; } }}int main() { char str[] = &quot; I am a student. &quot;; str_reverse(str); if(str != nullptr) { printf(&quot;%s&quot;, str); } return 0;} 题目二：左旋转字符串。 字符串的左旋转操作是把字符串前面的若干个字符转移到字符串的尾部。比如输入字符串abcdefg和数字2，函数返回左旋两位得到的结果cdefgab。 题目一中的翻转字符串，如果在本例中，可以类比于将ab cdefg翻转为cdefg ab，所以可以使用和题目一类似的思路。 完整实现代码： 123456789101112131415161718192021222324252627282930313233343536373839404142#include &lt;iostream&gt;#include &lt;cstring&gt;void reverse(char* pstart, char* pend) { if(pstart == nullptr || pend == nullptr) { return; } while(pstart &lt; pend) { char temp = *pstart; *pstart = *pend; *pend = temp; pstart++; pend--; }}void str_left_rotate(char* str, int n) { int len = strlen(str); if(str == nullptr || n &lt; 0 || n &gt;= len || len == 0) { return; } // 三次翻转即可 char* pstart; char* pend; pstart = str; pend = str + n - 1; reverse(pstart, pend); pstart = str + n; pend = str + len - 1; reverse(pstart, pend); pstart = str; pend = str + len - 1; reverse(pstart, pend);}int main() { char str[] = &quot;abcdefg&quot;; str_left_rotate(str, 2); if(str != nullptr) { printf(&quot;%s&quot;, str); }} 面试题59：队列的最大值。 题目一：滑动窗口的最大值。 给定一个数组和滑动窗口大小，请找出所有滑动窗口里的最大值。例如{2,3,4,2,6,2,5,1}以及滑动窗口大小3，那么一共存在6个滑动窗口，他们的最大值分别是{4,4,6,6,6,5}。 使用一个双端队列来保存当前窗口最大值以及可能的次最大值们；如果新入窗口的元素大于队列的头元素（最大值），则清空队列，头部入队新元素；如果新入窗口的元素小于队列的头元素，则出尾部所有小于该新元素的数字，并在尾部入队新元素；同时在队列中只需要保存元素的index，用来同时获取数字以及判断当前其是否在窗口内，如果不在窗口内就要进行出队。 完整实现代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445#include &lt;iostream&gt;#include &lt;deque&gt;#include &lt;vector&gt;using namespace std;vector&lt;int&gt; windows_max(const vector&lt;int&gt;&amp; num, unsigned int size) { vector&lt;int&gt; maxs; if(num.size() &lt; size &amp;&amp; size &gt;= 1) { return maxs; } deque&lt;int&gt; index; // 初始化第一个窗口的状态 for(unsigned int i = 0; i &lt; size; i++) { while(!index.empty() &amp;&amp; num[i] &gt;= num[index.back()]) { index.pop_back(); } index.push_back(i); } // 开始滑动窗口 for(unsigned int i = size; i &lt; num.size(); i++) { maxs.push_back(num[index.front()]); // 清除所有尾部小于新元素的 while(!index.empty() &amp;&amp; num[i] &gt;= num[index.back()]) { index.pop_back(); } // 清除所有头部已经不在窗口的 if(!index.empty() &amp;&amp; index.front() &lt;= (int)(i - size)) { index.pop_front(); } index.push_back(i); } maxs.push_back(num[index.front()]); return maxs;}int main() { vector&lt;int&gt; num({2,3,4,2,6,2,5,1}); vector&lt;int&gt; maxs = windows_max(num, 3); for(int i = 0; i &lt; maxs.size(); i++) { printf(&quot;%d &quot;, maxs[i]); } return 0;} 题目二：队列的最大值。 定义一个队列，并实现函数max得到队列里的最大值，要求函数max、push_back和pop_front的时间复杂度都是O(1)。 思路和题目一类似，使用一个双端队列实现max。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263#include &lt;iostream&gt;#include &lt;deque&gt;using namespace std;template&lt;typename T&gt; class QueueWithMAx { public: QueueWithMAx(): cur_index(0) {} void push_back(T num) { while(!maxs.empty() &amp;&amp; num &gt;= maxs.back().num) { maxs.pop_back(); } InternalData idata = { num, cur_index }; data.push_back(idata); maxs.push_back(idata); cur_index++; } void pop_front() { if(maxs.empty()) { printf(&quot;Error: queue is empty\\n&quot;); } if(maxs.front().index == data.front().index) { // 如果要出队最大元素，maxs也要出队 maxs.pop_front(); } data.pop_front(); } int front() { if(data.empty()) { printf(&quot;Error: queue is empty\\n&quot;); } return data.front().num; } T max() const { if(maxs.empty()) { printf(&quot;Error: queue is empty\\n&quot;); } return maxs.front().num; } private: struct InternalData { T num; int index; }; deque&lt;InternalData&gt; data; deque&lt;InternalData&gt; maxs; int cur_index;};int main() { int num[] = {2,3,4,2,6,2,5,1}; QueueWithMAx&lt;int&gt; queue; for(int i = 0; i &lt; 8; i++) { queue.push_back(num[i]); printf(&quot;After push %d, max is %d\\n&quot;, num[i], queue.max()); } for(int i = 0; i &lt; 7; i++) { int front = queue.front(); queue.pop_front(); printf(&quot;After pop %d, max is %d\\n&quot;, front, queue.max()); } return 0;} 4 抽象建模能力有些面试官喜欢从日常生活中抽取提炼出问题，考查应聘者是否能简历数学模型并解决问题。 建模的第一步是选择合理的数据结构来表述问题。我们在根据问题的特点，综合考虑性能、编程难度等因素之后，选择最合适的数据结构来表达问题，也就是建立模型。 建模的第二步是分析模型中的内在规律，并用编程语言表述这种规律。 面试题60-63 面试题60：n个骰子的点数。 把n个骰子扔在地上，所有骰子朝上一面的点数之和为s。输入n，打印出现s的所有可能的值出现的概率。 最简单的方法递归地遍历骰子的所有值情况，然后记录和s的出现次数，时间复杂度O(6^n)，当n很大时难以接受。 其实可以简化这个问题，例如设f(n,s)为n个骰子时和s的出现次数，则有f(n,s)=f(n-1,s-1)+f(n-1,s-2)+f(n-1,s-3)+f(n-1,s-4)+f(n-1,s-5)+f(n-1,s-6)，写出这样的递归式，我们就可以想到通过迭代来代替递归的方式计算结果，设初值f(1,k)=1, 1&lt;=k&lt;=6，每次迭代，向后计算即可，时间复杂度O(n^2)。 完整实现代码： 1234567891011121314151617181920212223242526272829303132333435363738#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;void print_probability(int n) { if(n &lt; 1) { return; } int size = 6 * n + 1; int* prob1 = new int[size]; int* prob2 = new int[size]; std::fill(prob1, prob1 + size, 0); std::fill(prob2, prob2 + size, 0); std::fill(prob1 + 1, prob1 + 7, 1); for(int i = 0; i &lt; n - 1; i++) { for(int j = 1; j &lt; size; j++) { prob2[j] = 0; // 别忘了数值重置 for(int k = 1; k &lt;= 6 &amp;&amp; j-k&gt;=0; k++) { prob2[j] += prob1[j-k]; } } // 交换数组 int* temp = prob1; prob1 = prob2; prob2 = temp; } double total = (double)std::pow(6, n); for(int i = n; i &lt; size; i++) { printf(&quot;%d: %d\\n&quot;, i, prob1[i]); } delete[] prob1; delete[] prob2;}int main() { print_probability(11); return 0;} 相比于书上的代码，这一版本更加简洁。 面试题61：扑克牌中的顺子。 从扑克牌中随机抽5张牌，判断是不是一个顺子，即这5张牌是不是连续的。2~10为数字，A为1、J为11、Q为12、K为13，而大、小王可以看成任意数字。 思路比较基础，就是先把手里的数组排序（大小王当作0），统计0的个数，统计排序相邻数字之间的空缺总数，如果综述小于等于0的个数，则数组连续，否则不连续。如果数组中非0数字重复出现，则该数字不是连续的。 完整实现代码： 1234567891011121314151617181920212223242526272829303132333435363738#include &lt;iostream&gt;#include &lt;algorithm&gt;bool is_straight(int* numbers, int len) { if(numbers == nullptr || len &lt; 1) { return false; } std::sort(numbers, numbers+len); int zeros = 0; int gaps = 0; for(int i = 0; i &lt; len; i++) { if(numbers[i] == 0) { zeros++; continue; } if(i &gt; 0 &amp;&amp; numbers[i] == numbers[i-1]) { return false; } if(i &gt; 0) { gaps += numbers[i] - numbers[i-1] - 1; } } if(gaps &lt;= zeros) { return true; } else { return false; }}int main() { int nums[] = {1, 2, 0, 4, 5}; if(is_straight(nums, sizeof(nums)/sizeof(int))) { printf(&quot;Is straight.&quot;); } else { printf(&quot;Is not straight.&quot;); } return 0;} 如果觉得代码中排序的部分O(nlogn)不够快，因为这里出现的数字只有0~13，所以还可以使用哈希表实现O(n)的排序。 面试题62：圆圈中最后剩下的数字。 0,1,...,n-1这n个数字排成一个圆圈，从数字0开始，每次从这个圆圈里删除第m个数字。求出这个圆圈里剩下的最后一个数字。 例如上图的圆圈，从数字0开始，每次删除第3个数字，则删除的前4个数字是2、0、4、1，最后剩下的数字是3。 本题就是有名的约瑟夫(Josephuse)环问题。一种方法是用环形链表模拟圆圈的经典解法，时间复杂度O(nm)，另一种方法是分析被删除数字的规律，直接计算出圆圈中最后剩下的数字，时间复杂度O(n)。 链表模拟法就不再赘述了，主要讲一下第二个的规律分析法。 定义一个关于n和m的函数f(n,m)，表示每次在n个数字0,1,...,n-1中删除第m个数字最后剩下的数字。 在这n个数字中，第一个被删除的是(m-1)%n，简单起见，记为k，删除k之后剩下的n-1个数字为0,1,...,k-1,k+1,...,n-1，并且在下一次删除从数字k+1开始计数。相当于在剩下的序列中，k+1排在最前面，从而形成k+1,...,n-1,0,1,...,k-1。这个序列最后剩下的数字应该也是关于n和m的函数。 由于第二个序列和前面最初的序列不一样，因此函数不同于前面的函数，记为f'(n-1,m)，所以有f(n,m)=f'(n-1,m)。 接下来我们把，剩下的这n-1个数字的序列k+1,...,n-1,0,1,...,k-1进行映射，结果形成一个0~n-2的序列。 把映射定义为p，则有p(x)=(x-k-1)%n，映射的逆映射是p'(x)=(x+k+1)%n。 由于映射之后的序列和最初的序列具有相同的形式，即都是从0开始的连续序列，因此仍然可以用函数f来表示，记为f(n-1,m)。根据我们之前的推导，映射之前的序列剩下的数字是f'(n-1,m)=p'(f(n-1,m))=(f(n-1,m)+k+1)%n，把k=(m-1)%n代入，可以得到f(n,m)=f'(n-1,m)=[f(n-1,m)+m]%n。 通过分析后，我们找到了一个递归公式，要得到这n个数的序列中最后剩下的数字，只需要得到n-1个数字的序列中最后剩下的数字，并以此类推。 当n=1时，序列中只有一个数字0，那么很显然最后剩下的数字就是0，这种递归可以写为： 公式无论是用递归还是循环，都很容易实现。 完整实现代码： 1234567891011121314151617#include &lt;iostream&gt;int last_remaining(unsigned int n, unsigned int m) { if(n &lt; 1 || m &lt; 1) { return -1; } int last = 0; for(int i = 2; i &lt;= n; i++) { last = (last + m) % i; } return last;}int main() { printf(&quot;%d&quot;, last_remaining(5, 3)); return 0;} 时间复杂度O(n)，空间复杂度O(1)。 面试题63：股票的最大利润。 假设把某股票的价格按照时间先后顺序存储在数组中，请问买卖该股票一次，可能获得的最大利润是多少？例如一支股票在某些时间节点的价格为{9,11,8,5,7,12,16,14}。如果我们能在价格5时买入，并在价格16时卖出，则收获最大利润11。 暴力遍历法时间复杂度O(n^2)，但是只要在从前向后计算的时候，保存前面序列中的最小值，就可以计算出当前值和前面序列的最小值的差值，最后获得最大差值就是最大利润。 完整实现代码： 12345678910111213141516171819202122232425#include &lt;iostream&gt;#include &lt;limits.h&gt;int max_profit(int* numbers, int len) { if(numbers == nullptr || len &lt; 2) { return 0; } int min = numbers[0]; int max_profits = INT_MIN; for(int i = 1; i &lt; len; i++) { if(numbers[i] - min &gt; max_profits) { max_profits = numbers[i] - min; } if(min &gt; numbers[i]) { min = numbers[i]; } } return max_profits;}int main() { int numbers[] = {9,11,8,5,7,12,16,14}; printf(&quot;max profit is %d&quot;, max_profit(numbers, sizeof(numbers)/sizeof(int))); return 0;} 只需要扫描数组一次，该算法的时间复杂度O(n)。 5 发散思维能力发散思维的特点是思维活动的多向性和变通性，也就是思考问题时，注重运动多思路、多方案、多途径来解决问题。对于同一个问题，我们可以从不同的方向、侧面和层次，采用探索、转移、迁移、组合和分解等方法，提出多种创新的解法。 面试题64-66 面试题64：求1+2+…+n。 求1+2+...+n，要求不能使用乘除法、for、while、if、else、switch、case等关键字及条件判断语句(A?B:C)。 循环和递归实现在本题中就没办法使用了，可以尝试从一些语言特性的方面来解决。 解法一：利用构造函数求解。 循环只是让相同的代码重复执行n次而已，完全可以不用for和while来达到这个效果。比如定义一个类型，接着创建n个该类型的实例，那么这个类型的构造函数将确定会被调用n次，可以将与累加相关的代码放到构造函数里。 完整实现代码： 12345678910111213141516171819202122232425262728293031323334353637383940#include &lt;iostream&gt;class Temp {public: Temp() { ++N; Sum+=N; } static void reset() { N = 0; Sum = 0; } static unsigned int get_sum() { return Sum; }private: static unsigned int N; static unsigned int Sum;};unsigned int Temp::N = 0;unsigned int Temp::Sum = 0;unsigned int sum_solution1(unsigned int n) { Temp::reset(); Temp* a = new Temp[n]; // 靠内部的循环来作弊，绝了 delete[] a; a = nullptr; return Temp::get_sum();}int main() { printf(&quot;%d&quot;, sum_solution1(10)); return 0;} 解法二：利用虚函数求解。 同样可以围绕递归来做，既然不能在一个函数中判断是不是应该终止递归，那么不妨定义两个函数，一个充当递归函数，另一个函数处理终止递归地情况，需要做的就是在两个函数里二选一，从二选一我们很自然地想到布尔变量，比如值为true时，调用第一个函数，值为false时，调用第二个函数。 完整实现代码： 123456789101112131415161718192021222324252627282930313233#include &lt;iostream&gt;class A;A* Array[2];class A {public: virtual unsigned int sum(unsigned int n) { return 0; }};class B: public A {public: virtual unsigned int sum(unsigned int n) { // 使用状态来选择函数，实现if else return Array[(bool)n]-&gt;sum(n-1)+n; }};int sum_solution2(int n) { A a; B b; Array[0] = &amp;a; Array[1] = &amp;b; int value = Array[1]-&gt;sum(n); return value;}int main() { printf(&quot;%d&quot;, sum_solution2(10)); return 0;} 使用虚函数来实现函数的选择，当n不为0时，调用函数B::sum，当n等于0时，调用函数A::sum。 解法三：利用函数指针求解。 纯C语言的变成环境中，我们不能使用虚函数，此时可以用函数指针来模拟，这样代码可能还更加直观一点。 完整实现代码： 1234567891011121314151617#include &lt;iostream&gt;typedef unsigned int (*fun)(unsigned int);unsigned int terminator(unsigned int n) { return 0;}unsigned int sum_solution3(unsigned int n) { static fun f[2] = {terminator, sum_solution3}; return n + f[(bool)n](n-1);}int main() { printf(&quot;%d&quot;, sum_solution3(10)); return 0;} 解法四：利用模板类求解。 还可以让编译器帮助完成类似于递归地计算。 完整能够代码实现： 1234567891011121314#include &lt;iostream&gt;template&lt;unsigned int n&gt; struct sum_solution4 { enum value { N = sum_solution4&lt;n-1&gt;::N + n };};template&lt;&gt; struct sum_solution4&lt;1&gt; { enum Value {N = 1};};int main() { printf(&quot;%d&quot;, sum_solution4&lt;10&gt;::N); return 0;} 当编译器看到sum_solution4&lt;10&gt;，就会为模板类sum_solution4以参数10生成该类型的代码，并且以10为参数的类型需要得到以9为参数的类型，这个过程会一直递归到参数为1的类型（已经显式定义，编译器无须生成）。 由于这个过程是在编译过程中完成的，因此要求输入的n必须是在编译期间就能确定的常量，不能动态输入。而且编译器对递归编译代码的递归深度是有限制的，要求n不能太大。 面试题65：不用加减乘除做加法。 写一个函数，求两个整数之和，要求在函数体内不得使用+、-、×、÷四则运算符号。 不能用四则运算的话，就只能考虑用位运算（与、或、非、异或）的方式来实现加法了。 例如5+17=22，5的二进制是101，17的二进制是10001，我们试着把计算分成三步： 第一步，各位相加，不计进位，得到的结果是10100（1+1溢出后就是0）； 第二步，记下进位，在这个例子中只在最后一位相加时产生一个进位，结果是二进制的10； 第三步，把前两步的结果相加，得到结果10110，转换成十进制就是22。 现在把二进制的加法用位运算来代替： 第一步，非进位加法，其实和异或运算相同，例如101^10001=10100； 第二步，只有1加1时，会向前产生一个进位1，此时我们可以想象成两个数先做位与运算，然后再向左移动一位，例如101&amp;10001 &lt;&lt; 1 = 10； 第三步，把前面两步结果相加，又变成一个新的问题，递归调用前两步，直到不会再产生进位为止。 完整实现代码： 123456789101112131415161718192021222324252627#include &lt;iostream&gt;bool same_sign(int num1, int num2) { return (num1 &gt;&gt; 31) == (num2 &gt;&gt; 31);}int bit_add(int num1, int num2) { int sum, carry; int tnum1 = num1, tnum2 = num2; do { sum = tnum1^tnum2; carry = (tnum1 &amp; tnum2) &lt;&lt; 1; tnum1 = sum; tnum2 = carry; } while(tnum2 != 0); if(same_sign(num1, num2) &amp;&amp; !same_sign(num1, sum)) { printf(&quot;Error: add overflow\\n&quot;); return 0; } else { return sum; }}int main() { printf(&quot;%d&quot;, bit_add(200, 20)); return 0;} 在书上的代码基础上，加入对溢出的异常判断，其中对于溢出判定方法是，只有当两个数同号时才会在加法中溢出，并且最后结果和原来的两个数异号时，就代表发生了溢出，此时应该抛出异常。 PS：不使用新的变量，交换两个变量的值（适用于数值类）。比如有a、b，我们希望交换它们的值。有两种不同的方法： 面试题66：构建乘积数组。 给定一个数组A[0,1,...,n-1]，请构建一个数组B[0,1,...,n-1]，其中B中的元素B[i]=A[0]*A[1]*...*A[i-1]*A[i+1]*...*A[n-1]。不能使用除法。 因为不能使用除法，所以只能另辟蹊径，如果用暴力求解法，时间复杂度是O(n)。 如果单独地求解A[0]*A[1]*...*A[i-1]，我们是可以迭代地在O(n)时间里求解出所有的前序乘积的，同理所有的A[i-1]*A[i+1]*...*A[n-1]，我们也可以逆序地迭代O(n)的时间中求解，最后对于每一个B[i]找到对应的前序序列和逆序序列就可以用乘法得到最后的结果了。 PS：不知道这道题要不要考虑什么乘积大数溢出的问题，根据面试的具体情况来分析吧，这种题再加上大数就稍微有点复杂了。 完整实现代码： 12345678910111213141516171819202122232425262728293031323334#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;void multi_array(const vector&lt;double&gt;&amp; array1, vector&lt;double&gt;&amp; array2) { int len1 = array1.size(); int len2 = array2.size(); if(len1 != len2 || len2 &lt;= 1) { return; } // 先计算正序序列值，暂存在array2中 double temp = 1; for(int i = 0; i &lt; len1; i++) { array2[i] = temp; temp *= array1[i]; } // 计算逆序序列值，乘出最后结果 temp = 1; for(int i = len2 - 1; i &gt;= 0; i--) { array2[i] *= temp; temp *= array1[i]; }}int main() { vector&lt;double&gt; array1({1, 2, 3, 4, 5}); vector&lt;double&gt; array2(5); multi_array(array1, array2); for(int i = 0; i &lt; array2.size(); i++) { printf(&quot;%e &quot;, array2[i]); } return 0;} 这种思路的时间复杂度是O(n)。 6 总结面试是我们展示自己综合素质的时候，除了扎实的编程能力，我们还需要表现自己的沟通能力和学习能力，以及知识迁移能力、抽象建模能力和发散思维能力等方面的综合实力。","link":"/2021/01/23/s2o-c6/"},{"title":"《LearnOpenGL》入门 笔记","text":"Hello OpenGL! 笔记摘录源地址：LearnOpenGL CN OpenGL创建窗口你好，窗口 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990#include &lt;iostream&gt;// GLAD must be include before GLFW// GL/GLES/EGL/GLX/WGL Loader-Generator based on the official specs.#include &lt;glad/glad.h&gt; // GLFW is an Open Source, multi-platform library for OpenGL, OpenGL ES and Vulkan application development.// It provides a simple, platform-independent API for creating windows, contexts and surfaces, reading input, handling events, etc.#include &lt;GLFW/glfw3.h&gt;void framebuffer_size_callback(GLFWwindow* window, int width, int height) { glViewport(0, 0, width, height);}// 望能够在GLFW中实现一些输入控制，可以通过使用GLFW的几个输入函数来完成// 使用GLFW的glfwGetKey函数，它需要一个窗口以及一个按键作为输入// 这个函数将会返回这个按键是否正在被按下void process_input(GLFWwindow *window) { // 检查用户是否按下了返回键(Esc)，如果没有按下，glfwGetKey将会返回GLFW_RELEASE if (glfwGetKey(window, GLFW_KEY_ESCAPE) == GLFW_PRESS) { glfwSetWindowShouldClose(window, true); }}int main() { glfwInit(); glfwWindowHint(GLFW_CONTEXT_VERSION_MAJOR, 3); glfwWindowHint(GLFW_CONTEXT_VERSION_MINOR, 3); glfwWindowHint(GLFW_OPENGL_PROFILE, GLFW_OPENGL_CORE_PROFILE); // glfwWindowHint(GLFW_OPENGL_FORWARD_COMPAT, GL_TRUE); // for max os x // glfwCreateWindow(width, height, title, ..., ...) GLFWwindow* window = glfwCreateWindow(800, 600, &quot;LearnOpenGL&quot;, NULL, NULL); if (window == nullptr) { std::cout &lt;&lt; &quot;Failed to create GLFW window&quot; &lt;&lt; std::endl; glfwTerminate(); return -1; } glfwMakeContextCurrent(window); // GLAD是用来管理OpenGL的函数指针的 // 所以在调用任何OpenGL的函数之前我们需要初始化GLAD // 给GLAD传入了用来加载系统相关的OpenGL函数指针地址的函数 // GLFW给我们的是glfwGetProcAddress // 它根据我们编译的系统定义了正确的函数 if (!gladLoadGLLoader((GLADloadproc)glfwGetProcAddress)) { std::cout &lt;&lt; &quot;Failed to initialize GLAD&quot; &lt;&lt; std::endl; return -1; } // 告诉OpenGL渲染窗口的尺寸大小, 视口 Viewport // 窗口左下角的位置，宽度，高度 glViewport(0, 0, 800, 600); // 当用户改变窗口的大小的时候，视口也应该被调整 // 可以对窗口注册一个回调函数(Callback Function) // 它会在每次窗口大小被调整的时候被调用 // void framebuffer_size_callback(GLFWwindow* window, int width, int height); // 需要注册这个函数，告诉GLFW我们希望每当窗口调整大小的时候调用这个函数 glfwSetFramebufferSizeCallback(window, framebuffer_size_callback); // Render Loop // glfwWindowShouldClose函数在我们每次循环的开始前检查一次GLFW是否被要求退出 // 如果是的话该函数返回true然后渲染循环便结束了，之后为我们就可以关闭应用程序了 while (!glfwWindowShouldClose(window)) { // 检测用户输入 process_input(window); // 渲染指令 // 使用一个自定义的颜色清空屏幕 // 调用了glClearColor来设置清空屏幕所用的颜色 glClearColor(0.2f, 0.3f, 0.3f, 1.0f); // 状态设置函数 // 调用glClear函数来清空屏幕的颜色缓冲，它接受一个缓冲位(Buffer Bit)来指定要清空的缓冲 // 可能的缓冲位有GL_COLOR_BUFFER_BIT，GL_DEPTH_BUFFER_BIT和GL_STENCIL_BUFFER_BIT glClear(GL_COLOR_BUFFER_BIT); // 状态使用函数 // glfwSwapBuffers函数会交换颜色缓冲 // 它是一个储存着GLFW窗口每一个像素颜色值的大缓冲 // 它在这一迭代中被用来绘制，并且将会作为输出显示在屏幕上。 glfwSwapBuffers(window); // glfwPollEvents函数检查有没有触发什么事件 // 比如键盘输入、鼠标移动、更新窗口状态等 // 并调用对应的回调函数（可以通过回调方法手动设置） glfwPollEvents(); } // 当渲染循环结束后我们需要正确释放/删除之前的分配的所有资源 // 在main函数的最后调用glfwTerminate函数来完成 glfwTerminate(); return 0;} 你好，三角形 顶点数组对象：Vertex Array Object，VAO 顶点缓冲对象：Vertex Buffer Object，VBO 索引缓冲对象：Element Buffer Object，EBO或Index Buffer Object，IBO 3D坐标转为2D坐标的处理过程是由OpenGL的图形渲染管线（Graphics Pipeline，大多译为管线，实际上指的是一堆原始图形数据途经一个输送管道，期间经过各种变化处理最终出现在屏幕的过程）管理的。 图形渲染管线可以被划分为两个主要部分： 第一部分把你的3D坐标转换为2D坐标； 第二部分是把2D坐标转变为实际的有颜色的像素。 2D坐标和像素也是不同的，2D坐标精确表示（通常是浮点数的形式）一个点在2D空间中的位置，而2D像素是这个点的近似值，2D像素受到你的屏幕/窗口分辨率的限制。 图形渲染管线可以被划分为几个阶段，每个阶段将会把前一个阶段的输出作为输入。所有这些阶段都是高度专门化的（它们都有一个特定的函数），并且很容易并行执行。正是由于它们具有并行执行的特性，当今大多数显卡都有成千上万的小处理核心，它们在GPU上为每一个（渲染管线）阶段运行各自的小程序，从而在图形渲染管线中快速处理你的数据。这些小程序叫做着色器(Shader)。 有些着色器允许开发者自己配置，这就允许我们用自己写的着色器来替换默认的。这样我们就可以更细致地控制图形渲染管线中的特定部分了，而且因为它们运行在GPU上，所以它们可以给我们节约宝贵的CPU时间。OpenGL着色器是用OpenGL着色器语言(OpenGL Shading Language, GLSL)写成的，在下一节中我们再花更多时间研究它。 首先，我们以数组的形式传递3个3D坐标作为图形渲染管线的输入，用来表示一个三角形，这个数组叫做顶点数据(Vertex Data)；顶点数据是一系列顶点的集合。一个顶点(Vertex)是一个3D坐标的数据的集合。而顶点数据是用顶点属性(Vertex Attribute)表示的，它可以包含任何我们想用的数据。 为了让OpenGL知道我们的坐标和颜色值构成的到底是什么，OpenGL需要你去指定这些数据所表示的渲染类型。是希望把这些数据渲染成一系列的点？一系列的三角形？还是仅仅是一个长长的线？做出的这些提示叫做图元(Primitive)，任何一个绘制指令的调用都将把图元传递给OpenGL。这是其中的几个：GL_POINTS、GL_TRIANGLES、GL_LINE_STRIP。 图形渲染管线的第一个部分是顶点着色器(Vertex Shader)，它把一个单独的顶点作为输入。顶点着色器主要的目的是把3D坐标转为另一种3D坐标（后面会解释），同时顶点着色器允许我们对顶点属性进行一些基本处理。 图元装配(Primitive Assembly)阶段将顶点着色器输出的所有顶点作为输入（如果是GL_POINTS，那么就是一个顶点），并所有的点装配成指定图元的形状。 图元装配阶段的输出会传递给几何着色器(Geometry Shader)。几何着色器把图元形式的一系列顶点的集合作为输入，它可以通过产生新顶点构造出新的（或是其它的）图元来生成其他形状。 几何着色器的输出会被传入光栅化阶段(Rasterization Stage)，这里它会把图元映射为最终屏幕上相应的像素，生成供片段着色器(Fragment Shader)使用的片段(Fragment)。在片段着色器运行之前会执行裁切(Clipping)。裁切会丢弃超出你的视图以外的所有像素，用来提升执行效率。 OpenGL中的一个片段(Fragment)是OpenGL渲染一个像素所需的所有数据。 片段着色器(Fragment Shader or Pixel Shader)的主要目的是计算一个像素的最终颜色，这也是所有OpenGL高级效果产生的地方。通常，片段着色器包含3D场景的数据（比如光照、阴影、光的颜色等等），这些数据可以被用来计算最终像素的颜色。 在所有对应颜色值确定以后，最终的对象将会被传到最后一个阶段，我们叫做Alpha测试和混合(Blending)阶段。这个阶段检测片段的对应的深度（和模板(Stencil)）值（后面会讲），用它们来判断这个像素是其它物体的前面还是后面，决定是否应该丢弃。这个阶段也会检查alpha值（alpha值定义了一个物体的透明度）并对物体进行混合(Blend)。所以，即使在片段着色器中计算出来了一个像素输出的颜色，在渲染多个三角形的时候最后的像素颜色也可能完全不同。 可以看到，图形渲染管线非常复杂，它包含很多可配置的部分。然而，对于大多数场合，我们只需要配置顶点和片段着色器就行了，几何着色器是可选的，通常使用它默认的着色器就行了。 在现代OpenGL中，我们必须定义至少一个顶点着色器和一个片段着色器（因为GPU中没有默认的顶点/片段着色器）。出于这个原因，刚开始学习现代OpenGL的时候可能会非常困难，因为在你能够渲染自己的第一个三角形之前已经需要了解一大堆知识了。 顶点输入开始绘制图形之前，我们必须先给OpenGL输入一些顶点数据。OpenGL是一个3D图形库，所以我们在OpenGL中指定的所有坐标都是3D坐标（x、y和z）。OpenGL仅当3D坐标在3个轴（x、y和z）上都为-1.0到1.0的范围内时才处理它。所有在所谓的标准化设备坐标(Normalized Device Coordinates)范围内的坐标才会最终呈现在屏幕上（在这个范围以外的坐标都不会显示）。 由于我们希望渲染一个三角形，我们一共要指定三个顶点，每个顶点都有一个3D位置。我们会将它们以标准化设备坐标的形式（OpenGL的可见区域）定义为一个float数组。 12345float vertices[] = { -0.5f, -0.5f, 0.0f, 0.5f, -0.5f, 0.0f, 0.0f, 0.5f, 0.0f}; 由于OpenGL是在3D空间中工作的，而我们渲染的是一个2D三角形，我们将它顶点的z坐标设置为0.0。这样子的话三角形每一点的深度(Depth)都是一样的，从而使它看上去像是2D的。 标准化设备坐标(Normalized Device Coordinates, NDC)：一旦你的顶点坐标已经在顶点着色器中处理过，它们就应该是标准化设备坐标了，标准化设备坐标是一个x、y和z值在-1.0到1.0的一小段空间。任何落在范围外的坐标都会被丢弃/裁剪，不会显示在你的屏幕上。下面你会看到我们定义的在标准化设备坐标中的三角形(忽略z轴)： 与通常的屏幕坐标不同，y轴正方向为向上，(0, 0)坐标是这个图像的中心，而不是左上角。最终你希望所有(变换过的)坐标都在这个坐标空间中，否则它们就不可见了。 你的标准化设备坐标接着会变换为屏幕空间坐标(Screen-space Coordinates)，这是使用你通过glViewport函数提供的数据，进行视口变换(Viewport Transform)完成的。所得的屏幕空间坐标又会被变换为片段输入到片段着色器中。 定义这样的顶点数据以后，我们会把它作为输入发送给图形渲染管线的第一个处理阶段：顶点着色器。它会在GPU上创建内存用于储存我们的顶点数据，还要配置OpenGL如何解释这些内存，并且指定其如何发送给显卡。顶点着色器接着会处理我们在内存中指定数量的顶点。 我们通过顶点缓冲对象(Vertex Buffer Objects, VBO)管理这个内存，它会在GPU内存（通常被称为显存）中储存大量顶点。使用这些缓冲对象的好处是我们可以一次性的发送一大批数据到显卡上，而不是每个顶点发送一次。从CPU把数据发送到显卡相对较慢，所以只要可能我们都要尝试尽量一次性发送尽可能多的数据。当数据发送至显卡的内存中后，顶点着色器几乎能立即访问顶点，这是个非常快的过程。 顶点缓冲对象是我们在OpenGL教程中第一个出现的OpenGL对象。就像OpenGL中的其它对象一样，这个缓冲有一个独一无二的ID，所以我们可以使用glGenBuffers函数和一个缓冲ID生成一个VBO对象： 12unsigned int VBO;glGenBuffers(1, &amp;VBO); OpenGL有很多缓冲对象类型，顶点缓冲对象的缓冲类型是GL_ARRAY_BUFFER。OpenGL允许我们同时绑定多个缓冲，只要它们是不同的缓冲类型。我们可以使用glBindBuffer函数把新创建的缓冲绑定到GL_ARRAY_BUFFER目标上： 1glBindBuffer(GL_ARRAY_BUFFER, VBO); 从这一刻起，我们使用的任何（在GL_ARRAY_BUFFER目标上的）缓冲调用都会用来配置当前绑定的缓冲(VBO)。然后我们可以调用glBufferData函数，它会把之前定义的顶点数据复制到缓冲的内存中： 1glBufferData(GL_ARRAY_BUFFER, sizeof(vertices), vertices, GL_STATIC_DRAW); glBufferData是一个专门用来把用户定义的数据复制到当前绑定缓冲的函数。 第一个参数是目标缓冲的类型：顶点缓冲对象当前绑定到GL_ARRAY_BUFFER目标上； 第二个参数指定传输数据的大小(以字节为单位)；用一个简单的sizeof计算出顶点数据大小就行； 第三个参数是我们希望发送的实际数据； 第四个参数指定了我们希望显卡如何管理给定的数据。它有三种形式： GL_STATIC_DRAW：数据不会或几乎不会改变； GL_DYNAMIC_DRAW：数据会被改变很多； GL_STREAM_DRAW：数据每次绘制时都会改变。 三角形的位置数据不会改变，每次渲染调用时都保持原样，所以它的使用类型最好是GL_STATIC_DRAW； 如果，比如说一个缓冲中的数据将频繁被改变，那么使用的类型就是GL_DYNAMIC_DRAW或GL_STREAM_DRAW，这样就能确保显卡把数据放在能够高速写入的内存部分。 现在我们已经把顶点数据储存在显卡的内存中，用VBO这个顶点缓冲对象管理。下面我们会创建一个顶点和片段着色器来真正处理这些数据。 顶点着色器 Vertex Shader我们需要做的第一件事是用着色器语言GLSL(OpenGL Shading Language)编写顶点着色器，然后编译这个着色器，这样我们就可以在程序中使用它了。下面你会看到一个非常基础的GLSL顶点着色器的源代码： 123456#version 330 corelayout (location = 0) in vec3 aPos;void main() { gl_Position = vec4(aPos.x, aPos.y, aPos.z, 1.0);} GLSL看起来很像C语言。每个着色器都起始于一个版本声明。OpenGL 3.3以及和更高版本中，GLSL版本号和OpenGL的版本是匹配的（比如说GLSL 420版本对应于OpenGL 4.2）。我们同样明确表示我们会使用核心模式。 下一步，使用in关键字，在顶点着色器中声明所有的输入顶点属性(Input Vertex Attribute)。现在我们只关心位置(Position)数据，所以我们只需要一个顶点属性。GLSL有一个向量数据类型，它包含1到4个float分量，包含的数量可以从它的后缀数字看出来。由于每个顶点都有一个3D坐标，我们就创建一个vec3输入变量aPos。我们同样也通过layout (location = 0)设定了输入变量的位置值(Location)你后面会看到为什么我们会需要这个位置值。 向量(Vector)：在GLSL中一个向量有最多4个分量，每个分量值都代表空间中的一个坐标，它们可以通过vec.x、vec.y、vec.z和vec.w来获取。注意vec.w分量不是用作表达空间中的位置的（我们处理的是3D不是4D），而是用在所谓透视除法(Perspective Division)上。 为了设置顶点着色器的输出，我们必须把位置数据赋值给预定义的gl_Position变量，它在幕后是vec4类型的。在main函数的最后，gl_Position设置的值会成为该顶点着色器的输出。 当前这个顶点着色器可能是我们能想到的最简单的顶点着色器了，因为我们对输入数据什么都没有处理就把它传到着色器的输出了。在真实的程序里输入数据通常都不是标准化设备坐标，所以我们首先必须先把它们转换至OpenGL的可视区域内。 编译着色器上面写的顶点着色器源码存储在一个C字符串中，为了能让OpenGL能使用它，我们必须在运行时动态编译它的源码。 我们首先要做的是创建一个着色器对象，注意还是用ID来引用的。所以我们储存这个顶点着色器为unsigned int，然后用glCreateShader创建这个着色器： 12unsigned int vertexShader;vertexShader = glCreateShader(GL_VERTEX_SHADER); 我们把需要创建的着色器类型以参数形式提供给glCreateShader。由于我们正在创建一个顶点着色器，传递的参数是GL_VERTEX_SHADER。 下一步我们把这个着色器源码附加到着色器对象上，然后编译它： 12glShaderSource(vertexShader, 1, &amp;vertexShaderSource, NULL);glCompileShader(vertexShader); glShaderSource函数： 把要编译的着色器对象作为第一个参数； 第二参数指定了传递的源码字符串数量，这里只有一个； 第三个参数是顶点着色器真正的源码； 第四个参数我们先设置为NULL。 检测编译时错误可以通过以下代码来实现： 123int success;char infoLog[512];glGetShaderiv(vertexShader, GL_COMPILE_STATUS, &amp;success); 首先我们定义一个整型变量来表示是否成功编译，还定义了一个储存错误消息（如果有的话）的容器。然后我们用glGetShaderiv检查是否编译成功。如果编译失败，我们会用glGetShaderInfoLog获取错误消息，然后打印它。 1234if(!success) { glGetShaderInfoLog(vertexShader, 512, NULL, infoLog); std::cout &lt;&lt; &quot;ERROR::SHADER::VERTEX::COMPILATION_FAILED\\n&quot; &lt;&lt; infoLog &lt;&lt; std::endl;} 如果编译的时候没有检测到任何错误，顶点着色器就被编译成功了。 片段着色器片段着色器(Fragment Shader)是第二个也是最后一个我们打算创建的，用于渲染三角形的着色器。段着色器所做的是计算像素最后的颜色输出。为了让事情更简单，我们的片段着色器将会一直输出橘黄色(1.0f, 0.5f, 0.2f)。 在计算机图形中颜色被表示为有4个元素的数组：红色(R)、绿色(G)、蓝色(B)和alpha(透明度)分量(A)，通常缩写为RGBA。当在OpenGL或GLSL中定义一个颜色的时候，我们把颜色每个分量的强度设置在0.0到1.0之间。比如说我们设置红为1.0f，绿为1.0f，我们会得到两个颜色的混合色，即黄色。这三种颜色分量的不同调配可以生成超过1600万种不同的颜色！ 123456#version 330 coreout vec4 FragColor;void main() { FragColor = vec4(1.0f, 0.5f, 0.2f, 1.0f);} 片段着色器只需要一个输出变量，这个变量是一个4分量向量，它表示的是最终的输出颜色，我们应该自己将其计算出来。我们可以用out关键字声明输出变量，这里我们命名为FragColor。下面，我们将一个alpha值为1.0(1.0代表完全不透明)的橘黄色的vec4赋值给颜色输出。 编译片段着色器的过程与顶点着色器类似，只不过我们使用GL_FRAGMENT_SHADER常量作为着色器类型： 1234unsigned int fragmentShader;fragmentShader = glCreateShader(GL_FRAGMENT_SHADER);glShaderSource(fragmentShader, 1, &amp;fragmentShaderSource, NULL);glCompileShader(fragmentShader); 两个着色器现在都编译了，剩下的事情是把两个着色器对象链接到一个用来渲染的着色器程序(Shader Program)中。 着色器程序着色器程序对象(Shader Program Object)是多个着色器合并之后并最终链接完成的版本。如果要使用刚才编译的着色器（顶点、片段），我们必须把它们链接(Link)为一个着色器程序对象，然后在渲染对象的时候激活这个着色器程序。已激活着色器程序的着色器将在我们发送渲染调用(draw call)的时候被使用。 当链接着色器至一个程序的时候，它会把每个着色器的输出链接到下个着色器的输入。当输出和输入不匹配的时候，你会得到一个连接错误。 创建一个程序对象： 12unsigned int shaderProgram;shaderProgram = glCreateProgram(); glCreateProgram函数创建一个程序，并返回新创建程序对象的ID引用。现在我们需要把之前编译的着色器附加(glAttachShader)到程序对象上，然后用glLinkProgram链接它们： 123glAttachShader(shaderProgram, vertexShader);glAttachShader(shaderProgram, fragmentShader);glLinkProgram(shaderProgram); 代码应该很清楚，我们把着色器附加到了程序上，然后用glLinkProgram链接。 就像着色器的编译一样，我们也可以检测链接着色器程序是否失败，并获取相应的日志。与上面不同，我们不会调用glGetShaderiv和glGetShaderInfoLog，现在我们使用： 1234567int success;char infoLog[512];glGetProgramiv(shaderProgram, GL_LINK_STATUS, &amp;success);if(!success) { glGetProgramInfoLog(shaderProgram, 512, NULL, infoLog); // ...} 得到的结果就是一个程序对象，我们可以调用glUseProgram函数，用刚创建的程序对象作为它的参数，以激活这个程序对象： 1glUseProgram(shaderProgram); 在glUseProgram函数调用之后，每个着色器调用和渲染调用都会使用这个程序对象（也就是之前写的着色器)了。 对了，在把着色器对象链接到程序对象以后，记得删除着色器对象，我们不再需要它们了： 12glDeleteShader(vertexShader);glDeleteShader(fragmentShader); 现在，我们已经把输入顶点数据发送给了GPU，并指示了GPU如何在顶点和片段着色器中处理它。就快要完成了，但还没结束，OpenGL还不知道它该如何解释内存中的顶点数据，以及它该如何将顶点数据链接到顶点着色器的属性上。我们需要告诉OpenGL怎么做。 链接顶点属性顶点着色器允许我们指定任何以顶点属性为形式的输入。这使其具有很强的灵活性的同时，它还的确意味着我们必须手动指定输入数据的哪一个部分对应顶点着色器的哪一个顶点属性。所以，我们必须在渲染前指定OpenGL该如何解释顶点数据。 顶点缓冲数据会被解析为下面这样子： 位置数据被储存为32位（4字节）浮点值； 每个位置包含3个这样的值； 这几个值在数组中紧密排列(Tightly Packed)； 数据中第一个值在缓冲开始的位置。 有了这些信息我们就可以使用glVertexAttribPointer函数告诉OpenGL该如何解析顶点数据（应用到逐个顶点属性上）了： 12glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 3 * sizeof(float), (void*)0);glEnableVertexAttribArray(0); glVertexAttribPointer函数的参数非常多，所以我会逐一介绍它们： 第一个参数指定我们要配置的顶点属性。还记得我们在顶点着色器中使用layout(location = 0)定义了position顶点属性的位置值(Location)吗？它可以把顶点属性的位置值设置为0。因为我们希望把数据传递到这一个顶点属性中，所以这里我们传入0； 第二个参数指定顶点属性的大小。顶点属性是一个vec3，它由3个值组成，所以大小是3； 第三个参数指定数据的类型，这里是GL_FLOAT(GLSL中vec*都是由浮点数值组成的)。 第四个参数定义我们是否希望数据被标准化(Normalize)。如果我们设置为GL_TRUE，所有数据都会被映射到0（对于有符号型signed数据是-1）到1之间。我们把它设置为GL_FALSE，所有数据不会被处理。 第五个参数叫做步长(Stride)，它告诉我们在连续的顶点属性组之间的间隔。由于下个组位置数据在3个float之后，我们把步长设置为3 * sizeof(float)。要注意的是由于我们知道这个数组是紧密排列的（在两个顶点属性之间没有空隙）我们也可以设置为0来让OpenGL决定具体步长是多少（只有当数值是紧密排列时才可用）。一旦我们有更多的顶点属性，我们就必须更小心地定义每个顶点属性之间的间隔，我们在后面会看到更多的例子（译注: 这个参数的意思简单说就是从这个属性第二次出现的地方到整个数组0位置之间有多少字节）； 最后一个参数的类型是void*，所以需要我们进行这个奇怪的强制类型转换。它表示位置数据在缓冲中起始位置的偏移量(Offset)。由于位置数据在数组的开头，所以这里是0。我们会在后面详细解释这个参数。 每个顶点属性从一个VBO管理的内存中获得它的数据，而具体是从哪个VBO（程序中可以有多个VBO）获取则是通过在调用glVertexAttribPointer时绑定到GL_ARRAY_BUFFER的VBO决定的。由于在调用glVertexAttribPointer之前绑定的是先前定义的VBO对象，顶点属性0现在会链接到它的顶点数据。 现在我们已经定义了OpenGL该如何解释顶点数据，我们现在应该使用glEnableVertexAttribArray，以顶点属性位置值作为参数，启用顶点属性；顶点属性默认是禁用的。 自此，所有东西都已经设置好了： 我们使用一个顶点缓冲对象将顶点数据初始化至缓冲中； 建立了一个顶点和一个片段着色器； 告诉了OpenGL如何把顶点数据链接到顶点着色器的顶点属性上。 在OpenGL中绘制一个物体，代码会像是这样： 12345678910111213// 0. 复制顶点数组到缓冲中供OpenGL使用glBindBuffer(GL_ARRAY_BUFFER, VBO);glBufferData(GL_ARRAY_BUFFER, sizeof(vertices), vertices, GL_STATIC_DRAW);// 1. 设置顶点属性指针glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 3 * sizeof(float), (void*)0);glEnableVertexAttribArray(0);// 2. 当我们渲染一个物体时要使用着色器程序，已经编译链接好glUseProgram(shaderProgram);// 3. 绘制物体drawCall(); 每当我们绘制一个物体的时候都必须重复这一过程。这看起来可能不多，但是如果有超过5个顶点属性，上百个不同物体呢（这其实并不罕见）。绑定正确的缓冲对象，为每个物体配置所有顶点属性很快就变成一件麻烦事。 有没有一些方法可以使我们把所有这些状态配置储存在一个对象中，并且可以通过绑定这个对象来恢复状态呢？ 顶点数组对象顶点数组对象(Vertex Array Object, VAO)可以像顶点缓冲对象那样被绑定，任何随后的顶点属性调用都会储存在这个VAO中。这样的好处就是，当配置顶点属性指针时，你只需要将那些调用执行一次，之后再绘制物体的时候只需要绑定相应的VAO就行了。这使在不同顶点数据和属性配置之间切换变得非常简单，只需要绑定不同的VAO就行了。 OpenGL的核心模式要求我们使用VAO，所以它知道该如何处理我们的顶点输入。如果我们绑定VAO失败，OpenGL会拒绝绘制任何东西。 一个顶点数组对象会储存以下这些内容： glEnableVertexAttribArray和glDisableVertexAttribArray的调用； 通过glVertexAttribPointer设置的顶点属性配置； 通过glVertexAttribPointer调用与顶点属性关联的顶点缓冲对象。 创建一个VAO和创建一个VBO很类似： 12unsigned int VAO;glGenVertexArrays(1, &amp;VAO); 要想使用VAO，要做的只是使用glBindVertexArray绑定VAO。从绑定之后起，我们应该绑定和配置对应的VBO和属性指针，之后解绑VAO供之后使用。当我们打算绘制一个物体的时候，我们只要在绘制物体前简单地把VAO绑定到希望使用的设定上就行了： 12345678910111213141516171819// ..:: 初始化代码（只运行一次 (除非你的物体频繁改变)） :: ..// 1. 绑定VAOglBindVertexArray(VAO);// 2. 把顶点数组复制到缓冲中供OpenGL使用glBindBuffer(GL_ARRAY_BUFFER, VBO);glBufferData(GL_ARRAY_BUFFER, sizeof(vertices), vertices, GL_STATIC_DRAW);// 3. 设置顶点属性指针glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 3 * sizeof(float), (void*)0);glEnableVertexAttribArray(0);// ...// ..:: 绘制代码（渲染循环中） :: ..// 4. 绘制物体glUseProgram(shaderProgram);glBindVertexArray(VAO);drawCall(); 就这么多了！前面做的一切都是等待这一刻，一个储存了我们顶点属性配置和应使用的VBO的顶点数组对象。一般当你打算绘制多个物体时，你首先要生成/配置所有的VAO（和必须的VBO及属性指针)**，然后储存它们供后面使用。当我们打算绘制物体的时候就拿出相应的VAO，绑定它，绘制完物体后，再解绑VAO**。 一直期待的三角形要想绘制我们想要的物体，OpenGL给我们提供了glDrawArrays函数，它使用当前激活的着色器，之前定义的顶点属性配置，和VBO的顶点数据（通过VAO间接绑定）来绘制图元。 123glUseProgram(shaderProgram);glBindVertexArray(VAO);glDrawArrays(GL_TRIANGLES, 0, 3); glDrawArrays函数： 第一个参数是我们打算绘制的OpenGL图元的类型。由于我们在一开始时说过，我们希望绘制的是一个三角形，这里传递GL_TRIANGLES给它； 第二个参数指定了顶点数组的起始索引，我们这里填0； 最后一个参数指定我们打算绘制多少个顶点，这里是3（我们只从我们的数据中渲染一个三角形，它只有3个顶点长）。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173// ... 其他代码没有修改const char* vertexShaderSource = &quot;#version 330 core\\n&quot; &quot;layout (location = 0) in vec3 aPos;\\n&quot; &quot;void main() {\\n&quot; &quot; gl_Position = vec4(aPos.x, aPos.y, aPos.z, 1.0);\\n&quot; &quot;}\\0&quot;;const char* fragmentShaderSource = &quot;#version 330 core\\n&quot; &quot;out vec4 FragColor;\\n&quot; &quot;void main() {\\n&quot; &quot; FragColor = vec4(1.0f, 0.5f, 0.2f, 1.0f);\\n&quot; &quot;}\\n\\0&quot;;unsigned int get_shader_program() { // 创建顶点着色器 VertexShader unsigned int vertexShader = glCreateShader(GL_VERTEX_SHADER); // 把着色器源码附加到着色器对象上 glShaderSource(vertexShader, 1, &amp;vertexShaderSource, NULL); // 编译着色器 glCompileShader(vertexShader); // 检测编译错误 int success; char infoLog[512]; glGetShaderiv(vertexShader, GL_COMPILE_STATUS, &amp;success); if (!success) { glGetShaderInfoLog(vertexShader, 512, NULL, infoLog); std::cout &lt;&lt; &quot;ERROR::SHADER::VERTEX::COMPILATION_FAILED\\n&quot; &lt;&lt; infoLog &lt;&lt; std::endl; } // 创建片段着色器 FragmentShader unsigned int fragmentShader = glCreateShader(GL_FRAGMENT_SHADER); // 着色器源码附加到着色器对象上 glShaderSource(fragmentShader, 1, &amp;fragmentShaderSource, NULL); // 编译着色器 glCompileShader(fragmentShader); // 检测编译错误 glGetShaderiv(fragmentShader, GL_COMPILE_STATUS, &amp;success); if (!success) { glGetShaderInfoLog(fragmentShader, 512, NULL, infoLog); std::cout &lt;&lt; &quot;ERROR::SHADER::FRAGMENT::COMPILATION_FAILED\\n&quot; &lt;&lt; infoLog &lt;&lt; std::endl; } // 创建程序对象 unsigned int shaderProgram = glCreateProgram(); // 着色器附加到程序对象上 glAttachShader(shaderProgram, vertexShader); glAttachShader(shaderProgram, fragmentShader); // 链接 glLinkProgram(shaderProgram); // 检测链接错误 glGetProgramiv(shaderProgram, GL_LINK_STATUS, &amp;success); if (!success) { glGetProgramInfoLog(shaderProgram, 512, NULL, infoLog); std::cout &lt;&lt; &quot;ERROR::SHADER::PROGRAM::LINKING_FAILED\\n&quot; &lt;&lt; infoLog &lt;&lt; std::endl; } // 删除创建的着色器（已经不再需要了） glDeleteShader(vertexShader); glDeleteShader(fragmentShader); return shaderProgram;}void get_vbo_and_vao(unsigned int &amp;VBO, unsigned int &amp;VAO) { float vertices[] = { -0.5f, -0.5f, 0.0f, // left 0.5f, -0.5f, 0.0f, // right 0.0f, 0.5f, 0.0f // top }; // 创建顶点属性对象 glGenVertexArrays(1, &amp;VAO); // 创建顶点缓冲对象 glGenBuffers(1, &amp;VBO); // 先绑定VAO，再绑定VBO，然后再配置顶点属性 glBindVertexArray(VAO); // 绑定VBO到GL_ARRAY_BUFFER glBindBuffer(GL_ARRAY_BUFFER, VBO); // 顶点数据复制到缓冲的内存中 glBufferData(GL_ARRAY_BUFFER, sizeof(vertices), vertices, GL_STATIC_DRAW); // 告诉OpenGL如何解析顶点数据 glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 3 * sizeof(float), (void*)0); // 以顶点属性值作为参数，启动顶点属性 glEnableVertexAttribArray(0); // 先解绑VAO glBindVertexArray(0); // 解绑VBO glBindBuffer(GL_ARRAY_BUFFER, 0);}int main() { glfwInit(); glfwWindowHint(GLFW_CONTEXT_VERSION_MAJOR, 3); glfwWindowHint(GLFW_CONTEXT_VERSION_MINOR, 3); glfwWindowHint(GLFW_OPENGL_PROFILE, GLFW_OPENGL_CORE_PROFILE); // glfwWindowHint(GLFW_OPENGL_FORWARD_COMPAT, GL_TRUE); // for max os x // glfwCreateWindow(width, height, title, ..., ...) GLFWwindow* window = glfwCreateWindow(800, 600, &quot;LearnOpenGL&quot;, NULL, NULL); if (window == nullptr) { std::cout &lt;&lt; &quot;Failed to create GLFW window&quot; &lt;&lt; std::endl; glfwTerminate(); return -1; } glfwMakeContextCurrent(window); // GLAD是用来管理OpenGL的函数指针的 // 所以在调用任何OpenGL的函数之前我们需要初始化GLAD // 给GLAD传入了用来加载系统相关的OpenGL函数指针地址的函数 // GLFW给我们的是glfwGetProcAddress // 它根据我们编译的系统定义了正确的函数 if (!gladLoadGLLoader((GLADloadproc)glfwGetProcAddress)) { std::cout &lt;&lt; &quot;Failed to initialize GLAD&quot; &lt;&lt; std::endl; return -1; } // 告诉OpenGL渲染窗口的尺寸大小, 视口 Viewport // 窗口左下角的位置，宽度，高度 glViewport(0, 0, 800, 600); // 当用户改变窗口的大小的时候，视口也应该被调整 // 可以对窗口注册一个回调函数(Callback Function) // 它会在每次窗口大小被调整的时候被调用 // void framebuffer_size_callback(GLFWwindow* window, int width, int height); // 需要注册这个函数，告诉GLFW我们希望每当窗口调整大小的时候调用这个函数 glfwSetFramebufferSizeCallback(window, framebuffer_size_callback); // 准备ShaderProgram和VBO、VAO unsigned int shaderProgram = get_shader_program(); unsigned int VBO, VAO; get_vbo_and_vao(VBO, VAO); // Render Loop // glfwWindowShouldClose函数在我们每次循环的开始前检查一次GLFW是否被要求退出 // 如果是的话该函数返回true然后渲染循环便结束了，之后为我们就可以关闭应用程序了 while (!glfwWindowShouldClose(window)) { // 检测用户输入 process_input(window); // 渲染指令 // 使用一个自定义的颜色清空屏幕 // 调用了glClearColor来设置清空屏幕所用的颜色 glClearColor(0.2f, 0.3f, 0.3f, 1.0f); // 状态设置函数 // 调用glClear函数来清空屏幕的颜色缓冲，它接受一个缓冲位(Buffer Bit)来指定要清空的缓冲 // 可能的缓冲位有GL_COLOR_BUFFER_BIT，GL_DEPTH_BUFFER_BIT和GL_STENCIL_BUFFER_BIT glClear(GL_COLOR_BUFFER_BIT); // 状态使用函数 // 激活程序对象 glUseProgram(shaderProgram); // 绑定VAO glBindVertexArray(VAO); // 绘制 glDrawArrays(GL_TRIANGLES, 0, 3); // 解绑VAO glBindVertexArray(0); // glfwSwapBuffers函数会交换颜色缓冲 // 它是一个储存着GLFW窗口每一个像素颜色值的大缓冲 // 它在这一迭代中被用来绘制，并且将会作为输出显示在屏幕上。 glfwSwapBuffers(window); // glfwPollEvents函数检查有没有触发什么事件 // 比如键盘输入、鼠标移动、更新窗口状态等 // 并调用对应的回调函数（可以通过回调方法手动设置） glfwPollEvents(); } // 可选，程序结束前释放申请的资源 glDeleteVertexArrays(1, &amp;VAO); glDeleteBuffers(1, &amp;VBO); glDeleteProgram(shaderProgram); // 当渲染循环结束后我们需要正确释放/删除之前的分配的所有资源 // 在main函数的最后调用glfwTerminate函数来完成 glfwTerminate(); return 0;} 索引缓冲对象在渲染顶点这一话题上我们还有最后一个需要讨论的东西——索引缓冲对象(Element Buffer Object，EBO，也叫Index Buffer Object，IBO)。要解释索引缓冲对象的工作方式最好还是举个例子：假设我们不再绘制一个三角形而是绘制一个矩形。我们可以绘制两个三角形来组成一个矩形（OpenGL主要处理三角形）。 12345678910float vertices[] = { // 第一个三角形 0.5f, 0.5f, 0.0f, // 右上角 0.5f, -0.5f, 0.0f, // 右下角 -0.5f, 0.5f, 0.0f, // 左上角 // 第二个三角形 0.5f, -0.5f, 0.0f, // 右下角 -0.5f, -0.5f, 0.0f, // 左下角 -0.5f, 0.5f, 0.0f // 左上角}; 可以看到，有几个顶点叠加了。我们指定了右下角和左上角两次！一个矩形只有4个而不是6个顶点，这样就产生50%的额外开销。当我们有包括上千个三角形的模型之后这个问题会更糟糕，这会产生一大堆浪费。更好的解决方案是只储存不同的顶点，并设定绘制这些顶点的顺序。这样子我们只要储存4个顶点就能绘制矩形了，之后只要指定绘制的顺序就行了。如果OpenGL提供这个功能就好了，对吧？ 很幸运，索引缓冲对象的工作方式正是这样的。和顶点缓冲对象一样，EBO也是一个缓冲，它专门储存索引，OpenGL调用这些顶点的索引来决定该绘制哪个顶点。所谓的索引绘制(Indexed Drawing)正是我们问题的解决方案。 首先，我们先要定义（不重复的）顶点，和绘制出矩形所需的索引： 123456789101112// 顶点float vertices[] = { 0.5f, 0.5f, 0.0f, // 右上角 0.5f, -0.5f, 0.0f, // 右下角 -0.5f, -0.5f, 0.0f, // 左下角 -0.5f, 0.5f, 0.0f // 左上角};// 索引unsigned int indices[] = { // 注意索引从0开始! 0, 1, 3, // 第一个三角形 1, 2, 3 // 第二个三角形}; 下一步我们需要创建索引缓冲对象： 12unsigned int EBO;glGenBuffers(1, &amp;EBO); 与VBO类似，我们先绑定EBO然后用glBufferData把索引复制到缓冲里。同样，和VBO类似，我们会把这些函数调用放在绑定和解绑函数调用之间，只不过这次我们把缓冲的类型定义为GL_ELEMENT_ARRAY_BUFFER。 12glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, EBO);glBufferData(GL_ELEMENT_ARRAY_BUFFER, sizeof(indices), indices, GL_STATIC_DRAW); 要注意的是，我们传递了GL_ELEMENT_ARRAY_BUFFER当作缓冲目标。最后一件要做的事是用glDrawElements来替换glDrawArrays函数，来指明我们从索引缓冲渲染。使用glDrawElements时，我们会使用当前绑定的索引缓冲对象中的索引进行绘制： 12glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, EBO);glDrawElements(GL_TRIANGLES, 6, GL_UNSIGNED_INT, 0); glDrawElements的参数说明： 第一个参数指定了我们绘制的模式，这个和glDrawArrays的一样； 第二个参数是我们打算绘制顶点的个数，这里填6，也就是说我们一共需要绘制6个顶点； 第三个参数是索引的类型，这里是GL_UNSIGNED_INT； 最后一个参数里我们可以指定EBO中的偏移量（或者传递一个索引数组，但是这是当你不在使用索引缓冲对象的时候），但是我们会在这里填写0。 glDrawElements函数从当前绑定到GL_ELEMENT_ARRAY_BUFFER目标的EBO中获取索引。这意味着我们必须在每次要用索引渲染一个物体时绑定相应的EBO，这还是有点麻烦。不过顶点数组对象VAO同样可以保存索引缓冲对象的绑定状态。VAO绑定时正在绑定的索引缓冲对象会被保存为VAO的元素缓冲对象。绑定VAO的同时也会自动绑定EBO。 1234567891011121314151617181920212223// ..:: 初始化代码 :: ..// 1. 绑定顶点数组对象glBindVertexArray(VAO);// 2. 把我们的顶点数组复制到一个顶点缓冲中，供OpenGL使用glBindBuffer(GL_ARRAY_BUFFER, VBO);glBufferData(GL_ARRAY_BUFFER, sizeof(vertices), vertices, GL_STATIC_DRAW);// 3. 复制我们的索引数组到一个索引缓冲中，供OpenGL使用glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, EBO);glBufferData(GL_ELEMENT_ARRAY_BUFFER, sizeof(indices), indices, GL_STATIC_DRAW);// 4. 设定顶点属性指针glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 3 * sizeof(float), (void*)0);glEnableVertexAttribArray(0);// [...]// ..:: 绘制代码（渲染循环中） :: ..glUseProgram(shaderProgram);glBindVertexArray(VAO);glDrawElements(GL_TRIANGLES, 6, GL_UNSIGNED_INT, 0);glBindVertexArray(0); 当目标是GL_ELEMENT_ARRAY_BUFFER的时候，VAO会储存glBindBuffer的函数调用。这也意味着它也会储存解绑调用，所以确保你没有在解绑VAO之前解绑索引数组缓冲，否则它就没有这个EBO配置了。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102// ... 其他代码都没有修改void get_vbo_ebo_and_vao(unsigned int &amp;VBO, unsigned int &amp;EBO, unsigned int &amp;VAO) { // 顶点 float vertices[] = { 0.5f, 0.5f, 0.0f, // 右上角 0.5f, -0.5f, 0.0f, // 右下角 -0.5f, -0.5f, 0.0f, // 左下角 -0.5f, 0.5f, 0.0f // 左上角 }; // 索引 unsigned int indices[] = { // 注意索引从0开始! 0, 1, 3, // 第一个三角形 1, 2, 3 // 第二个三角形 }; // 创建顶点属性对象 glGenVertexArrays(1, &amp;VAO); // 创建顶点缓冲对象和索引缓冲对象 glGenBuffers(1, &amp;VBO); glGenBuffers(1, &amp;EBO); // 先绑定VAO，再绑定VBO，然后再配置顶点属性 glBindVertexArray(VAO); // 绑定VBO到GL_ARRAY_BUFFER glBindBuffer(GL_ARRAY_BUFFER, VBO); // 顶点数据复制到缓冲的内存中 glBufferData(GL_ARRAY_BUFFER, sizeof(vertices), vertices, GL_STATIC_DRAW); // 绑定EBO到GL_ELEMENT_ARRAY_BUFFER glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, EBO); // 索引数据复制到缓冲的内存中 glBufferData(GL_ELEMENT_ARRAY_BUFFER, sizeof(indices), indices, GL_STATIC_DRAW); // 告诉OpenGL如何解析顶点数据 glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 3 * sizeof(float), (void*)0); // 以顶点属性值作为参数，启动顶点属性 glEnableVertexAttribArray(0); // 先解绑VAO glBindVertexArray(0); // 解绑VBO和EBO glBindBuffer(GL_ARRAY_BUFFER, 0); glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, 0);}int main() { // ... 其他代码都没有修改，不再赘述 // 准备ShaderProgram和VBO、VAO unsigned int shaderProgram = get_shader_program(); unsigned int VBO, EBO, VAO; get_vbo_ebo_and_vao(VBO, EBO, VAO); // glPolygonMode(GL_FRONT_AND_BACK, GL_LINE); // Render Loop // glfwWindowShouldClose函数在我们每次循环的开始前检查一次GLFW是否被要求退出 // 如果是的话该函数返回true然后渲染循环便结束了，之后为我们就可以关闭应用程序了 while (!glfwWindowShouldClose(window)) { // 检测用户输入 process_input(window); // 渲染指令 // 使用一个自定义的颜色清空屏幕 // 调用了glClearColor来设置清空屏幕所用的颜色 glClearColor(0.2f, 0.3f, 0.3f, 1.0f); // 状态设置函数 // 调用glClear函数来清空屏幕的颜色缓冲，它接受一个缓冲位(Buffer Bit)来指定要清空的缓冲 // 可能的缓冲位有GL_COLOR_BUFFER_BIT，GL_DEPTH_BUFFER_BIT和GL_STENCIL_BUFFER_BIT glClear(GL_COLOR_BUFFER_BIT); // 状态使用函数 // 激活程序对象 glUseProgram(shaderProgram); // 绑定VAO glBindVertexArray(VAO); // 绘制 glDrawElements(GL_TRIANGLES, 6, GL_UNSIGNED_INT, 0); // 解绑VAO glBindVertexArray(0); // glfwSwapBuffers函数会交换颜色缓冲 // 它是一个储存着GLFW窗口每一个像素颜色值的大缓冲 // 它在这一迭代中被用来绘制，并且将会作为输出显示在屏幕上。 glfwSwapBuffers(window); // glfwPollEvents函数检查有没有触发什么事件 // 比如键盘输入、鼠标移动、更新窗口状态等 // 并调用对应的回调函数（可以通过回调方法手动设置） glfwPollEvents(); } // glPolygonMode(GL_FRONT_AND_BACK, GL_FILL); // 可选，程序结束前释放申请的资源 glDeleteVertexArrays(1, &amp;VAO); glDeleteBuffers(1, &amp;VBO); glDeleteBuffers(1, &amp;EBO); glDeleteProgram(shaderProgram); // 当渲染循环结束后我们需要正确释放/删除之前的分配的所有资源 // 在main函数的最后调用glfwTerminate函数来完成 glfwTerminate(); return 0;} 线框模式(Wireframe Mode)：要想用线框模式绘制你的三角形，你可以通过glPolygonMode(GL_FRONT_AND_BACK, GL_LINE)函数配置OpenGL如何绘制图元。第一个参数表示我们打算将其应用到所有的三角形的正面和背面，第二个参数告诉我们用线来绘制。之后的绘制调用会一直以线框模式绘制三角形，直到我们用glPolygonMode(GL_FRONT_AND_BACK, GL_FILL)将其设置回默认模式。 练习题 添加更多顶点到数据中，使用glDrawArrays，尝试绘制两个彼此相连的三角形； 创建相同的两个三角形，但对它们的数据使用不同的VAO和VBO； 创建两个着色器程序，第二个程序使用一个不同的片段着色器，输出黄色；再次绘制这两个三角形，让其中一个输出为黄色。 （咕咕，之后再做） 着色器从基本意义上来说，着色器只是一种把输入转化为输出的程序。着色器也是一种非常独立的程序，因为它们之间不能相互通信；它们之间唯一的沟通只有通过输入和输出。 现在我们会用一种更加广泛的形式详细解释着色器，特别是OpenGL着色器语言(GLSL)。 GLSL着色器是使用一种叫GLSL的类C语言写成的。GLSL是为图形计算量身定制的，它包含一些针对向量和矩阵操作的有用特性。 着色器的开头总是要声明版本，接着是输入和输出变量、uniform和main函数。每个着色器的入口点都是main函数，在这个函数中我们处理所有的输入变量，并将结果输出到输出变量中。如果你不知道什么是uniform也不用担心，我们后面会进行讲解。 一个典型的着色器有下面的结构： 123456789101112131415#version version_numberin type in_variable_name;in type in_variable_name;out type out_variable_name;uniform type uniform_name;int main(){ // 处理输入并进行一些图形操作 ... // 输出处理过的结果到输出变量 out_variable_name = weird_stuff_we_processed;} 当我们特别谈论到顶点着色器的时候，每个输入变量也叫顶点属性(Vertex Attribute)。我们能声明的顶点属性是有上限的，它一般由硬件来决定。OpenGL确保至少有16个包含4分量的顶点属性可用，但是有些硬件或许允许更多的顶点属性，你可以查询GL_MAX_VERTEX_ATTRIBS来获取具体的上限： 123int nrAttributes;glGetIntegerv(GL_MAX_VERTEX_ATTRIBS, &amp;nrAttributes);std::cout &lt;&lt; &quot;Maximum nr of vertex attributes supported: &quot; &lt;&lt; nrAttributes &lt;&lt; std::endl; 通常情况下它至少会返回16个，大部分情况下是够用了。 数据类型和其他编程语言一样，GLSL有数据类型可以来指定变量的种类。GLSL中包含C等其它语言大部分的默认基础数据类型：int、float、double、uint和bool。GLSL也有两种容器类型，它们会在这个教程中使用很多，分别是向量(Vector)和矩阵(Matrix)，其中矩阵我们会在之后的教程里再讨论。 向量(Vector)：GLSL中的向量是一个可以包含有1、2、3或者4个分量的容器，分量的类型可以是前面默认基础类型的任意一个。它们可以是下面的形式（n代表分量的数量）： vecn：包含n个float分量的默认向量； bvecn：包含n个bool分量的向量； ivecn：包含n个int分量的向量； uvecn：包含n个unsigned int分量的向量； dvecn：包含n个double分量的向量。 大多数时候我们使用vecn，因为float足够满足大多数要求了。 一个向量的分量可以通过vec.x这种方式获取，这里x是指这个向量的第一个分量。你可以分别使用.x、.y、.z和.w来获取它们的第1、2、3、4个分量。GLSL也允许你对颜色使用rgba，或是对纹理坐标使用stpq访问相同的分量。 向量这一数据类型也允许一些有趣而灵活的分量选择方式，叫做重组(Swizzling)。重组允许这样的语法： 1234vec2 someVec;vec4 differentVec = someVec.xyxx;vec3 anotherVec = differentVec.zyw;vec4 otherVec = someVec.xxxx + anotherVec.yxzy; 你可以使用上面4个字母任意组合来创建一个和原来向量一样长的（同类型）新向量，只要原来向量有那些分量即可；然而，你不允许在一个vec2向量中去获取.z元素。我们也可以把一个向量作为一个参数传给不同的向量构造函数，以减少需求参数的数量： 123vec2 vect = vec2(0.5, 0.7);vec4 result = vec4(vect, 0.0, 0.0);vec4 otherResult = vec4(result.xyz, 1.0); 向量是一种灵活的数据类型，我们可以把用在各种输入和输出上。 输入与输出我们希望每个着色器都有输入和输出，这样才能进行数据交流和传递。GLSL定义了in和out关键字专门来实现这个目的。每个着色器使用这两个关键字设定输入和输出，只要一个输出变量与下一个着色器阶段的输入匹配，它就会传递下去。但在顶点和片段着色器中会有点不同。 顶点着色器应该接收的是一种特殊形式的输入，否则就会效率低下。顶点着色器的输入特殊在，它从顶点数据中直接接收输入。为了定义顶点数据该如何管理，我们使用location这一元数据指定输入变量，这样我们才可以在CPU上配置顶点属性。我们已经在前面的教程看过这个了，layout (location = 0)。顶点着色器需要为它的输入提供一个额外的layout标识，这样我们才能把它链接到顶点数据。 你也可以忽略layout (location = 0)标识符，通过在OpenGL代码中使用glGetAttribLocation查询属性位置值(Location)，但是我更喜欢在着色器中设置它们，这样会更容易理解而且节省你（和OpenGL）的工作量。 另一个例外是片段着色器，它需要一个vec4颜色输出变量，因为片段着色器需要生成一个最终输出的颜色。如果你在片段着色器没有定义输出颜色，OpenGL会把你的物体渲染为黑色（或白色）。 所以，如果我们打算从一个着色器向另一个着色器发送数据，我们必须在发送方着色器中声明一个输出，在接收方着色器中声明一个类似的输入。当类型和名字都一样的时候，OpenGL就会把两个变量链接到一起，它们之间就能发送数据了（这是在链接程序对象时完成的）。 为了展示这是如何工作的，我们会稍微改动一下之前教程里的那个着色器，让顶点着色器为片段着色器决定颜色。 顶点着色器： 123456789#version 330 corelayout (location = 0) in vec3 aPos; // 位置变量的属性位置值为0out vec4 vertexColor; // 为片段着色器指定一个颜色输出void main() { gl_Position = vec4(aPos, 1.0); // 把一个vec3作为vec4的构造器的参数 vertexColor = vec4(0.5, 0.0, 0.0, 1.0); // 把输出变量设置为暗红色} 片段着色器： 12345678#version 330 coreout vec4 FragColor;in vec4 vertexColor; // 从顶点着色器传来的输入变量（名称相同、类型相同）void main() { FragColor = vertexColor;} 你可以看到我们在顶点着色器中声明了一个vertexColor变量作为vec4输出，并在片段着色器中声明了一个类似的vertexColor。由于它们名字相同且类型相同，片段着色器中的vertexColor就和顶点着色器中的vertexColor链接了。由于我们在顶点着色器中将颜色设置为深红色，最终的片段也是深红色的。 让我们更上一层楼，看看能否从应用程序中直接给片段着色器发送一个颜色！ UniformUniform是一种从CPU中的应用向GPU中的着色器发送数据的方式，但uniform和顶点属性有些不同。首先，uniform是全局的(Global)。全局意味着uniform变量必须在每个着色器程序对象中都是独一无二的(只有一个，而不是每个着色器都有单独一个的意思)，而且它可以被着色器程序的任意着色器在任意阶段访问。第二，无论你把uniform值设置成什么，uniform会一直保存它们的数据，直到它们被重置或更新。 我们可以在一个着色器中添加uniform关键字至类型和变量名前来声明一个GLSL的uniform。从此处开始我们就可以在着色器中使用新声明的uniform了。我们来看看这次是否能通过uniform设置三角形的颜色： 12345678#version 330 coreout vec4 FragColor;uniform vec4 ourColor; // 在OpenGL程序代码中设定这个变量void main() { FragColor = ourColor;} 我们在片段着色器中声明了一个uniform vec4的ourColor，并把片段着色器的输出颜色设置为uniform值的内容。因为uniform是全局变量，我们可以在任何着色器中定义它们，而无需通过顶点着色器作为中介。顶点着色器中不需要这个uniform，所以我们不用在那里定义它。 如果你声明了一个uniform却在GLSL代码中没用过，编译器会静默移除这个变量，导致最后编译出的版本中并不会包含它，这可能导致几个非常麻烦的错误，记住这点！ 这个uniform现在还是空的；我们还没有给它添加任何数据，所以下面我们就做这件事。我们首先需要找到着色器中uniform属性的索引/位置值。当我们得到uniform的索引/位置值后，我们就可以更新它的值了。这次我们不去给像素传递单独一个颜色，而是让它随着时间改变颜色： 12345float timeValue = glfwGetTime();float greenValue = (sin(timeValue) / 2.0f) + 0.5f;int vertexColorLocation = glGetUniformLocation(shaderProgram, &quot;ourColor&quot;);glUseProgram(shaderProgram);glUniform4f(vertexColorLocation, 0.0f, greenValue, 0.0f, 1.0f); 首先我们通过glfwGetTime()获取运行的秒数。然后我们使用sin函数让颜色在0.0到1.0之间改变，最后将结果储存到greenValue里。 接着，我们用glGetUniformLocation查询uniform ourColor的位置值。我们为查询函数提供着色器程序和uniform的名字（这是我们希望获得的位置值的来源）。如果glGetUniformLocation返回-1就代表没有找到这个位置值。最后，我们可以通过glUniform4f函数设置uniform值。注意，查询uniform地址不要求你之前使用过着色器程序，但是更新一个uniform之前你必须先使用程序（调用glUseProgram)，因为它是在当前激活的着色器程序中设置uniform的。 因为OpenGL在其核心是一个C库，所以它不支持类型重载，在函数参数不同的时候就要为其定义新的函数；glUniform是一个典型例子。这个函数有一个特定的后缀，标识设定的uniform的类型。可能的后缀有： f：函数需要一个float作为它的值； i：函数需要一个int作为它的值； ui：函数需要一个unsigned int作为它的值； 3f：函数需要3个float作为它的值； fv：函数需要一个float向量/数组作为它的值。 每当你打算配置一个OpenGL的选项时就可以简单地根据这些规则选择适合你的数据类型的重载函数。在我们的例子里，我们希望分别设定uniform的4个float值，所以我们通过glUniform4f传递我们的数据(注意，我们也可以使用fv版本，一维向量)。 现在你知道如何设置uniform变量的值了，我们可以使用它们来渲染了。如果我们打算让颜色慢慢变化，我们就要在游戏循环的每一次迭代中（所以他会逐帧改变）更新这个uniform，否则三角形就不会改变颜色。 uniform对于设置一个在渲染迭代中会改变的属性是一个非常有用的工具，它也是一个在程序和着色器间数据交互的很好工具，但假如我们打算为每个顶点设置一个颜色的时候该怎么办？这种情况下，我们就不得不声明和顶点数目一样多的uniform了。在这一问题上更好的解决方案是在顶点属性中包含更多的数据，这是我们接下来要做的事情。 更多属性在前面的教程中，我们了解了如何填充VBO、配置顶点属性指针以及如何把它们都储存到一个VAO里。这次，我们同样打算把颜色数据加进顶点数据中。我们将把颜色数据添加为3个float值至vertices数组。我们将把三角形的三个角分别指定为红色、绿色和蓝色： 123456float vertices[] = { // 位置 // 颜色 0.5f, -0.5f, 0.0f, 1.0f, 0.0f, 0.0f, // 右下 -0.5f, -0.5f, 0.0f, 0.0f, 1.0f, 0.0f, // 左下 0.0f, 0.5f, 0.0f, 0.0f, 0.0f, 1.0f // 顶部}; 由于现在有更多的数据要发送到顶点着色器，我们有必要去调整一下顶点着色器，使它能够接收颜色值作为一个顶点属性输入。需要注意的是我们用layout标识符来把aColor属性的位置值设置为1： 12345678910#version 330 corelayout (location = 0) in vec3 aPos; // 位置变量的属性位置值为 0layout (location = 1) in vec3 aColor; // 颜色变量的属性位置值为 1out vec3 ourColor; // 向片段着色器输出一个颜色void main() { gl_Position = vec4(aPos, 1.0); ourColor = aColor; // 将ourColor设置为我们从顶点数据那里得到的输入颜色} 由于我们不再使用uniform来传递片段的颜色了，现在使用ourColor输出变量，我们必须再修改一下片段着色器： 1234567#version 330 coreout vec4 FragColor; in vec3 ourColor;void main() { FragColor = vec4(ourColor, 1.0);} 因为我们添加了另一个顶点属性，并且更新了VBO的内存，我们就必须重新配置顶点属性指针。更新后的VBO内存中的数据现在看起来像这样： 知道了现在使用的布局，我们就可以使用glVertexAttribPointer函数更新顶点格式， 123456// 位置属性glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 6 * sizeof(float), (void*)0);glEnableVertexAttribArray(0);// 颜色属性glVertexAttribPointer(1, 3, GL_FLOAT, GL_FALSE, 6 * sizeof(float), (void*)(3* sizeof(float)));glEnableVertexAttribArray(1); glVertexAttribPointer函数的前几个参数比较明了。这次我们配置属性位置值为1的顶点属性。颜色值有3个float那么大，我们不去标准化这些值。 由于我们现在有了两个顶点属性，我们不得不重新计算步长值。为获得数据队列中下一个属性值（比如位置向量的下个x分量）我们必须向右移动6个float，其中3个是位置值，另外3个是颜色值。这使我们的步长值为6乘以float的字节数**（=24字节）。 同样，这次我们必须指定一个偏移量。对于每个顶点来说，位置顶点属性在前，所以它的偏移量是0。颜色属性紧随位置数据之后，所以偏移量就是3 * sizeof(float)，用字节来计算就是12字节。 这个图片可能不是你所期望的那种，因为我们只提供了3个颜色，而不是我们现在看到的大调色板。这是在片段着色器中进行的所谓片段插值(Fragment Interpolation)的结果。当渲染一个三角形时，光栅化(Rasterization)阶段通常会造成比原指定顶点更多的片段。光栅会根据每个片段在三角形形状上所处相对位置决定这些片段的位置（属性？）。 我们自己的着色器类编写、编译、管理着色器是件麻烦事。在着色器主题的最后，我们会写一个类来让我们的生活轻松一点，它可以从硬盘读取着色器，然后编译并链接它们，并对它们进行错误检测，这就变得很好用了。这也会让你了解该如何封装目前所学的知识到一个抽象对象中。 我们会把着色器类全部放在在头文件里，主要是为了学习用途，当然也方便移植。我们先来添加必要的include，并定义类结构： 12345678910111213141516171819202122232425262728#ifndef SHADER_H // 避免重复include#define SHADER_H#include &lt;glad/glad.h&gt;; // 包含glad来获取所有的必须OpenGL头文件#include &lt;string&gt;#include &lt;fstream&gt;#include &lt;sstream&gt;#include &lt;iostream&gt;class Shader { public: // 程序ID unsigned int ID; // 构造器读取并构建着色器 Shader(const GLchar* vertexPath, const GLchar* fragmentPath); // 使用/激活程序 void use(); // uniform工具函数 void setBool(const std::string &amp;name, bool value) const; void setInt(const std::string &amp;name, int value) const; void setFloat(const std::string &amp;name, float value) const;};#endif 在上面，我们在头文件顶部使用了几个预处理指令(Preprocessor Directives)。这些预处理指令(#ifndef SHADER_H)会告知你的编译器只在它没被包含过的情况下才包含和编译这个头文件，即使多个文件都包含了这个着色器头文件。它是用来防止链接冲突的。 着色器类储存了着色器程序的ID。它的构造器需要顶点和片段着色器源代码的文件路径，这样我们就可以把源码的文本文件储存在硬盘上了。除此之外，为了让我们的生活更轻松一点，还加入了一些工具函数：use用来激活着色器程序，所有的set…函数能够查询一个unform的位置值并设置它的值。 从文件读取我们使用C++文件流读取着色器内容，储存到几个string对象里： 1234567891011121314151617181920212223242526272829303132333435363738// 构造器读取并构建着色器Shader(const GLchar* vertexPath, const GLchar* fragmentPath) { // 1. 从文件路径中获取顶点/片段着色器 std::string vertexCode; std::string fragmentCode; std::ifstream vShaderFile; std::ifstream fShaderFile; // 保证ifstream对象可以抛出异常 vShaderFile.exceptions(std::ifstream::failbit | std::ifstream::badbit); fShaderFile.exceptions(std::ifstream::failbit | std::ifstream::badbit); try { // 打开文件 vShaderFile.open(vertexPath); fShaderFile.open(fragmentPath); std::stringstream vShaderStream, fShaderStream; // 读取文件的缓冲内容到数据流中 vShaderStream &lt;&lt; vShaderFile.rdbuf(); fShaderStream &lt;&lt; fShaderFile.rdbuf(); // 关闭文件处理器 vShaderFile.close(); fShaderFile.close(); // 转换数据流到string vertexCode = vShaderStream.str(); fragmentCode = fShaderStream.str(); } catch (std::ifstream::failure e) { std::cout &lt;&lt; &quot;ERROR::SHADER::FILE_NOT_SUCCESFULLY_READ&quot; &lt;&lt; std::endl; } const char* vShaderCode = vertexCode.c_str(); const char* fShaderCode = fragmentCode.c_str(); // ... 后续代码} 下一步，我们需要编译和链接着色器。注意，我们也将检查编译/链接是否失败，如果失败则打印编译时错误，调试的时候这些错误输出会及其重要（你总会需要这些错误日志的）： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950// 构造器读取并构建着色器Shader(const GLchar* vertexPath, const GLchar* fragmentPath) { // 1. 从文件路径中获取顶点/片段着色器 // ... 这部分代码见上面 // 2. 编译着色器 unsigned int vertexShader, fragmentShader; int success; char infoLog[512]; // 顶点着色器 vertexShader = glCreateShader(GL_VERTEX_SHADER); glShaderSource(vertexShader, 1, &amp;vShaderCode, NULL); glCompileShader(vertexShader); // 打印编译错误（如果有的话） glGetShaderiv(vertexShader, GL_COMPILE_STATUS, &amp;success); if (!success) { glGetShaderInfoLog(vertexShader, 512, NULL, infoLog); std::cout &lt;&lt; &quot;ERROR::SHADER::VERTEX::COMPILATION_FAILED\\n&quot; &lt;&lt; infoLog &lt;&lt; std::endl; }; // 片段着色器 fragmentShader = glCreateShader(GL_FRAGMENT_SHADER); glShaderSource(fragmentShader, 1, &amp;fShaderCode, NULL); glCompileShader(fragmentShader); // 打印编译错误（如果有的话） glGetShaderiv(fragmentShader, GL_COMPILE_STATUS, &amp;success); if (!success) { glGetShaderInfoLog(fragmentShader, 512, NULL, infoLog); std::cout &lt;&lt; &quot;ERROR::SHADER::VERTEX::COMPILATION_FAILED\\n&quot; &lt;&lt; infoLog &lt;&lt; std::endl; }; ID = glCreateProgram(); glAttachShader(ID, vertexShader); glAttachShader(ID, fragmentShader); glLinkProgram(ID); // 打印连接错误（如果有的话） glGetProgramiv(ID, GL_LINK_STATUS, &amp;success); if (!success) { glGetProgramInfoLog(ID, 512, NULL, infoLog); std::cout &lt;&lt; &quot;ERROR::SHADER::PROGRAM::LINKING_FAILED\\n&quot; &lt;&lt; infoLog &lt;&lt; std::endl; } // 删除着色器，它们已经链接到我们的程序中了，已经不再需要了 glDeleteShader(vertexShader); glDeleteShader(fragmentShader);} use函数非常简单： 1234// 使用/激活程序void use() { glUseProgram(ID);} uniform的setter函数也很类似： 12345678910// uniform工具函数void setBool(const std::string &amp;name, bool value) const { glUniform1i(glGetUniformLocation(ID, name.c_str()), (int)value);}void setInt(const std::string &amp;name, int value) const { glUniform1i(glGetUniformLocation(ID, name.c_str()), value);}void setFloat(const std::string &amp;name, float value) const { glUniform1f(glGetUniformLocation(ID, name.c_str()), value);} 现在我们就写完了一个完整的着色器类。使用这个着色器类很简单；只要创建一个着色器对象，从那一点开始我们就可以开始使用了： 123456789101112131415// ... GLFW GLAD初始化// ... VBO EBO VAO初始化Shader ourShader(&quot;shader.vs&quot;, &quot;shader.fs&quot;);while(...) { // ... 其他操作 ourShader.use(); // 代替了原本的glUseProgram(shaderProgram); // 绑定VAO glBindVertexArray(VAO); // 绘制 glDrawElements(GL_TRIANGLES, 6, GL_UNSIGNED_INT, 0); // 解绑VAO glBindVertexArray(0); // ...} 我们把顶点和片段着色器储存为两个叫做shader.vs和shader.fs的文件。你可以使用自己喜欢的名字命名着色器文件；我自己觉得用.vs和.fs作为扩展名很直观。 纹理我们已经了解到，我们可以为每个顶点添加颜色来增加图形的细节，从而创建出有趣的图像。但是，如果想让图形看起来更真实，我们就必须有足够多的顶点，从而指定足够多的颜色。这将会产生很多额外开销，因为每个模型都会需求更多的顶点，每个顶点又需求一个颜色属性。 艺术家和程序员更喜欢使用纹理(Texture)。纹理是一个2D图片（甚至也有1D和3D的纹理），它可以用来添加物体的细节；你可以想象纹理是一张绘有砖块的纸，无缝折叠贴合到你的3D的房子上，这样你的房子看起来就像有砖墙外表了。因为我们可以在一张图片上插入非常多的细节，这样就可以让物体非常精细而不用指定额外的顶点。 除了图像以外，纹理也可以被用来储存大量的数据，这些数据可以发送到着色器上（例如纹理深度信息），但是这不是我们现在的主题。 为了能够把纹理映射(Map)到三角形上，我们需要指定三角形的每个顶点各自对应纹理的哪个部分。这样每个顶点就会关联着一个纹理坐标(Texture Coordinate)，用来标明该从纹理图像的哪个部分采样（译注：采集片段颜色）。之后在图形的其它片段上进行片段插值(Fragment Interpolation)（插值纹理坐标）。 纹理坐标在x和y轴上，范围为0到1之间（注意我们使用的是2D纹理图像）。使用纹理坐标获取纹理颜色叫做采样(Sampling)。纹理坐标起始于(0, 0)，也就是纹理图片的左下角，终于(1, 1)，即纹理图片的右上角。下面的图片展示了我们是如何把纹理坐标映射到三角形上的。 我们为三角形指定了3个纹理坐标点。如上图所示，我们希望三角形的左下角对应纹理的左下角，因此我们把三角形左下角顶点的纹理坐标设置为(0, 0)；三角形的上顶点对应于图片的上中位置所以我们把它的纹理坐标设置为(0.5, 1.0)；同理右下方的顶点设置为(1, 0)。我们只要给顶点着色器传递这三个纹理坐标就行了，接下来它们会被传片段着色器中，它会为每个片段进行纹理坐标的插值。 纹理坐标看起来就像这样： 12345float texCoords[] = { 0.0f, 0.0f, // 左下角 1.0f, 0.0f, // 右下角 0.5f, 1.0f // 上中}; 对纹理采样的解释非常宽松，它可以采用几种不同的插值方式。所以我们需要自己告诉OpenGL该怎样对纹理采样。 纹理环绕方式纹理坐标的范围通常是从(0, 0)到(1, 1)，那如果我们把纹理坐标设置在范围之外会发生什么？OpenGL默认的行为是重复这个纹理图像（我们基本上忽略浮点纹理坐标的整数部分），但OpenGL提供了更多的选择： GL_REPEAT：对纹理的默认行为。重复纹理图像； GL_MIRRORED_REPEAT：和GL_REPEAT一样，但每次重复图片是镜像放置的； GL_CLAMP_TO_EDGE：纹理坐标会被约束在0到1之间，超出的部分会重复纹理坐标的边缘，产生一种边缘被拉伸的效果； GL_CLAMP_TO_BORDER：超出的坐标为用户指定的边缘颜色。 当纹理坐标超出默认范围时，每个选项都有不同的视觉效果输出。我们来看看这些纹理图像的例子： 前面提到的每个选项都可以使用glTexParameter*函数(*不是指针，是不同类型的重载，看后面代码就知道了)对单独的一个坐标轴(str)设置（s、t（如果是使用3D纹理那么还有一个r）它们和x、y、z是等价的）： 12glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_MIRRORED_REPEAT);glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_MIRRORED_REPEAT); 第一个参数指定了纹理目标；我们使用的是2D纹理，因此纹理目标是GL_TEXTURE_2D； 第二个参数需要我们指定设置的选项与应用的纹理轴。我们打算配置的是WRAP选项，并且指定S和T轴； 最后一个参数需要我们传递一个环绕方式(Wrapping)，在这个例子中OpenGL会给当前激活的纹理设定纹理环绕方式为GL_MIRRORED_REPEAT。 如果我们选择GL_CLAMP_TO_BORDER选项，我们还需要指定一个边缘的颜色。这需要使用glTexParameter函数的fv后缀形式(float vector)，用GL_TEXTURE_BORDER_COLOR作为它的选项，并且传递一个float数组作为边缘的颜色值： 12float borderColor[] = { 1.0f, 1.0f, 0.0f, 1.0f };glTexParameterfv(GL_TEXTURE_2D, GL_TEXTURE_BORDER_COLOR, borderColor); 纹理过滤纹理坐标不依赖于分辨率(Resolution)，它可以是任意浮点值，所以OpenGL需要知道怎样将纹理像素(Texture Pixel，也叫Texel，译注1)映射到纹理坐标。 当你有一个很大的物体但是纹理的分辨率很低的时候这就变得很重要了。你可能已经猜到了，OpenGL也有对于纹理过滤(Texture Filtering)的选项。纹理过滤有很多个选项，但是现在我们只讨论最重要的两种：GL_NEAREST和GL_LINEAR。 Texture Pixel也叫Texel，你可以想象你打开一张.jpg格式图片，不断放大你会发现它是由无数像素点组成的，这个点就是纹理像素；注意不要和纹理坐标搞混，纹理坐标是你给模型顶点设置的那个数组，OpenGL以这个顶点的纹理坐标数据去查找纹理图像上的像素，然后进行采样提取纹理像素的颜色。 GL_NEAREST（也叫邻近过滤，Nearest Neighbor Filtering）是OpenGL默认的纹理过滤方式。当设置为GL_NEAREST的时候，OpenGL会选择中心点最接近纹理坐标的那个像素。下图中你可以看到四个像素，加号代表纹理坐标。左上角那个纹理像素的中心距离纹理坐标最近，所以它会被选择为样本颜色： GL_LINEAR（也叫线性过滤，(Bi)linear Filtering）它会基于纹理坐标附近的纹理像素，计算出一个插值，近似出这些纹理像素之间的颜色。一个纹理像素的中心距离纹理坐标越近，那么这个纹理像素的颜色对最终的样本颜色的贡献越大。下图中你可以看到返回的颜色是邻近像素的混合色： 那么这两种纹理过滤方式有怎样的视觉效果呢？让我们看看在一个很大的物体上应用一张低分辨率的纹理会发生什么吧（纹理被放大了，每个纹理像素都能看到）： GL_NEAREST产生了颗粒状的图案，我们能够清晰看到组成纹理的像素，而GL_LINEAR能够产生更平滑的图案，很难看出单个的纹理像素（但是变得有点模糊了）。GL_LINEAR可以产生更真实的输出，但有些开发者更喜欢8-bit风格，所以他们会用GL_NEAREST选项。 当进行放大(Magnify)和缩小(Minify)操作的时候可以设置纹理过滤的选项，比如你可以在纹理被缩小的时候使用邻近过滤，被放大时使用线性过滤。我们需要使用glTexParameter*函数为放大和缩小指定过滤方式。这段代码看起来会和纹理环绕方式的设置很相似： 12glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_NEAREST);glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR); 多级渐远纹理假设我们有一个包含着上千物体的大房间，每个物体上都有纹理。有些物体会很远，但其纹理会拥有与近处物体同样高的分辨率。由于远处的物体可能只产生很少的片段，OpenGL从高分辨率纹理中为这些片段获取正确的颜色值就很困难，因为它需要对一个跨过纹理很大部分的片段只拾取一个纹理颜色。在小物体上这会产生不真实的感觉，更不用说对它们使用高分辨率纹理浪费内存的问题了。 OpenGL使用一种叫做多级渐远纹理(Mipmap)的概念来解决这个问题，它简单来说就是一系列的纹理图像，后一个纹理图像是前一个的二分之一（宽高同时二分之一，总面积四分之一）。多级渐远纹理背后的理念很简单：距观察者的距离超过一定的阈值，OpenGL会使用不同的多级渐远纹理，即最适合物体的距离的那个。由于距离远，解析度不高也不会被用户注意到。同时，多级渐远纹理另一加分之处是它的性能非常好。让我们看一下多级渐远纹理是什么样子的： 手工为每个纹理图像创建一系列多级渐远纹理很麻烦，幸好OpenGL有一个glGenerateMipmaps函数，在创建完一个纹理后调用它，OpenGL就会承担接下来的所有工作了。 在渲染中切换多级渐远纹理级别(Level)时，OpenGL在两个不同级别的多级渐远纹理层之间会产生不真实的生硬边界。就像普通的纹理过滤一样，切换多级渐远纹理级别时你也可以在两个不同多级渐远纹理级别之间使用NEAREST和LINEAR过滤。 为了指定不同多级渐远纹理级别之间的过滤方式，你可以使用下面四个选项中的一个代替原有的过滤方式： GL_NEAREST_MIPMAP_NEAREST：使用最邻近的多级渐远纹理来匹配像素大小，并使用邻近插值进行纹理采样； GL_LINEAR_MIPMAP_NEAREST：使用最邻近的多级渐远纹理级别，并使用线性插值进行采样； GL_NEAREST_MIPMAP_LINEAR：在两个最匹配像素大小的多级渐远纹理之间进行线性插值，使用邻近插值进行采样； GL_LINEAR_MIPMAP_LINEAR：在两个邻近的多级渐远纹理之间使用线性插值，并使用线性插值进行采样。 就像纹理过滤一样，我们可以使用glTexParameteri将过滤方式设置为前面四种提到的方法之一： 12glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR_MIPMAP_LINEAR);glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR); 一个常见的错误是，将放大过滤的选项设置为多级渐远纹理过滤选项之一。这样没有任何效果，因为多级渐远纹理主要是使用在纹理被缩小的情况下的：纹理放大不会使用多级渐远纹理，为放大过滤设置多级渐远纹理的选项会产生一个GL_INVALID_ENUM错误代码。 加载与创建纹理使用纹理之前要做的第一件事是把它们加载到我们的应用中。纹理图像可能被储存为各种各样的格式，每种都有自己的数据结构和排列，所以我们如何才能把这些图像加载到应用中呢？一个解决方案是选一个需要的文件格式，比如.PNG，然后自己写一个图像加载器，把图像转化为字节序列。写自己的图像加载器虽然不难，但仍然挺麻烦的，而且如果要支持更多文件格式呢？你就不得不为每种你希望支持的格式写加载器了。 另一个解决方案也许是一种更好的选择，使用一个支持多种流行格式的图像加载库来为我们解决这个问题。比如说我们要用的stb_image.h库。 stb_image.h是Sean Barrett的一个非常流行的单头文件图像加载库，它能够加载大部分流行的文件格式，并且能够很简单得整合到你的工程之中。下载这一个头文件，将它以stb_image.h的名字加入你的工程，并另创建一个新的C++文件，输入以下代码： 12#define STB_IMAGE_IMPLEMENTATION#include &quot;stb_image.h&quot; 通过定义STB_IMAGE_IMPLEMENTATION，预处理器会修改头文件，让其只包含相关的函数定义源码，等于是将这个头文件变为一个 .cpp 文件了。现在只需要在你的程序中包含stb_image.h并编译就可以了。 下面的教程中，我们会使用一张木箱的图片。要使用stb_image.h加载图片，我们需要使用它的stbi_load函数： 12int width, height, nrChannels;unsigned char *data = stbi_load(&quot;container.jpg&quot;, &amp;width, &amp;height, &amp;nrChannels, 0); 这个函数首先接受一个图像文件的位置作为输入。接下来它需要三个int作为它的第二、第三和第四个参数，stb_image.h将会用图像的宽度、高度和颜色通道的个数填充这三个变量。我们之后生成纹理的时候会用到的图像的宽度和高度的。 生成纹理和之前生成的OpenGL对象一样，纹理也是使用ID引用的。让我们来创建一个： 12unsigned int texture;glGenTextures(1, &amp;texture); glGenTextures函数首先需要输入生成纹理的数量（本例子中是1），然后把它们储存在第二个参数的unsigned int数组中（我们的例子中只是单独的一个unsigned int），就像其他对象一样，我们需要绑定它，让之后任何的纹理指令都可以配置当前绑定的纹理： 1glBindTexture(GL_TEXTURE_2D, texture); 现在纹理已经绑定了，我们可以使用前面载入的图片数据生成一个纹理了。纹理可以通过glTexImage2D来生成： 12glTexImage2D(GL_TEXTURE_2D, 0, GL_RGB, width, height, 0, GL_RGB, GL_UNSIGNED_BYTE, data);glGenerateMipmap(GL_TEXTURE_2D); glTexImage2D参数不少，所以我们一个一个地讲解： 第一个参数指定了纹理目标(Target)。设置为GL_TEXTURE_2D意味着会生成与当前绑定的纹理对象在同一个目标上的纹理（任何绑定到GL_TEXTURE_1D和GL_TEXTURE_3D的纹理不会受到影响）； 第二个参数为纹理指定多级渐远纹理的级别，如果你希望单独手动设置每个多级渐远纹理的级别的话。这里我们填0，也就是基本级别。 第三个参数告诉OpenGL我们希望把纹理储存为何种格式。我们的图像只有RGB值，因此我们也把纹理储存为RGB值。 第四个和第五个参数设置最终的纹理的宽度和高度。我们之前加载图像的时候储存了它们，所以我们使用对应的变量； 第六个参数总是被设置为0（历史遗留的问题）； 第七第八个参数定义了源图的格式和数据类型。我们使用RGB值加载这个图像，并把它们储存为char(byte)数组，我们将会传入对应值； 最后一个参数是真正的图像数据（之前stbi_load加载的图像数据，unsigned char* data）。 当调用glTexImage2D时，当前绑定的纹理对象就会被附加上纹理图像。然而，目前只有基本级别(Base-level)的纹理图像被加载了，如果要使用多级渐远纹理，我们必须手动设置所有不同的图像（不断递增第二个参数）。或者，直接在生成纹理之后调用glGenerateMipmap。这会为当前绑定的纹理自动生成所有需要的多级渐远纹理。 生成了纹理和相应的多级渐远纹理后，释放图像的内存是一个很好的习惯。 1stbi_image_free(data); 生成一个纹理的过程应该看起来像这样： 123456789101112131415161718192021222324unsigned int texture;glGenTextures(1, &amp;texture);glBindTexture(GL_TEXTURE_2D, texture);// 为当前绑定的纹理对象设置环绕、过滤方式glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_REPEAT);glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_REPEAT);glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);// 加载并生成纹理int width, height, nrChannels;unsigned char *data = stbi_load(&quot;container.jpg&quot;, &amp;width, &amp;height, &amp;nrChannels, 0);if (data) { glTexImage2D(GL_TEXTURE_2D, 0, GL_RGB, width, height, 0, GL_RGB, GL_UNSIGNED_BYTE, data); glGenerateMipmap(GL_TEXTURE_2D);} else { std::cout &lt;&lt; &quot;Failed to load texture&quot; &lt;&lt; std::endl;}// 释放之前加载的图像stbi_image_free(data);// glBindTexture(GL_TEXTURE_2D, 0); // 可选的解绑操作 应用纹理后面的这部分我们会使用glDrawElements绘制「你好，三角形」教程最后一部分的矩形。我们需要告知OpenGL如何采样纹理，所以我们必须使用纹理坐标更新顶点数据： 1234567float vertices[] = {// ---- 位置 ---- ---- 颜色 ---- - 纹理坐标 - 0.5f, 0.5f, 0.0f, 1.0f, 0.0f, 0.0f, 1.0f, 1.0f, // 右上 0.5f, -0.5f, 0.0f, 0.0f, 1.0f, 0.0f, 1.0f, 0.0f, // 右下 -0.5f, -0.5f, 0.0f, 0.0f, 0.0f, 1.0f, 0.0f, 0.0f, // 左下 -0.5f, 0.5f, 0.0f, 1.0f, 1.0f, 0.0f, 0.0f, 1.0f // 左上}; 由于我们添加了一个额外的顶点属性，我们必须告诉OpenGL我们新的顶点格式： 12glVertexAttribPointer(2, 2, GL_FLOAT, GL_FALSE, 8 * sizeof(float), (void*)(6 * sizeof(float)));glEnableVertexAttribArray(2); 注意，我们同样需要调整前面两个顶点属性的步长参数为8 * sizeof(float)。 接着我们需要调整顶点着色器使其能够接受顶点坐标为一个顶点属性，并把坐标传给片段着色器： 12345678910111213#version 330 corelayout (location = 0) in vec3 aPos;layout (location = 1) in vec3 aColor;layout (location = 2) in vec2 aTexCoord;out vec3 ourColor;out vec2 TexCoord;void main() { gl_Position = vec4(aPos, 1.0); ourColor = aColor; TexCoord = aTexCoord;} 片段着色器应该接下来会把输出变量TexCoord作为输入变量。 片段着色器也应该能访问纹理对象，但是我们怎样能把纹理对象传给片段着色器呢？GLSL有一个供纹理对象使用的内建数据类型，叫做采样器(Sampler)，它以纹理类型作为后缀，比如sampler1D、sampler3D，或在我们的例子中的sampler2D。我们可以简单声明一个uniform sampler2D把一个纹理添加到片段着色器中，稍后我们会把纹理赋值给这个uniform。 1234567891011#version 330 coreout vec4 FragColor;in vec3 ourColor;in vec2 TexCoord;uniform sampler2D ourTexture;void main() { FragColor = texture(ourTexture, TexCoord);} 我们使用GLSL内建的texture函数来采样纹理的颜色，它第一个参数是纹理采样器，第二个参数是对应的纹理坐标。texture函数会使用之前设置的纹理参数对相应的颜色值进行采样。这个片段着色器的输出就是纹理的（插值）纹理坐标上的(过滤后的)颜色。 现在只剩下在调用glDrawElements之前绑定纹理了，它会自动把纹理赋值给片段着色器的采样器： 123glBindTexture(GL_TEXTURE_2D, texture);glBindVertexArray(VAO);glDrawElements(GL_TRIANGLES, 6, GL_UNSIGNED_INT, 0); 我们还可以把得到的纹理颜色与顶点颜色混合，来获得更有趣的效果。我们只需把纹理颜色与顶点颜色在片段着色器中相乘来混合二者的颜色： 1FragColor = texture(ourTexture, TexCoord) * vec4(ourColor, 1.0); 纹理单元你可能会奇怪为什么sampler2D变量是个uniform，我们却不用glUniform给它赋值。使用glUniform1i，我们可以给纹理采样器分配一个位置值，这样的话我们能够在一个片段着色器中设置多个纹理。一个纹理的位置值通常称为一个纹理单元(Texture Unit)。一个纹理的默认纹理单元是0，它是默认的激活纹理单元，所以教程前面部分我们没有分配一个位置值。 纹理单元的主要目的是让我们在着色器中可以使用多于一个的纹理。通过把纹理单元赋值给采样器，我们可以一次绑定多个纹理，只要我们首先激活对应的纹理单元。就像glBindTexture一样，我们可以使用glActiveTexture激活纹理单元，传入我们需要使用的纹理单元： 12glActiveTexture(GL_TEXTURE0); // 在绑定纹理之前先激活纹理单元glBindTexture(GL_TEXTURE_2D, texture); 激活纹理单元之后，接下来的glBindTexture函数调用会绑定这个纹理到当前激活的纹理单元，纹理单元GL_TEXTURE0默认总是被激活，所以我们在前面的例子里当我们使用glBindTexture的时候，无需激活任何纹理单元。 OpenGL至少保证有16个纹理单元供你使用，也就是说你可以激活从GL_TEXTURE0到GL_TEXTRUE15。它们都是按顺序定义的，所以我们也可以通过GL_TEXTURE0 + 8的方式获得GL_TEXTURE8，这在当我们需要循环一些纹理单元的时候会很有用。 我们仍然需要编辑片段着色器来接收另一个采样器。这应该相对来说非常直接了： 123456789#version 330 core...uniform sampler2D texture1;uniform sampler2D texture2;void main() { FragColor = mix(texture(texture1, TexCoord), texture(texture2, TexCoord), 0.2);} 最终输出颜色现在是两个纹理的结合。GLSL内建的mix函数需要接受两个值作为参数，并对它们根据第三个参数进行线性插值。如果第三个值是0.0，它会返回第一个输入；如果是1.0，会返回第二个输入值。0.2会返回80%的第一个输入颜色和20%的第二个输入颜色，即返回两个纹理的混合色。 我们现在需要载入并创建另一个纹理；你应该对这些步骤很熟悉了。记得创建另一个纹理对象，载入图片，使用glTexImage2D生成最终纹理。对于第二个纹理我们使用一张你学习OpenGL时的面部表情图片（草）。 为了使用第二个纹理（以及第一个），我们必须改变一点渲染流程，先绑定两个纹理到对应的纹理单元，然后定义哪个uniform采样器对应哪个纹理单元： 1234567glActiveTexture(GL_TEXTURE0);glBindTexture(GL_TEXTURE_2D, texture1);glActiveTexture(GL_TEXTURE1);glBindTexture(GL_TEXTURE_2D, texture2);glBindVertexArray(VAO);glDrawElements(GL_TRIANGLES, 6, GL_UNSIGNED_INT, 0); 我们还要通过使用glUniform1i设置每个采样器的方式告诉OpenGL每个着色器采样器属于哪个纹理单元。我们只需要设置一次即可，所以这个会放在渲染循环的前面： 1234567ourShader.use(); // 不要忘记在设置uniform变量之前激活着色器程序！glUniform1i(glGetUniformLocation(ourShader.ID, &quot;texture1&quot;), 0); // 手动设置ourShader.setInt(&quot;texture2&quot;, 1); // 或者使用着色器类设置while(...) { // [...]} 通过使用glUniform1i设置采样器，我们保证了每个uniform采样器对应着正确的纹理单元。你应该能得到下面的结果： 你可能注意到纹理上下颠倒了！这是因为OpenGL要求y轴0.0坐标是在图片的底部的，但是图片的y轴0.0坐标通常在顶部。很幸运，stb_image.h能够在图像加载时帮助我们翻转y轴，只需要在加载任何图像前加入以下语句即可： 1stbi_set_flip_vertically_on_load(true); 在让stb_image.h在加载图片时翻转y轴之后你就应该能够获得下面的结果了： 练习题 修改片段着色器，仅让笑脸图案朝另一个方向看； 尝试用不同的纹理环绕方式，设定一个从0.0f到2.0f范围内的（而不是原来的0.0f到1.0f）纹理坐标。试试看能不能在箱子的角落放置4个笑脸：参考解答，结果。记得一定要试试其它的环绕方式； 尝试在矩形上只显示纹理图像的中间一部分，修改纹理坐标，达到能看见单个的像素的效果。尝试使用GL_NEAREST的纹理过滤方式让像素显示得更清晰； 使用一个uniform变量作为mix函数的第三个参数来改变两个纹理可见度，使用上和下键来改变箱子或笑脸的可见度。 变换尽管我们现在已经知道了如何创建一个物体、着色、加入纹理，给它们一些细节的表现，但因为它们都还是静态的物体，仍是不够有趣。我们可以尝试着在每一帧改变物体的顶点并且重配置缓冲区从而使它们移动，但这太繁琐了，而且会消耗很多的处理时间。 矩阵(Matrix)对象可以更好的变换(Transform)一个物体。当然，这并不是说我们会去讨论武术和数字虚拟世界（译注：Matrix同样也是电影「黑客帝国」的英文名，电影中人类生活在数字虚拟世界，主角（基努·里维斯）会武术）（草）。 为了深入了解变换，我们首先要在讨论矩阵之前进一步了解一下向量。这一节的目标是让你拥有将来需要的最基础的数学背景知识。如果你发现这节十分困难，尽量尝试去理解它们，当你以后需要它们的时候回过头来复习这些概念。 向量向量最基本的定义就是一个方向。或者更正式的说，向量有一个方向(Direction)和大小(Magnitude，也叫做强度或长度)。向量可以在任意维度(Dimension)上，但是我们通常只使用2至4维。如果一个向量有2个维度，它表示一个平面的方向(想象一下2D的图像)，当它有3个维度的时候它可以表达一个3D世界的方向。 由于向量是一个方向，所以有些时候会很难形象地将它们用位置(Position)表示出来。为了让其更为直观，我们通常设定这个方向的原点为(0, 0, 0)，然后指向一个方向，对应一个点，使其变为位置向量(Position Vector)（你也可以把起点设置为其他的点，然后说：这个向量从这个点起始指向另一个点）。 注意，数学上是没有向量与标量相加这个运算的，但是很多线性代数的库都对它有支持（比如说我们用的GLM）。如果你使用过numpy的话，可以把它理解为Broadcasting。 我们使用**勾股定理(**Pythagoras Theorem)来获取向量的长度(Length)/大小(Magnitude)。 有一个特殊类型的向量叫做单位向量(Unit Vector)。单位向量有一个特别的性质——它的长度是1。我们可以用任意向量的每个分量除以向量的长度得到它的单位向量。我们把这种方法叫做一个向量的标准化(Normalizing)。单位向量头上有一个^样子的记号。 在相乘的时候我们有两种特定情况可以选择：一个是点乘(Dot Product)，记作v⋅k，另一个是叉乘(Cross Product)，记作v×k。 两个向量的点乘等于它们的数乘结果乘以两个向量之间夹角的余弦值。使用点乘可以很容易测试两个向量是否正交(Orthogonal)或平行（正交意味着两个向量互为直角）。你也可以通过点乘的结果计算两个非单位向量的夹角，点乘的结果除以两个向量的长度之积，得到的结果就是夹角的余弦值，即cosθ。点乘是通过将对应分量逐个相乘，然后再把所得积相加来计算的。 叉乘只在3D空间中有定义，它需要两个不平行向量作为输入，生成一个正交于两个输入向量的第三个向量。如果输入的两个向量也是正交的，那么叉乘之后将会产生3个互相正交的向量。 矩阵矩阵中每一项叫做矩阵的元素(Element)。 矩阵可以通过(i, j)进行索引，i是行，j是列。矩阵有几个运算，分别是：矩阵加法、减法和乘法。 矩阵与标量之间的加减要处理到每一个元素上，和向量类似。 注意，数学上是没有矩阵与标量相加减的运算的，但是很多线性代数的库都对它有支持（比如说我们用的GLM）。如果你使用过numpy的话，可以把它理解为Broadcasting。 矩阵与矩阵之间的加减就是两个矩阵对应元素的加减运算，所以总体的规则和与标量运算是差不多的，只不过在相同索引下的元素才能进行运算。这也就是说加法和减法只对同维度的矩阵才是有定义的。 和矩阵与标量的加减一样，矩阵与标量之间的乘法也是矩阵的每一个元素分别乘以该标量。现在我们也就能明白为什么这些单独的数字要叫做标量(Scalar)了。简单来说，标量就是用它的值缩放(Scale)矩阵的所有元素（译注：注意Scalar是由Scale + -ar演变过来的）。 矩阵之间的乘法不见得有多复杂，但的确很难让人适应。矩阵乘法基本上意味着遵照规定好的法则进行相乘。当然，相乘还有一些限制： 只有当左侧矩阵的列数与右侧矩阵的行数相等，两个矩阵才能相乘； 矩阵相乘不遵守交换律(Commutative)，也就是说A⋅B≠B⋅A。 假设A ⋅ B = C，那么Cij的值为A矩阵的第i行向量与B矩阵的第j列向量的点积结果，这基本上就是矩阵乘法的内核。 矩阵与向量相乘目前为止，通过这些教程我们已经相当了解向量了。我们用向量来表示位置，表示颜色，甚至是纹理坐标。如果我们有一个M×N维矩阵，我们可以用这个矩阵乘以我们的N×1向量，因为这个矩阵的列数等于向量的行数，所以它们就能相乘。 单位矩阵在OpenGL中，由于某些原因（齐次坐标系，为了能够方便地在变换矩阵中加入平移变换）我们通常使用4×4的变换矩阵，而其中最重要的原因就是大部分的向量都是4分量的。我们能想到的最简单的变换矩阵就是单位矩阵(Identity Matrix)。这种变换矩阵使一个向量完全不变。 缩放对一个向量进行缩放(Scaling)就是对向量的长度进行缩放，而保持它的方向不变。由于我们进行的是2维或3维操作，我们可以分别定义一个有2或3个缩放变量的向量，每个变量缩放一个轴(x、y或z)。 不均匀(Non-uniform)缩放，因为每个轴的缩放因子(Scaling Factor)都不一样。如果每个轴的缩放因子都一样那么就叫均匀缩放(Uniform Scale)。 注意，第四个缩放向量仍然是1，因为在3D空间中缩放w分量是无意义的。w分量另有其他用途，在后面我们会看到。 位移位移(Translation)是在原始向量的基础上加上另一个向量从而获得一个在不同位置的新向量的过程，从而在位移向量基础上移动了原始向量。 齐次坐标(Homogeneous Coordinates)：向量的w分量也叫齐次坐标。想要从齐次向量得到3D向量，我们可以把x、y和z坐标分别除以w坐标。我们通常不会注意这个问题，因为w分量通常是1.0。使用齐次坐标有几点好处：它允许我们在3D向量上进行位移（如果没有w分量我们是不能位移向量的），而且下一章我们会用w值创建3D视觉效果。如果一个向量的齐次坐标是0，这个坐标就是方向向量(Direction Vector)，因为w坐标是0，这个向量就不能位移（译注：这也就是我们说的不能位移一个方向）。 旋转首先我们来定义一个向量的旋转到底是什么。2D或3D空间中的旋转用角(Angle)来表示。角可以是角度制或弧度制的，周角是360角度或2PI弧度。我个人更喜欢用角度，因为它们看起来更直观。 大多数旋转函数需要用弧度制的角，但幸运的是角度制的角也可以很容易地转化为弧度制的： 弧度转角度：角度 = (弧度 / PI) * 180.0f； 角度转弧度：弧度 = (角度 / 180.0f) * PI。 PI约等于3.14159265359。 在3D空间中旋转需要定义一个角和一个旋转轴(Rotation Axis)，物体会沿着给定的旋转轴旋转特定角度。 旋转矩阵在3D空间中每个单位轴都有不同定义，旋转角度用θ表示。 沿x轴旋转： 沿y轴旋转： 沿z轴旋转： 利用旋转矩阵我们可以把任意位置向量沿一个单位旋转轴进行旋转。也可以将多个矩阵复合，比如先沿着x轴旋转再沿着y轴旋转。但是这会很快导致一个问题——万向节死锁（Gimbal Lock）。在这里我们不会讨论它的细节，但是对于3D空间中的旋转，一个更好的模型是沿着任意的一个轴，而不是对一系列旋转矩阵进行复合。样的一个（超级麻烦的）矩阵是存在的，见下面这个公式，其中(Rx,Ry,Rz)代表任意旋转轴： 在数学上讨论如何生成这样的矩阵仍然超出了本节内容。但是记住，即使这样一个矩阵也不能完全解决万向节死锁问题（尽管会极大地避免）。避免万向节死锁的真正解决方案是使用四元数(Quaternion)，它不仅更安全，而且计算会更有效率。 对四元数的理解会用到非常多的数学知识。如果你想了解四元数与3D旋转之间的关系，可以来阅读这篇的教程四元数与三维旋转。如果你对万向节死锁的概念仍不是那么清楚，可以来阅读教程的Bonus章节()。现在3Blue1Brown也已经开始了一个四元数的视频系列，他采用球极平面投影(Stereographic Projection)的方式将四元数投影到3D空间，同样有助于理解四元数的概念Visualizing quaternions。 矩阵的组合使用矩阵进行变换的真正力量在于，根据矩阵之间的乘法，我们可以把多个变换组合到一个矩阵中。让我们看看我们是否能生成一个变换矩阵，让它组合多个变换。假设我们有一个顶点(x, y, z)，我们希望将其缩放2倍，然后位移(1, 2, 3)个单位。我们需要一个位移和缩放矩阵来完成这些变换。结果的变换矩阵看起来像这样： 注意，当矩阵相乘时我们先写位移再写缩放变换的。矩阵乘法是不遵守交换律的，这意味着它们的顺序很重要。当矩阵相乘时，在最右边的矩阵是第一个与向量相乘的，所以你应该从右向左读这个乘法。建议您在组合矩阵时，先进行缩放操作，然后是旋转，最后才是位移，否则它们会（消极地）互相影响。比如，如果你先位移再缩放，位移的向量也会同样被缩放（译注：比如向某方向移动2米，2米也许会被缩放成1米）！ 用最终的变换矩阵左乘我们的向量会得到以下结果： 实践OpenGL没有自带任何的矩阵和向量知识，所以我们必须定义自己的数学类和函数。在教程中我们更希望抽象所有的数学细节，使用已经做好了的数学库。幸运的是，有个易于使用，专门为OpenGL量身定做的数学库，那就是GLM。 GLM是OpenGL Mathematics的缩写，它是一个只有头文件的库，也就是说我们只需包含对应的头文件就行了，不用链接和编译。GLM可以在它们的网站上下载OpenGL Mathematics。把头文件的根目录复制到你的includes文件夹，然后你就可以使用这个库了。 PS：GLM库从0.9.9版本起，默认会将矩阵类型初始化为一个零矩阵（所有元素均为0），而不是单位矩阵（对角元素为1，其它元素为0）。如果你使用的是0.9.9或0.9.9以上的版本，你需要将所有的矩阵初始化改为 glm::mat4 mat = glm::mat4(1.0f)。如果你想与本教程的代码保持一致，请使用低于0.9.9版本的GLM，或者改用上述代码初始化所有的矩阵。 我们需要的GLM的大多数功能都可以从下面这3个头文件中找到： 123#include &lt;glm/glm.hpp&gt;#include &lt;glm/gtc/matrix_transform.hpp&gt;#include &lt;glm/gtc/type_ptr.hpp&gt; 我们来看看是否可以利用我们刚学的变换知识把一个向量(1, 0, 0)位移(1, 1, 0)个单位（注意，我们把它定义为一个glm::vec4类型的值，齐次坐标设定为1.0）： 123456789glm::vec4 vec(1.0f, 0.0f, 0.0f, 1.0f);// 译注：下面就是矩阵初始化的一个例子，如果使用的是0.9.9及以上版本// 下面这行代码就需要改为:glm::mat4 trans = glm::mat4(1.0f);// 0.9.9以下的版本矩阵初始化为：// glm::mat4 trans; // 会初始化为单位阵trans = glm::translate(trans, glm::vec3(1.0f, 1.0f, 0.0f));vec = trans * vec;std::cout &lt;&lt; vec.x &lt;&lt; vec.y &lt;&lt; vec.z &lt;&lt; std::endl; 我们先用GLM内建的向量类定义一个叫做vec的向量。接下来定义一个mat4类型的trans，默认是一个4×4单位矩阵。下一步是创建一个变换矩阵，我们是把单位矩阵和一个位移向量传递给glm::translate函数来完成这个工作的（然后用给定的矩阵乘以位移矩阵就能获得最后需要的矩阵）。 之后我们把向量乘以位移矩阵并且输出最后的结果。如果你仍记得位移矩阵是如何工作的话，得到的向量应该是(1 + 1, 0 + 1, 0 + 0)，也就是(2, 1, 0)。这个代码片段将会输出210，所以这个位移矩阵是正确的。 我们来做些更有意思的事情，让我们来旋转和缩放之前教程中的那个箱子。首先我们把箱子逆时针旋转90度。然后缩放0.5倍，使它变成原来的一半大。我们先来创建变换矩阵： 12345glm::mat4 trans = glm::mat4(1.0f);trans = glm::rotate(trans, glm::radians(90.0f), glm::vec3(0.0, 0.0, 1.0));trans = glm::scale(trans, glm::vec3(0.5, 0.5, 0.5));// 注意这里的顺序 identity · rotate · scale · vector// 感觉glm的函数是在原矩阵后面追加矩阵 首先，我们把箱子在每个轴都缩放到0.5倍，然后沿z轴旋转90度。GLM希望它的角度是弧度制的(Radian)，所以我们使用glm::radians将角度转化为弧度。注意有纹理的那面矩形是在XY平面上的，所以我们需要把它绕着z轴旋转。因为我们把这个矩阵传递给了GLM的每个函数，GLM会自动将矩阵相乘，返回的结果是一个包括了多个变换的变换矩阵。 下一个大问题是：如何把矩阵传递给着色器？我们在前面简单提到过GLSL里也有一个mat4类型。所以我们将修改顶点着色器让其接收一个mat4的uniform变量，然后再用矩阵uniform乘以位置向量： 123456789101112#version 330 corelayout (location = 0) in vec3 aPos;layout (location = 1) in vec2 aTexCoord;out vec2 TexCoord;uniform mat4 transform;void main() { gl_Position = transform * vec4(aPos, 1.0f); TexCoord = vec2(aTexCoord.x, 1.0 - aTexCoord.y);} GLSL也有mat2和mat3类型，从而允许了像向量一样的混合运算。前面提到的所有数学运算（像是标量-矩阵相乘，矩阵-向量相乘和矩阵-矩阵相乘）在矩阵类型里都可以使用。当出现特殊的矩阵运算的时候我们会特别说明。 在把位置向量传给gl_Position之前，我们先添加一个uniform，并且将其与变换矩阵相乘。我们的箱子现在应该是原来的二分之一大小并（向左）旋转了90度。当然，我们仍需要把变换矩阵传递给着色器： 12unsigned int transformLoc = glGetUniformLocation(ourShader.ID, &quot;transform&quot;);glUniformMatrix4fv(transformLoc, 1, GL_FALSE, glm::value_ptr(trans)); 我们首先查询uniform变量的地址，然后用有Matrix4fv后缀的glUniform函数把矩阵数据发送给着色器。第一个参数你现在应该很熟悉了，它是uniform的位置值。第二个参数告诉OpenGL我们将要发送多少个矩阵，这里是1。第三个参数询问我们我们是否希望对我们的矩阵进行置换(Transpose)，也就是说交换我们矩阵的行和列。OpenGL开发者通常使用一种内部矩阵布局，叫做列主序(Column-major Ordering)布局。GLM的默认布局就是列主序，所以并不需要置换矩阵，我们填GL_FALSE。最后一个参数是真正的矩阵数据，但是GLM并不是把它们的矩阵储存为OpenGL所希望接受的那种，因此我们要先用GLM的自带的函数value_ptr来变换这些数据。 我们创建了一个变换矩阵，在顶点着色器中声明了一个uniform，并把矩阵发送给了着色器，着色器会变换我们的顶点坐标。最后的结果应该看起来像这样： 完美！我们的箱子向左侧旋转，并是原来的一半大小，所以变换成功了。我们现在做些更有意思的，看看我们是否可以让箱子随着时间旋转，我们还会重新把箱子放在窗口的右下角。要让箱子随着时间推移旋转，我们必须在游戏循环中更新变换矩阵，因为它在每一次渲染迭代中都要更新。我们使用GLFW的时间函数来获取不同时间的角度： 123glm::mat4 trans = glm::mat4(1.0f);trans = glm::translate(trans, glm::vec3(0.5f, -0.5f, 0.0f));trans = glm::rotate(trans, (float)glfwGetTime(), glm::vec3(0.0f, 0.0f, 1.0f)); 要记住的是前面的例子中我们可以在任何地方声明变换矩阵，但是现在我们必须在每一次迭代中创建它，从而保证我们能够不断更新旋转角度。这也就意味着我们不得不在每次游戏循环的迭代中重新创建变换矩阵。通常在渲染场景的时候，我们也会有多个需要在每次渲染迭代中都用新值重新创建的变换矩阵。 在这里我们先把箱子围绕原点(0, 0, 0)旋转，之后，我们把旋转过后的箱子位移到屏幕的右下角。记住，实际的变换顺序应该与阅读顺序相反：尽管在代码中我们先位移再旋转，实际的变换却是先应用旋转再是位移的。 下一节中，我们会讨论怎样使用矩阵为顶点定义不同的坐标空间。这将是我们进入实时3D图像的第一步！ 坐标系统在上一个教程中，我们学习了如何有效地利用矩阵的变换来对所有顶点进行变换。OpenGL希望在每次顶点着色器运行后，我们可见的所有顶点都为标准化设备坐标(Normalized Device Coordinate, NDC)。也就是说，每个顶点的x，y，z坐标都应该在-1.0到1.0之间，超出这个坐标范围的顶点都将不可见。我们通常会自己设定一个坐标的范围，之后再在顶点着色器中将这些坐标变换为标准化设备坐标。然后将这些标准化设备坐标传入光栅器(Rasterizer)，将它们变换为屏幕上的二维坐标或像素。 将坐标变换为标准化设备坐标，接着再转化为屏幕坐标的过程通常是分步进行的，也就是类似于流水线那样子。在流水线中，物体的顶点在最终转化为屏幕坐标之前还会被变换到多个坐标系统(Coordinate System)。将物体的坐标变换到几个过渡坐标系(Intermediate Coordinate System)的优点在于，在这些特定的坐标系统中，一些操作或运算更加方便和容易，这一点很快就会变得很明显。对我们来说比较重要的总共有5个不同的坐标系统： 局部空间(Local Space，或者称为物体空间(Object Space))； 世界空间(World Space)； 观察空间(View Space，或者称为视觉空间(Eye Space))； 裁剪空间(Clip Space)； 屏幕空间(Screen Space)。 这就是一个顶点在最终被转化为片段之前需要经历的所有不同状态。 概述为了将坐标从一个坐标系变换到另一个坐标系，我们需要用到几个变换矩阵，最重要的几个分别是模型(Model)、观察(View)、投影(Projection)三个矩阵。 我们的顶点坐标起始于局部空间(Local Space)，在这里它称为局部坐标(Local Coordinate)，它在之后会变为世界坐标(World Coordinate)，观察坐标(View Coordinate)，裁剪坐标(Clip Coordinate)，并最后以屏幕坐标(Screen Coordinate)的形式结束。下面的这张图展示了整个流程以及各个变换过程做了什么： 局部坐标是对象相对于局部原点的坐标，也是物体起始的坐标； 下一步是将局部坐标变换为世界空间坐标，世界空间坐标是处于一个更大的空间范围的。这些坐标相对于世界的全局原点，它们会和其它物体一起相对于世界的原点进行摆放； 接下来我们将世界坐标变换为观察空间坐标，使得每个坐标都是从摄像机或者说观察者的角度进行观察的； 坐标到达观察空间之后，我们需要将其投影到裁剪坐标。裁剪坐标会被处理至-1.0到1.0的范围内，并判断哪些顶点将会出现在屏幕上（深度测试）； 最后，我们将裁剪坐标变换为屏幕坐标，我们将使用一个叫做视口变换(Viewport Transform)的过程。视口变换将位于-1.0到1.0范围的坐标变换到由glViewport函数所定义的坐标范围内。最后变换出来的坐标将会送到光栅器，将其转化为片段。 我们之所以将顶点变换到各个不同的空间的原因是，有些操作在特定的坐标系统中才有意义且更方便。例如，当需要对物体进行修改的时候，在局部空间中来操作会更说得通；如果要对一个物体做出一个相对于其它物体位置的操作时，在世界坐标系中来做这个才更说得通，等等。 接下来我们将要更仔细地讨论各个坐标系统。 局部空间局部空间是指物体所在的坐标空间，即对象最开始所在的地方。 模型的所有顶点都是在局部空间中：它们相对于你的物体来说都是局部的。 我们一直使用的那个箱子的顶点是被设定在-0.5到0.5的坐标范围中，(0, 0)是它的原点。这些都是局部坐标。 世界空间如果我们将我们所有的物体导入到程序当中，它们有可能会全挤在世界的原点(0, 0, 0)上，这并不是我们想要的结果。我们想为每一个物体定义一个位置，从而能在更大的世界当中放置它们。世界空间中的坐标正如其名：是指顶点相对于世界的坐标。如果你希望将物体分散在世界上摆放（特别是非常真实的那样），这就是你希望物体变换到的空间。物体的坐标将会从局部变换到世界空间；该变换是由模型矩阵(Model Matrix)实现的。 模型矩阵是一种变换矩阵，它能通过对物体进行位移、缩放、旋转来将它置于它本应该在的位置或朝向。你可以将它想像为变换一个房子，你需要先将它缩小（它在局部空间中太大了），并将其位移至郊区的一个小镇，然后在y轴上往左旋转一点以搭配附近的房子。你也可以把上一节将箱子到处摆放在场景中用的那个矩阵大致看作一个模型矩阵；我们将箱子的局部坐标变换到场景/世界中的不同位置。 观察空间观察空间经常被人们称之OpenGL的摄像机(Camera)（所以有时也称为摄像机空间(Camera Space)或视觉空间(Eye Space)）。观察空间是将世界空间坐标转化为用户视野前方的坐标而产生的结果。因此观察空间就是从摄像机的视角所观察到的空间。而这通常是由一系列的位移和旋转的组合来完成，平移/旋转场景从而使得特定的对象被变换到摄像机的前方。这些组合在一起的变换通常存储在一个观察矩阵(View Matrix)里，它被用来将世界坐标变换到观察空间。在下一节中我们将深入讨论如何创建一个这样的观察矩阵来模拟一个摄像机。 裁剪空间在一个顶点着色器运行的最后，OpenGL期望所有的坐标都能落在一个特定的范围内，且任何在这个范围之外的点都应该被裁剪掉(Clipped)。被裁剪掉的坐标就会被忽略，所以剩下的坐标就将变为屏幕上可见的片段。这也就是裁剪空间(Clip Space)名字的由来。 为了将顶点坐标从观察变换到裁剪空间，我们需要定义一个投影矩阵(Projection Matrix)，它指定了一个范围的坐标，比如在每个维度上的-1000到1000。投影矩阵接着会将在这个指定的范围内的坐标变换为标准化设备坐标的范围(-1.0, 1.0)。所有在范围外的坐标不会被映射到在-1.0到1.0的范围之间，所以会被裁剪掉。在上面这个投影矩阵所指定的范围内，坐标(1250, 500, 750)将是不可见的，这是由于它的x坐标超出了范围，它被转化为一个大于1.0的标准化设备坐标，所以被裁剪掉了。 如果只是图元(Primitive)，例如三角形，的一部分超出了裁剪体积(Clipping Volume)，则OpenGL会重新构建这个三角形为一个或多个三角形让其能够适合这个裁剪范围。 由投影矩阵创建的观察箱(Viewing Box)被称为平截头体(Frustum)，每个出现在平截头体范围内的坐标都会最终出现在用户的屏幕上。将特定范围内的坐标转化到标准化设备坐标系的过程（而且它很容易被映射到2D观察空间坐标）被称之为投影(Projection)，因为使用投影矩阵能将3D坐标投影(Project)到很容易映射到2D的标准化设备坐标系中。 一旦所有顶点被变换到裁剪空间，最终的操作——透视除法(Perspective Division)将会执行，在这个过程中我们将位置向量的x，y，z分量分别除以向量的齐次w分量；透视除法是将4D裁剪空间坐标变换为3D标准化设备坐标的过程。这一步会在每一个顶点着色器运行的最后被自动执行。 在这一阶段之后，最终的坐标将会被映射到屏幕空间中（使用glViewport中的设定），并被变换成片段。 将观察坐标变换为裁剪坐标的投影矩阵可以为两种不同的形式，每种形式都定义了不同的平截头体。我们可以选择创建一个正射投影矩阵(Orthographic Projection Matrix)或一个透视投影矩阵(Perspective Projection Matrix)。 正射投影正射投影矩阵定义了一个类似立方体的平截头箱，它定义了一个裁剪空间，在这空间之外的顶点都会被裁剪掉。创建一个正射投影矩阵需要指定可见平截头体的宽、高和长度。在使用正射投影矩阵变换至裁剪空间之后处于这个平截头体内的所有坐标将不会被裁剪掉。它的平截头体看起来像一个容器： 上面的平截头体定义了可见的坐标，它由由宽、高、近(Near)平面和远(Far)平面所指定。任何出现在近平面之前或远平面之后的坐标都会被裁剪掉。正射平截头体直接将平截头体内部的所有坐标映射为标准化设备坐标，因为每个向量的w分量都没有进行改变；如果w分量等于1.0，透视除法则不会改变这个坐标。 要创建一个正射投影矩阵，我们可以使用GLM的内置函数glm::ortho： 12glm::ortho(0.0f, 800.0f, 0.0f, 600.0f, 0.1f, 100.0f);// left, right, bottom, top, near, far 前两个参数指定了平截头体的左右坐标，第三和第四参数指定了平截头体的底部和顶部。通过这四个参数我们定义了近平面和远平面的大小，然后第五和第六个参数则定义了近平面和远平面的距离。这个投影矩阵会将处于这些x，y，z值范围内的坐标变换为标准化设备坐标。 正射投影矩阵直接将坐标映射到2D平面中，即你的屏幕，但实际上一个直接的投影矩阵会产生不真实的结果，因为这个投影没有将透视(Perspective)考虑进去。所以我们需要透视投影矩阵来解决这个问题。 透视投影如果你曾经体验过实际生活给你带来的景象，你就会注意到离你越远的东西看起来更小。这个奇怪的效果称之为透视(Perspective)。透视的效果在我们看一条无限长的高速公路或铁路时尤其明显，正如下面图片显示的那样： 正如你看到的那样，由于透视，这两条线在很远的地方看起来会相交。这正是透视投影想要模仿的效果，它是使用透视投影矩阵来完成的。这个投影矩阵将给定的平截头体范围映射到裁剪空间，除此之外还修改了每个顶点坐标的w值，从而使得离观察者越远的顶点坐标w分量越大。被变换到裁剪空间的坐标都会在-w到w的范围之间（任何大于这个范围的坐标都会被裁剪掉）。OpenGL要求所有可见的坐标都落在-1.0到1.0范围内，作为顶点着色器最后的输出，因此，一旦坐标在裁剪空间内之后，透视除法就会被应用到裁剪空间坐标上： 顶点坐标的每个分量都会除以它的w分量，距离观察者越远顶点坐标就会越小。这是也是w分量非常重要的另一个原因，它能够帮助我们进行透视投影。最后的结果坐标就是处于标准化设备空间中的。如果你对正射投影矩阵和透视投影矩阵是如何计算的很感兴趣（且不会对数学感到恐惧的话）我推荐这篇由Songho写的文章。 在GLM中可以这样创建一个透视投影矩阵： 1glm::perspective(glm::radians(45.0f), (float)width/(float)height, 0.1f, 100.0f); 同样，glm::perspective所做的其实就是创建了一个定义了可视空间的大平截头体，任何在这个平截头体以外的东西最后都不会出现在裁剪空间体积内，并且将会受到裁剪。一个透视平截头体可以被看作一个不均匀形状的箱子，在这个箱子内部的每个坐标都会被映射到裁剪空间上的一个点。下面是一张透视平截头体的图片： glm::perspective的第一个参数定义了fov的值，它表示的是视野(Field of View)，并且设置了观察空间的大小。如果想要一个真实的观察效果，它的值通常设置为45.0f，但想要一个末日风格的结果你可以将其设置一个更大的值。第二个参数设置了宽高比，由视口的宽除以高所得。第三和第四个参数设置了平截头体的近和远平面。我们通常设置近距离为0.1f，而远距离设为100.0f。所有在近平面和远平面内且处于平截头体内的顶点都会被渲染。 当你把透视矩阵的 near 值设置太大时（如10.0f），OpenGL会将靠近摄像机的坐标（在0.0f和10.0f之间）都裁剪掉，这会导致一个你在游戏中很熟悉的视觉效果：在太过靠近一个物体的时候你的视线会直接穿过去。 当使用正射投影时，每一个顶点坐标都会直接映射到裁剪空间中而不经过任何精细的透视除法（它仍然会进行透视除法，只是w分量没有被改变（它保持为1），因此没有起作用）。因为正射投影没有使用透视，远处的物体不会显得更小，所以产生奇怪的视觉效果。由于这个原因，正射投影主要用于二维渲染以及一些建筑或工程的程序，在这些场景中我们更希望顶点不会被透视所干扰。某些如 Blender 等进行三维建模的软件有时在建模时也会使用正射投影，因为它在各个维度下都更准确地描绘了每个物体。下面你能够看到在Blender里面使用两种投影方式的对比： 把它们都组合到一起我们为上述的每一个步骤都创建了一个变换矩阵：模型矩阵、观察矩阵和投影矩阵。一个顶点坐标将会根据以下过程被变换到裁剪坐标： 注意矩阵运算的顺序是相反的（记住我们需要从右往左阅读矩阵的乘法）。最后的顶点应该被赋值到顶点着色器中的gl_Position，OpenGL将会自动进行透视除法和裁剪。 然后呢？顶点着色器的输出要求所有的顶点都在裁剪空间内，这正是我们刚才使用变换矩阵所做的。OpenGL然后对裁剪坐标执行透视除法从而将它们变换到标准化设备坐标。OpenGL会使用glViewPort内部的参数来将标准化设备坐标映射到屏幕坐标，每个坐标都关联了一个屏幕上的点（在我们的例子中是一个800x600的屏幕）。这个过程称为视口变换。 进入3D既然我们知道了如何将3D坐标变换为2D坐标，我们可以开始使用真正的3D物体，而不是枯燥的2D平面了。 在开始进行3D绘图时，我们首先创建一个模型矩阵。这个模型矩阵包含了位移、缩放与旋转操作，它们会被应用到所有物体的顶点上，以变换它们到全局的世界空间。让我们变换一下我们的平面，将其绕着x轴旋转，使它看起来像放在地上一样。这个模型矩阵看起来是这样的： 12glm::mat4 model = glm::mat4(1.0f);model = glm::rotate(model, glm::radians(-55.0f), glm::vec3(1.0f, 0.0f, 0.0f)); 通过将顶点坐标乘以这个模型矩阵，我们将该顶点坐标变换到世界坐标。我们的平面看起来就是在地板上，代表全局世界里的平面。 接下来我们需要创建一个观察矩阵。我们想要在场景里面稍微往后移动，以使得物体变成可见的（当在世界空间时，我们位于原点(0,0,0)）。要想在场景里面移动，先仔细想一想下面这个句子： 将摄像机向后移动，和将整个场景向前移动是一样的。 这正是观察矩阵所做的，我们以相反于摄像机移动的方向移动整个场景。因为我们想要往后移动，并且OpenGL是一个右手坐标系(Right-handed System)，所以我们（摄像机）需要沿着z轴的正方向移动。我们会通过将场景沿着z轴负方向平移来实现。它会给我们一种我们在往后移动的感觉。 右手坐标系(Right-handed System)：按照惯例，OpenGL是一个右手坐标系。简单来说，就是正x轴在你的右手边，正y轴朝上，而正z轴是朝向后方的。想象你的屏幕处于三个轴的中心，则正z轴穿过你的屏幕朝向你。坐标系画起来如下： 为了理解为什么被称为右手坐标系，按如下的步骤做： 沿着正y轴方向伸出你的右臂，手指着上方； 大拇指指向右方； 食指指向上方； 中指向下弯曲90度。 如果你的动作正确，那么你的大拇指指向正x轴方向，食指指向正y轴方向，中指指向正z轴方向。如果你用左臂来做这些动作，你会发现z轴的方向是相反的。这个叫做左手坐标系，它被DirectX广泛地使用。注意在标准化设备坐标系中OpenGL实际上使用的是左手坐标系（投影矩阵交换了左右手）。 就目前来说，观察矩阵是这样的： 1234glm::mat4 view = glm::mat4(1.0f);// 注意，我们将矩阵向我们要进行移动场景的反方向移动// 因为这里真正移动的东西是场景而不是相机view = glm::translate(view, glm::vec3(0.0f, 0.0f, -3.0f)); 最后我们需要做的是定义一个投影矩阵。我们希望在场景中使用透视投影，所以像这样声明一个投影矩阵： 12glm::mat4 projection = glm::mat4(1.0f);projection = glm::perspective(glm::radians(45.0f), screenWidth / screenHeight, 0.1f, 100.0f); 既然我们已经创建了变换矩阵，我们应该将它们传入顶点着色器。首先，让我们在顶点着色器中声明一个uniform变换矩阵然后将它乘以顶点坐标： 123456789101112#version 330 corelayout (location = 0) in vec3 aPos;...uniform mat4 model;uniform mat4 view;uniform mat4 projection;void main() { // 注意乘法要从右向左读 gl_Position = projection * view * model * vec4(aPos, 1.0); ...} 我们还应该将矩阵传入顶点着色器（这通常在每次的渲染迭代中进行，因为变换矩阵会经常变动）： 123456int modelLoc = glGetUniformLocation(ourShader.ID, &quot;model&quot;);glUniformMatrix4fv(modelLoc, 1, GL_FALSE, glm::value_ptr(model));int viewLoc = glGetUniformLocation(ourShader.ID, &quot;view&quot;);glUniformMatrix4fv(viewLoc, 1, GL_FALSE, glm::value_ptr(view));int projectionLoc = glGetUniformLocation(ourShader.ID, &quot;projection&quot;);glUniformMatrix4fv(projectionLoc, 1, GL_FALSE, glm::value_ptr(projection)); 我们的顶点坐标已经使用模型、观察和投影矩阵进行变换了，最终的物体应该会： 稍微向后倾斜至地板方向； 离我们有一些距离； 有透视效果（顶点越远，变得越小）。 更多的3D到目前为止，我们一直都在使用一个2D平面，而且甚至是在3D空间里！所以，让我们大胆地拓展我们的2D平面为一个3D立方体。要想渲染一个立方体，我们一共需要36个顶点（6个面 x 每个面有2个三角形组成 x 每个三角形有3个顶点）。 12345678910111213141516171819202122232425262728293031323334353637383940414243float vertices[] = { -0.5f, -0.5f, -0.5f, 0.0f, 0.0f, 0.5f, -0.5f, -0.5f, 1.0f, 0.0f, 0.5f, 0.5f, -0.5f, 1.0f, 1.0f, 0.5f, 0.5f, -0.5f, 1.0f, 1.0f, -0.5f, 0.5f, -0.5f, 0.0f, 1.0f, -0.5f, -0.5f, -0.5f, 0.0f, 0.0f, -0.5f, -0.5f, 0.5f, 0.0f, 0.0f, 0.5f, -0.5f, 0.5f, 1.0f, 0.0f, 0.5f, 0.5f, 0.5f, 1.0f, 1.0f, 0.5f, 0.5f, 0.5f, 1.0f, 1.0f, -0.5f, 0.5f, 0.5f, 0.0f, 1.0f, -0.5f, -0.5f, 0.5f, 0.0f, 0.0f, -0.5f, 0.5f, 0.5f, 1.0f, 0.0f, -0.5f, 0.5f, -0.5f, 1.0f, 1.0f, -0.5f, -0.5f, -0.5f, 0.0f, 1.0f, -0.5f, -0.5f, -0.5f, 0.0f, 1.0f, -0.5f, -0.5f, 0.5f, 0.0f, 0.0f, -0.5f, 0.5f, 0.5f, 1.0f, 0.0f, 0.5f, 0.5f, 0.5f, 1.0f, 0.0f, 0.5f, 0.5f, -0.5f, 1.0f, 1.0f, 0.5f, -0.5f, -0.5f, 0.0f, 1.0f, 0.5f, -0.5f, -0.5f, 0.0f, 1.0f, 0.5f, -0.5f, 0.5f, 0.0f, 0.0f, 0.5f, 0.5f, 0.5f, 1.0f, 0.0f, -0.5f, -0.5f, -0.5f, 0.0f, 1.0f, 0.5f, -0.5f, -0.5f, 1.0f, 1.0f, 0.5f, -0.5f, 0.5f, 1.0f, 0.0f, 0.5f, -0.5f, 0.5f, 1.0f, 0.0f, -0.5f, -0.5f, 0.5f, 0.0f, 0.0f, -0.5f, -0.5f, -0.5f, 0.0f, 1.0f, -0.5f, 0.5f, -0.5f, 0.0f, 1.0f, 0.5f, 0.5f, -0.5f, 1.0f, 1.0f, 0.5f, 0.5f, 0.5f, 1.0f, 0.0f, 0.5f, 0.5f, 0.5f, 1.0f, 0.0f, -0.5f, 0.5f, 0.5f, 0.0f, 0.0f, -0.5f, 0.5f, -0.5f, 0.0f, 1.0f}; 为了有趣一点，我们将让立方体随着时间旋转： 1model = glm::rotate(model, (float)glfwGetTime() * glm::radians(50.0f), glm::vec3(0.5f, 1.0f, 0.0f)); 然后我们使用glDrawArrays来绘制立方体，但这一次总共有36个顶点： 1glDrawArrays(GL_TRIANGLES, 0, 36); 这的确有点像是一个立方体，但又有种说不出的奇怪。立方体的某些本应被遮挡住的面被绘制在了这个立方体其他面之上。之所以这样是因为OpenGL是一个三角形一个三角形地来绘制你的立方体的，所以即便之前那里有东西它也会覆盖之前的像素。因为这个原因，有些三角形会被绘制在其它三角形上面，虽然它们本不应该是被覆盖的。 幸运的是，OpenGL存储深度信息在一个叫做Z缓冲(Z-buffer)的缓冲中，它允许OpenGL决定何时覆盖一个像素而何时不覆盖。通过使用Z缓冲，我们可以配置OpenGL来进行深度测试。 Z缓冲OpenGL存储它的所有深度信息于一个Z缓冲(Z-buffer)中，也被称为深度缓冲(Depth Buffer)。GLFW会自动为你生成这样一个缓冲（就像它也有一个颜色缓冲来存储输出图像的颜色）。深度值存储在每个片段里面（作为片段的z值），当片段想要输出它的颜色时，OpenGL会将它的深度值和z缓冲进行比较，如果当前的片段在其它片段之后，它将会被丢弃，否则将会覆盖。这个过程称为深度测试(Depth Testing)，它是由OpenGL自动完成的。 然而，如果我们想要确定OpenGL真的执行了深度测试，首先我们要告诉OpenGL我们想要启用深度测试，它默认是关闭的。我们可以通过glEnable函数来开启深度测试。glEnable和glDisable函数允许我们启用或禁用某个OpenGL功能。这个功能会一直保持启用/禁用状态，直到另一个调用来禁用/启用它。现在我们想启用深度测试，需要开启GL_DEPTH_TEST： 1glEnable(GL_DEPTH_TEST); 因为我们使用了深度测试，我们也想要在每次渲染迭代之前清除深度缓冲（否则前一帧的深度信息仍然保存在缓冲中）。就像清除颜色缓冲一样，我们可以通过在glClear函数中指定DEPTH_BUFFER_BIT位来清除深度缓冲： 1glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT); 更多的立方体！现在我们想在屏幕上显示10个立方体。每个立方体看起来都是一样的，区别在于它们在世界的位置及旋转角度不同。立方体的图形布局已经定义好了，所以当渲染更多物体的时候我们不需要改变我们的缓冲数组和属性数组，我们唯一需要做的只是改变每个对象的模型矩阵来将立方体变换到世界坐标系中。 首先，让我们为每个立方体定义一个位移向量来指定它在世界空间的位置。我们将在一个glm::vec3数组中定义10个立方体位置： 123456789101112glm::vec3 cubePositions[] = { glm::vec3( 0.0f, 0.0f, 0.0f), glm::vec3( 2.0f, 5.0f, -15.0f), glm::vec3(-1.5f, -2.2f, -2.5f), glm::vec3(-3.8f, -2.0f, -12.3f), glm::vec3( 2.4f, -0.4f, -3.5f), glm::vec3(-1.7f, 3.0f, -7.5f), glm::vec3( 1.3f, -2.0f, -2.5f), glm::vec3( 1.5f, 2.0f, -2.5f), glm::vec3( 1.5f, 0.2f, -1.5f), glm::vec3(-1.3f, 1.0f, -1.5f) }; 现在，在游戏循环中，我们调用glDrawArrays 10次，但这次在我们渲染之前每次传入一个不同的模型矩阵到顶点着色器中。我们将会在游戏循环中创建一个小的循环用不同的模型矩阵渲染我们的物体10次。注意我们也对每个箱子加了一点旋转： 123456789101112glBindVertexArray(VAO);for(unsigned int i = 0; i &lt; 10; i++) { glm::mat4 model = glm::mat4(1.0f);; model = glm::translate(model, cubePositions[i]); float angle = 20.0f * i; model = glm::rotate(model, (float)glfwGetTime() * glm::radians(angle), glm::vec3(1.0f, 0.3f, 0.5f)); // 这里需要给之前的Shader类添加一个setMat4函数 ，具体写法为： // glUniformMatrix4fv(glGetUniformLocation(ID, name.c_str()), 1, GL_FALSE, &amp;mat[0][0]); ourShader.setMat4(&quot;model&quot;, model); glDrawArrays(GL_TRIANGLES, 0, 36);} 练习题 对GLM的projection函数中的FoV和aspect-ratio参数进行实验。看能否搞懂它们是如何影响透视平截头体的； 将观察矩阵在各个方向上进行位移，来看看场景是如何改变的。注意把观察矩阵当成摄像机对象； 使用模型矩阵只让是3倍数的箱子旋转（以及第1个箱子），而让剩下的箱子保持静止。 摄像机前面的教程中我们讨论了观察矩阵以及如何使用观察矩阵移动场景（我们向后移动了一点）。OpenGL本身没有摄像机(Camera)的概念，但我们可以通过把场景中的所有物体往相反方向移动的方式来模拟出摄像机，产生一种我们在移动的感觉，而不是场景在移动。 本节我们将会讨论如何在OpenGL中配置一个摄像机，并且将会讨论FPS风格的摄像机，让你能够在3D场景中自由移动。我们也会讨论键盘和鼠标输入，最终完成一个自定义的摄像机类。 摄像机/观察空间当我们讨论摄像机/观察空间(Camera/View Space)的时候，是在讨论以摄像机的视角作为场景原点时场景中所有的顶点坐标：观察矩阵把所有的世界坐标变换为相对于摄像机位置与方向的观察坐标。要定义一个摄像机，我们需要它在世界空间中的位置、观察的方向、一个指向它右侧的向量以及一个指向它上方的向量。细心的读者可能已经注意到我们实际上创建了一个三个单位轴相互垂直的、以摄像机的位置为原点的坐标系。 摄像机位置 获取摄像机位置很简单。摄像机位置简单来说就是世界空间中一个指向摄像机位置的向量。我们把摄像机位置设置为上一节中的那个相同的位置： 1glm::vec3 cameraPos = glm::vec3(0.0f, 0.0f, 3.0f); 摄像机方向 下一个需要的向量是摄像机的方向，这里指的是摄像机指向哪个方向。现在我们让摄像机指向场景原点：``(0, 0, 0)。还记得如果将两个矢量相减，我们就能得到这两个矢量的差吗？用场景原点向量减去摄像机位置向量的结果就是摄像机的指向向量。由于我们知道摄像机指向z轴负方向，但我们希望方向向量(Direction Vector)指向摄像机的z轴正方向。如果我们交换相减的顺序，我们就会获得一个指向摄像机正z轴方向的向量： 12glm::vec3 cameraTarget = glm::vec3(0.0f, 0.0f, 0.0f);glm::vec3 cameraDirection = glm::normalize(cameraPos - cameraTarget); 方向向量(Direction Vector)并不是最好的名字，因为它实际上指向从它到目标向量的相反方向（译注：注意看前面的那个图，蓝色的方向向量大概指向z轴的正方向，与摄像机实际指向的方向是正好相反的）。 右轴 我们需要的另一个向量是一个右向量(Right Vector)，它代表摄像机空间的x轴的正方向。为获取右向量我们需要先使用一个小技巧：先定义一个上向量(Up Vector)。接下来把上向量和第二步得到的方向向量进行叉乘。两个向量叉乘的结果会同时垂直于两向量，因此我们会得到指向x轴正方向的那个向量（如果我们交换两个向量叉乘的顺序就会得到相反的指向x轴负方向的向量）： 123glm::vec3 up = glm::vec3(0.0f, 1.0f, 0.0f);// 注意叉乘的顺序，右手系glm::vec3 cameraRight = glm::normalize(glm::cross(up, cameraDirection)); 上轴 现在我们已经有了x轴向量和z轴向量，获取一个指向摄像机的正y轴向量就相对简单了：我们把方向向量和右向量进行叉乘： 12// 注意叉乘顺序，右手系glm::vec3 cameraUp = glm::cross(cameraDirection, cameraRight); 对于想学到更多数学原理的读者，提示一下，在线性代数中这个处理叫做格拉姆—施密特正交化(Gram-Schmidt Process)。使用这些摄像机向量我们就可以创建一个LookAt矩阵了，它在创建摄像机的时候非常有用。 Look At使用矩阵的好处之一是如果你使用3个相互垂直（或非线性）的轴定义了一个坐标空间，你可以用这3个轴外加一个平移向量来创建一个矩阵，并且你可以用这个矩阵乘以任何向量来将其变换到那个坐标空间。这正是LookAt矩阵所做的，现在我们有了3个相互垂直的轴和一个定义摄像机空间的位置坐标，我们可以创建我们自己的LookAt矩阵了： 其中R是右向量，U是上向量，D是方向向量，P是摄像机位置向量。注意，位置向量是相反的，因为我们最终希望把世界平移到与我们自身移动的相反方向。把这个LookAt矩阵作为观察矩阵可以很高效地把所有世界坐标变换到刚刚定义的观察空间。LookAt矩阵就像它的名字表达的那样：它会创建一个看着(Look at)给定目标的观察矩阵。 幸运的是，GLM已经提供了这些支持。我们要做的只是定义一个摄像机位置，一个目标位置和一个表示世界空间中的上向量的向量（我们计算右向量使用的那个上向量）。接着GLM就会创建一个LookAt矩阵，我们可以把它当作我们的观察矩阵： 1234glm::mat4 view = glm::mat4(1.0f);view = glm::lookAt(glm::vec3(0.0f, 0.0f, 3.0f), // position glm::vec3(0.0f, 0.0f, 0.0f), // target position glm::vec3(0.0f, 1.0f, 0.0f)); // up vector glm::LookAt函数需要一个位置、目标和上向量。它会创建一个和在上一节使用的一样的观察矩阵。 在讨论用户输入之前，我们先来做些有意思的事，把我们的摄像机在场景中旋转。我们会将摄像机的注视点保持在(0, 0, 0)。 123456789float radius = 10.f;float camX = sin(glfwGetTime()) * radius;float camZ = cos(glfwGetTime()) * radius;glm::mat4 view = glm::mat4(1.0f);view = glm::lookAt( glm::vec3(camX, 0.0f, camZ), // position glm::vec3(0.0f, 0.0f, 0.0f), // target glm::vec3(0.0f, 1.0f, 0.0f) // up-vec); 自由移动1234glm::vec3 cameraPos = glm::vec3(0.0f, 0.0f, 3.0f);glm::vec3 cameraFront = glm::vec3(0.0f, 0.0f, -1.0f);glm::vec3 cameraUp = glm::vec3(0.0f, 1.0f, 0.0f);glm::vec3 cameraRight = glm::normalize(glm::cross(cameraFront, cameraUp)); 注意，我们对右向量进行了标准化。如果我们没对这个向量进行标准化，最后的叉乘结果会根据cameraFront变量返回大小不同的向量。如果我们不对向量进行标准化，我们就得根据摄像机的朝向不同加速或减速移动了，但如果进行了标准化移动就是匀速的。 LookAt函数现在成了： 1glm::mat4 view = glm::lookAt(cameraPos, cameraPos + cameraFront, cameraUp); 我们已经为GLFW的键盘输入定义过一个process_input函数了，我们来新添加几个需要检查的按键命令： 12345678910111213float cameraSpeed = 0.05f; // adjust accordinglyif (glfwGetKey(window, GLFW_KEY_W) == GLFW_PRESS) { cameraPos += cameraSpeed * cameraFront;}if (glfwGetKey(window, GLFW_KEY_S) == GLFW_PRESS) { cameraPos -= cameraSpeed * cameraFront;}if (glfwGetKey(window, GLFW_KEY_A) == GLFW_PRESS) { cameraPos -= cameraSpeed * cameraRight;}if (glfwGetKey(window, GLFW_KEY_W) == GLFW_PRESS) { cameraPos += cameraSpeed * cameraRight;} 移动速度目前我们的移动速度是个常量。理论上没什么问题，但是实际情况下根据处理器的能力不同，有些人可能会比其他人每秒绘制更多帧，也就是以更高的频率调用process_input函数。结果就是，根据配置的不同，有些人可能移动很快，而有些人会移动很慢。当你发布你的程序的时候，你必须确保它在所有硬件上移动速度都一样。 图形程序和游戏通常会跟踪一个时间差(Deltatime)变量，它储存了渲染上一帧所用的时间。我们把所有速度都去乘以deltaTime值。结果就是，如果我们的deltaTime很大，就意味着上一帧的渲染花费了更多时间，所以这一帧的速度需要变得更高来平衡渲染所花去的时间。使用这种方法时，无论你的电脑快还是慢，摄像机的速度都会相应平衡，这样每个用户的体验就都一样了。 我们跟踪两个全局变量来计算出deltaTime值： 12float deltaTime = 0.0f; // 当前帧与上一帧的时间差float lastFrame = 0.0f; // 上一帧的时间 在每一帧中我们计算出新的deltaTime以备后用。 123float currentFrame = glfwGetTime();deltaTime = currentFrame - lastFrame;lastFrame = currentFrame; 现在我们有了deltaTime，在计算速度的时候可以将其考虑进去了： 1float cameraSpeed = 2.5f * deltaTime; 现在我们有了一个在任何系统上移动速度都一样的摄像机（近似一样）。 视角移动现在还不能转向，移动很受限制，是时候加入鼠标了！ 为了能够改变视角，我们需要根据鼠标的输入来该表cameraFront向量，然而，根据鼠标移动改变方向向量有点复杂，需要一些三角学知识。 欧拉角 欧拉角(Euler Angle)是可以表示3D空间中任何旋转的3个值，由莱昂哈德·欧拉(Leonhard Euler)在18世纪提出。一共有3种欧拉角：俯仰角(Pitch)、偏航角(Yaw)和滚转角(Roll)，下面的图片展示了它们的含义： 俯仰角是描述我们如何往上或往下看的角，可以在第一张图中看到。第二张图展示了偏航角，偏航角表示我们往左和往右看的程度。滚转角代表我们如何翻滚摄像机，通常在太空飞船的摄像机中使用。每个欧拉角都有一个值来表示，把三个角结合起来我们就能够计算3D空间中任何的旋转向量了。 对于我们的摄像机系统来说，我们只关心俯仰角和偏航角，所以我们不会讨论滚转角。给定一个俯仰角和偏航角，我们可以把它们转换为一个代表新的方向向量的3D向量。俯仰角和偏航角转换为方向向量的处理需要一些三角学知识，我们先从最基本的情况开始： 如果我们把斜边边长定义为1，我们就能知道邻边的长度是cos(x/h)=cos(x/1)=cosx，它的对边是sin(y/h)=sin(y/1)=siny。这样我们获得了能够得到x和y方向长度的通用公式，它们取决于所给的角度。我们使用它来计算方向向量的分量： 这个三角形看起来和前面的三角形很像，所以如果我们想象自己在xz平面上，看向y轴，我们可以基于第一个三角形计算来计算它的长度/y方向的强度(Strength)（我们往上或往下看多少）。从图中我们可以看到对于一个给定俯仰角的y值等于sinθ： 1direction.y = sin(glm::radians(pitch)); // 注意我们先把角度转为弧度 这里我们只更新了y值，仔细观察x和z分量也被影响了。从三角形中我们可以看到它们的值等于： 12direction.x = cos(glm::radians(pitch));direction.z = cos(glm::radians(pitch)); 看看我们是否能够为偏航角找到需要的分量： 就像俯仰角的三角形一样，我们可以看到x分量取决于cos(yaw)的值，z值同样取决于偏航角的正弦值。把这个加到前面的值中，会得到基于俯仰角和偏航角的方向向量： 1234direction.x = cos(glm::radians(pitch)) * cos(glm::radians(yaw));// 译注：direction代表摄像机的前轴(Front)，这个前轴是和本文第一幅图片的第二个摄像机的方向向量是相反的direction.y = sin(glm::radians(pitch));direction.z = cos(glm::radians(pitch)) * sin(glm::radians(yaw)); 这样我们就有了一个可以把俯仰角和偏航角转化为用来自由旋转视角的摄像机的3维方向向量了。你可能会奇怪：我们怎么得到俯仰角和偏航角？ 鼠标输入 偏航角和俯仰角是通过鼠标（或手柄）移动获得的，水平的移动影响偏航角，竖直的移动影响俯仰角。它的原理就是，储存上一帧鼠标的位置，在当前帧中我们当前计算鼠标位置与上一帧的位置相差多少。如果水平/竖直差别越大那么俯仰角或偏航角就改变越大，也就是摄像机需要移动更多的距离。 首先我们要告诉GLFW，它应该隐藏光标，并捕捉(Capture)它。捕捉光标表示的是，如果焦点在你的程序上（译注：即表示你正在操作这个程序，Windows中拥有焦点的程序标题栏通常是有颜色的那个，而失去焦点的程序标题栏则是灰色的），光标应该停留在窗口中（除非程序失去焦点或者退出）。我们可以用一个简单地配置调用来完成： 1glfwSetInputMode(window, GLFW_CURSOR, GLFW_CURSOR_DISABLED); 在调用这个函数之后，无论我们怎么去移动鼠标，光标都不会显示了，它也不会离开窗口（避免移出窗口就不能再旋转摄像机了）。对于FPS摄像机系统来说非常完美。 为了计算俯仰角和偏航角，我们需要让GLFW监听鼠标移动事件。（和键盘输入相似）我们会用一个回调函数来完成，函数的原型如下： 1void mouse_callback(GLFWwindow* window, double xpos, double ypos); 这里的xpos和ypos代表当前鼠标的位置。当我们用GLFW注册了回调函数之后，鼠标一移动mouse_callback函数就会被调用： 1glfwSetCursorPosCallback(window, mouse_callback); 在处理FPS风格摄像机的鼠标输入的时候，我们必须在最终获取方向向量之前做下面这几步： 计算鼠标距上一帧的偏移量； 把偏移量添加到摄像机的俯仰角和偏航角中； 对偏航角和俯仰角进行最大和最小值的限制（视野限制）； 计算方向向量。 第一步是计算鼠标自上一帧的偏移量。我们必须先在程序中储存上一帧的鼠标位置，我们把它的初始值设置为屏幕的中心（屏幕的尺寸是800x600）： 1float lastX = 400, lastY = 300; 然后在鼠标的回调函数中我们计算当前帧和上一帧鼠标位置的偏移量： 123456789float xoffset = xpos - lastX;// 注意这里是相反的，因为y坐标是从底部往顶部依次增大的float yoffset = lastY - ypos;lastX = xpos;lastY = ypos;float sensitivity = 0.05f;xoffset *= sensitivity;yoffset *= sensitivity; 注意我们把偏移量乘以了sensitivity（灵敏度）值。如果我们忽略这个值，鼠标移动就会太大了；你可以自己实验一下，找到适合自己的灵敏度值。 接下来我们把偏移量加到全局变量pitch和yaw上： 12yaw += xoffset;pitch += yoffset; 第三步，我们需要给摄像机添加一些限制，这样摄像机就不会发生奇怪的移动了（这样也会避免一些奇怪的问题）。对于俯仰角，要让用户不能看向高于89度的地方（在90度时视角会发生逆转，所以我们把89度作为极限），同样也不允许小于-89度。这样能够保证用户只能看到天空或脚下，但是不能超越这个限制。我们可以在值超过限制的时候将其改为极限值来实现： 1234if(pitch &gt; 89.0f) pitch = 89.0f;if(pitch &lt; -89.0f) pitch = -89.0f; 注意我们没有给偏航角设置限制，这是因为我们不希望限制用户的水平旋转。当然，给偏航角设置限制也很容易，如果你愿意可以自己实现。 第四也是最后一步，就是通过俯仰角和偏航角来计算以得到真正的方向向量： 12345glm::vec3 front;front.x = cos(glm::radians(pitch)) * cos(glm::radians(yaw));front.y = sin(glm::radians(pitch));front.z = cos(glm::radians(pitch)) * sin(glm::radians(yaw));cameraFront = glm::normalize(front); 计算出来的方向向量就会包含根据鼠标移动计算出来的所有旋转了。由于cameraFront向量已经包含在GLM的lookAt函数中，我们这就没什么问题了。 如果你现在运行代码，你会发现在窗口第一次获取焦点的时候摄像机会突然跳一下。这个问题产生的原因是，在你的鼠标移动进窗口的那一刻，鼠标回调函数就会被调用，这时候的xpos和ypos会等于鼠标刚刚进入屏幕的那个位置。这通常是一个距离屏幕中心很远的地方，因而产生一个很大的偏移量，所以就会跳了。我们可以简单的使用一个bool变量检验我们是否是第一次获取鼠标输入，如果是，那么我们先把鼠标的初始位置更新为xpos和ypos值，这样就能解决这个问题；接下来的鼠标移动就会使用刚进入的鼠标位置坐标来计算偏移量了： 123456// 这个bool变量初始时是设定为true的if(firstMouse) { lastX = xpos; lastY = ypos; firstMouse = false;} 最后mouse_callback的代码应该是这样的： 123456789101112131415161718192021222324252627282930313233343536373839404142void mouse_callback(GLFWwindow* window, double xpos, double ypos) { // 这个bool变量初始时是设定为true的 if (firstMouse) { lastX = xpos; lastY = ypos; firstMouse = false; } // 偏航角从-90度开始，鼠标向左移动，值变的更小 // 视角要朝左旋转的话，就要更小的偏航角值 // 所以直接加上 xpose - lastX即可 float xoffset = xpos - lastX; // 而俯仰角是相反的，鼠标向上移动，值变的更小 // 视角要朝上旋转的话，就要更大的俯仰角 // 所以要反过来减两个坐标的差值 float yoffset = lastY - ypos; lastX = xpos; lastY = ypos; float sensitivity = 0.05f; xoffset *= sensitivity; yoffset *= sensitivity; yaw += xoffset; pitch += yoffset; if (pitch &gt; 89.0f) { pitch = 89.0f; } if (pitch &lt; -89.0f) { pitch = -89.0f; } glm::vec3 front; front.x = cos(glm::radians(pitch)) * cos(glm::radians(yaw)); front.y = sin(glm::radians(pitch)); front.z = cos(glm::radians(pitch)) * sin(glm::radians(yaw)); cameraFront = glm::normalize(front); // 其实还要重新计算Right和Up向量 // 否则变换角度后 左右移动会发生异常 cameraRight = glm::normalize(glm::cross(cameraFront, worldUp)); cameraUp = glm::normalize(glm::cross(cameraRight, cameraFront));} 计算cameraFront这部分放在mouse_callback中可能更适合一点，因为它只有在鼠标移动的时候才会发生改变，如果放在渲染循环中，计算可能是比较冗余的，因为其实有可能在几个帧中间鼠标并没有发生移动，所以没有必要去计算。 缩放 作为我们摄像机系统的一个附加内容，我们还会来实现一个缩放(Zoom)接口。在之前的教程中我们说视野(Field of View)或fov定义了我们可以看到场景中多大的范围。当视野变小时，场景投影出来的空间就会减小，产生放大(Zoom In)了的感觉。我们会使用鼠标的滚轮来放大和缩小。与鼠标移动、键盘输入一样，我们需要一个鼠标滚轮的回调函数： 123456789void scroll_callback(GLFWwindow* window, double xoffset, double yoffset){ if(fov &gt;= 1.0f &amp;&amp; fov &lt;= 45.0f) fov -= yoffset; if(fov &lt;= 1.0f) fov = 1.0f; if(fov &gt;= 45.0f) fov = 45.0f;} 当滚动鼠标滚轮的时候，yoffset值代表我们竖直滚动的大小。当scroll_callback函数被调用后，我们改变全局变量fov变量的内容。因为45.0f是默认的视野值，我们将会把缩放级别(Zoom Level)限制在1.0f到45.0f。 我们现在在每一帧都必须把透视投影矩阵上传到GPU，但现在使用fov变量作为它的视野： 1projection = glm::perspective(glm::radians(fov), 800.0f / 600.0f, 0.1f, 100.0f); 最后不要忘记注册鼠标滚轮的回调函数： 1glfwSetScrollCallback(window, scroll_callback); 现在，我们就实现了一个简单的摄像机系统了，它能够让我们在3D环境中自由移动。 注意，使用欧拉角的摄像机系统并不完美。根据你的视角限制或者是配置，你仍然可能引入万向节死锁问题。最好的摄像机系统是使用四元数(Quaternions)的，但我们将会把这个留到后面讨论。 摄像机类接下来的教程中，我们将会一直使用一个摄像机来浏览场景，从各个角度观察结果。然而，由于一个摄像机会占用每篇教程很大的篇幅，我们将会从细节抽象出来，创建我们自己的摄像机对象，它会完成大多数的工作，而且还会提供一些附加的功能。与着色器教程不同，我们不会带你一步一步创建摄像机类，我们只会提供你一份（有完整注释的）代码，如果你想知道它的内部构造的话可以自己去阅读。 和着色器对象一样，我们把摄像机类写在一个单独的头文件中。 1 我们介绍的摄像机系统是一个FPS风格的摄像机，它能够满足大多数情况需要，而且与欧拉角兼容，但是在创建不同的摄像机系统，比如飞行模拟摄像机，时就要当心。每个摄像机系统都有自己的优点和不足，所以确保对它们进行了详细研究。比如，这个FPS摄像机不允许俯仰角大于90度，而且我们使用了一个固定的上向量(0, 1, 0)，这在需要考虑滚转角的时候就不能用了。 词汇复习 OpenGL：一个定义了函数布局和输出的图形API的正式规范； GLAD：一个拓展加载库，用来为我们加载并设定所有OpenGL函数指针，从而让我们能够使用所有（现代）OpenGL函数； 视口(Viewport)：我们需要渲染的窗口； 图形管线(Graphics Pipeline)：一个顶点在呈现为像素之前经过的全部过程； 着色器(Shader)：一个运行在显卡上的小型程序，很多阶段的图形管道都可以使用自定义的着色器来代替原有的功能，在OpenGL有些部分是我们必须提供的； 标准化设备坐标(Normalized Device Coordinates, NDC)：顶点在通过在剪裁坐标系中剪裁与透视除法后最终呈现在的坐标系。所有位置在NDC下-1.0到1.0的顶点将不会被丢弃并且可见； VBO-顶点缓冲对象(Vertex Buffer Object)：一个调用显存并存储所有顶点数据供显卡使用的缓冲对象； VAO-顶点数组对象(Vertex Array Object)：存储缓冲区和顶点属性状态； EBO-索引缓冲对象(Element Buffer Object)：一个存储索引供索引化绘制使用的缓冲对象； Uniform：一个特殊类型的GLSL变量。它是全局的（在一个着色器程序中每一个着色器都能够访问uniform变量），并且只需要被设定一次； 纹理(Texture)：一种包裹着物体的特殊类型图像，给物体精细的视觉效果； 纹理缠绕(Texture Wrapping)：定义了一种当纹理顶点超出范围(0, 1)时指定OpenGL如何采样纹理的模式； 纹理过滤(Texture Filtering)：定义了一种当有多种纹素选择时指定OpenGL如何采样纹理的模式。这通常在纹理被放大情况下发生； 多级渐远纹理(Mipmaps)：被存储的材质的一些缩小版本，根据距观察者的距离会使用材质的合适大小； stb_image.h：图像加载库； 纹理单元(Texture Units)：通过绑定纹理到不同纹理单元从而允许多个纹理在同一对象上渲染； 向量(Vector)：一个定义了在空间中方向和/或位置的数学实体； 矩阵(Matrix)：一个矩形阵列的数学表达式； GLM：一个为OpenGL打造的数学库； 局部空间(Local Space)：一个物体的初始空间。所有的坐标都是相对于物体的原点的； 世界空间(World Space)：所有的坐标都相对于全局原点； 观察空间(View Space)：所有的坐标都是从摄像机的视角观察的； 裁剪空间(Clip Space)：所有的坐标都是从摄像机视角观察的，但是该空间应用了投影。这个空间应该是一个顶点坐标最终的空间，作为顶点着色器的输出。OpenGL负责处理剩下的事情（裁剪/透视除法）； 屏幕空间(Screen Space)：所有的坐标都由屏幕视角来观察。坐标的范围是从0到屏幕的宽/高； LookAt矩阵：一种特殊类型的观察矩阵，它创建了一个坐标系，其中所有坐标都根据从一个位置正在观察目标的用户旋转或者平移； 欧拉角(Euler Angles)：被定义为偏航角(Yaw)，俯仰角(Pitch)，和滚转角(Roll)从而允许我们通过这三个值构造任何3D方向。","link":"/2021/01/23/learnopengl-c1/"},{"title":"《LeetCode》精选200题计划","text":"之后一个月(1.25~2.28)准备刷一下LeetCode的精选200题，题目大部分都是中等或者困难。 到时候会按照标签来刷，也会按标签总结这类题目的一些规律。","link":"/2021/01/24/leetcode-200-select/"}],"tags":[{"name":"笔记","slug":"笔记","link":"/tags/%E7%AC%94%E8%AE%B0/"}],"categories":[{"name":"3D游戏与图形学的数学","slug":"3D游戏与图形学的数学","link":"/categories/3D%E6%B8%B8%E6%88%8F%E4%B8%8E%E5%9B%BE%E5%BD%A2%E5%AD%A6%E7%9A%84%E6%95%B0%E5%AD%A6/"},{"name":"计划-Flags","slug":"计划-Flags","link":"/categories/%E8%AE%A1%E5%88%92-Flags/"},{"name":"剑指Offer","slug":"剑指Offer","link":"/categories/%E5%89%91%E6%8C%87Offer/"},{"name":"Real Time Rendering 4th","slug":"Real-Time-Rendering-4th","link":"/categories/Real-Time-Rendering-4th/"},{"name":"LearnOpenGL","slug":"LearnOpenGL","link":"/categories/LearnOpenGL/"}]}