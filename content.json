{"pages":[{"title":"关于我","text":"一个普普通通程序员，专攻(自封)图形学、实时渲染以及游戏引擎，其他领域的例如机器学习、深度学习、数据挖掘、后端开发、前端开发之类的，也都多少懂一点点，出于兴趣学习。 日常就是学点喜欢的技术，写点喜欢的代码，闲的时候画点画。 博客主要用于记载一些阅读书籍的笔记心得，偶尔放一些用于当作品集的炫酷Demo。 联系方式： 日常练习: augbubbles@foxmail.com 工作相关: mi.work@outlook.com","link":"/about/index.html"}],"posts":[{"title":"11月的计划","text":"11月大概还剩下一周的时间，主要是在尝试起步学一些东西： 《剑指Offer》：大概前几章，简单过一下摸一下这本书的安排规律，每章尽量写一点浓缩知识点； 《3D游戏与计算机图形学中的数学方法》：之前把Games101课程简单过了一下，再通过刷这本书巩固一下基础的数学。 12月的初步规划： 《剑指Offer》； 《3D游戏与计算机图形学中的数学方法》； 《Fundamentals of Computer Graphics》 。 1月的初步规划： 《Effictive C++》； 《Real Time Rendering 4th》； 《游戏引擎架构》。","link":"/2020/11/19/plan-2020/"},{"title":"《剑指Offer》第1章笔记","text":"第1章主要介绍的是几种面试方式的不同流程以及注意事项。 “…技术面试中的5个要素，是全书的大纲,…” 远程桌面面试 思考清楚再开始编码； 良好的代码命名和缩进对齐； 单元测试、断点调试。 面试的3个环节行为面试、技术面试、应聘者提问。 行为面试 自我介绍：30s-1min，介绍主要学习和工作经历； 项目经验：STAR模型描述项目经历； Situation：简短的项目背景； Task：自己完成的任务，注意区分“参与”和“负责”； Action：如何完成任务的，详细介绍自己完成任务的方式方法； Result：自己的贡献，尝试量化自己的产出，让人直接接收到你的成果。 掌握技能：注意区分“了解”、“熟悉”和“精通”； 了解：上过课、看过书，但没有做过实际项目，通常只建议有用的时候再写； 熟悉：通常的情况，指能够独立解决大部分问题； 精通：得心应手，能够轻松回答领域内的绝大多数问题。 为什么跳槽：尽量不说抱怨层面的原因，多从自我发展的角度阐述选择的理由。 技术面试平均1个小时的面试，技术面试会占据40-50分钟的时间。 总的来说面试官关注应聘者的5种素质： 扎实的基础知识：编程语言、数据结构和算法； 能写高质量的代码：代码鲁棒性，边界考虑（另外还需要注意代码规范或者风格）； 分析问题的思路清晰：从简单完备的思路出发，用各种方法来尝试优化，例如画图形象化，举例具象化，分解简单化； 能够优化时间、空间效率：熟知数据结构优缺点，熟练掌握常用算法； 学习、沟通、综合能力。 PS：5个要素分别对应本书的第2、3、4、5、6章节内容。 应聘者提问如果觉得面试后临时想比较困难，可以在面试前提前准备一些问题。 主要围绕公司、职位、项目等工作上的事情，不太适合问较远较模糊或者和工薪相关的问题（之后再和HR聊也可以）。","link":"/2020/11/24/s2o-c1/"},{"title":"《剑指Offer》第2章笔记 编程语言","text":"第2章主要围绕编程语言、数据结构和算法，介绍技术面所需要的“基础知识”。 编程语言书里代码都是用 C/C++/C# 实现的，后面分别从 C++ 和 C# 语言的角度来讲述其中一些被问道的细节点，这样的细节点因为篇幅限制，不可能都写进书里，所以还需要通过阅读对应编程语言的书籍来进阶了解，同时其他语言的使用者也可以从其中窥探到面试官在针对语言掌握的考量时，都是从什么样的角度出发的。 C++通常语言面试的问题有3种类型： 对于语言中概念的理解程度； 面对代码，分析运行结果（或错误）； 在上下文环境中，定义类型或实现函数。 作者推荐的几本C++书，根据自己的情况选择阅读顺序： 《Effective C++》：书中列举了C++经常出现的问题以及解决这些问题的技巧（大多是面试官比较喜欢问的方向），适合面试之前突击C++； 《C++ Primer》：人称C++全书，适合全面了解的时候阅读，也可以当作宝典查询； 《深度探索C++对象模型》：深度了解C++对象的内部机制，介绍很多较为底层的知识点； 《The C++ Programming Language》：C++圣经（大概），适合全面深入掌握C++。 下面通过一道面试题（第3种类型）来表现一下这类题目是如何考查语言知识点的。 面试题1：赋值运算符函数，如下为类型CMyString的声明，请为该类型添加赋值运算符函数。 123456789class CMyString { public: CMyString(char* pData=nullptr); CMyString(const CMyString&amp; str); ~CMyString(void); private: char* m_pData;}; Tips：赋值运算符主要负责变量在进行赋值 = 运算时，如何处理变量对象内部成员变化。 定义C++中的赋值运算符函数时，需要关注点有： 返回值类型声明为引用，函数结束前返回实例自身的引用，因为返回引用才允许连续赋值的情况，例如 str1 = str2 = str3，否则无法通过编译； 把传入的参数类型声明为常量引用，如果不是引用，形参到实参传递会调用一次复制构造函数（函数的传值引用），引用可以避免这样的开销；同时因为赋值运算并不会修改传入的实例的状态，所以应进一步加上 const 关键字； 释放实例自身已有的内存，主要在对象有动态分配内存情况下考虑，如果忘记在分配新内存前释放旧内存空间，程序旧出现了内存泄漏(memory leakge)，这块内存无法被回收使用（资源浪费、占用空间导致空间不够用）； 判断传入参数和当前实例(*this)是不是同一个实例，是则不进行赋值，如果不判断就直接赋值，在同一个实例情况下，会导致在还没有拷贝到传入参数（自己）的内存时，就释放自己的内存，这也就导致传入参数的内存被释放了（因为函数是传引用），最后找不到待赋值的内容。 经典解法： 123456789101112131415#include &lt;cstring&gt;CMyString&amp; CMyString::operator=(const CMyString&amp; str) { if(this == &amp;str) { // 对象的 this 是一个地址 return *this; // 传对象 而不是地址 } delete []m_pData; // 数组的释放方式 m_pData = nullptr; m_pData = new char[strlen(str.m_pData) + 1]; // 申请新空间，多的1位给'\\0' strcpy(m_pData, str.m_pData); // 复制 赋值 return *this;} 如果对自己有更高的要求，应该再进一步地考虑其中涉及到的问题。 前面的函数中，分配内存之前先释放了内存，如果在分配内存时，内存不足就会导致 new char 排除异常，m_pData将是一个空指针，并且无法回退到之前的结果，也就是说一旦赋值运算符内部抛出了异常，实例不再保持有效的状态（并不是原有的状态），这违背了异常安全性（Exception Safety）原则（正常情况下，如果抛出异常也不应该导致内容被错误操作）。 简单的方法是先用 new 分配新内容，再 delete 释放已有的； 更好的办法是创建一个临时实例，再交换临时实例和原来的实例。 12345678910#include &lt;cstring&gt;#include &lt;algorithm&gt;CMyString&amp; CMyString::operator=(const CMyString&amp; str) { if(this == &amp;str) { CMyString tmp(str); // 复制构造函数 std::swap(m_pData, tmp.m_pData); // 交换地址 } return *this;} 当 tmp 局部变量遇到 if 结束时，会自动调用它的析构函数，会把交换下来的 this 的 m_pData 所指向的内存释放掉；在新的代码中，在复制构造函数中分配内存，如果由于内存不足抛出异常时，由于此时还没有修改原来的实例状态，实例的状态依旧是有效的（原有的），也就保证了异常安全性。 完整代码（包含所有实现和测试）： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;class CMyString { public: CMyString(char* pData); // 第一个参数设定默认值会导致无法通过编译 CMyString(const CMyString&amp; str); ~CMyString(void); CMyString&amp; operator=(const CMyString&amp; str); // 赋值运算符函数声明 void print(void); // 标准输出函数 private: char* m_pData;};// 构造函数CMyString::CMyString(char* pData) { if(pData != nullptr) { m_pData = new char[strlen(pData) + 1]; strcpy(m_pData, pData); }}// 复制构造函数CMyString::CMyString(const CMyString&amp; str) { if(str.m_pData != nullptr) { m_pData = new char[strlen(str.m_pData) + 1]; strcpy(m_pData, str.m_pData); }}// 析构函数CMyString::~CMyString(void) { if(m_pData != nullptr) { delete []m_pData; m_pData = nullptr; }}void CMyString::print(void) { std::cout &lt;&lt; m_pData &lt;&lt; std::endl;}// 赋值运算符函数CMyString&amp; CMyString::operator=(const CMyString&amp; str) { if(this != &amp;str) { CMyString tmp(str); // 复制构造函数 std::swap(m_pData, tmp.m_pData); // 交换地址 } return *this;}int main() { // 测试CMyString CMyString str1(&quot;Sword&quot;); CMyString str2(&quot;2&quot;); CMyString str3(&quot;Offer&quot;); str1 = str2 = str3; str1.print(); // Offer str2.print(); // Offer str3.print(); // Offer return 0;} 如果完整的去实现上面这个题目，会引出一些非常容易忽略的细节问题（并且会导致严重错误），例如在初始化变量 str1 时，CMyString str1(&quot;Sword&quot;);，其中所传入的参数一般都是程序声明的字符串常量，如果在构造函数中简单地实现为： 1234// Mem ErrorCMyString::CMyString(char* pData) { m_pData = pData;} 就会导致赋值运算符函数中的析构函数调用过程发生错误，因为析构函数中的 delete []m_pData 的delete操作符只负责操作堆(Heap)中的内存区域(因为new只在堆里申请内存区域)，如果使用delete操作符去释放一个字符串常量指针所指向的区域，就会发生错误（大概是访问越界）。 所以在初始化时应该使用和delete对应的new操作，在堆中申请内存，再把传入参数的内容复制到其中。 123456CMyString::CMyString(char* pData) { if(pData != nullptr) { m_pData = new char[strlen(pData) + 1]; strcpy(m_pData, pData); }} C#因为还没怎么学C#的东西，C#的部分暂时跳过，记录一下推荐的书： 《Professional C#》：特点是附录中有描述C#和其他语言的区别； 《CLR Via C#》：深入介绍C#，对CLR和.NET进行剖析，可以方便理解装箱卸箱、垃圾回收、反射等概念。 面试题2：实现Singleton模式（单例模式） 暂时跳过。 涉及到设计模式的部分，列举一些可以参考阅读的资料： 《设计模式：C++常用设计模式》：https://refactoringguru.cn/design-patterns/cpp ； 《Head First 设计模式》：感觉是一本比较老的书，可能之后看看吧； 《Game Programming Patterns》：http://gameprogrammingpatterns.com/contents.html 。","link":"/2020/11/25/s2o-c2-lg/"},{"title":"《3D图形的数学》第1章笔记 向量","text":"对于成功的3D程序猿，掌握如何进行向量运算是一种基本的技能要求。 原书：《3D游戏与计算机图形学中的数学方法》 by Eric.Lengyel 1 向量的形式一个n维向量V可以表示为： $$ \\textbf{V} = < V_{1}, V_{2}, ... , V_{n} > \\tag{1.1} $$ 系数a和向量V的乘积可以定义为： $$ a\\textbf{V} = < aV_{1}, aV_{2}, ... , aV_{n} > \\tag{1.4} $$ 向量加减运算： $$ \\textbf{P} + \\textbf{Q} = < P_{1} + Q_{1}, P_{2} + Q_{2}, ... , P_{n} + Q_{n} > \\tag{1.5} $$ 【定理1.1】对于给定的任何两个系数a和b，以及任何三个向量P、Q和R，有以下运算规律： \\(\\textbf{P} + \\textbf{Q} = \\textbf{Q} + \\textbf{P}\\) \\((\\textbf{P} + \\textbf{Q}) + \\textbf{R} = \\textbf{P} + (\\textbf{Q} + \\textbf{R})\\) \\((ab)\\textbf{P} = a(b\\textbf{P})\\) \\(a(\\textbf{P} + \\textbf{Q}) = a\\textbf{P} + a\\textbf{Q}\\) \\((a + b)\\textbf{P} = a\\textbf{P} + b\\textbf{P}\\) n维向量V的模，||V||： $$ \\textbf{||V||} = \\sqrt{\\sum_{i=1}^{n} V_{i}^{2}} \\tag{1.6} $$ 模也称为向量的范数或者长度，模为1的向量称为单位向量。 设向量V表示一个三维点或方向，则公式(1.6)可以展开为： $$ \\textbf{||V||} = \\sqrt{V_{x}^{2} + V_{y}^{2} + V_{z}^{2}} \\tag{1.7} $$ 如果向量V至少有至少有一个非零分量，可以通过乘 \\(1/\\textbf{||V||}\\) 得到V方向上的一个单位向量，也叫做单位化、规格化。 【定理1.2】 对于任意给定系数a，任意的两个向量P和Q，有以下性质： \\( \\textbf{||P||} \\geq 0 \\) 当且仅当 \\( \\textbf{||P||}=&lt;0, 0, …, 0&gt; \\)时，\\( \\textbf{||P||}=0 \\) \\( \\textbf{||aP||}=|a|\\textbf{||P||} \\) \\( \\textbf{||P + Q||} \\leq \\textbf{||P||} + \\textbf{||Q||} \\) 其中的第4条，可以由三角不等式得到。 2 点积向量间的点积，也叫做数量积或内积，3D图形中经常用点积来度量两个向量指向的差异。 【定理1.3】 两个n维向量P和Q的点积，记作P·Q，即： $$ \\textbf{P} \\cdot \\textbf{Q} = \\sum_{i=1}^{n} P_{i}Q_{i} \\tag{1.9} $$ 向量的点积等于两个向量的对应分量乘积之和。 在三维空间中，有： $$ \\textbf{P} \\cdot \\textbf{Q} = P_{x}Q_{x} + P_{y}Q_{y} + P_{z}Q_{z} \\tag{1.10} $$ 【定理1.4】 对于给定的两个向量P和Q，点积满足公式： $$ \\textbf{P} \\cdot \\textbf{Q} = \\textbf{||P||}\\textbf{||Q||} cos \\alpha \\tag{1.12} $$ \\(\\alpha\\)是向量P和Q之间的夹角（详细的说是P和Q的起点、终点决定的平面夹角）。 Tips：定理1.4的证明要用到余弦定理，一个三角形有三条边\\(a,b,c\\)，\\(a,b\\)夹角是\\(\\alpha\\)时，三边满足等式关系\\(c^{2} = a^{2} + b^{2} - 2abcos\\alpha\\)。 定理1.4可以得出两个结论： 当且仅当 \\(\\textbf{P} \\cdot \\textbf{Q} = 0\\) 时， 向量P和向量Q相互垂直。点积为0的向量称为正交向量，零向量和任意向量正交； 点积正负号说明两个向量的方向情况，例如在看平面法线和平面外一点，可以查看点相对于平面的位置，是在法线同侧（点积为正）还是在不同侧（点积为负）。 【定理1.5】 对于任意给定系数a，任意的两个向量P和Q，有以下性质： \\( \\textbf{P} \\cdot \\textbf{Q} = \\textbf{Q} \\cdot \\textbf{P} \\) \\( (a\\textbf{P}) \\cdot \\textbf{Q} = a(\\textbf{P} \\cdot \\textbf{Q}) \\) \\( \\textbf{P} \\cdot (\\textbf{Q} + \\textbf{R}) = \\textbf{P} \\cdot \\textbf{Q} + \\textbf{P} \\cdot \\textbf{R} \\) \\( \\textbf{P} \\cdot \\textbf{P} = \\textbf{||P||}^{2} \\) \\( | \\textbf{P} \\cdot \\textbf{Q} | \\leq \\textbf{||P||} \\cdot \\textbf{||Q||} \\) 向量P在向量Q上的投影长度： $$ \\textbf{||P||}cos\\alpha = \\frac{\\textbf{P}\\cdot\\textbf{Q}}{\\textbf{||Q||}} \\tag{1.17} $$ 如果再乘以单位向量 \\( \\frac{\\textbf{Q}}{\\textbf{||Q||}} \\)，就可以得到具有该长度并且平行于Q的一个向量，即表示向量P到向量Q的投影，记作\\( proj_{\\textbf{Q}} \\textbf{P} \\)： $$ proj_{\\textbf{Q}}\\textbf{P} = \\frac{\\textbf{P} \\cdot \\textbf{Q}}{\\textbf{||Q||}^{2}} \\textbf{Q} \\tag{1.18} $$ P到Q的投影也可以看作是一个线性变换过程，所以可以表示为矩阵和向量乘积，三维情况下，\\( proj_{\\textbf{Q}} \\textbf{P} \\) 也可以用下面的公式计算： $$ proj_{\\textbf{Q}} \\textbf{P} = \\frac{1}{\\textbf{Q}^{2}} \\left[ \\begin{matrix} Q_{x}^{2} & Q_{x}Q_{y} & Q_{x}Q_{z} \\\\ Q_{x}Q_{y} & Q_{y}^{2} & Q_{y}Q_{z} \\\\ Q_{x}Q_{z} & Q_{y}Q_{z} & Q_{z}^{2} \\end{matrix} \\right] \\left[ \\begin{matrix} P_{x} \\\\ P_{y} \\\\ P_{z} \\end{matrix} \\right] \\tag{1.20} $$ 向量P相对于向量Q的垂直分量记作\\( perp_{\\textbf{Q}} \\textbf{P} \\)，可以用向量P减去投影分量得到垂直分量： $$ perp_{\\textbf{Q}} \\textbf{P} = \\textbf{P} - proj_{\\textbf{Q}} \\textbf{P} \\tag{1.19} $$ 3 叉积两个三维向量的叉积又称为向量积，结果是一个新的向量，这个向量垂直于原来的两个向量。 在3D图形学中，已知曲面上一点的两个不同方向的切向量，就可以通过求叉积得到曲面在该点的法向量。 【定义1.6】 两个3D向量P和Q的叉积记作 \\(\\textbf{P} \\times \\textbf{Q}\\)，结果向量为： $$ \\textbf{P} \\times \\textbf{Q} = < P_{y}Q_{z} - P_{z}Q_{y}, P_{z}Q_{x} - P_{x}Q_{z}, P_{x}Q_{y} - P_{y}Q_{x} > \\tag{1.21} $$ 便于记忆的一个工具是伪行列式： $$ \\textbf{P} \\times \\textbf{Q} = \\left| \\begin{matrix} i & j & k \\\\ P_{x} & P_{y} & P_{z} \\\\ Q_{x} & Q_{y} & Q_{z} \\end{matrix} \\right| \\tag{1.22} $$ 这里i,j,k是x,y,z轴的单位向量： $$ \\begin{aligned} \\textbf{i} &= \\\\ \\textbf{j} &= \\\\ \\textbf{k} &= \\end{aligned} \\tag{1.23} $$ 叉积\\(\\textbf{P} \\times \\textbf{Q}\\)也可以用线性变换的形式表示，变换矩阵派生于P，作用于Q： $$ \\textbf{P} \\times \\textbf{Q} = \\left[ \\begin{matrix} 0 & -P_{z} & P_{y} \\\\ P_{z} & 0 & -P_{x} \\\\ -P_{y} & P_{x} & 0 \\end{matrix} \\right] \\left[ \\begin{matrix} Q_{x} \\\\ Q_{y} \\\\ Q_{z} \\end{matrix} \\right] \\tag{1.25} $$ Tips：原书P7的公式(1.25)有疏漏，变换矩阵中出现了Q的分量。 对于任意给定的三个3D向量P、Q和R，等式 \\((\\textbf{P} \\times \\textbf{Q}) \\cdot \\textbf{R}\\) 的值可以通过伪行列式乘以R得到： $$ (\\textbf{P} \\times \\textbf{Q}) \\cdot \\textbf{R} = \\left| \\begin{matrix} R_{x} & R_{y} & R_{z} \\\\ P_{x} & P_{y} & P_{z} \\\\ Q_{x} & Q_{y} & Q_{z} \\end{matrix} \\right| = \\left| \\begin{matrix} P_{x} & P_{y} & P_{z} \\\\ Q_{x} & Q_{y} & Q_{z} \\\\ R_{x} & R_{y} & R_{z} \\end{matrix} \\right| \\tag{1.27} $$ Tips：行列式表达我在这里书写了两种表达形式，第一种是延续之前伪行列式的写法，只是将R替代了ijk的位置，第二种写法来自于书上，遵循PQR的出现次序的记忆法，两者的值根据初等变化法则是相等的。 如果P、Q和R中任何一个可以表示为其他两个向量的线性组合，则行列式的值为0（根据垂直法则和点积定理推导）。 【定理1.8】 对于给定的两个3D向量P和Q，叉积\\(\\textbf{P} \\times \\textbf{Q}\\)满足下面公式： $$ ||\\textbf{P} \\times \\textbf{Q}|| = \\textbf{||P||}\\textbf{||Q||}sin\\alpha \\tag{1.28} $$ \\(\\alpha\\)为P和Q的夹角。 由定理1.8可知，叉积\\(\\textbf{P} \\times \\textbf{Q}\\)的模等于由向量P和Q组成的平行四边形的面积。因此，一个三角形的顶点\\(V_{1}, V_{2}, V_{3}\\)，可以计算其面积A: $$ A = \\frac{1}{2} || (V_{2} - V_{1}) \\times (V_{3} - V_{1}) || \\tag{1.32} $$ 叉积得到的非零向量一定垂直于原本的两个向量，但满足要求的有两种方向，为了确定叉积方向，引入叉积遵循的右手法则。例如，使用右手手指指向P方向，手心朝向Q反向，则大拇指就是叉积\\(\\textbf{P} \\times \\textbf{Q}\\)的方向。 空间轴的单位向量ijk，按照圆形循环的方式排序，i在j之前，j在k之前，k在i之前，则这样的顺序叉积乘等于第三个向量： $$ \\begin{aligned} \\textbf{i} \\times \\textbf{j} &= \\textbf{k} \\\\ \\textbf{j} \\times \\textbf{k} &= \\textbf{i} \\\\ \\textbf{k} \\times \\textbf{i} &= \\textbf{j} \\end{aligned} \\tag{1.33} $$ 反之，按照相反的顺序相接的叉乘等于第三个向量的负值。 【定理1.9】 对于给定系数a，b和任意三个3D向量P、Q和R，有以下性质： \\( \\textbf{P} \\times \\textbf{Q} = - (\\textbf{Q} \\times \\textbf{P}) \\) \\( (a\\textbf{P}) \\times \\textbf{Q} = a(\\textbf{P} \\times \\textbf{Q}) \\) \\( \\textbf{P} \\times (\\textbf{Q} + \\textbf{R}) = \\textbf{P} \\times \\textbf{Q} + \\textbf{P} \\times \\textbf{R} \\) \\( \\textbf{P} \\times \\textbf{P} = \\textbf{0} = &lt;0, 0, 0&gt; \\) \\( (\\textbf{P} \\times \\textbf{Q}) \\cdot \\textbf{R} = (\\textbf{R} \\times \\textbf{P}) \\cdot \\textbf{Q} = (\\textbf{Q} \\times \\textbf{R}) \\cdot \\textbf{P} \\) （注意顺序，满足圆形循环） \\( \\textbf{P} \\times (\\textbf{Q} \\times \\textbf{P}) = \\textbf{P} \\times \\textbf{Q} \\times \\textbf{P} = \\textbf{P}^{2}\\textbf{Q} - (\\textbf{P} \\cdot \\textbf{Q}) \\textbf{P} \\) 前五条都比较容易证明，稍微说一下最后一条的证明方式： $$ \\begin{aligned} \\textbf{P} \\times (\\textbf{Q} \\times \\textbf{P}) &= \\textbf{P} \\times [-(\\textbf{P} \\times \\textbf{Q})] \\\\ &= [\\textbf{P} \\times -(\\textbf{P} \\times \\textbf{Q})] \\\\ &= -[-(\\textbf{P} \\times \\textbf{Q}) \\times \\textbf{P}] \\\\ &= (\\textbf{P} \\times \\textbf{Q}) \\times \\textbf{P} \\\\ &= \\textbf{P} \\times \\textbf{Q} \\times \\textbf{P} \\end{aligned} \\tag{1.35} $$ 后面的具体计算式，是通过对三个分量分别求值得到的结果，不再赘述。 由定理1.9可以得到 叉积不满足交换律和结合律。 4 向量空间【定理1.10】 向量空间是一个集合V，元素成为向量，下面定义向量空间中的加法和乘数，并介绍一些性质： V对于加法运算封闭； V对于乘数运算封闭； V中存在一个零元素 \\(\\textbf{0}\\)； V中任意向量P存在向量Q使其 \\( \\textbf{P} + \\textbf{Q} = \\textbf{0}\\)； 加法满足结合律； 乘数满足结合律； 乘数对于加法满足分配率，\\( a(\\textbf{P} + \\textbf{Q}) = a\\textbf{P} + a\\textbf{Q}\\)； 系数加法对于乘数满足分配率，\\( (a + b)\\textbf{P} = a\\textbf{P} + b\\textbf{P}\\)。 将由n元组组成的向量空间记作 \\(R^{n}\\)，比如三维的向量空间记作\\(R^{3}\\)。 每一个向量空间都可以由一组向量的线性组合来生成，生成向量空间的向量组成为基。 【定义1.11】 对于一组向量 {\\( \\textbf{e}_{1}, \\textbf{e}_{2}, …, \\textbf{e}_{n} \\)}，如果不存在这样一组实数 {\\(a_{1}, a_{2}, …, a_{n}\\)}，其中至少有一个 \\(a_{i}\\) 不为0，使得下式成立： $$ a_{1}\\textbf{e}_{1} + a_{2}\\textbf{e}_{2} + \\cdots + a_{n}\\textbf{e}_{n} = 0 \\tag{1.40} $$ 则称这组向量线性无关，否则称向量组线性相关。 一个n维向量空间可以由n个线性无关的向量组成的向量集合生成，这个向量组成为基。 【定义1.12】 向量空间V的基B是一个由n个线性无关的向量组成的集合，即 \\(\\textbf{B}\\)={\\(\\textbf{e}_{1}, \\textbf{e}_{2}, …, \\textbf{e}_{n} \\)}，对于向量空间V中的任意一个元素P，都存在一组实数使得： $$ \\textbf{P} = a_{1}\\textbf{e}_{1} + a_{2}\\textbf{e}_{2} + \\cdots + a_{n}\\textbf{e}_{n} \\tag{1.41} $$ 任意空间向量\\(R^{n}\\)都具有无限个基，对基的形式进行一些限定后，可以使基具有特定的性质。 【定义1.13】 对于向量空间的基\\(\\textbf{B}\\)={\\(\\textbf{e}_{1}, \\textbf{e}_{2}, …, \\textbf{e}_{n} \\)}，如果对于任意 \\(i \\neq j\\) 都有 \\(\\textbf{e}_{i} \\cdot \\textbf{e}_{j} = 0\\)，则该基为正交基。 【定理1.14】 对于给定的两个向量 \\(\\textbf{e}_{1}\\) 和 \\(\\textbf{e}_{2}\\)， 如果\\(\\textbf{e}_{1} \\cdot \\textbf{e}_{2} = 0\\)，则\\(\\textbf{e}_{1}\\) 和 \\(\\textbf{e}_{2}\\)线性无关。 对基的另一个形式限定就是基的所有向量都具有单位长度（更简单化了），引入Kronecker delta符号 \\(\\delta_{ij}\\)，定义如下： $$ \\delta_{ij} = \\left\\{ \\begin{aligned} 1, i&=j \\\\ 0, i&\\neq j \\end{aligned} \\right. \\tag{1.42} $$ 【定理1.15】 如果对于每一对 \\((i, j)\\) 有 \\(\\textbf{e}_{i} \\cdot \\textbf{e}_{j} = \\delta_{ij}\\)，则基 \\(\\beta\\)={\\(\\textbf{e}_{1}, \\textbf{e}_{2}, …, \\textbf{e}_{n} \\)}称为向量空间的正交规范基。 显然向量组{\\(\\textbf{i}, \\textbf{j}, \\textbf{k}\\)}是\\(R^{3}\\)的一个正交规范基。 有一个方法可以将具有n个线性无关向量的向量组转换为向量空间\\(R^{n}\\)的正交基，基本思想是减去向量在前面每个向量上的投影，结果肯定和前面所有的向量正交。 【定理1.16】 Gram-Schmidt 正交规范化： 对于由n个线性无关想了组成的向量组\\(\\textbf{B}\\)={\\(\\textbf{e}_{1}, \\textbf{e}_{2}, …, \\textbf{e}_{n} \\)}，算法可以产生向量组\\(\\beta\\)={\\(\\textbf{e}_{1}^{‘}, \\textbf{e}_{2}^{‘}, …, \\textbf{e}_{n}^{‘} \\)}，当 \\(i \\neq j\\)时，\\(\\textbf{e}_{i}^{i} \\cdot \\textbf{e}_{j}^{i} = 0\\)。 设 \\(\\textbf{e}_{1}^{‘} = \\textbf{e}_{1}\\)； 从i=2开始； 从\\(\\textbf{e}_{i}\\)中减去\\(\\textbf{e}_{i}\\)在向量\\(\\textbf{e}_{1}^{‘}, \\textbf{e}_{2}^{‘}, …, \\textbf{e}_{i-1}^{‘} \\)上地投影，结果为\\(\\textbf{e}_{i}^{‘}\\)，即 $$ \\textbf{e}_{i}^{'} = \\textbf{e}_{i} - \\sum_{k=1}^{i-1} proj_{\\textbf{e}_{k}} \\textbf{e}_{i} = \\textbf{e}_{i} - \\sum_{k=1}^{i-1} \\frac{\\textbf{e}_{i} \\cdot \\textbf{e}_{k}}{\\textbf{e}_{k}^{2}} \\textbf{e}_{k} \\tag{1.43} $$ 如果i &lt; n，i加1，重复步骤3。 如果需要进一步生成正交规范基，就对每个\\(\\textbf{e}_{i}^{‘}\\)进行规范化。","link":"/2020/11/27/3dmath-c1/"},{"title":"《剑指Offer》第2章笔记 数组","text":"数据结构是技术面的重点，主要围绕数组、字符串、链表、树、栈以及队列这几种常见的数据结构展开。 嗯，除了语言和算法以外的最重要的（废话）。 数组的一些特点（主要是指C/C++中的基础数组类型）： 连续的内存，按照顺序存储； 创建时需要指定数组的容量大小； O(1)时间读/写任何位置元素； 为了解决基础数组空间效率不高的问题，人们设计了动态数组，比如 C++ STL 中的 vector ，其中为了避免空间浪费，先为数组开辟小空间，当数据数目超过容量时，再重新分配一块更大的空间，把之间的数据复制到新的数组中，再把之前的内存释放（一般没有延续之前地址往后申请内存的操作，所以只能整块申请，然后再释放掉新的），但是这样就会带来内存空间申请和数据迁移的时间开销，因此使用动态数组要尽量减少改变数组容量大小的操作。 在C/C++中，数组和指针既相互关联又有区别。 声明一个数组时，数组的名字也是一个指针（不可修改的指针变量），该指针指向数组的第一个元素。需要注意的是，C/C++不会主动记录数组的大小，所以在访问数组元素时，程序要确保不会超过边界。 1234567891011121314151617int get_size(int data[]) { return sizeof(data);}Error: Cannot find module 'gulplog'int main() { int data1[] = {1, 2, 3, 4, 5}; int size1 = sizeof(data1); int* data2 = data1; int size2 = sizeof(data2); int size3 = get_size(data1); printf(&quot;%d, %d, %d&quot;, size1, size2, size3); // 20, 4, 4} 在上面的代码中： sizeof(data1) == 20：sizeof(data1)求数组的大小（字节数），data1包含5个整数，每个整数4字节，所以20字节； sizeof(data2) == 4：data2声明是指针，尽管指向了数组指针，但本质仍然是指针，在32位系统上，对任意指针求sizeof都是4(32位系统是4个字节的地址)； get_size(data1) == 4：在C/C++中，数组作为函数参数传递时，会退化为同类型的指针，尽管函数声明的是数组参数，但还是会退化为指针（语言概念特色），所以结果仍然是4。 面试题3 题目一：找出数组中重复的数字。 数组长度n，数字都在 0 - n-1 的范围内，数组中某些数字重复，但不知道有几个数字重复，请找出数组中任意一个重复数字；例如{2, 3, 1, 0, 2, 5, 3}，重复数字2或者3。 思路1：简单的排序再搜索就可以，但需要 O(nlogn) 的时间开销； 改进思路2：常用的一种优化思路是使用哈希表，从头到尾记录所有数字的出现次数，如果次数大于2就是重复的数字，时间开销降低到了 O(n) ，但凭空多了哈希表的 O(n) 开销； 大部分的人都能想到第二种方法，然后书的作者会介绍第三种方法： 数字都在0~n-1的范围内，如果数组不重复，则数字i出现在下标i的位置，如果重复，则某些位置有多个数字，同时有些位置没有数字。 但我觉得对这种方法的阐述，稍微有点凭空跳脱，没有和之前提到的前两种思路有任何延续，所以一时可能较于难以理解这里的思路，尤其是之后的算法流程。 我们可以延续之前的改进思路2，使用哈希表的优点是时间开销少，缺点是多了空间开销，那么进一步的优化思路是：如何减少空间上的开销？ 在已知数字出现在 0 ~ n-1 范围内时，哈希表的一种简单实现是位置i存储数字i的出现频率： 1234int array[5] = {1, 3, 3, 0, 2};int hash[5] = {0, 0, 0, 0, 0};... // for num in array to finish hashcout &lt;&lt; hash &lt;&lt; endl; // [1, 1, 1, 2, 0] 那么，你可以想到的一种优化思路是：原数组存储的数字在读取过一次后其实就没有作用了，所以在数字i被读取了之后，将它“自己的位置”作为哈希表的存储位，不就不需要额外的空间了么？ 更加细节地，在数字i被读取了过后，尽管它本身可能不在位置i上，可以把原本位置i的数字替换到当前的位置，最后我们使用位置i作为数字i的哈希表存储位，就完成了一步操作；对全数组的数字都执行这样的操作，就可以找出重复的数字了。 这个方法本质上是延续哈希表的思路，并且具体实现的方式你就会发现和作者提出的方法是一致的，所以我猜测作者的实质本意是将改进思路2的一种延续优化，但并没有在书中进行说明这种思路转变，稍微有点儿可惜。 PS：这样的改进思路在延续了简单哈希表实现的同时，也延续了这样的哈希表缺点，即无法处理0 ~ n-1 范围以外的数字情况。 从头到尾依次扫描数组中的每个数字，当扫描到位置i的数字m时，判断m==i： 如果相等，说明数字i在位置i上，继续执行； 如果不相等，将位置m上的数字交换到位置i上，位置m上放置了数字m，从位置i继续下一步判断；如果在交换之前发现，位置m上已经是数字m了，那么就说明数字m重复了，程序结束。 一个栗子： 12345678[1, 3, 3, 0, 2] // i=0[3, 1, 3, 0, 2] // i=0 1 on 1[0, 1, 3, 3, 2] // i=0 3 on 3[0, 1, 3, 3, 2] // i=0 0 on 0[0, 1, 3, 3, 2] // i=1 1 on 1[0, 1, 2, 3, 3] // i=2 2 on 2[0, 1, 2, 3, 3] // i=3 3 on 3[0, 1, 2, 3, 3] // i=4 3 already on 3, 3 repeat 完整代码实现： 123456789101112131415161718192021222324252627282930313233#include &lt;iostream&gt;int find_repeat(int array[], int len) { int i = 0; while(i &lt; len) { int m = array[i]; if(m != i) { if(array[m] != m) { // swap int temp = array[m]; array[m] = m; array[i] = temp; } else { return m; } } else { i++; } } return len;}int main() { int array[] = {1, 3, 3, 0, 2}; int len = sizeof(array) / sizeof(array[0]); int dup = find_repeat(array, len); if(dup == len) { printf(&quot;No Repeat Number\\n&quot;); } else { printf(&quot;Repeat Number: %d\\n&quot;, dup); } return 0;} 在其中还可以加上前一节提到的安全、边界等问题的考虑，在下面贴的作者的实现里面可以看到： 1234567891011121314151617181920212223242526bool duplicate(int array[], int len, int* dup) { // 考虑参数失效 if(array == nullptr || len &lt;= 0) { return false; } // 考虑超过边界 for(int i = 0; i &lt; len; i++) { if(array[i] &lt; 0 || array[i] &gt; len - 1) { return false; } } // 实现比较优雅 流程相同 for(int i = 0; i &lt; len; i++) { while(array[i] != i) { if(array[i] == array[array[i]]) { *dup = array[i]; return true; } // swap int temp = array[i]; array[i] = array[temp]; array[temp] = temp; } } return false;} 面试题3 题目二：不修改数组找出重复的数字。 在长度n+1的数组里的所有数字都在1~n的范围内，所以数组至少有一个数字是重复的。请找出数组中任意一个重复的数字，但不能修改输入的数组。 这一题虽然可以像题目一那样，只需要多开辟一个n+1长度的辅助数组，用来解决问题，但是这样就多了O(n)的空间开销。 一般在这种限定情况下，很难再和题目一一样做到时间、空间开销非常小的情况下完成任务，所以可以退一步，不需要缩减到O(n)时间，比如维持和快排复杂度O(nlogn)相同情况下，达成O(1)的空间开销也是一种优化的思路。 因为出发点不同，我们再次退回到最简单的方法： 没有额外的空间帮助记录时，就只能每次判断一个数字是否有重复，即判断n次，每次有n长度的遍历开销，也就是O(n^2)； 所以有两个优化的方向：（1）减少判断的次数n；（2）减少遍历长度n。 在没有额外信息辅助的情况下，优化（2）一般是很难做的（因为每个数只有遍历了全部才知道是否有重复），所以我们可以尝试优化（1）的部分。 最简单思路下，只有遍历了1~n的n个数在数组中的情况，才能知道谁重复了，我们可以用一些技巧来减少需要判断的次数。 其实非常巧妙，这条技巧就在题目中：“1~n范围内的数，在长度n+1的数组中必然存在一个重复”，这个命题成立的原因是，如果你遍历一次数组，统计1~n范围内数字的出现次数(n+1)，出现情况是大于n的（这里的n指1~n的这个范围长度），进一步地推广到一个普适命题“i~j范围内的数，在长度n+1的数组中，如果出现次数大于(j-i+1)，那必然存在重复”； 也就是意味着我们只用使用一次O(n)的遍历时间，就可以确定一个范围的数字是否存在重复。这样的性质可以让我们不断地缩小所需要判断的数字范围，这也就是时间开销上的优化。 具体地，我们可以联想到二分法： 一开始将范围1~n分为两部分，一半是1~m，另一半是m+1~n； 如果范围1~m的数字的统计次数大于m，则这个范围内有重复的数字；否则另一半m+1~n的区间里一定有包含重复的数字； 继续二分存在重复数字的范围，重复步骤； 直到确定到某个重复数字。 比如说题目给的例子{ 2, 3, 5, 4, 3, 2, 6, 7 }： [1-4]范围的数字出现5次，[5-7]范围的数字出现3次，重复在[1-4]; [1-2]范围的数字出现2次，[3-4]范围的数字出现3次，重复在[3-4]； [3]数字出现2次，[4]数字出现1次，重复数字是3。 然后简单分析一下时间复杂度，每次遍历统计的时间开销不变O(n)，因为数字范围二分，一共需要走O(logn)步，所以在O(nlogn)时间中可以找出重复数字。 完整代码实现： 123456789101112131415161718192021222324252627282930313233#include &lt;iostream&gt;bool is_repeat(int array[], int len, int start, int end) { int count = 0; for(int i = 0; i &lt; len; i++) { if(array[i] &lt;= end &amp;&amp; array[i] &gt;= start) { count += 1; } } return count &gt; (end - start + 1);}int find_repeat(int array[], int len) { int start = 1; int end = len-1; while(end != start) { int mid = (end + start) / 2; if(is_repeat(array, len, start, mid)) { end = mid; } else { start = mid+1; } } return start;}int main() { int array[] = {2, 3, 5, 4, 3, 2, 6, 7}; int len = sizeof(array) / sizeof(array[0]); int dup = find_repeat(array, len); printf(&quot;Repeat Number: %d\\n&quot;, dup); // 3 return 0;} Tips：上述代码没有考虑一些安全、边界问题，所以比较简短。 需要指出的一点是，上面的使用的这种方法不能保证找出所有重复的数字，例如其中的2也是重复数字，但是算法只找出了3，一个原因是因为只会检查其中一半范围，例如检查到前一半有重复的时候，就不会再检查后一半范围了，另一个原因是算法无法确定是其中一个数字出现2次还是几次。 面试题4：二维数组中的查找 在一个二维整数数组中，每一行从左到右递增，每一列从上到下递增，判断数组中是否含有指定数字。 例如： $$ \\begin{matrix} 1 & 2 & 8 & 9 \\\\ 2 & 4 & 9 & 12 \\\\ 4 & 7 & 10 & 13 \\\\ 6 & 8 & 11 & 15 \\end{matrix} $$ 当一个数和矩阵中间的一个数比较时，除了相等，还有两种情况： (a)当查询数字小于目标数字时，说明目标数字一定不会出现在左上角，剩下需要判断的区域在其右边和下边； (b)当查询数字大于目标数字时，说明目标数字一定不会出现在右下角，剩下需要判断的区域在其左边和上边。 当我们按照常规思路，尝试从(0,0)出发，向右下角进行搜索时，我们跳转到下一格只有通过2种方式，从上转移到下，和从左转移到右，如果我们把已遍历的位置称为“已知信息”，我们可以看到这种搜索方式，大部分“已知信息”都集中在左上部，这在比较出现的两种情况中，要么无法提供任何信息，要么只能提供重叠区域的信息，无法让转移确定下一次的方向。 所以为了避免“已知信息”的浪费，我们可以尝试从右上角(0, n-1)出发，向左下角进行搜索，这样会提供更多的信息，如果发生向下转移，代表上边没有比目标数更大的，如果发生向左转移，代表右边的数比目标数更大，所以导致更加明确的在左下角区域中搜索目标数。 完整代码实现： 1234567891011121314151617181920212223242526272829303132#include &lt;iostream&gt;bool find(int matrix[][4], int rows, int cols, int target) { int i = 0; int j = cols - 1; while(i &lt; rows &amp;&amp; j &gt;= 0) { if(matrix[i][j] &lt; target) { i++; } else if(matrix[i][j] &gt; target) { j--; } else { return true; } } return false;}int main() { int matrix[][4] = { {1, 2, 8, 9}, {2, 4, 9, 12}, {4, 7, 10, 13}, {6, 8, 11, 15} }; int target = 7; if(find(matrix, 4, 4, target)) { printf(&quot;Found!\\n&quot;); } else { printf(&quot;Not Found!\\n&quot;); } return 0;}","link":"/2020/11/26/s2o-c2-array/"},{"title":"《剑指Offer》第2章笔记 链表","text":"链表应该是面试时被提及最频繁的数据结构。 链表的结构很简单，它由指针把若干个节点连接成链状结构，链表的创建、插入节点、删除节点等操作都只需要20行左右的代码就能实现，代码量比较适合面试（哈希表、有向图等复杂的一个操作可能就需要很多代码）。 链表是一种动态数据结构，创建链表时，无须知道链表长度，插入节点时，只需要为新节点分配内存，然后调整指针的指向来确保新节点被链接到链表中；内存分配不是在创建链表时一次性完成的，而是每添加一个节点分配一次内存。 典型的单向链表节点定义： 1234struct Node { int value; Node* next;}; 往链表末尾添加一个节点： 1234567891011121314151617void add_to_tail(Node** phead, int value) { // 头结点是一个指针的指针 Node* pnew = new Node(); pnew-&gt;value = value; pnew-&gt;next = nullptr; if(*phead == nullptr) { // 创建头节点 *phead = pnew; } else { // 添加节点到尾部 Node* pnode = *phead; while(pnode-&gt;next != nullptr) { pnode = pnode-&gt;next; } pnode-&gt;next = pnew; }} 想要在链表中找到第i个节点，那我们只能从头结点开始遍历链表，时间效率为O(n)，而在数组中只需要O(1)的时间。 找到第一个含有某值节点并删除该节点的代码： 1234567891011121314151617181920212223242526272829void remove_node(Node** phead, int value) { if(phead==nullptr || *phead==nullptr) { return; } Node* p_delete = nullptr; if((*phead)-&gt;value == value) { // 头结点删除需要单独考虑操作 p_delete = *phead; *phead = (*phead)-&gt;next; } else { Node* pnode = *phead; // 寻找删除节点的前一个节点 while(pnode-&gt;next != nullptr &amp;&amp; pnode-&gt;next-&gt;value != value) { pnode = pnode-&gt;next; } if(pnode-&gt;next != nullptr &amp;&amp; pnode-&gt;next-&gt;value == value) { // 调整删除节点前一个节点的链接 p_delete = pnode-&gt;next; pnode-&gt;next = pnode-&gt;next-&gt;next; } } if(p_delete != nullptr) { delete p_delete; p_delete = nullptr; }} 一些特殊形式的链表也会被经常考到： 环形链表：链表末尾节点指向头结点（面试题62）； 双向链表：节点还有一个指向前一个节点的指针（面试题36）； 复杂链表：节点还有拥有指向任意节点的指针（面试题35）。 面试题6：从尾到头打印链表 输入一个链表的头节点，从尾到头反过来打印每个节点的值。 1234struct Node { int value; Node* next;}; Tips：如果打算修改输入数据，最好先问面试官是不是允许修改，这里假设面试官不能改变链表的结构。 这道题目需要先访问的节点后输出，可以想到使用栈这种数据结构，每次访问到节点，就压到栈中，输出的时候只需要循环出栈即可。 完整代码实现： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#include &lt;iostream&gt;#include &lt;stack&gt;struct Node { int value; Node* next;};void add_to_tail(Node** phead, int value) { // 头结点是一个指针的指针 Node* pnew = new Node(); pnew-&gt;value = value; pnew-&gt;next = nullptr; if(*phead == nullptr) { // 创建头节点 *phead = pnew; } else { // 添加节点到尾部 Node* pnode = *phead; while(pnode-&gt;next != nullptr) { pnode = pnode-&gt;next; } pnode-&gt;next = pnew; }}void reverse_print(Node** phead) { if(phead==nullptr || *phead==nullptr) { return; } std::stack&lt;Node*&gt; pstack; Node* pnode = *phead; while(pnode != nullptr) { pstack.push(pnode); pnode = pnode-&gt;next; } while(!pstack.empty()) { pnode = pstack.top(); printf(&quot;%d\\t&quot;, pnode-&gt;value); pstack.pop(); }}int main() { int values[] = {1, 2, 3, 4, 5}; Node** phead = new Node*; *phead = nullptr; for(int i = 0; i &lt; 5; i++) { add_to_tail(phead, values[i]); } reverse_print(phead); return 0;} 具体的实现中需要注意到的一个点是头节点的初始化，因为是指针的指针，所以需要先申请一个Node指针类型的指针，new Node*，然后再将头结点指向的节点设置为nullptr，这样才不会在访问时出错。 如果可以使用栈结构来实现，也可以考虑使用递归的方式实现，通过递归访问，只有在返回函数的时候再输出节点，就可以实现逆序输出。 12345678// 调用的时候要使用 *pheadvoid reverse_print_rec(Node* node) { if(node == nullptr) { return; } reverse_print_rec(node-&gt;next); printf(&quot;%d\\t&quot;, node-&gt;value);} 递归的代码相比于使用栈会简洁很多，但是使用递归是有代价的，函数递归使用的栈空间通常会有限制（比自己建立栈的空间要小），所以如果链表过于长可能会导致函数调用栈溢出。","link":"/2020/11/30/s2o-c2-linked/"},{"title":"《剑指Offer》第2章笔记 字符串","text":"字符串的使用频率非常高，为了优化，很多语言都对字符串做了特殊的规定。 C/C++中每个字符串都以字符 \\0 做为结尾，这样便于运行时判断字符数组的尾部，由于这个特点，字符串数组的长度比真实字符串长度要多1才可以，这样容易导致一些错误： 12char str[10];strcpy(str, &quot;0123456789&quot;); // Error 为了节省内存，C/C++把常量字符串放到一个单独的内存区域，当几个指针赋值给相同的常量字符串时，实际上会指向相同的内存地址。但用常量内存来初始化字符数组时，情况又有所不同了，看下面的例子： 12345678910111213int main() { char str1[] = &quot;hello world&quot;; char str2[] = &quot;hello world&quot;; char* str3 = &quot;hello world&quot;; char* str4 = &quot;hello world&quot;; printf(&quot;str1 =%p\\n&quot;, str1); // 0061fe04 printf(&quot;str2 =%p\\n&quot;, str2); // 0061fdf8 printf(&quot;str3 =%p\\n&quot;, str3); // 00409001 printf(&quot;str4 =%p\\n&quot;, str4); // 00409001 return 0;} str1和str2是两个字符数组，在初始化赋值时，运行时为为他们分配两个长度为12字节的内存空间，并把字符串赋值到数组中去（而不是直接拷贝字符串常量地址），所以他们的初始地址是不同的。 str3和str4是两个指针，不需要再分配内存来存储内容，只需要传递地址，所以他们就拷贝了同一个地址。 面试题5：替换空格 实现一个函数，把字符串的每个空格替换成%20，例如输入We are happy.，则输出We%20are%20happy.。 题目来自于网络编程中的URL特殊字符编码，有时候服务器不一定支持一些特殊字符URL，所以需要先将特殊转换成ASCII码的两位十六进制表示，比如空格的ASCII码是32，即十六进制的0x20，空格被替换成%20，比如#的ASCII码为35，十六进制0x23，在URL中被替换成%23。 一般有两种解决方向： 在原字符数组上进行处理； 申请新字符数组，将新内容写进去； 在面试过程中遇到这样的问题，如果确定题目中没有限定说明，可以向面试官进一步地问清楚应该考虑什么样的限定条件。 在这里我们假设（作者假设）面试官需要在原字符数组上替换，输入的字符串后面有足够多的内存空间。 我们仍然从最简思路入手： 思路1：在字符串中进行遍历，当碰到空格时，将空格替换为%20，由于替换的字符串比空格多2个字符，为了放入%20，所以要将后续的字符串后移两位，重复该操作直到字符串没有空格。 假设字符串长度n，对于每个空格字符，需要移动后面O(n)个字符，所以时间开销是O(n^2)。 显然这个方法过于简单，还不是最优解，观察可以发现，有些字符串被反复后移，但其实对于一个固定空格个数的字符串，这些字符串所应该处的最终位置我们是可以计算出来的，比如We are happy.中We前面没有空格，不需要向后移动，are前面有1个空格，所以字符串会被后移2位，happy.前面有2个空格，需要移动4位。 所以对于某些字符串其最终的位置反而是通过计算得到的，不需要反复的重复移动（拷贝字符串时间开销大）。 思路2：使用一个空格计数器，在移动字符串时，根据当前空格计数器来判断当前字符需要后移多少位，然后直接将字符移动到目标位置上，遇到空格时，根据计算的后移位置，直接顺序写入%20。时间开销因为只需要遍历一次字符串，所以是O(n)。 这样的思路还是有亿点点问题需要考虑，如果从头开始移动字符串，则后面的字符串还没有空出来时，就需要先移动后面的字符串，这样就导致问题变得稍微有点复杂，所以我们可以反过来，从尾部开始处理移动操作。 思路3：先遍历一次字符串，统计空格出现次数，计算最终字符串的长度，然后从尾部开始处理移动，申请两个指针，一个指向原字符位置，一个指向移动目标位置，当遇到普通字符时，直接转移，遇到空格时，在目标位置写入替换字符串。时间开销仍然是O(n)。 完整实现代码: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include &lt;iostream&gt;#include &lt;cstring&gt;bool replace(char* str, char* ori, char* rep) { if(str != nullptr &amp;&amp; ori != nullptr &amp;&amp; rep != nullptr &amp;&amp; strlen(str) &gt; 0 &amp;&amp; strlen(ori) &gt; 0 &amp;&amp; strlen(rep) &gt; 0) { int count = 0; int ori_len = strlen(ori); int rep_len = strlen(rep); for(int i = 0; i &lt; strlen(str); i++) { if(strncmp((str+i), ori, ori_len) == 0) { count++; } } if(count == 0) { return true; } char* po = str + strlen(str) + 1; char* pr = po + count * (rep_len - ori_len); while(po &gt;= str) { if(strncmp(po, ori, ori_len) == 0) { for(char* tmp = rep + (rep_len - 1); tmp &gt;= rep; tmp--) { *pr = *tmp; pr--; } po--; } else { *pr = *po; po--; pr--; } } return true; } else { return false; }}int main() { char str[100] = &quot;We are happy.&quot;; char ori[10] = &quot; &quot;; char rep[10] = &quot;%20&quot;; if(replace(str, ori, rep)) { printf(&quot;%s\\n&quot;, str); } else { printf(&quot;Error\\n&quot;); }} Tips：代码和原作者的实现有出入，实现了相对来说比较通用的字符串替换，但是方法以及代码仅仅只针对这道题目而言是有效的，还有非常多该题目以外的问题其实是没有考虑到的，例如需要被替换不是单个的空格而是多个空格甚至是任意字符、替换的字符串如果长度小于被替换字符串该怎么处理，等等（修改上述代码中的初始字符串即可看到结果会出现问题）；不过不在这里继续讨论，可以自行尝试思考。 拓展题练习题： 已排序的两个数组A1和A2，A1尾部有足够多的空间容纳A2，将A2的所有数组插入A1中，并且最终A1中所有数字是有序的。","link":"/2020/11/28/s2o-c2-string/"}],"tags":[{"name":"笔记","slug":"笔记","link":"/tags/%E7%AC%94%E8%AE%B0/"}],"categories":[{"name":"3D游戏与图形学的数学","slug":"3D游戏与图形学的数学","link":"/categories/3D%E6%B8%B8%E6%88%8F%E4%B8%8E%E5%9B%BE%E5%BD%A2%E5%AD%A6%E7%9A%84%E6%95%B0%E5%AD%A6/"},{"name":"计划-Flags","slug":"计划-Flags","link":"/categories/%E8%AE%A1%E5%88%92-Flags/"},{"name":"剑指Offer","slug":"剑指Offer","link":"/categories/%E5%89%91%E6%8C%87Offer/"}]}