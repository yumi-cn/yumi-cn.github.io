{"pages":[{"title":"关于我","text":"一个普普通通程序员，专攻(自封)图形学、实时渲染以及游戏引擎，其他领域的例如机器学习、深度学习、数据挖掘、后端开发、前端开发之类的，也都多少懂一点点，出于兴趣学习。 日常就是学点喜欢的技术，写点喜欢的代码，闲的时候画点画。 博客主要用于记载一些阅读书籍的笔记心得，偶尔放一些用于当作品集的炫酷Demo。 联系方式： 日常练习: augbubbles@foxmail.com 工作相关: mi.work@outlook.com","link":"/about/index.html"}],"posts":[{"title":"11月的计划","text":"11月大概还剩下一周的时间，主要是在尝试起步学一些东西： 《剑指Offer》：大概前几章，简单过一下摸一下这本书的安排规律，每章尽量写一点浓缩知识点； 《3D游戏与计算机图形学中的数学方法》：之前把Games101课程简单过了一下，再通过刷这本书巩固一下基础的数学。 12月的初步规划： 《剑指Offer》； 《3D游戏与计算机图形学中的数学方法》； 《Fundamentals of Computer Graphics》 。 1月的初步规划： 《Effictive C++》； 《Real Time Rendering 4th》； 《游戏引擎架构》。","link":"/2020/11/19/plan-2020/"},{"title":"《剑指Offer》第1章笔记","text":"第1章主要介绍的是几种面试方式的不同流程以及注意事项。 “…技术面试中的5个要素，是全书的大纲,…” 远程桌面面试 思考清楚再开始编码； 良好的代码命名和缩进对齐； 单元测试、断点调试。 面试的3个环节行为面试、技术面试、应聘者提问。 行为面试 自我介绍：30s-1min，介绍主要学习和工作经历； 项目经验：STAR模型描述项目经历； Situation：简短的项目背景； Task：自己完成的任务，注意区分“参与”和“负责”； Action：如何完成任务的，详细介绍自己完成任务的方式方法； Result：自己的贡献，尝试量化自己的产出，让人直接接收到你的成果。 掌握技能：注意区分“了解”、“熟悉”和“精通”； 了解：上过课、看过书，但没有做过实际项目，通常只建议有用的时候再写； 熟悉：通常的情况，指能够独立解决大部分问题； 精通：得心应手，能够轻松回答领域内的绝大多数问题。 为什么跳槽：尽量不说抱怨层面的原因，多从自我发展的角度阐述选择的理由。 技术面试平均1个小时的面试，技术面试会占据40-50分钟的时间。 总的来说面试官关注应聘者的5种素质： 扎实的基础知识：编程语言、数据结构和算法； 能写高质量的代码：代码鲁棒性，边界考虑（另外还需要注意代码规范或者风格）； 分析问题的思路清晰：从简单完备的思路出发，用各种方法来尝试优化，例如画图形象化，举例具象化，分解简单化； 能够优化时间、空间效率：熟知数据结构优缺点，熟练掌握常用算法； 学习、沟通、综合能力。 PS：5个要素分别对应本书的第2、3、4、5、6章节内容。 应聘者提问如果觉得面试后临时想比较困难，可以在面试前提前准备一些问题。 主要围绕公司、职位、项目等工作上的事情，不太适合问较远较模糊或者和工薪相关的问题（之后再和HR聊也可以）。","link":"/2020/11/24/s2o-c1/"},{"title":"《剑指Offer》第2章笔记 编程语言","text":"第2章主要围绕编程语言、数据结构和算法，介绍技术面所需要的“基础知识”。 编程语言书里代码都是用 C/C++/C# 实现的，后面分别从 C++ 和 C# 语言的角度来讲述其中一些被问道的细节点，这样的细节点因为篇幅限制，不可能都写进书里，所以还需要通过阅读对应编程语言的书籍来进阶了解，同时其他语言的使用者也可以从其中窥探到面试官在针对语言掌握的考量时，都是从什么样的角度出发的。 C++通常语言面试的问题有3种类型： 对于语言中概念的理解程度； 面对代码，分析运行结果（或错误）； 在上下文环境中，定义类型或实现函数。 作者推荐的几本C++书，根据自己的情况选择阅读顺序： 《Effective C++》：书中列举了C++经常出现的问题以及解决这些问题的技巧（大多是面试官比较喜欢问的方向），适合面试之前突击C++； 《C++ Primer》：人称C++全书，适合全面了解的时候阅读，也可以当作宝典查询； 《深度探索C++对象模型》：深度了解C++对象的内部机制，介绍很多较为底层的知识点； 《The C++ Programming Language》：C++圣经（大概），适合全面深入掌握C++。 下面通过一道面试题（第3种类型）来表现一下这类题目是如何考查语言知识点的。 面试题1：赋值运算符函数，如下为类型CMyString的声明，请为该类型添加赋值运算符函数。 123456789class CMyString { public: CMyString(char* pData=nullptr); CMyString(const CMyString&amp; str); ~CMyString(void); private: char* m_pData;}; Tips：赋值运算符主要负责变量在进行赋值 = 运算时，如何处理变量对象内部成员变化。 定义C++中的赋值运算符函数时，需要关注点有： 返回值类型声明为引用，函数结束前返回实例自身的引用，因为返回引用才允许连续赋值的情况，例如 str1 = str2 = str3，否则无法通过编译； 把传入的参数类型声明为常量引用，如果不是引用，形参到实参传递会调用一次复制构造函数（函数的传值引用），引用可以避免这样的开销；同时因为赋值运算并不会修改传入的实例的状态，所以应进一步加上 const 关键字； 释放实例自身已有的内存，主要在对象有动态分配内存情况下考虑，如果忘记在分配新内存前释放旧内存空间，程序旧出现了内存泄漏(memory leakge)，这块内存无法被回收使用（资源浪费、占用空间导致空间不够用）； 判断传入参数和当前实例(*this)是不是同一个实例，是则不进行赋值，如果不判断就直接赋值，在同一个实例情况下，会导致在还没有拷贝到传入参数（自己）的内存时，就释放自己的内存，这也就导致传入参数的内存被释放了（因为函数是传引用），最后找不到待赋值的内容。 经典解法： 123456789101112131415#include &lt;cstring&gt;CMyString&amp; CMyString::operator=(const CMyString&amp; str) { if(this == &amp;str) { // 对象的 this 是一个地址 return *this; // 传对象 而不是地址 } delete []m_pData; // 数组的释放方式 m_pData = nullptr; m_pData = new char[strlen(str.m_pData) + 1]; // 申请新空间，多的1位给'\\0' strcpy(m_pData, str.m_pData); // 复制 赋值 return *this;} 如果对自己有更高的要求，应该再进一步地考虑其中涉及到的问题。 前面的函数中，分配内存之前先释放了内存，如果在分配内存时，内存不足就会导致 new char 排除异常，m_pData将是一个空指针，并且无法回退到之前的结果，也就是说一旦赋值运算符内部抛出了异常，实例不再保持有效的状态（并不是原有的状态），这违背了异常安全性（Exception Safety）原则（正常情况下，如果抛出异常也不应该导致内容被错误操作）。 简单的方法是先用 new 分配新内容，再 delete 释放已有的； 更好的办法是创建一个临时实例，再交换临时实例和原来的实例。 12345678910#include &lt;cstring&gt;#include &lt;algorithm&gt;CMyString&amp; CMyString::operator=(const CMyString&amp; str) { if(this == &amp;str) { CMyString tmp(str); // 复制构造函数 std::swap(m_pData, tmp.m_pData); // 交换地址 } return *this;} 当 tmp 局部变量遇到 if 结束时，会自动调用它的析构函数，会把交换下来的 this 的 m_pData 所指向的内存释放掉；在新的代码中，在复制构造函数中分配内存，如果由于内存不足抛出异常时，由于此时还没有修改原来的实例状态，实例的状态依旧是有效的（原有的），也就保证了异常安全性。 完整代码（包含所有实现和测试）： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;class CMyString { public: CMyString(char* pData); // 第一个参数设定默认值会导致无法通过编译 CMyString(const CMyString&amp; str); ~CMyString(void); CMyString&amp; operator=(const CMyString&amp; str); // 赋值运算符函数声明 void print(void); // 标准输出函数 private: char* m_pData;};// 构造函数CMyString::CMyString(char* pData) { if(pData != nullptr) { m_pData = new char[strlen(pData) + 1]; strcpy(m_pData, pData); }}// 复制构造函数CMyString::CMyString(const CMyString&amp; str) { if(str.m_pData != nullptr) { m_pData = new char[strlen(str.m_pData) + 1]; strcpy(m_pData, str.m_pData); }}// 析构函数CMyString::~CMyString(void) { if(m_pData != nullptr) { delete []m_pData; m_pData = nullptr; }}void CMyString::print(void) { std::cout &lt;&lt; m_pData &lt;&lt; std::endl;}// 赋值运算符函数CMyString&amp; CMyString::operator=(const CMyString&amp; str) { if(this != &amp;str) { CMyString tmp(str); // 复制构造函数 std::swap(m_pData, tmp.m_pData); // 交换地址 } return *this;}int main() { // 测试CMyString CMyString str1(&quot;Sword&quot;); CMyString str2(&quot;2&quot;); CMyString str3(&quot;Offer&quot;); str1 = str2 = str3; str1.print(); // Offer str2.print(); // Offer str3.print(); // Offer return 0;} 如果完整的去实现上面这个题目，会引出一些非常容易忽略的细节问题（并且会导致严重错误），例如在初始化变量 str1 时，CMyString str1(&quot;Sword&quot;);，其中所传入的参数一般都是程序声明的字符串常量，如果在构造函数中简单地实现为： 1234// Mem ErrorCMyString::CMyString(char* pData) { m_pData = pData;} 就会导致赋值运算符函数中的析构函数调用过程发生错误，因为析构函数中的 delete []m_pData 的delete操作符只负责操作堆(Heap)中的内存区域(因为new只在堆里申请内存区域)，如果使用delete操作符去释放一个字符串常量指针所指向的区域，就会发生错误（大概是访问越界）。 所以在初始化时应该使用和delete对应的new操作，在堆中申请内存，再把传入参数的内容复制到其中。 123456CMyString::CMyString(char* pData) { if(pData != nullptr) { m_pData = new char[strlen(pData) + 1]; strcpy(m_pData, pData); }} C#因为还没怎么学C#的东西，C#的部分暂时跳过，记录一下推荐的书： 《Professional C#》：特点是附录中有描述C#和其他语言的区别； 《CLR Via C#》：深入介绍C#，对CLR和.NET进行剖析，可以方便理解装箱卸箱、垃圾回收、反射等概念。 面试题2：实现Singleton模式（单例模式） 暂时跳过。 涉及到设计模式的部分，列举一些可以参考阅读的资料： 《设计模式：C++常用设计模式》：https://refactoringguru.cn/design-patterns/cpp ； 《Head First 设计模式》：感觉是一本比较老的书，可能之后看看吧； 《Game Programming Patterns》：http://gameprogrammingpatterns.com/contents.html 。","link":"/2020/11/25/s2o-c2-lg/"}],"tags":[{"name":"笔记","slug":"笔记","link":"/tags/%E7%AC%94%E8%AE%B0/"}],"categories":[{"name":"《剑指Offer》","slug":"《剑指Offer》","link":"/categories/%E3%80%8A%E5%89%91%E6%8C%87Offer%E3%80%8B/"},{"name":"计划-Flags","slug":"计划-Flags","link":"/categories/%E8%AE%A1%E5%88%92-Flags/"}]}