<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>画码余生</title>
  
  <subtitle>副标题</subtitle>
  <link href="https://yumi-cn.github.io/atom.xml" rel="self"/>
  
  <link href="https://yumi-cn.github.io/"/>
  <updated>2020-12-01T12:51:52.499Z</updated>
  <id>https://yumi-cn.github.io/</id>
  
  <author>
    <name>Yumiko</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>《3D图形的数学》第2章笔记 矩阵</title>
    <link href="https://yumi-cn.github.io/2020/12/01/3dmath-c2/"/>
    <id>https://yumi-cn.github.io/2020/12/01/3dmath-c2/</id>
    <published>2020-12-01T09:19:10.000Z</published>
    <updated>2020-12-01T12:51:52.499Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>在三维变换中，矩阵运算是最常用的表达方式。</p></blockquote><a id="more"></a><h2 id="1-矩阵的性质"><a href="#1-矩阵的性质" class="headerlink" title="1 矩阵的性质"></a>1 矩阵的性质</h2><p>一个 \(n \times m\) 的矩阵M就是一个有n行和m列的数组，如果 \(n = m\) 则矩阵M是方阵，把矩阵M第j列的第i行元素（或者第i行第j列）记作 \(M_{ij}\)。</p><p><strong>矩阵M的转置</strong>，记作 \(\textbf{M}^{T}\)，是一个\(m \times n\)矩阵，其中 \(M_{ij}^{T} = M_{ji}\)。</p><p><strong>矩阵的数乘</strong>，或者叫标量乘积，和向量类似，是乘以矩阵的每个元素。</p><p><strong>矩阵的加法</strong>，两个相同大小的矩阵，对应行列的元素相加。</p><p><strong>矩阵的乘法</strong>，如果矩阵F的行数和矩阵G的列数相等，则矩阵F和G可以相乘，假设F是\(n \times m\)的矩阵，G是\(m \times p\)的矩阵，FG就是\(n \times p\)的矩阵，FG在(i, j)位置上的元素可以表示为：</p><div>$$(\textbf{F}\textbf{G})_{ij} = \sum_{k=1}^{m}F_{ik}G_{kj} = \textbf{F}_{i*} \cdot \textbf{G}_{*j} \tag{2.5}$$</div><p>其实也可以看作是矩阵F的第i行和矩阵G的第j列元素之间的点积。</p><p><strong>单位阵</strong>是\(n \times n\)的矩阵，记作\(\textbf{I}_{n}\)，对于\(n \times n\)的矩阵M，有 \( \textbf{M} \textbf{I}_{n}\) = \(\textbf{I}_{n} \textbf{M}\) = \(\textbf{M}\)。</p><div>$$\textbf{I}_{n} =\left[\begin{matrix}1 & 0 & \cdots & 0 \\0 & 1 & \cdots & 0 \\\vdots & \vdots & \ddots & \vdots \\0 & 0 & \cdots & 1\end{matrix}\right]\tag{2.6}$$</div><p>因为单位阵尺寸由情况而定，所以通常把下标n去掉，记作 \(\textbf{I}\)。</p><p><strong>【定理2.1】</strong> 矩阵有以下性质：</p><ul><li>矩阵加法满足交换律和结合律；</li><li>系数加法乘矩阵、系数乘矩阵加法，均满足分配率；</li></ul><p><strong>【定理2.2】</strong> 还具有以下性质：</p><ul><li>系数乘矩阵先后不影响结果；</li><li>矩阵连乘，先后不影响结果；</li><li>\((\textbf{F}\textbf{G})^{T}=\textbf{G}^{T}\textbf{F}^{T}\)。</li></ul><h2 id="2-线性方程组"><a href="#2-线性方程组" class="headerlink" title="2 线性方程组"></a>2 线性方程组</h2><p>矩阵提供了一种有效并且简便的线性方程组表示法，例如线性方程组：</p><div>$$\begin{aligned}3x + 2y - 3z &= 5 \\4x - 3y + 6z &= 1 \\x - z &= 3\end{aligned}\tag{2.10}$$</div><p>可以用以下矩阵形式表示：</p><div>$$\left[\begin{matrix}3 & 2 & -3 \\4 & -3 & 6 \\1 & 0 & -1\end{matrix}\right]\left[\begin{matrix}x \\y \\z\end{matrix}\right]= \left[\begin{matrix}5 \\1 \\3\end{matrix}\right]\tag{2.11}$$</div><p>在未知向量&lt;x,y,z&gt;前面的矩阵叫做<strong>系数矩阵</strong>，在等号右边的列向量叫做<strong>常数向量</strong>。常数向量不为0的线性方程组叫做<strong>非齐次方程组</strong>，常数向量为0叫做<strong>齐次方程组</strong>。</p><p>把系数矩阵和常数向量并置一起（称为增广矩阵），执行基本行变换，就可以得到线性方程组的解。</p><p><strong>【定义2.3】</strong> 所谓<strong>基本行变换</strong>就是对一个矩阵执行以下三种变换之一：</p><ul><li>两行相互交换；</li><li>一行和不为0的系数相乘；</li><li>一行与一个不为0的系数乘后加到另一行上。</li></ul><p>方程(2.11)为例，写出增广矩阵：</p><div>$$\left[\begin{array}{ccc|c}3 & 2 & -3 & 5 \\4 & -3 & 6 & 1 \\1 & 0 & -1 & 3\end{array}\right]\tag{2.12}$$</div><p>对线性方程组的增广矩阵进行的行变换不会影响线性方程组的解，只是使线性方程组更加容易计算（可以同步理解成，一般求方程组解的步骤，使用方程组互相带入化简，使得方程组最后较容易解出值）。</p><p><strong>当用行变换求解一个线性方程组时，目标是把系数矩阵变换为它的最简形式</strong>。</p><p><strong>【定义2.4】</strong> 当且仅当一个矩阵满足一下条件，称为最简形式：</p><ul><li>每一个非0行，最左边的非0元素，即前导元素，必须为1；</li><li>每一个非0行均在全0行前面，或者说，全0行在矩阵底部；</li><li>如果一行前导元素在第j列，则其他行第j列的元素均为0；</li><li>对任意两个非0行 \(i_{2}\) 和 \(i_{1}\)，如果满足\(i_{2} &gt; i_{1}\)，并且相应的前导元素分别位于\(j_{2}\)和\(j_{1}\)列，则必然存在\(j_{2} &gt; j_{1}\)。</li></ul><p>或者简单来说，对于最简形式的矩阵，前导元素是向下向右的趋势的，并且，包含前导元素的列只有一个1，其他元素都为0。</p><p>一个最简形式矩阵例子：</p><div>$$\left[\begin{matrix}1 & 0 & -3 & 0 \\0 & 1 & 2 & 0 \\0 & 0 & 0 & 1 \\0 & 0 & 0 & 0 \end{matrix}\right]\tag{2.14}$$</div><p><strong>【算法2.6】</strong> 把一个线性方程组的 \(n \times (n+1)\) 增广矩阵M变换为最简形式，以下每一步的M在逐渐更新，而不是保持原始状态：</p><ol><li>下标i=1；</li><li>下标j=1，从第1列到第n列开始循环；</li><li>找到一个满足行号 \(k \geq i\)，并且 \(\textbf{M}_{kj} \neq 0\) 的行，如果不存在，跳到步骤8；</li><li>如果 \(k \neq i\)，交换第k行和第i行；</li><li>使矩阵M的元素(i, j)变为1：将第i行乘以 \(1 / \textbf{M}_{ij}\)；</li><li>把第j列中除第i行之外的元素变为0：对于每一行r，\(1 \leq r \leq n\) 且 \(r \neq i\)，将第i行乘 \(-\textbf{M}_{rj}\)加到第r行上；</li><li>i加1；</li><li>如果\(j \leq n\)，j加1，跳到步骤3。</li></ol><p>简单来说，就是每次找到第j列上的前导元素在哪一行，然后把这一行放在对应的位置上，让前导元素变1，再清除第j列上的其它元素，直到再找不到有前导元素的行，算法停止。</p><p>对于化简到最简形式后，如何判断方程组解的情况，有以下规律：</p><ul><li>如果系数矩阵的最简形式是一个单位阵，<strong>方程组有唯一解</strong>；</li><li>如果有一行或多行全为0，方程组要么无解，要么有无穷多解；</li><li>如果某一行系数矩阵为0而常数向量不为0，<strong>则方程组无解</strong>。</li></ul><h2 id="3-逆矩阵"><a href="#3-逆矩阵" class="headerlink" title="3 逆矩阵"></a>3 逆矩阵</h2><p>对一个\(n \times n\)的矩阵M而言，如果存在一个矩阵\(M^{-1}\)，使得 \(\textbf{M}\textbf{M}^{-1}=\textbf{M}^{-1}\textbf{M}=\textbf{I}\)，则称矩阵M是可逆的，矩阵\(M^{-1}\)叫做M的逆矩阵。</p><p>并不是每个矩阵都可逆，没有逆矩阵的矩阵叫做奇异矩阵，例如任何一行或一列为0的矩阵就是奇异矩阵。</p><p><strong>【定理2.9】</strong> 有一行或一列全为0的矩阵是不可逆的。</p><p><strong>【定理2.10】</strong> 一个矩阵M是可逆的，当且仅当\(M^{T}\)是可逆的。</p><p><strong>证明：</strong></p><p>假设M是可逆的，则\(M^{-1}\)存在，所以有：</p><div>$$\textbf{M}^{T}(\textbf{M}^{-1})^{T} =(\textbf{M}^{-1}\textbf{M})^{T} = \textbf{I}^{T} = \textbf{I}\tag{2.29}$$</div><p>并且</p><div>$$(\textbf{M}^{-1})^{T}\textbf{M}^{T} =(\textbf{M}\textbf{M}^{-1})^{T} = \textbf{I}^{T} = \textbf{I}\tag{2.30}$$</div><p>因此，\((\textbf{M}^{-1})^{T}\)是 \(\textbf{M}^{T}\)的逆矩阵。</p><p>类似，如果假设\(\textbf{M}^{T}\)是可逆的，则\((\textbf{M}{T})^{-1}\)存在：</p><div>$$\textbf{M}[(\textbf{M}^{T})^{-1}]^{T} =[(\textbf{M}^{T})^{-1}\textbf{M}^{T})]^{T} =\textbf{I}^{T} = \textbf{I}\tag{2.31}$$</div><p>而且</p><div>$$[(\textbf{M}^{T})^{-1}]^{T}\textbf{M} =[(\textbf{M}^{T}(\textbf{M}^{T})^{-1})]^{T} =\textbf{I}^{T} = \textbf{I}\tag{2.32}$$</div><p>因此，\([(\textbf{M}^{T})^{-1}]^{T}\)是M的逆矩阵。</p><p><strong>【定理2.11】</strong> 如果F和G都是\(n \times n\)的可逆矩阵，那么FG也是可逆的，并且 \((\textbf{F}\textbf{G})^{-1}\) = \(\textbf{G}^{-1}\textbf{F}^{-1}\)。</p><p>求矩阵最简形式的方法（算法2.6）也可以用来计算矩阵逆矩阵，为了计算\(n \times n\)矩阵的逆矩阵，在矩阵的右边并接一个单位阵，以形成一个\(n \times 2n\)的矩阵。</p><div>$$\left[\begin{array}{cccc|cccc}M_{11} & M_{12} & \cdots & M_{1n} & 1 & 0 & \cdots & 0 \\M_{21} & M_{22} & \cdots & M_{2n} & 0 & 1 & \cdots & 0 \\\vdots & \vdots & \ddots & \vdots & \vdots & \vdots & \ddots & \vdots \\M_{n1} & M_{n2} & \cdots & M_{nn} & 0 & 0 & \cdots & 1\end{array}\right]\tag{2.34}$$</div><p>对整个矩阵执行基本行变换操作，直到其左边的\(n \times n\)矩阵变为单位阵，这时右边的\(n \times n\)部分就是M的逆矩阵，如果左边无法化为单位矩阵，则该矩阵不可逆。</p><p><strong>【定理2.14】</strong> 假设(n \times n\)矩阵 \(M^{‘}\)是(n \times n\)矩阵M进行基本变换后得到的矩阵，则有 \(M^{‘}=EM\)，其中E是对单位阵进行相同的基本变换的最终矩阵。</p><p>把<strong>单位阵</strong>经过<strong>行变换</strong>后得到的矩阵称为<strong>初等矩阵</strong>，如果为了把矩阵M变为单位阵而必须经过k次基本行变换，那么：</p><div>$$\textbf{I} = \textbf{E}_{k}\textbf{E}_{k-1} \cdots \textbf{E}_{1}\textbf{M}\tag{2.47}$$</div><p>其中矩阵 \(\textbf{E}_{1}, \textbf{E}_{2}, \cdots, \textbf{E}_{k}\)是单位阵对应的k次行变换的初等矩阵，也就是说，矩阵 \(\textbf{E}_{k}\textbf{E}_{k-1} \cdots \textbf{E}_{1}\)之间的积即为M的逆矩阵。</p><p><strong>【定理2.15】</strong> 当且仅当矩阵M的<strong>行是一个线性无关向量集</strong>时，(n \times n\)矩阵M是可逆的。</p><h2 id="4-行列式"><a href="#4-行列式" class="headerlink" title="4 行列式"></a>4 行列式</h2><p>方阵的行列式得到的是一个标量，矩阵M的行列式记作\(det \textbf{M}\)，行列式使用垂直线取代矩阵两侧的括号。</p><div>$$det \textbf{M} =\left|\begin{matrix}M_{11} & M_{12} & M_{13} \\M_{21} & M_{22} & M_{23} \\M_{31} & M_{32} & M_{33}\end{matrix}\right|\tag{2.50}$$</div><p>\(n \times n\)矩阵M的行列式的值由一个递推公式给出，用符号 \(M^{|i, j|}\)表示原始矩阵M中第i行和第j列删除后行程的 \((n-1) \times (n-1)\)矩阵，用这种方法，行列式值可用以下方法计算：</p><div>$$det \textbf{M} = \sum_{i=1}^{n}(-1)^{i+k}M_{ik} det \textbf{M}^{|i,k|}\tag{2.53}$$</div><div>$$det \textbf{M} = \sum_{i=1}^{n}(-1)^{k+j}M_{kj} det \textbf{M}^{|k,j|}\tag{2.54}$$</div><p>其中k是满足条件 \(1 \leq k \leq n\)的任意常数。</p><p>二阶矩阵的行列式公式：</p><div>$$\left|\begin{matrix}a & b \\c & d\end{matrix}\right|= ad - bc\tag{2.55}$$</div><p>三阶矩阵的行列式公式：</p><div>$$\begin{aligned}\left|\begin{matrix}a_{11} & a_{12} & a_{13} \\a_{21} & a_{22} & a_{23} \\a_{31} & a_{32} & a_{33}\end{matrix}\right|= a_{11}det\textbf{M}^{|1,1|} - a_{12}det\textbf{M}^{|1,2|} + a_{13}det\textbf{M}^{|1,3|} \\= a_{11}(a_{22}a_{33}-a_{23}a_{32}) -a_{12}(a_{21}a_{33}-a_{23}a_{31}) +a_{13}(a_{21}a_{32}-a_{22}a_{31})\end{aligned}\tag{2.56}$$</div><p><strong>【定理2.16】</strong> 执行基本变换对一个矩阵的行列式有以下性质：</p><ul><li>两行交换，行列式取反；</li><li>矩阵一行乘比例系数a则行列式变为原来的a倍；</li><li>把一行的若干倍加到另一行对行列式没有影响。</li></ul><p><strong>【推论2.17】</strong> 如果矩阵有相同行，则行列式为0。</p><p><strong>【定理2.18】</strong> \(n \times n\)矩阵M当且仅当 \(det \textbf{M} \neq 0\)时是可逆的。</p><p><strong>【定理2.19】</strong> 对任意两个 \(n \times n\)的矩阵F和G，有 \(det\textbf{F}\textbf{G}=det\textbf{F}det\textbf{G}\)。</p><p>Tips：初等矩阵乘积的行列式等于行列式的乘积。</p><p><strong>【定理2.20】</strong> 假设F是 \(n \times n\)矩阵，如果另一 \(n \times n\)矩阵G的元素为：</p><div>$$G_{ij} = (-1)^{i + j} \frac{det \textbf{F}^{|j, i|}}{det \textbf{F}}\tag{2.62}$$</div><p>那么 \(\textbf{G}=\textbf{F}^{-1}\)。</p><p>通过定理2.20可以推出图形学中经常用的几个逆矩阵计算公式主要是2阶和3阶的。</p><p>2阶方阵逆矩阵公式：</p><div>$$\textbf{A}^{-1} = \frac{1}{det \textbf{A}}\left[\begin{matrix}A_{22} & -A_{12}\\-A_{21} & A_{11}\end{matrix}\right]\tag{2.63}$$</div><p>3阶方阵逆矩阵公式：</p><div>$$\textbf{B}^{-1} = \frac{1}{det \textbf{B}}\left[\begin{matrix}B_{22}B_{33}-B_{23}B_{32} & B_{13}B_{32}-B_{12}B_{33} & B_{12}B_{23}-B_{13}B_{22} \\B_{23}B_{31}-B_{21}B_{33} & B_{11}B_{33}-B_{13}B_{31} & B_{13}B_{21}-B_{11}B_{23} \\B_{21}B_{32}-B_{22}B_{31} & B_{12}B_{31}-B_{11}B_{32} & B_{11}B_{22}-B_{12}B_{21}\end{matrix}\right]$$</div><h2 id="5-特征值与特征向量"><a href="#5-特征值与特征向量" class="headerlink" title="5 特征值与特征向量"></a>5 特征值与特征向量</h2><p>对于<strong>可逆方阵</strong>，<strong>必然</strong>存在一个<strong>向量</strong>，当该<strong>向量与可逆方阵相乘</strong>时，<strong>向量只会发生大小变换而方向不变</strong>，即，对于n阶方阵M，存在着非0的n维向量 \(\textbf{V}_{1}, \textbf{V}_{2}, \cdots, \textbf{V}_{n}\)满足：</p><div>$$\textbf{M}\textbf{V}_{i} = \lambda_{i}\textbf{V}_{i}\tag{2.65}$$</div><p>其中比例系数 \(\lambda_{i}\) 称为矩阵M的特征值，而向量 \(\textbf{V}_{i}\)是对应特征值的特征向量。</p><p>对式（2.65）进行变换可得到矩阵的特征值：</p><div>$$(\textbf{M}-\lambda_{i}\textbf{I})\textbf{V}_{i} = \textbf{0}\tag{2.66}$$</div><p>对于非0向量 \(\textbf{V}_{i}\)，如果上式成立，矩阵 \(\textbf{M}-\lambda_{i}\textbf{I}\)一定是奇异矩阵（不可逆），否则就可以对其求逆，得到:</p><div>$$\textbf{V}_{i} = (\textbf{M}-\lambda_{i}\textbf{I})^{-1}\textbf{0} = \textbf{0}\tag{2.67}$$</div><p>这个非0向量矛盾，所以矩阵 \(\textbf{M}-\lambda_{i}\textbf{I}\)的行列式为0，因此可以通过：</p><div>$$det(\textbf{M}-\lambda\textbf{I}) = 0\tag{2.68}$$</div><p>计算出矩阵的特征值解，由2.68式得出的关于 \(\lambda\)的n阶多项式叫做矩阵M的特征多项式，多项式的根就是矩阵M的特征值。</p><p>一旦矩阵的特征值求得，就可以代入式(2.66)，计算出相应的特征向量，因为矩阵 \(\textbf{M}-\lambda_{i}\textbf{I}\) 是奇异的，所以简化形式至少有一行全为0，所以有无穷多解（比如特征向量的系数倍数向量也是特征向量），因此特征向量可以表示成任意常数的形式，如果有必要也可以取特征向量的长度为1。</p><p>通常，<strong>如果矩阵特征值是复数，则相应的特征向量也含有复数元素</strong>；确保有实数特征值以及相应的实数特征向量的矩阵是<strong>对称矩阵</strong>。</p><p><strong>【定义2.23】</strong> 一个n阶方阵，当且仅当 对任意i和j均有 \(M_{ij}=M_{ji}\) 时是对称矩阵，也就是说如果矩阵元素关于主对角线对称，则该矩阵就成为<strong>对称矩阵</strong>。</p><p><strong>【定理2.24】</strong> 矩阵<strong>元素为实数</strong>的对称矩阵的特征值也是实数。</p><p><strong>【定理2.25】</strong> 对应于<strong>对称矩阵</strong>M的<strong>不同特征值的特征向量</strong>是<strong>正交</strong>的。</p><h2 id="6-对角化"><a href="#6-对角化" class="headerlink" title="6 对角化"></a>6 对角化</h2><p>对角矩阵（对称矩阵的特例），只在主对角线上有非0元素的矩阵。</p><p>给定方阵M，如果能找到一个矩阵A使得 \(\textbf{A}^{-1}\textbf{M}\textbf{A}\) 是对角矩阵，那么就说矩阵A将矩阵M对角化了。</p><p><strong>【定理2.26】</strong> 假设M是特征值为 \(\lambda_{1}, \lambda_{2}, \cdots, \lambda_{n}\)的n阶方阵，且与特征值对应的特征向量 \(\textbf{V}_{1}, \textbf{V}_{2}, \cdots, \textbf{V}_{n}\) 是一个<strong>线性无关集</strong>，则矩阵A：</p><div>$$A = [ \textbf{V}_{1} \textbf{V}_{2} \cdots \textbf{V}_{n} ]\tag{2.82}$$</div><p>可以将矩阵M对角化，而且 \(\textbf{A}^{-1}\textbf{M}\textbf{A}\) 的主对角元素是矩阵M的特征值，即：</p><div>$$\textbf{A}^{-1}\textbf{M}\textbf{A} =\left[\begin{matrix}\lambda_{1} & 0 & \cdots & 0 \\0 & \lambda_{2} & \cdots & 0\\\vdots & \vdots & \ddots & \vdots\\0 & 0 & \cdots & \lambda_{n}\end{matrix}\right]\tag{2.83}$$</div><p>相反，如果存在一个可逆矩阵A使得 \(\textbf{A}^{-1}\textbf{M}\textbf{A}\) 是一个对角阵，则矩阵A的列必然是矩阵M的特征向量，而 \(\textbf{A}^{-1}\textbf{M}\textbf{A}\) 的对角线元素则是矩阵M的特征值。</p>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;在三维变换中，矩阵运算是最常用的表达方式。&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="3D游戏与图形学的数学" scheme="https://yumi-cn.github.io/categories/3D%E6%B8%B8%E6%88%8F%E4%B8%8E%E5%9B%BE%E5%BD%A2%E5%AD%A6%E7%9A%84%E6%95%B0%E5%AD%A6/"/>
    
    
    <category term="笔记" scheme="https://yumi-cn.github.io/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>《剑指Offer》第2章笔记 链表</title>
    <link href="https://yumi-cn.github.io/2020/11/30/s2o-c2-linked/"/>
    <id>https://yumi-cn.github.io/2020/11/30/s2o-c2-linked/</id>
    <published>2020-11-30T11:09:59.000Z</published>
    <updated>2020-11-30T12:17:30.456Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>链表应该是面试时被提及最频繁的数据结构。</p></blockquote><a id="more"></a><p>链表的结构很简单，它由指针把若干个节点连接成链状结构，链表的创建、插入节点、删除节点等操作都只需要20行左右的代码就能实现，代码量比较适合面试（哈希表、有向图等复杂的一个操作可能就需要很多代码）。</p><p>链表是一种动态数据结构，创建链表时，无须知道链表长度，插入节点时，只需要为新节点分配内存，然后调整指针的指向来确保新节点被链接到链表中；内存分配不是在创建链表时一次性完成的，而是每添加一个节点分配一次内存。</p><p>典型的单向链表节点定义：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> value;</span><br><span class="line">    Node* next;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>往链表末尾添加一个节点：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add_to_tail</span><span class="params">(Node** phead, <span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 头结点是一个指针的指针</span></span><br><span class="line">    Node* pnew = <span class="keyword">new</span> Node();</span><br><span class="line">    pnew-&gt;value = value;</span><br><span class="line">    pnew-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">if</span>(*phead == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="comment">// 创建头节点</span></span><br><span class="line">        *phead = pnew;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 添加节点到尾部</span></span><br><span class="line">        Node* pnode = *phead;</span><br><span class="line">        <span class="keyword">while</span>(pnode-&gt;next != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            pnode = pnode-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        pnode-&gt;next = pnew;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>想要在链表中找到第i个节点，那我们只能从头结点开始遍历链表，时间效率为<code>O(n)</code>，而在数组中只需要<code>O(1)</code>的时间。</p><p>找到第一个含有某值节点并删除该节点的代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">remove_node</span><span class="params">(Node** phead, <span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(phead==<span class="literal">nullptr</span> || *phead==<span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Node* p_delete = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">if</span>((*phead)-&gt;value == value) &#123;</span><br><span class="line">        <span class="comment">// 头结点删除需要单独考虑操作</span></span><br><span class="line">        p_delete = *phead;</span><br><span class="line">        *phead = (*phead)-&gt;next;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        Node* pnode = *phead;</span><br><span class="line">        <span class="comment">// 寻找删除节点的前一个节点</span></span><br><span class="line">        <span class="keyword">while</span>(pnode-&gt;next != <span class="literal">nullptr</span></span><br><span class="line">            &amp;&amp; pnode-&gt;next-&gt;value != value) &#123;</span><br><span class="line">                pnode = pnode-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(pnode-&gt;next != <span class="literal">nullptr</span> &amp;&amp; pnode-&gt;next-&gt;value == value) &#123;</span><br><span class="line">            <span class="comment">// 调整删除节点前一个节点的链接</span></span><br><span class="line">            p_delete = pnode-&gt;next;</span><br><span class="line">            pnode-&gt;next = pnode-&gt;next-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(p_delete != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="keyword">delete</span> p_delete;</span><br><span class="line">        p_delete = <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一些特殊形式的链表也会被经常考到：</p><ul><li>环形链表：链表末尾节点指向头结点（面试题62）；</li><li>双向链表：节点还有一个指向前一个节点的指针（面试题36）；</li><li>复杂链表：节点还有拥有指向任意节点的指针（面试题35）。</li></ul><blockquote><p>面试题6：从尾到头打印链表</p></blockquote><p>输入一个链表的头节点，从尾到头反过来打印每个节点的值。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> value;</span><br><span class="line">    Node* next;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>Tips：如果打算修改输入数据，最好先问面试官是不是允许修改，这里假设面试官不能改变链表的结构。</p><p>这道题目需要先访问的节点后输出，可以想到使用栈这种数据结构，每次访问到节点，就压到栈中，输出的时候只需要循环出栈即可。</p><p>完整代码实现：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> value;</span><br><span class="line">    Node* next;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add_to_tail</span><span class="params">(Node** phead, <span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 头结点是一个指针的指针</span></span><br><span class="line">    Node* pnew = <span class="keyword">new</span> Node();</span><br><span class="line">    pnew-&gt;value = value;</span><br><span class="line">    pnew-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">if</span>(*phead == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="comment">// 创建头节点</span></span><br><span class="line">        *phead = pnew;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 添加节点到尾部</span></span><br><span class="line">        Node* pnode = *phead;</span><br><span class="line">        <span class="keyword">while</span>(pnode-&gt;next != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            pnode = pnode-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        pnode-&gt;next = pnew;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">reverse_print</span><span class="params">(Node** phead)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(phead==<span class="literal">nullptr</span> || *phead==<span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">stack</span>&lt;Node*&gt; pstack;</span><br><span class="line">    Node* pnode = *phead;</span><br><span class="line">    <span class="keyword">while</span>(pnode != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        pstack.push(pnode);</span><br><span class="line">        pnode = pnode-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(!pstack.empty()) &#123;</span><br><span class="line">        pnode = pstack.top();</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\t&quot;</span>, pnode-&gt;value);</span><br><span class="line">        pstack.pop();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> values[] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line">    Node** phead = <span class="keyword">new</span> Node*;</span><br><span class="line">    *phead = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">        add_to_tail(phead, values[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    reverse_print(phead);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>具体的实现中需要注意到的一个点是头节点的初始化，因为是指针的指针，所以需要先申请一个<strong>Node指针类型的指针</strong>，<code>new Node*</code>，然后再将头结点指向的节点设置为<code>nullptr</code>，这样才不会在访问时出错。</p><p>如果可以使用栈结构来实现，也可以考虑使用递归的方式实现，通过递归访问，只有在返回函数的时候再输出节点，就可以实现逆序输出。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 调用的时候要使用 *phead</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">reverse_print_rec</span><span class="params">(Node* node)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(node == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    reverse_print_rec(node-&gt;next);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\t&quot;</span>, node-&gt;value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>递归的代码相比于使用栈会简洁很多，但是使用递归是有代价的，函数递归使用的栈空间通常会有限制（比自己建立栈的空间要小），所以如果链表过于长可能会导致函数调用栈溢出。</p>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;链表应该是面试时被提及最频繁的数据结构。&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="剑指Offer" scheme="https://yumi-cn.github.io/categories/%E5%89%91%E6%8C%87Offer/"/>
    
    
    <category term="笔记" scheme="https://yumi-cn.github.io/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>《剑指Offer》第2章笔记 字符串</title>
    <link href="https://yumi-cn.github.io/2020/11/28/s2o-c2-string/"/>
    <id>https://yumi-cn.github.io/2020/11/28/s2o-c2-string/</id>
    <published>2020-11-28T14:06:05.000Z</published>
    <updated>2020-11-30T11:09:14.812Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>字符串的使用频率非常高，为了优化，很多语言都对字符串做了特殊的规定。</p></blockquote><a id="more"></a><p>C/C++中每个字符串都以字符 <code>\0</code> 做为结尾，这样便于运行时判断字符数组的尾部，由于这个特点，字符串数组的长度比真实字符串长度要多1才可以，这样容易导致一些错误：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> str[<span class="number">10</span>];</span><br><span class="line"><span class="built_in">strcpy</span>(str, <span class="string">&quot;0123456789&quot;</span>); <span class="comment">// Error</span></span><br></pre></td></tr></table></figure><p>为了节省内存，C/C++把常量字符串放到一个单独的内存区域，当几个指针赋值给相同的常量字符串时，实际上会指向相同的内存地址。但用常量内存来初始化字符数组时，情况又有所不同了，看下面的例子：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> str1[] = <span class="string">&quot;hello world&quot;</span>;</span><br><span class="line">    <span class="keyword">char</span> str2[] = <span class="string">&quot;hello world&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span>* str3 = <span class="string">&quot;hello world&quot;</span>;</span><br><span class="line">    <span class="keyword">char</span>* str4 = <span class="string">&quot;hello world&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;str1 =%p\n&quot;</span>, str1); <span class="comment">// 0061fe04</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;str2 =%p\n&quot;</span>, str2); <span class="comment">// 0061fdf8</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;str3 =%p\n&quot;</span>, str3); <span class="comment">// 00409001</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;str4 =%p\n&quot;</span>, str4); <span class="comment">// 00409001</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>str1</code>和<code>str2</code>是两个字符数组，在初始化赋值时，运行时为为他们分配两个长度为12字节的内存空间，并把字符串赋值到数组中去（而不是直接拷贝字符串常量地址），所以他们的初始地址是不同的。</p><p><code>str3</code>和<code>str4</code>是两个指针，不需要再分配内存来存储内容，只需要传递地址，所以他们就拷贝了同一个地址。</p><blockquote><p>面试题5：替换空格</p></blockquote><p>实现一个函数，把字符串的每个空格替换成<code>%20</code>，例如输入<code>We are happy.</code>，则输出<code>We%20are%20happy.</code>。</p><p>题目来自于网络编程中的URL特殊字符编码，有时候服务器不一定支持一些特殊字符URL，所以需要先将特殊转换成ASCII码的两位十六进制表示，比如空格的ASCII码是<code>32</code>，即十六进制的<code>0x20</code>，空格被替换成<code>%20</code>，比如<code>#</code>的ASCII码为35，十六进制<code>0x23</code>，在URL中被替换成<code>%23</code>。</p><p>一般有两种解决方向：</p><ul><li>在原字符数组上进行处理；</li><li>申请新字符数组，将新内容写进去；</li></ul><p>在面试过程中遇到这样的问题，如果确定题目中没有限定说明，可以向面试官进一步地问清楚应该考虑什么样的限定条件。</p><p>在这里我们假设（作者假设）面试官需要在原字符数组上替换，输入的字符串后面有足够多的内存空间。</p><p>我们仍然从最简思路入手：</p><ul><li><strong>思路1</strong>：在字符串中进行遍历，当碰到空格时，将空格替换为<code>%20</code>，由于替换的字符串比空格多2个字符，为了放入<code>%20</code>，所以要将后续的字符串后移两位，重复该操作直到字符串没有空格。</li></ul><p>假设字符串长度<code>n</code>，对于每个空格字符，需要移动后面<code>O(n)</code>个字符，所以时间开销是<code>O(n^2)</code>。</p><p>显然这个方法过于简单，还不是最优解，观察可以发现，有些字符串被反复后移，但其实对于一个固定空格个数的字符串，这些字符串所应该处的最终位置我们是可以计算出来的，比如<code>We are happy.</code>中<code>We</code>前面没有空格，不需要向后移动，<code>are</code>前面有1个空格，所以字符串会被后移2位，<code>happy.</code>前面有2个空格，需要移动4位。</p><p>所以对于某些字符串其最终的位置反而是通过计算得到的，不需要反复的重复移动（拷贝字符串时间开销大）。</p><ul><li><strong>思路2</strong>：使用一个空格计数器，在移动字符串时，根据当前空格计数器来判断当前字符需要后移多少位，然后直接将字符移动到目标位置上，遇到空格时，根据计算的后移位置，直接顺序写入<code>%20</code>。时间开销因为只需要遍历一次字符串，所以是<code>O(n)</code>。</li></ul><p>这样的思路还是有亿点点问题需要考虑，如果从头开始移动字符串，则后面的字符串还没有空出来时，就需要先移动后面的字符串，这样就导致问题变得稍微有点复杂，所以我们可以反过来，从尾部开始处理移动操作。</p><ul><li><strong>思路3</strong>：先遍历一次字符串，统计空格出现次数，计算最终字符串的长度，然后从尾部开始处理移动，申请两个指针，一个指向原字符位置，一个指向移动目标位置，当遇到普通字符时，直接转移，遇到空格时，在目标位置写入替换字符串。时间开销仍然是<code>O(n)</code>。</li></ul><p>完整实现代码:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">replace</span><span class="params">(<span class="keyword">char</span>* str, <span class="keyword">char</span>* ori, <span class="keyword">char</span>* rep)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(str != <span class="literal">nullptr</span> &amp;&amp; ori != <span class="literal">nullptr</span> &amp;&amp; rep != <span class="literal">nullptr</span></span><br><span class="line">       &amp;&amp; <span class="built_in">strlen</span>(str) &gt; <span class="number">0</span> &amp;&amp; <span class="built_in">strlen</span>(ori) &gt; <span class="number">0</span> &amp;&amp; <span class="built_in">strlen</span>(rep) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> ori_len = <span class="built_in">strlen</span>(ori);</span><br><span class="line">        <span class="keyword">int</span> rep_len = <span class="built_in">strlen</span>(rep);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">strlen</span>(str); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">strncmp</span>((str+i), ori, ori_len) == <span class="number">0</span>) &#123;</span><br><span class="line">                count++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(count == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">char</span>* po = str + <span class="built_in">strlen</span>(str) + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">char</span>* pr = po + count * (rep_len - ori_len);</span><br><span class="line">        <span class="keyword">while</span>(po &gt;= str) &#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">strncmp</span>(po, ori, ori_len) == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">char</span>* tmp = rep + (rep_len - <span class="number">1</span>); tmp &gt;= rep; tmp--) &#123;</span><br><span class="line">                    *pr = *tmp;</span><br><span class="line">                    pr--;</span><br><span class="line">                &#125;</span><br><span class="line">                po--;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                *pr = *po;</span><br><span class="line">                po--;</span><br><span class="line">                pr--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> str[<span class="number">100</span>] = <span class="string">&quot;We are happy.&quot;</span>;</span><br><span class="line">    <span class="keyword">char</span> ori[<span class="number">10</span>] = <span class="string">&quot; &quot;</span>;</span><br><span class="line">    <span class="keyword">char</span> rep[<span class="number">10</span>] = <span class="string">&quot;%20&quot;</span>;</span><br><span class="line">    <span class="keyword">if</span>(replace(str, ori, rep)) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, str);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Error\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Tips：代码和原作者的实现有出入，实现了相对来说比较通用的字符串替换，但是方法以及代码仅仅只针对这道题目而言是有效的，还有非常多该题目以外的问题其实是没有考虑到的，例如需要被替换不是单个的空格而是多个空格甚至是任意字符、替换的字符串如果长度小于被替换字符串该怎么处理，等等（修改上述代码中的初始字符串即可看到结果会出现问题）；不过不在这里继续讨论，可以自行尝试思考。</p><blockquote><p>拓展题练习题： 已排序的两个数组A1和A2，A1尾部有足够多的空间容纳A2，将A2的所有数组插入A1中，并且最终A1中所有数字是有序的。</p></blockquote>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;字符串的使用频率非常高，为了优化，很多语言都对字符串做了特殊的规定。&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="剑指Offer" scheme="https://yumi-cn.github.io/categories/%E5%89%91%E6%8C%87Offer/"/>
    
    
    <category term="笔记" scheme="https://yumi-cn.github.io/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>《3D图形的数学》第1章笔记 向量</title>
    <link href="https://yumi-cn.github.io/2020/11/27/3dmath-c1/"/>
    <id>https://yumi-cn.github.io/2020/11/27/3dmath-c1/</id>
    <published>2020-11-27T12:14:23.000Z</published>
    <updated>2020-11-28T09:18:55.646Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>对于成功的3D程序猿，掌握如何进行向量运算是一种基本的技能要求。</p></blockquote><a id="more"></a><blockquote><p>原书：《3D游戏与计算机图形学中的数学方法》 by Eric.Lengyel</p></blockquote><h2 id="1-向量的形式"><a href="#1-向量的形式" class="headerlink" title="1 向量的形式"></a>1 向量的形式</h2><p>一个n维向量<strong>V</strong>可以表示为：</p><div>$$\textbf{V} = < V_{1}, V_{2}, ... , V_{n} > \tag{1.1}$$</div><p>系数a和向量<strong>V</strong>的乘积可以定义为：</p><div>$$a\textbf{V} = < aV_{1}, aV_{2}, ... , aV_{n} > \tag{1.4}$$</div><p>向量加减运算：</p><div>$$\textbf{P} + \textbf{Q}= < P_{1} + Q_{1}, P_{2} + Q_{2}, ... , P_{n} + Q_{n} > \tag{1.5}$$</div><p><strong>【定理1.1】</strong>对于给定的任何两个系数a和b，以及任何三个向量<strong>P</strong>、<strong>Q</strong>和<strong>R</strong>，有以下运算规律：</p><ul><li>\(\textbf{P} + \textbf{Q} = \textbf{Q} + \textbf{P}\)</li><li>\((\textbf{P} + \textbf{Q}) + \textbf{R} = \textbf{P} + (\textbf{Q} + \textbf{R})\)</li><li>\((ab)\textbf{P} = a(b\textbf{P})\)</li><li>\(a(\textbf{P} + \textbf{Q}) = a\textbf{P} + a\textbf{Q}\)</li><li>\((a + b)\textbf{P} = a\textbf{P} + b\textbf{P}\)</li></ul><p>n维向量<strong>V</strong>的模，||<strong>V</strong>||：</p><div>$$\textbf{||V||} = \sqrt{\sum_{i=1}^{n} V_{i}^{2}} \tag{1.6}$$</div><p>模也称为向量的范数或者长度，模为1的向量称为单位向量。</p><p>设向量<strong>V</strong>表示一个三维点或方向，则公式(1.6)可以展开为：</p><div>$$\textbf{||V||} = \sqrt{V_{x}^{2} + V_{y}^{2} + V_{z}^{2}} \tag{1.7}$$</div><p>如果向量V至少有至少有一个非零分量，可以通过乘 \(1/\textbf{||V||}\) 得到V方向上的一个单位向量，也叫做单位化、规格化。</p><p><strong>【定理1.2】</strong> 对于任意给定系数a，任意的两个向量<strong>P</strong>和<strong>Q</strong>，有以下性质：</p><ul><li>\( \textbf{||P||} \geq 0 \)</li><li>当且仅当 \( \textbf{||P||}=&lt;0, 0, …, 0&gt; \)时，\( \textbf{||P||}=0 \)</li><li>\( \textbf{||aP||}=|a|\textbf{||P||} \)</li><li>\( \textbf{||P + Q||} \leq \textbf{||P||} + \textbf{||Q||} \)</li></ul><p>其中的第4条，可以由三角不等式得到。</p><h2 id="2-点积"><a href="#2-点积" class="headerlink" title="2 点积"></a>2 点积</h2><p><strong>向量间</strong>的<strong>点积</strong>，也叫做<strong>数量积</strong>或<strong>内积</strong>，3D图形中经常用点积来度量两个向量指向的差异。</p><p><strong>【定理1.3】</strong> 两个n维向量P和Q的点积，记作P·Q，即：</p><div>$$\textbf{P} \cdot \textbf{Q}= \sum_{i=1}^{n} P_{i}Q_{i} \tag{1.9}$$</div><p>向量的点积等于两个向量的对应分量乘积之和。</p><p>在三维空间中，有：</p><div>$$\textbf{P} \cdot \textbf{Q}= P_{x}Q_{x} + P_{y}Q_{y} + P_{z}Q_{z} \tag{1.10}$$</div><p><strong>【定理1.4】</strong> 对于给定的两个向量P和Q，点积满足公式：</p><div>$$\textbf{P} \cdot \textbf{Q}= \textbf{||P||}\textbf{||Q||} cos \alpha \tag{1.12}$$</div><p>\(\alpha\)是向量P和Q之间的夹角（详细的说是P和Q的起点、终点决定的平面夹角）。</p><p>Tips：定理1.4的证明要用到余弦定理，一个三角形有三条边\(a,b,c\)，\(a,b\)夹角是\(\alpha\)时，三边满足等式关系\(c^{2} = a^{2} + b^{2} - 2abcos\alpha\)。</p><p>定理1.4可以得出两个结论：</p><ul><li>当且仅当 \(\textbf{P} \cdot \textbf{Q} = 0\) 时， 向量P和向量Q相互垂直。点积为0的向量称为正交向量，零向量和任意向量正交；</li><li>点积正负号说明两个向量的方向情况，例如在看平面法线和平面外一点，可以查看点相对于平面的位置，是在法线同侧（点积为正）还是在不同侧（点积为负）。</li></ul><p><strong>【定理1.5】</strong> 对于任意给定系数a，任意的两个向量<strong>P</strong>和<strong>Q</strong>，有以下性质：</p><ul><li>\( \textbf{P} \cdot \textbf{Q} = \textbf{Q} \cdot \textbf{P} \)</li><li>\( (a\textbf{P}) \cdot \textbf{Q} = a(\textbf{P} \cdot \textbf{Q}) \)</li><li>\( \textbf{P} \cdot (\textbf{Q} + \textbf{R}) = \textbf{P} \cdot \textbf{Q} + \textbf{P} \cdot \textbf{R} \)</li><li>\( \textbf{P} \cdot \textbf{P} = \textbf{||P||}^{2} \)</li><li>\( | \textbf{P} \cdot \textbf{Q} | \leq \textbf{||P||} \cdot \textbf{||Q||} \)</li></ul><p>向量P在向量Q上的投影长度：</p><div>$$\textbf{||P||}cos\alpha= \frac{\textbf{P}\cdot\textbf{Q}}{\textbf{||Q||}} \tag{1.17}$$</div><p>如果再乘以单位向量 \( \frac{\textbf{Q}}{\textbf{||Q||}} \)，就可以得到具有该长度并且平行于Q的一个向量，即表示向量P到向量Q的投影，记作\( proj_{\textbf{Q}} \textbf{P} \)：</p><div>$$proj_{\textbf{Q}}\textbf{P} = \frac{\textbf{P} \cdot \textbf{Q}}{\textbf{||Q||}^{2}} \textbf{Q} \tag{1.18}$$</div><p>P到Q的投影也可以看作是一个线性变换过程，所以可以表示为矩阵和向量乘积，三维情况下，\( proj_{\textbf{Q}} \textbf{P} \) 也可以用下面的公式计算：</p><div>$$proj_{\textbf{Q}} \textbf{P} = \frac{1}{\textbf{Q}^{2}}\left[\begin{matrix}Q_{x}^{2} & Q_{x}Q_{y} & Q_{x}Q_{z} \\Q_{x}Q_{y} & Q_{y}^{2} & Q_{y}Q_{z} \\Q_{x}Q_{z} & Q_{y}Q_{z} & Q_{z}^{2}\end{matrix}\right]\left[\begin{matrix}P_{x} \\P_{y} \\P_{z}\end{matrix}\right]\tag{1.20}$$</div><p>向量P相对于向量Q的垂直分量记作\( perp_{\textbf{Q}} \textbf{P} \)，可以用向量P减去投影分量得到垂直分量：</p><div>$$perp_{\textbf{Q}} \textbf{P} = \textbf{P} - proj_{\textbf{Q}} \textbf{P} \tag{1.19}$$</div><h2 id="3-叉积"><a href="#3-叉积" class="headerlink" title="3 叉积"></a>3 叉积</h2><p>两个三维向量的叉积又称为向量积，结果是一个新的向量，这个向量垂直于原来的两个向量。</p><p>在3D图形学中，已知曲面上一点的两个不同方向的切向量，就可以通过求叉积得到曲面在该点的法向量。</p><p><strong>【定义1.6】</strong> 两个3D向量P和Q的叉积记作 \(\textbf{P} \times \textbf{Q}\)，结果向量为：</p><div>$$\textbf{P} \times \textbf{Q}= <P_{y}Q_{z} - P_{z}Q_{y},P_{z}Q_{x} - P_{x}Q_{z},P_{x}Q_{y} - P_{y}Q_{x} > \tag{1.21}$$</div><p>便于记忆的一个工具是伪行列式：</p><div>$$\textbf{P} \times \textbf{Q} =\left|\begin{matrix}i & j & k \\P_{x} & P_{y} & P_{z} \\Q_{x} & Q_{y} & Q_{z}\end{matrix}\right|\tag{1.22}$$</div><p>这里i,j,k是x,y,z轴的单位向量：</p><div>$$\begin{aligned}\textbf{i} &= <1, 0, 0> \\\textbf{j} &= <0, 1, 0> \\\textbf{k} &= <0, 0, 1>\end{aligned}\tag{1.23}$$</div><p>叉积\(\textbf{P} \times \textbf{Q}\)也可以用线性变换的形式表示，变换矩阵派生于P，作用于Q：</p><div>$$\textbf{P} \times \textbf{Q} =\left[\begin{matrix}0 & -P_{z} & P_{y} \\P_{z} & 0 & -P_{x} \\-P_{y} & P_{x} & 0\end{matrix}\right]\left[\begin{matrix}Q_{x} \\Q_{y} \\Q_{z}\end{matrix}\right]\tag{1.25}$$</div><p>Tips：原书P7的公式(1.25)有疏漏，变换矩阵中出现了Q的分量。</p><p>对于任意给定的三个3D向量P、Q和R，等式 \((\textbf{P} \times \textbf{Q}) \cdot \textbf{R}\) 的值可以通过伪行列式乘以R得到：</p><div>$$(\textbf{P} \times \textbf{Q}) \cdot \textbf{R} =\left|\begin{matrix}R_{x} & R_{y} & R_{z} \\P_{x} & P_{y} & P_{z} \\Q_{x} & Q_{y} & Q_{z}\end{matrix}\right|=\left|\begin{matrix}P_{x} & P_{y} & P_{z} \\Q_{x} & Q_{y} & Q_{z} \\R_{x} & R_{y} & R_{z}\end{matrix}\right|\tag{1.27}$$</div><p>Tips：行列式表达我在这里书写了两种表达形式，第一种是延续之前伪行列式的写法，只是将R替代了ijk的位置，第二种写法来自于书上，遵循PQR的出现次序的记忆法，两者的值根据初等变化法则是相等的。</p><p>如果P、Q和R中任何一个可以表示为其他两个向量的线性组合，则行列式的值为0（根据垂直法则和点积定理推导）。</p><p><strong>【定理1.8】</strong> 对于给定的两个3D向量P和Q，叉积\(\textbf{P} \times \textbf{Q}\)满足下面公式：</p><div>$$||\textbf{P} \times \textbf{Q}|| = \textbf{||P||}\textbf{||Q||}sin\alpha \tag{1.28}$$</div><p>\(\alpha\)为P和Q的夹角。</p><p>由定理1.8可知，叉积\(\textbf{P} \times \textbf{Q}\)的模等于由向量P和Q组成的平行四边形的面积。因此，一个三角形的顶点\(V_{1}, V_{2}, V_{3}\)，可以计算其面积A:</p><div>$$A = \frac{1}{2} || (V_{2} - V_{1}) \times (V_{3} - V_{1}) || \tag{1.32}$$</div><p>叉积得到的非零向量一定垂直于原本的两个向量，但满足要求的有两种方向，为了确定叉积方向，引入叉积遵循的<strong>右手法则</strong>。例如，使用右手手指指向P方向，手心朝向Q反向，则大拇指就是叉积\(\textbf{P} \times \textbf{Q}\)的方向。</p><p>空间轴的单位向量ijk，按照圆形循环的方式排序，i在j之前，j在k之前，k在i之前，则这样的顺序叉积乘等于第三个向量：</p><div>$$\begin{aligned} \textbf{i} \times \textbf{j} &= \textbf{k} \\ \textbf{j} \times \textbf{k} &= \textbf{i} \\ \textbf{k} \times \textbf{i} &= \textbf{j}\end{aligned}\tag{1.33}$$</div><p>反之，按照相反的顺序相接的叉乘等于第三个向量的负值。</p><p><strong>【定理1.9】</strong> 对于给定系数a，b和任意三个3D向量P、Q和R，有以下性质：</p><ul><li>\( \textbf{P} \times \textbf{Q} = - (\textbf{Q} \times \textbf{P}) \)</li><li>\( (a\textbf{P}) \times \textbf{Q} = a(\textbf{P} \times \textbf{Q}) \)</li><li>\( \textbf{P} \times (\textbf{Q} + \textbf{R}) = \textbf{P} \times \textbf{Q} + \textbf{P} \times \textbf{R} \)</li><li>\( \textbf{P} \times \textbf{P} = \textbf{0} = &lt;0, 0, 0&gt; \)</li><li>\( (\textbf{P} \times \textbf{Q}) \cdot \textbf{R} = (\textbf{R} \times \textbf{P}) \cdot \textbf{Q} = (\textbf{Q} \times \textbf{R}) \cdot \textbf{P} \) （注意顺序，满足圆形循环）</li><li>\( \textbf{P} \times (\textbf{Q} \times \textbf{P}) = \textbf{P} \times \textbf{Q} \times \textbf{P} = \textbf{P}^{2}\textbf{Q} - (\textbf{P} \cdot \textbf{Q}) \textbf{P} \)</li></ul><p>前五条都比较容易证明，稍微说一下最后一条的证明方式：</p><div>$$\begin{aligned}\textbf{P} \times (\textbf{Q} \times \textbf{P}) &= \textbf{P} \times [-(\textbf{P} \times \textbf{Q})] \\ &= [\textbf{P} \times -(\textbf{P} \times \textbf{Q})] \\ &= -[-(\textbf{P} \times \textbf{Q}) \times \textbf{P}] \\ &= (\textbf{P} \times \textbf{Q}) \times \textbf{P} \\ &= \textbf{P} \times \textbf{Q} \times \textbf{P}\end{aligned}\tag{1.35}$$</div><p>后面的具体计算式，是通过对三个分量分别求值得到的结果，不再赘述。</p><p>由定理1.9可以得到 <strong>叉积不满足交换律和结合律</strong>。</p><h2 id="4-向量空间"><a href="#4-向量空间" class="headerlink" title="4 向量空间"></a>4 向量空间</h2><p><strong>【定理1.10】</strong> 向量空间是一个集合V，元素成为向量，下面定义向量空间中的加法和乘数，并介绍一些性质：</p><ul><li>V对于加法运算封闭；</li><li>V对于乘数运算封闭；</li><li>V中存在一个零元素 \(\textbf{0}\)；</li><li>V中任意向量P存在向量Q使其 \( \textbf{P} + \textbf{Q} = \textbf{0}\)；</li><li>加法满足结合律；</li><li>乘数满足结合律；</li><li>乘数对于加法满足分配率，\( a(\textbf{P} + \textbf{Q}) = a\textbf{P} + a\textbf{Q}\)；</li><li>系数加法对于乘数满足分配率，\( (a + b)\textbf{P} = a\textbf{P} + b\textbf{P}\)。</li></ul><p>将由n元组组成的向量空间记作 \(R^{n}\)，比如三维的向量空间记作\(R^{3}\)。</p><p>每一个向量空间都可以由一组向量的线性组合来生成，生成向量空间的向量组成为基。</p><p><strong>【定义1.11】</strong> 对于一组向量 {\( \textbf{e}_{1}, \textbf{e}_{2}, …, \textbf{e}_{n} \)}，<strong>如果不存在</strong>这样一组实数 {\(a_{1}, a_{2}, …, a_{n}\)}，其中<strong>至少有一个</strong> \(a_{i}\) 不为0，使得下式成立：</p><div>$$a_{1}\textbf{e}_{1} + a_{2}\textbf{e}_{2} + \cdots + a_{n}\textbf{e}_{n} = 0 \tag{1.40}$$</div><p><strong>则称这组向量线性无关，否则称向量组线性相关</strong>。</p><p>一个n维向量空间可以由n个线性无关的向量组成的向量集合生成，这个向量组成为基。</p><p><strong>【定义1.12】</strong> 向量空间V的基B是一个由n个线性无关的向量组成的集合，即 \(\textbf{B}\)={\(\textbf{e}_{1}, \textbf{e}_{2}, …, \textbf{e}_{n} \)}，对于向量空间V中的任意一个元素P，都存在一组实数使得：</p><div>$$\textbf{P} = a_{1}\textbf{e}_{1} + a_{2}\textbf{e}_{2} + \cdots + a_{n}\textbf{e}_{n} \tag{1.41}$$</div><p>任意空间向量\(R^{n}\)都具有无限个基，对基的形式进行一些限定后，可以使基具有特定的性质。</p><p><strong>【定义1.13】</strong> 对于向量空间的基\(\textbf{B}\)={\(\textbf{e}_{1}, \textbf{e}_{2}, …, \textbf{e}_{n} \)}，如果对于任意 \(i \neq j\) 都有 \(\textbf{e}_{i} \cdot \textbf{e}_{j} = 0\)，则该基为正交基。</p><p><strong>【定理1.14】</strong> 对于给定的两个向量 \(\textbf{e}_{1}\) 和 \(\textbf{e}_{2}\)， 如果\(\textbf{e}_{1} \cdot \textbf{e}_{2} = 0\)，则\(\textbf{e}_{1}\) 和 \(\textbf{e}_{2}\)线性无关。</p><p>对基的另一个形式限定就是基的所有向量都具有单位长度（更简单化了），引入Kronecker delta符号 \(\delta_{ij}\)，定义如下：</p><div>$$\delta_{ij} =\left\{\begin{aligned} 1, i&=j  \\ 0, i&\neq j\end{aligned}\right.\tag{1.42}$$</div><p><strong>【定理1.15】</strong> 如果对于每一对 \((i, j)\) 有 \(\textbf{e}_{i} \cdot \textbf{e}_{j} = \delta_{ij}\)，则基 \(\beta\)={\(\textbf{e}_{1}, \textbf{e}_{2}, …, \textbf{e}_{n} \)}称为向量空间的正交规范基。</p><p>显然向量组{\(\textbf{i}, \textbf{j}, \textbf{k}\)}是\(R^{3}\)的一个正交规范基。</p><p>有一个方法可以将具有n个线性无关向量的向量组转换为向量空间\(R^{n}\)的正交基，基本思想是减去向量在前面每个向量上的投影，结果肯定和前面所有的向量正交。</p><p><strong>【定理1.16】</strong> <strong>Gram-Schmidt 正交规范化：</strong> 对于由n个线性无关想了组成的向量组\(\textbf{B}\)={\(\textbf{e}_{1}, \textbf{e}_{2}, …, \textbf{e}_{n} \)}，算法可以产生向量组\(\beta\)={\(\textbf{e}_{1}^{‘}, \textbf{e}_{2}^{‘}, …, \textbf{e}_{n}^{‘} \)}，当 \(i \neq j\)时，\(\textbf{e}_{i}^{i} \cdot \textbf{e}_{j}^{i} = 0\)。</p><ol><li>设 \(\textbf{e}_{1}^{‘} = \textbf{e}_{1}\)；</li><li>从i=2开始；</li><li>从\(\textbf{e}_{i}\)中减去\(\textbf{e}_{i}\)在向量\(\textbf{e}_{1}^{‘}, \textbf{e}_{2}^{‘}, …, \textbf{e}_{i-1}^{‘} \)上地投影，结果为\(\textbf{e}_{i}^{‘}\)，即</li></ol><div>$$\textbf{e}_{i}^{'} =\textbf{e}_{i} - \sum_{k=1}^{i-1} proj_{\textbf{e}_{k}} \textbf{e}_{i} =\textbf{e}_{i} - \sum_{k=1}^{i-1} \frac{\textbf{e}_{i} \cdot \textbf{e}_{k}}{\textbf{e}_{k}^{2}} \textbf{e}_{k} \tag{1.43}$$</div><ol start="4"><li>如果i &lt; n，i加1，重复步骤3。</li><li>如果需要进一步生成正交规范基，就对每个\(\textbf{e}_{i}^{‘}\)进行规范化。</li></ol>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;对于成功的3D程序猿，掌握如何进行向量运算是一种基本的技能要求。&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="3D游戏与图形学的数学" scheme="https://yumi-cn.github.io/categories/3D%E6%B8%B8%E6%88%8F%E4%B8%8E%E5%9B%BE%E5%BD%A2%E5%AD%A6%E7%9A%84%E6%95%B0%E5%AD%A6/"/>
    
    
    <category term="笔记" scheme="https://yumi-cn.github.io/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>《剑指Offer》第2章笔记 数组</title>
    <link href="https://yumi-cn.github.io/2020/11/26/s2o-c2-array/"/>
    <id>https://yumi-cn.github.io/2020/11/26/s2o-c2-array/</id>
    <published>2020-11-26T13:57:25.000Z</published>
    <updated>2020-11-28T14:12:10.637Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>数据结构是技术面的重点，主要围绕数组、字符串、链表、树、栈以及队列这几种常见的数据结构展开。</p></blockquote><a id="more"></a><p>嗯，除了语言和算法以外的最重要的（废话）。</p><hr><p>数组的一些特点（主要是指C/C++中的基础数组类型）：</p><ul><li>连续的内存，按照顺序存储；</li><li>创建时需要指定数组的容量大小；</li><li><code>O(1)</code>时间读/写任何位置元素；</li></ul><p>为了解决基础数组空间效率不高的问题，人们设计了动态数组，比如 <code>C++ STL</code> 中的 <code>vector</code> ，其中为了避免空间浪费，先为数组开辟小空间，当数据数目超过容量时，再重新分配一块更大的空间，把之间的数据复制到新的数组中，再把之前的内存释放（一般没有延续之前地址往后申请内存的操作，所以只能整块申请，然后再释放掉新的），但是这样就会带来内存空间申请和数据迁移的时间开销，因此使用动态数组要尽量减少改变数组容量大小的操作。</p><blockquote><p>在C/C++中，数组和指针既相互关联又有区别。</p></blockquote><p>声明一个数组时，数组的名字也是一个指针（不可修改的指针变量），该指针指向数组的第一个元素。需要注意的是，C/C++不会主动记录数组的大小，所以在访问数组元素时，程序要确保不会超过边界。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">get_size</span><span class="params">(<span class="keyword">int</span> data[])</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">sizeof</span>(data);</span><br><span class="line">&#125;Error: Cannot find module &#x27;gulplog&#x27;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> data1[] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line">  <span class="keyword">int</span> size1 = <span class="keyword">sizeof</span>(data1);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span>* data2 = data1;</span><br><span class="line">  <span class="keyword">int</span> size2 = <span class="keyword">sizeof</span>(data2);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span> size3 = get_size(data1);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%d, %d, %d&quot;</span>, size1, size2, size3);</span><br><span class="line">  <span class="comment">// 20, 4, 4</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>在上面的代码中：</p><ul><li><code>sizeof(data1) == 20</code>：<code>sizeof(data1)</code>求数组的大小（字节数），<code>data1</code>包含5个整数，每个整数4字节，所以20字节；</li><li><code>sizeof(data2) == 4</code>：<code>data2</code>声明是指针，尽管指向了数组指针，但本质仍然是指针，在32位系统上，对任意指针求<code>sizeof</code>都是4(32位系统是4个字节的地址)；</li><li><code>get_size(data1) == 4</code>：在C/C++中，数组作为函数参数传递时，会退化为同类型的指针，尽管函数声明的是数组参数，但还是会退化为指针（语言概念特色），所以结果仍然是4。</li></ul><hr><blockquote><p>面试题3 题目一：找出数组中重复的数字。</p></blockquote><p>数组长度n，数字都在 <code>0</code> - <code>n-1</code> 的范围内，数组中某些数字重复，但不知道有几个数字重复，请找出数组中任意一个重复数字；例如<code>&#123;2, 3, 1, 0, 2, 5, 3&#125;</code>，重复数字2或者3。</p><ul><li><strong>思路1</strong>：简单的排序再搜索就可以，但需要 <code>O(nlogn)</code> 的时间开销；</li><li><strong>改进思路2</strong>：常用的一种优化思路是使用哈希表，从头到尾记录所有数字的出现次数，如果次数大于2就是重复的数字，时间开销降低到了 <code>O(n)</code> ，但凭空多了哈希表的 <code>O(n)</code> 开销；</li></ul><p>大部分的人都能想到第二种方法，然后书的作者会介绍第三种方法：</p><blockquote><p>数字都在0~n-1的范围内，如果数组不重复，则数字i出现在下标i的位置，如果重复，则某些位置有多个数字，同时有些位置没有数字。</p></blockquote><p>但我觉得对这种方法的阐述，<strong>稍微有点凭空跳脱</strong>，没有和之前提到的前两种思路有任何延续，所以一时可能较于难以理解这里的思路，尤其是之后的算法流程。</p><p>我们可以延续之前的<strong>改进思路2</strong>，使用哈希表的优点是时间开销少，缺点是多了空间开销，那么进一步的优化思路是：<strong>如何减少空间上的开销？</strong></p><p>在已知数字出现在 <code>0</code> ~ <code>n-1</code> 范围内时，哈希表的一种简单实现是位置<code>i</code>存储数字<code>i</code>的出现频率：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> <span class="built_in">array</span>[<span class="number">5</span>] = &#123;<span class="number">1</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">0</span>, <span class="number">2</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> hash[<span class="number">5</span>] = &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>&#125;;</span><br><span class="line">... <span class="comment">// for num in array to finish hash</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; hash &lt;&lt; <span class="built_in">endl</span>; <span class="comment">// [1, 1, 1, 2, 0]</span></span><br></pre></td></tr></table></figure><p>那么，你可以想到的一种优化思路是：原数组存储的数字在读取过一次后其实就没有作用了，所以在数字<code>i</code>被读取了之后，<strong>将它“自己的位置”作为哈希表的存储位</strong>，<strong>不就不需要额外的空间了么</strong>？</p><p>更加细节地，在数字<code>i</code>被读取了过后，尽管它本身可能不在位置<code>i</code>上，可以把原本位置<code>i</code>的数字替换到当前的位置，最后我们使用位置<code>i</code>作为数字<code>i</code>的哈希表存储位，就完成了一步操作；对全数组的数字都执行这样的操作，就可以找出重复的数字了。</p><p>这个方法本质上是延续哈希表的思路，并且具体实现的方式你就会发现和作者提出的方法是一致的，所以我猜测作者的实质本意是将改进思路2的一种延续优化，但并没有在书中进行说明这种思路转变，稍微有点儿可惜。</p><p>PS：这样的改进思路在延续了简单哈希表实现的同时，也延续了这样的哈希表缺点，即无法处理<code>0</code> ~ <code>n-1</code> 范围以外的数字情况。</p><p>从头到尾依次扫描数组中的每个数字，当扫描到位置<code>i</code>的数字<code>m</code>时，判断<code>m==i</code>：</p><ul><li>如果相等，说明数字<code>i</code>在位置<code>i</code>上，继续执行；</li><li>如果不相等，将位置<code>m</code>上的数字交换到位置<code>i</code>上，位置<code>m</code>上放置了数字<code>m</code>，从位置<code>i</code>继续下一步判断；如果在交换之前发现，位置<code>m</code>上已经是数字<code>m</code>了，那么就说明数字<code>m</code>重复了，程序结束。</li></ul><p>一个栗子：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">1</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">0</span>, <span class="number">2</span>] <span class="comment">// i=0</span></span><br><span class="line">[<span class="number">3</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">0</span>, <span class="number">2</span>] <span class="comment">// i=0 1 on 1</span></span><br><span class="line">[<span class="number">0</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">2</span>] <span class="comment">// i=0 3 on 3</span></span><br><span class="line">[<span class="number">0</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">2</span>] <span class="comment">// i=0 0 on 0</span></span><br><span class="line">[<span class="number">0</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">2</span>] <span class="comment">// i=1 1 on 1</span></span><br><span class="line">[<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">3</span>] <span class="comment">// i=2 2 on 2</span></span><br><span class="line">[<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">3</span>] <span class="comment">// i=3 3 on 3</span></span><br><span class="line">[<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">3</span>] <span class="comment">// i=4 3 already on 3, 3 repeat</span></span><br></pre></td></tr></table></figure><p>完整代码实现：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find_repeat</span><span class="params">(<span class="keyword">int</span> <span class="built_in">array</span>[], <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(i &lt; len) &#123;</span><br><span class="line">        <span class="keyword">int</span> m = <span class="built_in">array</span>[i];</span><br><span class="line">        <span class="keyword">if</span>(m != i) &#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">array</span>[m] != m) &#123;</span><br><span class="line">                <span class="comment">// swap</span></span><br><span class="line">                <span class="keyword">int</span> temp = <span class="built_in">array</span>[m];</span><br><span class="line">                <span class="built_in">array</span>[m] = m;</span><br><span class="line">                <span class="built_in">array</span>[i] = temp;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> m;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> len;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> <span class="built_in">array</span>[] = &#123;<span class="number">1</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">0</span>, <span class="number">2</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> len = <span class="keyword">sizeof</span>(<span class="built_in">array</span>) / <span class="keyword">sizeof</span>(<span class="built_in">array</span>[<span class="number">0</span>]);</span><br><span class="line">    <span class="keyword">int</span> dup = find_repeat(<span class="built_in">array</span>, len);</span><br><span class="line">    <span class="keyword">if</span>(dup == len) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;No Repeat Number\n&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Repeat Number: %d\n&quot;</span>, dup);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在其中还可以加上前一节提到的安全、边界等问题的考虑，在下面贴的作者的实现里面可以看到：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">duplicate</span><span class="params">(<span class="keyword">int</span> <span class="built_in">array</span>[], <span class="keyword">int</span> len, <span class="keyword">int</span>* dup)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 考虑参数失效</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">array</span> == <span class="literal">nullptr</span> || len &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 考虑超过边界</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">array</span>[i] &lt; <span class="number">0</span> || <span class="built_in">array</span>[i] &gt; len - <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 实现比较优雅 流程相同</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="built_in">array</span>[i] != i) &#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">array</span>[i] == <span class="built_in">array</span>[<span class="built_in">array</span>[i]]) &#123;</span><br><span class="line">                *dup = <span class="built_in">array</span>[i];</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// swap</span></span><br><span class="line">                <span class="keyword">int</span> temp = <span class="built_in">array</span>[i];</span><br><span class="line">                <span class="built_in">array</span>[i] = <span class="built_in">array</span>[temp];</span><br><span class="line">                <span class="built_in">array</span>[temp] = temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><blockquote><p>面试题3 题目二：不修改数组找出重复的数字。</p></blockquote><p>在长度n+1的数组里的所有数字都在1~n的范围内，所以数组至少有一个数字是重复的。请找出数组中任意一个重复的数字，但不能修改输入的数组。</p><p>这一题虽然可以像题目一那样，只需要多开辟一个n+1长度的辅助数组，用来解决问题，但是这样就多了O(n)的空间开销。</p><p>一般在这种限定情况下，很难再和题目一一样做到时间、空间开销非常小的情况下完成任务，所以可以退一步，不需要缩减到O(n)时间，比如维持和快排复杂度O(nlogn)相同情况下，达成O(1)的空间开销也是一种优化的思路。</p><p>因为出发点不同，我们再次退回到最简单的方法：</p><ul><li>没有额外的空间帮助记录时，就只能每次判断一个数字是否有重复，即判断n次，每次有n长度的遍历开销，也就是O(n^2)；</li></ul><p>所以有<strong>两个优化的方向</strong>：（1）减少判断的次数n；（2）减少遍历长度n。</p><p>在没有额外信息辅助的情况下，优化（2）一般是很难做的（因为每个数只有遍历了全部才知道是否有重复），所以我们可以尝试优化（1）的部分。</p><p>最简单思路下，只有遍历了1~n的n个数在数组中的情况，才能知道谁重复了，我们可以用一些技巧来减少需要判断的次数。</p><p>其实非常巧妙，这条技巧就在题目中：“1~n范围内的数，在长度n+1的数组中必然存在一个重复”，这个命题成立的原因是，如果你遍历一次数组，统计1~n范围内数字的出现次数(n+1)，出现情况是大于n的（这里的n指1~n的这个范围长度），进一步地推广到一个普适命题“i~j范围内的数，在长度n+1的数组中，如果出现次数大于(j-i+1)，那必然存在重复”；</p><p>也就是意味着我们只用使用一次O(n)的遍历时间，就可以确定一个范围的数字是否存在重复。这样的性质可以让我们不断地缩小所需要判断的数字范围，这也就是时间开销上的优化。</p><p>具体地，我们可以联想到二分法：</p><ul><li>一开始将范围1~n分为两部分，一半是1~m，另一半是m+1~n；</li><li>如果范围1~m的数字的统计次数大于m，则这个范围内有重复的数字；否则另一半m+1~n的区间里一定有包含重复的数字；</li><li>继续二分存在重复数字的范围，重复步骤；</li><li>直到确定到某个重复数字。</li></ul><p>比如说题目给的例子{ 2, 3, 5, 4, 3, 2, 6, 7 }：</p><ul><li>[1-4]范围的数字出现5次，[5-7]范围的数字出现3次，重复在[1-4];</li><li>[1-2]范围的数字出现2次，[3-4]范围的数字出现3次，重复在[3-4]；</li><li>[3]数字出现2次，[4]数字出现1次，重复数字是3。</li></ul><p>然后简单分析一下时间复杂度，每次遍历统计的时间开销不变O(n)，因为数字范围二分，一共需要走O(logn)步，所以在O(nlogn)时间中可以找出重复数字。</p><p>完整代码实现：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">is_repeat</span><span class="params">(<span class="keyword">int</span> <span class="built_in">array</span>[], <span class="keyword">int</span> len, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">array</span>[i] &lt;= end &amp;&amp; <span class="built_in">array</span>[i] &gt;= start) &#123;</span><br><span class="line">            count += <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count &gt; (end - start + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find_repeat</span><span class="params">(<span class="keyword">int</span> <span class="built_in">array</span>[], <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> start = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> end = len<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">while</span>(end != start) &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = (end + start) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(is_repeat(<span class="built_in">array</span>, len, start, mid)) &#123;</span><br><span class="line">            end = mid;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            start = mid+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> start;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> <span class="built_in">array</span>[] = &#123;<span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">6</span>, <span class="number">7</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> len = <span class="keyword">sizeof</span>(<span class="built_in">array</span>) / <span class="keyword">sizeof</span>(<span class="built_in">array</span>[<span class="number">0</span>]);</span><br><span class="line">    <span class="keyword">int</span> dup = find_repeat(<span class="built_in">array</span>, len);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Repeat Number: %d\n&quot;</span>, dup); <span class="comment">// 3</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Tips：上述代码没有考虑一些安全、边界问题，所以比较简短。</p><p>需要指出的一点是，上面的使用的这种方法不能保证找出所有重复的数字，例如其中的2也是重复数字，但是算法只找出了3，一个原因是因为只会检查其中一半范围，例如检查到前一半有重复的时候，就不会再检查后一半范围了，另一个原因是算法无法确定是其中一个数字出现2次还是几次。</p><hr><blockquote><p>面试题4：二维数组中的查找</p></blockquote><p>在一个二维整数数组中，每一行从左到右递增，每一列从上到下递增，判断数组中是否含有指定数字。</p><p>例如：</p><div>$$\begin{matrix}1 & 2 & 8 & 9 \\2 & 4 & 9 & 12 \\4 & 7 & 10 & 13 \\6 & 8 & 11 & 15\end{matrix}$$</div><p>当一个数和矩阵中间的一个数比较时，除了相等，还有两种情况：</p><ul><li>(a)当查询数字<strong>小于</strong>目标数字时，说明目标数字<strong>一定不会出现在左上角</strong>，剩下需要判断的区域在其右边和下边；</li><li>(b)当查询数字<strong>大于</strong>目标数字时，说明目标数字<strong>一定不会出现在右下角</strong>，剩下需要判断的区域在其左边和上边。</li></ul><div align="center"><p><img src="/images/s2o-c2-array-cv4.jpg" alt="比较的两种情况"></p></div><p>当我们按照常规思路，尝试从<code>(0,0)</code>出发，向右下角进行搜索时，我们跳转到下一格只有通过2种方式，从上转移到下，和从左转移到右，如果我们把已遍历的位置称为“已知信息”，我们可以看到这种搜索方式，<strong>大部分“已知信息”都集中在左上部</strong>，这在比较出现的两种情况中，要么无法提供任何信息，要么只能提供重叠区域的信息，<strong>无法让转移确定下一次的方向</strong>。</p><p>所以为了<strong>避免“已知信息”的浪费</strong>，我们可以尝试从右上角<code>(0, n-1)</code>出发，向左下角进行搜索，这样会提供更多的信息，如果发生向下转移，代表上边没有比目标数更大的，如果发生向左转移，代表右边的数比目标数更大，所以导致更加明确的在左下角区域中搜索目标数。</p><div align="center"><p><img src="/images/s2o-c2-array-cv4-2.jpg" alt="例子"></p></div><p>完整代码实现：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> matrix[][<span class="number">4</span>], <span class="keyword">int</span> rows, <span class="keyword">int</span> cols, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> j = cols - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(i &lt; rows &amp;&amp; j &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span>(matrix[i][j] &lt; target) &#123;</span><br><span class="line">            i++;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(matrix[i][j] &gt; target) &#123;</span><br><span class="line">            j--;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> matrix[][<span class="number">4</span>] = &#123;</span><br><span class="line">        &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">8</span>, <span class="number">9</span>&#125;,</span><br><span class="line">        &#123;<span class="number">2</span>, <span class="number">4</span>, <span class="number">9</span>, <span class="number">12</span>&#125;,</span><br><span class="line">        &#123;<span class="number">4</span>, <span class="number">7</span>, <span class="number">10</span>, <span class="number">13</span>&#125;,</span><br><span class="line">        &#123;<span class="number">6</span>, <span class="number">8</span>, <span class="number">11</span>, <span class="number">15</span>&#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">int</span> target = <span class="number">7</span>;</span><br><span class="line">    <span class="keyword">if</span>(find(matrix, <span class="number">4</span>, <span class="number">4</span>, target)) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Found!\n&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Not Found!\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;数据结构是技术面的重点，主要围绕数组、字符串、链表、树、栈以及队列这几种常见的数据结构展开。&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="剑指Offer" scheme="https://yumi-cn.github.io/categories/%E5%89%91%E6%8C%87Offer/"/>
    
    
    <category term="笔记" scheme="https://yumi-cn.github.io/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>《剑指Offer》第2章笔记 编程语言</title>
    <link href="https://yumi-cn.github.io/2020/11/25/s2o-c2-lg/"/>
    <id>https://yumi-cn.github.io/2020/11/25/s2o-c2-lg/</id>
    <published>2020-11-25T12:57:25.000Z</published>
    <updated>2020-11-28T09:20:58.171Z</updated>
    
    <content type="html"><![CDATA[<p>第2章主要围绕<strong>编程语言</strong>、<strong>数据结构</strong>和<strong>算法</strong>，介绍技术面所需要的“基础知识”。</p><a id="more"></a><h2 id="编程语言"><a href="#编程语言" class="headerlink" title="编程语言"></a>编程语言</h2><p>书里代码都是用 <code>C/C++/C#</code> 实现的，后面分别从 <code>C++</code> 和 <code>C#</code> 语言的角度来讲述其中一些被问道的细节点，这样的细节点因为篇幅限制，不可能都写进书里，所以还需要通过阅读对应编程语言的书籍来进阶了解，同时其他语言的使用者也可以从其中窥探到面试官在针对语言掌握的考量时，都是从什么样的角度出发的。</p><h3 id="C"><a href="#C" class="headerlink" title="C++"></a>C++</h3><p>通常语言面试的问题有3种类型：</p><ol><li>对于语言中概念的理解程度；</li><li>面对代码，分析运行结果（或错误）；</li><li>在上下文环境中，定义类型或实现函数。</li></ol><p>作者推荐的几本C++书，根据自己的情况选择阅读顺序：</p><ul><li><strong>《Effective C++》</strong>：书中列举了C++经常出现的问题以及解决这些问题的技巧（大多是面试官比较喜欢问的方向），适合面试之前突击C++；</li><li><strong>《C++ Primer》</strong>：人称C++全书，适合全面了解的时候阅读，也可以当作宝典查询；</li><li><strong>《深度探索C++对象模型》</strong>：深度了解C++对象的内部机制，介绍很多较为底层的知识点；</li><li><strong>《The C++ Programming Language》</strong>：C++圣经（大概），适合全面深入掌握C++。</li></ul><p>下面通过一道面试题（第3种类型）来表现一下这类题目是如何考查语言知识点的。</p><blockquote><p>面试题1：赋值运算符函数，如下为类型CMyString的声明，请为该类型添加赋值运算符函数。</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CMyString</span> &#123;</span></span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    CMyString(<span class="keyword">char</span>* pData=<span class="literal">nullptr</span>);</span><br><span class="line">    CMyString(<span class="keyword">const</span> CMyString&amp; str);</span><br><span class="line">    ~CMyString(<span class="keyword">void</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">char</span>* m_pData;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>Tips：赋值运算符主要负责变量在进行赋值 <code>=</code> 运算时，如何处理变量对象内部成员变化。</p><p>定义C++中的<strong>赋值运算符</strong>函数时，需要关注点有：</p><ul><li><strong>返回值类型声明为引用，函数结束前返回实例自身的引用</strong>，因为返回引用才允许连续赋值的情况，例如 <code>str1 = str2 = str3</code>，否则无法通过编译；</li><li>把<strong>传入的参数类型声明为常量引用</strong>，如果不是引用，形参到实参传递会调用一次复制构造函数（函数的传值引用），引用可以避免这样的开销；同时因为赋值运算并不会修改传入的实例的状态，所以应进一步加上 <code>const</code> 关键字；</li><li><strong>释放实例自身已有的内存</strong>，主要在对象有动态分配内存情况下考虑，如果忘记在分配新内存前释放旧内存空间，程序旧出现了内存泄漏(memory leakge)，这块内存无法被回收使用（资源浪费、占用空间导致空间不够用）；</li><li><strong>判断传入参数和当前实例</strong>(*this)是不是同一个实例，是则不进行赋值，如果不判断就直接赋值，在同一个实例情况下，会导致在还没有拷贝到传入参数（自己）的内存时，就释放自己的内存，这也就导致传入参数的内存被释放了（因为函数是传引用），最后找不到待赋值的内容。</li></ul><p>经典解法：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line">CMyString&amp; CMyString::<span class="keyword">operator</span>=(<span class="keyword">const</span> CMyString&amp; str) &#123;</span><br><span class="line">  <span class="keyword">if</span>(<span class="keyword">this</span> == &amp;str) &#123;  <span class="comment">// 对象的 this 是一个地址</span></span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;     <span class="comment">// 传对象 而不是地址</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">delete</span> []m_pData;   <span class="comment">// 数组的释放方式</span></span><br><span class="line">  m_pData = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">  m_pData = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="built_in">strlen</span>(str.m_pData) + <span class="number">1</span>]; <span class="comment">// 申请新空间，多的1位给&#x27;\0&#x27;</span></span><br><span class="line">  <span class="built_in">strcpy</span>(m_pData, str.m_pData); <span class="comment">// 复制 赋值</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果对自己有更高的要求，应该再进一步地考虑其中涉及到的问题。</p><p>前面的函数中，<strong>分配内存之前先释放了内存</strong>，如果在分配内存时，内存不足就会导致 <code>new char</code> 排除异常，<code>m_pData</code>将是一个空指针，并且无法回退到之前的结果，也就是说一旦赋值运算符内部抛出了异常，实例不再保持有效的状态（并不是原有的状态），这违背了异常安全性（Exception Safety）原则（正常情况下，如果抛出异常也不应该导致内容被错误操作）。</p><ul><li>简单的方法是先用 <code>new</code> 分配新内容，再 <code>delete</code> 释放已有的；</li><li>更好的办法是<strong>创建一个临时实例</strong>，再交换临时实例和原来的实例。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line">CMyString&amp; CMyString::<span class="keyword">operator</span>=(<span class="keyword">const</span> CMyString&amp; str) &#123;</span><br><span class="line">  <span class="keyword">if</span>(<span class="keyword">this</span> == &amp;str) &#123;</span><br><span class="line">    CMyString tmp(str); <span class="comment">// 复制构造函数</span></span><br><span class="line">    <span class="built_in">std</span>::swap(m_pData, tmp.m_pData); <span class="comment">// 交换地址</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当 <code>tmp</code> 局部变量遇到 <code>if</code> 结束时，会自动调用它的析构函数，会把交换下来的 <code>this</code> 的 <code>m_pData</code> 所指向的内存释放掉；在新的代码中，在复制构造函数中分配内存，如果由于内存不足抛出异常时，由于此时还没有修改原来的实例状态，实例的状态依旧是有效的（原有的），也就保证了异常安全性。</p><p>完整代码（包含所有实现和测试）：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CMyString</span> &#123;</span></span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    CMyString(<span class="keyword">char</span>* pData); <span class="comment">// 第一个参数设定默认值会导致无法通过编译</span></span><br><span class="line">    CMyString(<span class="keyword">const</span> CMyString&amp; str);</span><br><span class="line">    ~CMyString(<span class="keyword">void</span>);</span><br><span class="line">    CMyString&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> CMyString&amp; str); <span class="comment">// 赋值运算符函数声明</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">void</span>)</span></span>; <span class="comment">// 标准输出函数</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">char</span>* m_pData;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 构造函数</span></span><br><span class="line">CMyString::CMyString(<span class="keyword">char</span>* pData) &#123;</span><br><span class="line">    <span class="keyword">if</span>(pData != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        m_pData = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="built_in">strlen</span>(pData) + <span class="number">1</span>];</span><br><span class="line">        <span class="built_in">strcpy</span>(m_pData, pData);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 复制构造函数</span></span><br><span class="line">CMyString::CMyString(<span class="keyword">const</span> CMyString&amp; str) &#123;</span><br><span class="line">    <span class="keyword">if</span>(str.m_pData != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        m_pData = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="built_in">strlen</span>(str.m_pData) + <span class="number">1</span>];</span><br><span class="line">        <span class="built_in">strcpy</span>(m_pData, str.m_pData);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 析构函数</span></span><br><span class="line">CMyString::~CMyString(<span class="keyword">void</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span>(m_pData != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="keyword">delete</span> []m_pData;</span><br><span class="line">        m_pData = <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CMyString::print</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; m_pData &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 赋值运算符函数</span></span><br><span class="line">CMyString&amp; CMyString::<span class="keyword">operator</span>=(<span class="keyword">const</span> CMyString&amp; str) &#123;</span><br><span class="line">  <span class="keyword">if</span>(<span class="keyword">this</span> != &amp;str) &#123;</span><br><span class="line">    CMyString tmp(str); <span class="comment">// 复制构造函数</span></span><br><span class="line">    <span class="built_in">std</span>::swap(m_pData, tmp.m_pData); <span class="comment">// 交换地址</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 测试CMyString</span></span><br><span class="line">    <span class="function">CMyString <span class="title">str1</span><span class="params">(<span class="string">&quot;Sword&quot;</span>)</span></span>;</span><br><span class="line">    <span class="function">CMyString <span class="title">str2</span><span class="params">(<span class="string">&quot;2&quot;</span>)</span></span>;</span><br><span class="line">    <span class="function">CMyString <span class="title">str3</span><span class="params">(<span class="string">&quot;Offer&quot;</span>)</span></span>;</span><br><span class="line">    str1 = str2 = str3;</span><br><span class="line">    str1.print(); <span class="comment">// Offer</span></span><br><span class="line">    str2.print(); <span class="comment">// Offer</span></span><br><span class="line">    str3.print(); <span class="comment">// Offer</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果完整的去实现上面这个题目，会引出一些非常容易忽略的细节问题（并且会导致严重错误），例如在初始化变量 <code>str1</code> 时，<code>CMyString str1(&quot;Sword&quot;);</code>，其中所传入的参数一般都是程序声明的<strong>字符串常量</strong>，如果在构造函数中简单地实现为：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Mem Error</span></span><br><span class="line">CMyString::CMyString(<span class="keyword">char</span>* pData) &#123;</span><br><span class="line">    m_pData = pData;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>就会导致赋值运算符函数中的析构函数调用过程发生错误，因为析构函数中的 <code>delete []m_pData</code> 的delete操作符只负责操作堆(Heap)中的内存区域(因为new只在堆里申请内存区域)，如果使用delete操作符去释放一个字符串常量指针所指向的区域，就会发生错误（大概是访问越界）。</p><p>所以在初始化时应该使用和delete对应的new操作，在堆中申请内存，再把传入参数的内容复制到其中。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">CMyString::CMyString(<span class="keyword">char</span>* pData) &#123;</span><br><span class="line">    <span class="keyword">if</span>(pData != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        m_pData = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="built_in">strlen</span>(pData) + <span class="number">1</span>];</span><br><span class="line">        <span class="built_in">strcpy</span>(m_pData, pData);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="C-1"><a href="#C-1" class="headerlink" title="C#"></a>C#</h3><p>因为还没怎么学C#的东西，C#的部分暂时跳过，记录一下推荐的书：</p><ul><li>《Professional C#》：特点是附录中有描述C#和其他语言的区别；</li><li>《CLR Via C#》：深入介绍C#，对CLR和.NET进行剖析，可以方便理解装箱卸箱、垃圾回收、反射等概念。</li></ul><blockquote><p>面试题2：实现Singleton模式（单例模式）</p></blockquote><p>暂时跳过。</p><p>涉及到设计模式的部分，列举一些可以参考阅读的资料：</p><ul><li>《设计模式：C++常用设计模式》：<a href="https://refactoringguru.cn/design-patterns/cpp">https://refactoringguru.cn/design-patterns/cpp</a> ；</li><li>《Head First 设计模式》：感觉是一本比较老的书，可能之后看看吧；</li><li>《Game Programming Patterns》：<a href="http://gameprogrammingpatterns.com/contents.html">http://gameprogrammingpatterns.com/contents.html</a> 。</li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;第2章主要围绕&lt;strong&gt;编程语言&lt;/strong&gt;、&lt;strong&gt;数据结构&lt;/strong&gt;和&lt;strong&gt;算法&lt;/strong&gt;，介绍技术面所需要的“基础知识”。&lt;/p&gt;</summary>
    
    
    
    <category term="剑指Offer" scheme="https://yumi-cn.github.io/categories/%E5%89%91%E6%8C%87Offer/"/>
    
    
    <category term="笔记" scheme="https://yumi-cn.github.io/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>《剑指Offer》第1章笔记</title>
    <link href="https://yumi-cn.github.io/2020/11/24/s2o-c1/"/>
    <id>https://yumi-cn.github.io/2020/11/24/s2o-c1/</id>
    <published>2020-11-24T04:57:25.000Z</published>
    <updated>2020-11-28T09:20:54.477Z</updated>
    
    <content type="html"><![CDATA[<p>第1章主要介绍的是几种面试方式的不同流程以及注意事项。</p><blockquote><p>“…技术面试中的5个要素，是全书的大纲,…”</p></blockquote><a id="more"></a><h2 id="远程桌面面试"><a href="#远程桌面面试" class="headerlink" title="远程桌面面试"></a>远程桌面面试</h2><ul><li>思考清楚再开始编码；</li><li>良好的代码命名和缩进对齐；</li><li>单元测试、断点调试。</li></ul><h2 id="面试的3个环节"><a href="#面试的3个环节" class="headerlink" title="面试的3个环节"></a>面试的3个环节</h2><p>行为面试、技术面试、应聘者提问。</p><h3 id="行为面试"><a href="#行为面试" class="headerlink" title="行为面试"></a>行为面试</h3><ol start="0"><li>自我介绍：30s-1min，介绍主要学习和工作经历；</li><li>项目经验：STAR模型描述项目经历；<ul><li>Situation：简短的项目背景；</li><li>Task：自己完成的任务，注意区分“参与”和“负责”；</li><li>Action：如何完成任务的，详细介绍自己完成任务的方式方法；</li><li>Result：自己的贡献，尝试量化自己的产出，让人直接接收到你的成果。</li></ul></li><li>掌握技能：注意区分“了解”、“熟悉”和“精通”；<ul><li>了解：上过课、看过书，但没有做过实际项目，通常只建议有用的时候再写；</li><li>熟悉：通常的情况，指能够独立解决大部分问题；</li><li>精通：得心应手，能够轻松回答领域内的绝大多数问题。</li></ul></li><li>为什么跳槽：尽量不说抱怨层面的原因，多从自我发展的角度阐述选择的理由。</li></ol><h3 id="技术面试"><a href="#技术面试" class="headerlink" title="技术面试"></a>技术面试</h3><p>平均1个小时的面试，技术面试会占据40-50分钟的时间。</p><p>总的来说面试官关注应聘者的5种素质：</p><ul><li>扎实的基础知识：编程语言、数据结构和算法；</li><li>能写高质量的代码：代码鲁棒性，边界考虑（另外还需要注意代码规范或者风格）；</li><li>分析问题的思路清晰：从简单完备的思路出发，用各种方法来尝试优化，例如画图形象化，举例具象化，分解简单化；</li><li>能够优化时间、空间效率：熟知数据结构优缺点，熟练掌握常用算法；</li><li>学习、沟通、综合能力。</li></ul><p>PS：5个要素分别对应本书的第2、3、4、5、6章节内容。</p><h3 id="应聘者提问"><a href="#应聘者提问" class="headerlink" title="应聘者提问"></a>应聘者提问</h3><p>如果觉得面试后临时想比较困难，可以在面试前提前准备一些问题。</p><p>主要围绕公司、职位、项目等工作上的事情，不太适合问较远较模糊或者和工薪相关的问题（之后再和HR聊也可以）。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;第1章主要介绍的是几种面试方式的不同流程以及注意事项。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;“…技术面试中的5个要素，是全书的大纲,…”&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="剑指Offer" scheme="https://yumi-cn.github.io/categories/%E5%89%91%E6%8C%87Offer/"/>
    
    
    <category term="笔记" scheme="https://yumi-cn.github.io/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>11月的计划</title>
    <link href="https://yumi-cn.github.io/2020/11/19/plan-2020/"/>
    <id>https://yumi-cn.github.io/2020/11/19/plan-2020/</id>
    <published>2020-11-18T16:00:00.000Z</published>
    <updated>2020-11-27T13:55:01.557Z</updated>
    
    <content type="html"><![CDATA[<p>11月大概还剩下一周的时间，主要是在尝试起步学一些东西：</p><ul><li>《剑指Offer》：大概前几章，简单过一下摸一下这本书的安排规律，每章尽量写一点浓缩知识点；</li><li>《3D游戏与计算机图形学中的数学方法》：之前把Games101课程简单过了一下，再通过刷这本书巩固一下基础的数学。</li></ul><a id="more"></a><p>12月的初步规划：</p><ul><li>《剑指Offer》；</li><li>《3D游戏与计算机图形学中的数学方法》；</li><li>《Fundamentals of Computer Graphics》 。</li></ul><p>1月的初步规划：</p><ul><li>《Effictive C++》；</li><li>《Real Time Rendering 4th》；</li><li>《游戏引擎架构》。</li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;11月大概还剩下一周的时间，主要是在尝试起步学一些东西：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;《剑指Offer》：大概前几章，简单过一下摸一下这本书的安排规律，每章尽量写一点浓缩知识点；&lt;/li&gt;
&lt;li&gt;《3D游戏与计算机图形学中的数学方法》：之前把Games101课程简单过了一下，再通过刷这本书巩固一下基础的数学。&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="计划-Flags" scheme="https://yumi-cn.github.io/categories/%E8%AE%A1%E5%88%92-Flags/"/>
    
    
  </entry>
  
</feed>
