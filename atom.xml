<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>画码余生</title>
  
  <subtitle>副标题</subtitle>
  <link href="https://yumi-cn.github.io/atom.xml" rel="self"/>
  
  <link href="https://yumi-cn.github.io/"/>
  <updated>2021-03-13T07:52:34.238Z</updated>
  <id>https://yumi-cn.github.io/</id>
  
  <author>
    <name>Yumiko</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>3月的计划</title>
    <link href="https://yumi-cn.github.io/2021/03/13/plan-2021-03/"/>
    <id>https://yumi-cn.github.io/2021/03/13/plan-2021-03/</id>
    <published>2021-03-13T03:28:19.000Z</published>
    <updated>2021-03-13T07:52:34.238Z</updated>
    
    <content type="html"><![CDATA[<p>已经开始投了大半简历了hhh，甚至都开始面试了两次了。</p><p>尽管非常忙，但还是要继续把学习的任务规划下去，加油！</p><a id="more"></a><p>简单总结一下2月：</p><ul><li>过年基本没学啥，摸了，哭了。</li></ul><p>3月的规划：</p><ul><li><strong>《LeetCode-200》</strong>每部分的题目（至少常见的要先做了吧）；</li><li><strong>《Effective C++》</strong>剩下的20几个条款；</li><li><strong>《Real Time Rendering 3th》</strong>再通读一遍，一些经典的细节点可以再深入了解一下其中的实现原理；</li><li><strong>《C++ Primer》</strong>的一些经典章节再过一下吧；</li><li><strong>引擎面试题</strong>，只能去收集各大厂引擎、渲染方面的面经贴，然后总结各种各样的点，有必要的话拓展去了解；</li><li><strong>剩下的简历投递</strong>，还有几家没有投，注意别忘了。</li></ul><p>4月的规划：</p><p>3月下旬到4月中旬，估计是一波笔试面试的高峰期，这个时候就按照笔试、面试发现的自己的漏掉的知识点进行补全和总结，并整理从面试中获取到的一些信息，调整自己后面4个月准备秋招的学习计划，尽量做到好钢用在刀刃上。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;已经开始投了大半简历了hhh，甚至都开始面试了两次了。&lt;/p&gt;
&lt;p&gt;尽管非常忙，但还是要继续把学习的任务规划下去，加油！&lt;/p&gt;</summary>
    
    
    
    <category term="计划-Flags" scheme="https://yumi-cn.github.io/categories/%E8%AE%A1%E5%88%92-Flags/"/>
    
    
  </entry>
  
  <entry>
    <title>2月的计划</title>
    <link href="https://yumi-cn.github.io/2021/02/02/plan-2021-02/"/>
    <id>https://yumi-cn.github.io/2021/02/02/plan-2021-02/</id>
    <published>2021-02-02T12:05:19.000Z</published>
    <updated>2021-02-02T12:19:19.687Z</updated>
    
    <content type="html"><![CDATA[<p>距离2021的春招实习只有1个半月了。</p><p>1月的进度稍微有点不太乐观，继续把计划规划下去吧。</p><a id="more"></a><p>简单总结一下1月：</p><ul><li><strong>《剑指Offer》</strong>1-6章都已经刷完了；</li><li><strong>《3D游戏与计算机图形学中的数学方法》</strong> 和 <strong>《Real Time Rendering 4th》</strong>都没有怎么看，因为转头去学OpenGL了；</li><li><strong>《LearnOpenGL》</strong>学习了基础和光照部分，目前在模型加载部分；</li><li><strong>《Effective C++》</strong>也一点没看，只是稍微看了点CPP的基础内容。</li></ul><p>2月就把科研任务先放一放了，主要搞一下找实习要用的东西。</p><p>2月的规划：</p><ul><li><strong>《LearnOpenGL》</strong>全部内容；</li><li><strong>《LeetCode-200》</strong>每部分的题目；</li><li><strong>《Effective C++》</strong>的55个条款，尽量都写写代码尝试实践，每一个其实都涉及到不少原本C++中的知识点，应该都要同步学习或者复习一下；</li><li><strong>《Real Time Rendering 4th》</strong>第4-11章，只读，不写博客；</li><li><strong>《C++ Primer》</strong>2-16章，只读，不写博客；</li><li><strong>Unity3D入门和《Unity Shader 入门精要》</strong>，主要是了解Unity方面的相关知识；</li><li><strong>引擎面试题</strong>，只能去收集各大厂引擎、渲染方面的面经贴，然后总结各种各样的点，有必要的话拓展去了解；</li><li><strong>各大厂的简历投递</strong>，别忘了投简历了，注意提前收集他们的时间。</li></ul><p>3月的初步规划（基本上到了冲刺阶段了，剩下半个月时间）：</p><ul><li><strong>面试笔试题</strong>，每日做题的任务照常安排着走；</li><li><strong>引擎面试题</strong>，继续看收集的那些面试问题，顺带复习一下以前的笔记；</li><li><strong>《游戏引擎架构》</strong>，半个月简单刷一下这本书的大致内容，做到都有一定了解即可，当作知识广度阅读资料。</li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;距离2021的春招实习只有1个半月了。&lt;/p&gt;
&lt;p&gt;1月的进度稍微有点不太乐观，继续把计划规划下去吧。&lt;/p&gt;</summary>
    
    
    
    <category term="计划-Flags" scheme="https://yumi-cn.github.io/categories/%E8%AE%A1%E5%88%92-Flags/"/>
    
    
  </entry>
  
  <entry>
    <title>《LearnOpenGL》光照 笔记</title>
    <link href="https://yumi-cn.github.io/2021/01/26/learnopengl-c2/"/>
    <id>https://yumi-cn.github.io/2021/01/26/learnopengl-c2/</id>
    <published>2021-01-26T13:34:18.000Z</published>
    <updated>2021-01-26T13:34:55.616Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>上帝说，要有光，于是便有了光。</p></blockquote><a id="more"></a><blockquote><p>笔记摘录源地址：<a href="https://learnopengl-cn.github.io/">LearnOpenGL CN</a></p></blockquote><h2 id="颜色"><a href="#颜色" class="headerlink" title="颜色"></a>颜色</h2><p>颜色可以数字化的由红色(Red)、绿色(Green)和蓝色(Blue)三个分量组成，它们通常被缩写为<strong>RGB</strong>。仅仅用这三个值就可以组合出任意一种颜色。例如，要获取一个珊瑚红(Coral)色的话，我们可以定义这样的一个颜色向量：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">glm::vec3 <span class="title">coral</span><span class="params">(<span class="number">1.0f</span>, <span class="number">0.5f</span>, <span class="number">0.31f</span>)</span></span>;</span><br></pre></td></tr></table></figure><p>我们在现实生活中<strong>看到某一物体的颜色并不是这个物体真正拥有的颜色</strong>，而是<strong>它所反射的</strong>(Reflected)<strong>颜色</strong>。换句话说，那些不能被物体所吸收(Absorb)的颜色（被拒绝的颜色）就是我们能够感知到的物体的颜色。</p><p>例如，<strong>太阳光能被看见的白光其实是由许多不同的颜色组合而成的</strong>。如果我们将白光照在一个蓝色的玩具上，这个蓝色的玩具会吸收白光中除了蓝色以外的所有子颜色，不被吸收的蓝色光被反射到我们的眼中，让这个玩具看起来是蓝色的。下图显示的是一个珊瑚红的玩具，它以不同强度反射了多个颜色。</p><div align="center"><p><img src="/images/learnopengl-c2-f1.jpg"></p></div><p>你可以看到，<strong>白色的阳光实际上是所有可见颜色的集合，物体吸收了其中的大部分颜色</strong>。它仅反射了代表物体颜色的部分，<strong>被反射颜色的组合就是我们所感知到的颜色</strong>（此例中为珊瑚红）。</p><p>这些颜色反射的定律被直接地运用在图形领域。当我们在OpenGL中<strong>创建一个光源时</strong>，我们希望给光源一个颜色。在上一段中我们有一个白色的太阳，所以我们也将光源设置为白色。<strong>当我们把光源的颜色与物体的颜色值相乘</strong>，所得到的<strong>就是这个物体所反射的颜色</strong>（也就是我们所感知到的颜色）。</p><p>让我们再次审视我们的玩具（这一次它还是珊瑚红），看看如何在图形学中计算出它的反射颜色。我们将这两个颜色向量作分量相乘，结果就是最终的颜色向量了：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">glm::vec3 <span class="title">lightColor</span><span class="params">(<span class="number">1.0f</span>, <span class="number">1.0f</span>, <span class="number">1.0f</span>)</span></span>;</span><br><span class="line"><span class="function">glm::vec3 <span class="title">toyColor</span><span class="params">(<span class="number">1.0f</span>, <span class="number">0.5f</span>, <span class="number">0.31f</span>)</span></span>;</span><br><span class="line">glm::vec3 result = lightColor * toyColor;</span><br><span class="line"><span class="comment">// result = (1.0f, 0.5f, 0.31f)</span></span><br></pre></td></tr></table></figure><p>我们可以看到<strong>玩具的颜色吸收了白色光源中很大一部分的颜色</strong>，但它根据自身的颜色值<strong>对红、绿、蓝三个分量都做出了一定的反射</strong>。这也表现了<strong>现实中颜色的工作原理</strong>。由此，我们可以<strong>定义物体的颜色</strong>为<strong>物体从一个光源反射各个颜色分量的大小</strong>。现在，如果我们使用<strong>绿色的光源</strong>又会发生什么呢？</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">glm::vec3 <span class="title">lightColor</span><span class="params">(<span class="number">0.0f</span>, <span class="number">1.0f</span>, <span class="number">0.0f</span>)</span></span>;</span><br><span class="line"><span class="function">glm::vec3 <span class="title">toyColor</span><span class="params">(<span class="number">1.0f</span>, <span class="number">0.5f</span>, <span class="number">0.31f</span>)</span></span>;</span><br><span class="line">glm::vec3 result = lightColor * toyColor;</span><br><span class="line"><span class="comment">// result = (0.0f, 0.5f, 0.0f)</span></span><br></pre></td></tr></table></figure><p>可以看到，并没有红色和蓝色的光让我们的玩具来吸收或反射。这个玩具<strong>吸收了光线中一半的绿色值，但仍然也反射了一半的绿色值</strong>。玩具现在看上去是<strong>深绿色</strong>(Dark-greenish)的。我们可以看到，如果我们用绿色光源来照射玩具，那么只有绿色分量能被反射和感知到，<strong>红色和蓝色都不能被我们所感知到</strong>。这样做的结果是，<strong>一个珊瑚红的玩具突然变成了深绿色物体</strong>。现在我们来看另一个例子，使用<strong>深橄榄绿色</strong>(Dark olive-green)的光源：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">glm::vec3 <span class="title">lightColor</span><span class="params">(<span class="number">0.33f</span>, <span class="number">0.42f</span>, <span class="number">0.18f</span>)</span></span>;</span><br><span class="line"><span class="function">glm::vec3 <span class="title">toyColor</span><span class="params">(<span class="number">1.0f</span>, <span class="number">0.5f</span>, <span class="number">0.31f</span>)</span></span>;</span><br><span class="line">glm::vec3 result = lightColor * toyColor;</span><br><span class="line"><span class="comment">// result = (0.33f, 0.21f, 0.06f)</span></span><br></pre></td></tr></table></figure><p>可以看到，我们可以使用不同的光源颜色来让物体显现出意想不到的颜色。有创意地利用颜色其实并不难。</p><h3 id="创建一个光照场景"><a href="#创建一个光照场景" class="headerlink" title="创建一个光照场景"></a>创建一个光照场景</h3><p>首先我们需要一个<strong>物体来作为被投光</strong>(Cast the light)的对象，我们将使用前面教程中的那个著名的立方体箱子。我们<strong>还需要一个物体来代表光源在3D场景中的位置</strong>。简单起见，我们依然使用一个<strong>立方体来代表光源</strong>。</p><p>准备立方体箱子的数据。</p><p>我们首先需要一个<strong>顶点着色器</strong>来绘制箱子。与之前的顶点着色器相比，<strong>容器的顶点位置是保持不变的</strong>（虽然这一次我们不需要纹理坐标了），因此顶点着色器中没有新的代码。我们将会使用之前教程<strong>顶点着色器的精简版</strong>：</p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#version 330 core</span></span><br><span class="line"><span class="keyword">layout</span> (<span class="keyword">location</span> = <span class="number">0</span>) <span class="keyword">in</span> <span class="type">vec3</span> aPos;</span><br><span class="line"></span><br><span class="line"><span class="keyword">uniform</span> <span class="type">mat4</span> model;</span><br><span class="line"><span class="keyword">uniform</span> <span class="type">mat4</span> view;</span><br><span class="line"><span class="keyword">uniform</span> <span class="type">mat4</span> projection;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> main() &#123;</span><br><span class="line">    <span class="built_in">gl_Position</span> = projection * view * model * <span class="type">vec4</span>(aPos, <span class="number">1.0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>记得更新你的顶点数据和属性指针使其与新的顶点着色器保持一致。</p><p>因为我们还要创建一个<strong>表示灯</strong>（光源）<strong>的立方体</strong>，所以我们还要为这个灯创建一个专门的VAO。当然我们也可以让这个灯和其它物体使用同一个VAO，简单地对它的model（模型）矩阵做一些变换就好了，然而接下来的教程中<strong>我们会频繁地对顶点数据和属性指针做出修改</strong>，我们并<strong>不想让这些修改影响到灯</strong>（我们只关心灯的顶点位置），因此我们<strong>有必要为灯创建一个新的VAO</strong>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> lightVAO;</span><br><span class="line">glGenVertexArrays(<span class="number">1</span>, &amp;lightVAO);</span><br><span class="line">glBindVertexArray(lightVAO);</span><br><span class="line"><span class="comment">// 只需要绑定VBO不用再次设置VBO的数据，因为箱子的VBO数据中已经包含了正确的立方体顶点数据</span></span><br><span class="line">glBindBuffer(GL_ARRAY_BUFFER, VBO);</span><br><span class="line"><span class="comment">// 设置灯立方体的顶点属性（对我们的灯来说仅仅只有位置数据）</span></span><br><span class="line">glVertexAttribPointer(<span class="number">0</span>, <span class="number">3</span>, GL_FLOAT, GL_FALSE, <span class="number">3</span> * <span class="keyword">sizeof</span>(<span class="keyword">float</span>), (<span class="keyword">void</span>*)<span class="number">0</span>);</span><br><span class="line">glEnableVertexAttribArray(<span class="number">0</span>);</span><br></pre></td></tr></table></figure><p>现在我们已经创建了表示灯和被照物体箱子，我们只需要再<strong>定义一个片段着色器</strong>就行了：</p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#version 330 core</span></span><br><span class="line"><span class="keyword">out</span> <span class="type">vec4</span> FragColor;</span><br><span class="line"></span><br><span class="line"><span class="keyword">uniform</span> <span class="type">vec3</span> objectColor;</span><br><span class="line"><span class="keyword">uniform</span> <span class="type">vec3</span> lightColor;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> main() &#123;</span><br><span class="line">    FragColor = <span class="type">vec4</span>(lightColor * objectColor, <span class="number">1.0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个片段着色器从uniform变量中<strong>接受物体的颜色和光源的颜色</strong>。正如本节一开始所讨论的那样，我们将光源的颜色和物体（反射的）颜色相乘。这个着色器理解起来应该很容易。我们把物体的颜色设置为之前提到的珊瑚红色，并把光源设置为白色。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">lightingShader.use();</span><br><span class="line">lightingShader.setVec3(<span class="string">&quot;objectColor&quot;</span>, <span class="number">1.0f</span>, <span class="number">0.5f</span>, <span class="number">0.31f</span>);</span><br><span class="line">lightingShader.setVec3(<span class="string">&quot;lightColor&quot;</span>,  <span class="number">1.0f</span>, <span class="number">1.0f</span>, <span class="number">1.0f</span>);</span><br></pre></td></tr></table></figure><p>要注意的是，<strong>当我们修改顶点或者片段着色器后</strong>，<strong>灯的位置或颜色也会随之改变</strong>，这并不是我们想要的效果。我们<strong>不希望灯的颜色在接下来的教程中因光照计算的结果而受到影响</strong>，而是<strong>希望它能够与其它的计算分离</strong>。我们希望灯一直保持明亮，不受其它颜色变化的影响（这样它才更像是一个真实的光源）。</p><p>为了实现这个目标，我们<strong>需要为灯的绘制创建另外的一套着色器</strong>，从而能保证它能够在<strong>其它光照着色器发生改变的时候不受影响</strong>。顶点着色器与我们当前的顶点着色器是一样的，所以你可以直接把现在的顶点着色器用在灯上。<strong>灯的片段着色器给灯定义了一个不变的常量白色，保证了灯的颜色一直是亮的</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#version 330 core</span></span><br><span class="line">out vec4 FragColor;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    FragColor = vec4(<span class="number">1.0</span>); <span class="comment">// 将向量的四个分量全部设置为1.0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>当我们想要绘制我们的物体的时候</strong>，我们需要使用刚刚定义的光照着色器来绘制箱子（或者可能是其它的物体）。<strong>当我们想要绘制灯的时候</strong>，我们会使用灯的着色器。在之后的教程里我们会逐步更新这个光照着色器，从而能够慢慢地实现更真实的效果。</p><p>使用这个灯立方体的主要目的是为了<strong>让我们知道光源在场景中的具体位置</strong>。我们通常在场景中定义一个光源的位置，但这只是一个位置，它并没有视觉意义。为了显示真正的灯，<strong>我们将表示光源的立方体绘制在与光源相同的位置</strong>。我们将使用我们为它新建的片段着色器来绘制它，让它一直处于白色的状态，不受场景中的光照影响。</p><p>我们声明一个全局vec3变量来表示光源在场景的世界空间坐标中的位置：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">glm::vec3 <span class="title">lightPos</span><span class="params">(<span class="number">1.2f</span>, <span class="number">1.0f</span>, <span class="number">2.0f</span>)</span></span>;</span><br></pre></td></tr></table></figure><p>然后我们把灯位移到这里，然后将它缩小一点，让它不那么明显：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">model = glm::mat4();</span><br><span class="line">model = glm::translate(model, lightPos);</span><br><span class="line">model = glm::scale(model, glm::vec3(<span class="number">0.2f</span>));</span><br></pre></td></tr></table></figure><p>最后完整的渲染过程部分：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (!glfwWindowShouldClose(window)) &#123;</span><br><span class="line">    <span class="keyword">float</span> currentFrame = glfwGetTime();</span><br><span class="line">    deltaTime = currentFrame - lastFrame;</span><br><span class="line">    lastFrame = currentFrame;</span><br><span class="line"></span><br><span class="line">    process_input(window);</span><br><span class="line"></span><br><span class="line">    glClearColor(<span class="number">0.1f</span>, <span class="number">0.1f</span>, <span class="number">0.1f</span>, <span class="number">1.0f</span>);</span><br><span class="line">    glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 渲染立方体</span></span><br><span class="line">    shader.use();</span><br><span class="line">    shader.setVec3(<span class="string">&quot;objectColor&quot;</span>, glm::vec3(<span class="number">1.0f</span>, <span class="number">0.5f</span>, <span class="number">0.31f</span>));</span><br><span class="line">    shader.setVec3(<span class="string">&quot;lightColor&quot;</span>, glm::vec3(<span class="number">1.0f</span>, <span class="number">1.0f</span>, <span class="number">1.0f</span>));</span><br><span class="line"></span><br><span class="line">    glm::mat4 view = camera.GetViewMatrix();</span><br><span class="line"></span><br><span class="line">    glm::mat4 projection = glm::mat4(<span class="number">1.0f</span>);</span><br><span class="line">    projection = glm::perspective(glm::radians(camera.Zoom), (<span class="keyword">float</span>)width / (<span class="keyword">float</span>)height, <span class="number">0.1f</span>, <span class="number">100.0f</span>);</span><br><span class="line">    shader.setMat4(<span class="string">&quot;view&quot;</span>, view);</span><br><span class="line">    shader.setMat4(<span class="string">&quot;projection&quot;</span>, projection);</span><br><span class="line"></span><br><span class="line">    glm::mat4 model = glm::mat4(<span class="number">1.0f</span>);</span><br><span class="line">    shader.setMat4(<span class="string">&quot;model&quot;</span>, model);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 绑定VAO</span></span><br><span class="line">    glBindVertexArray(data.cube_VAO);</span><br><span class="line">    glDrawArrays(GL_TRIANGLES, <span class="number">0</span>, <span class="number">36</span>);</span><br><span class="line">    <span class="comment">// 解绑VAO</span></span><br><span class="line">    glBindVertexArray(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 渲染光源</span></span><br><span class="line">    light_shader.use();</span><br><span class="line">    light_shader.setMat4(<span class="string">&quot;view&quot;</span>, view);</span><br><span class="line">    light_shader.setMat4(<span class="string">&quot;projection&quot;</span>, projection);</span><br><span class="line">    model = glm::mat4(<span class="number">1.0f</span>);</span><br><span class="line">    model = glm::translate(model, light_pos);</span><br><span class="line">    model = glm::scale(model, glm::vec3(<span class="number">0.2f</span>)); <span class="comment">// a smaller cube</span></span><br><span class="line">    light_shader.setMat4(<span class="string">&quot;model&quot;</span>, model);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 绑定VAO</span></span><br><span class="line">    glBindVertexArray(data.light_VAO);</span><br><span class="line">    glDrawArrays(GL_TRIANGLES, <span class="number">0</span>, <span class="number">36</span>);</span><br><span class="line">    <span class="comment">// 解绑VAO</span></span><br><span class="line">    glBindVertexArray(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// glfwSwapBuffers函数会交换颜色缓冲</span></span><br><span class="line">    <span class="comment">// 它是一个储存着GLFW窗口每一个像素颜色值的大缓冲</span></span><br><span class="line">    <span class="comment">// 它在这一迭代中被用来绘制，并且将会作为输出显示在屏幕上。</span></span><br><span class="line">    glfwSwapBuffers(window);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// glfwPollEvents函数检查有没有触发什么事件</span></span><br><span class="line">    <span class="comment">// 比如键盘输入、鼠标移动、更新窗口状态等</span></span><br><span class="line">    <span class="comment">// 并调用对应的回调函数（可以通过回调方法手动设置）</span></span><br><span class="line">    glfwPollEvents();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><div align="center"><p><img src="/images/learnopengl-c2-f2.jpg"></p></div><h2 id="基础光照"><a href="#基础光照" class="headerlink" title="基础光照"></a>基础光照</h2><p>现实世界的光照是极其复杂的，而且会受到诸多因素的影响，这是我们有限的计算能力所无法模拟的。因此OpenGL的光照使用的是简化的模型，对现实的情况进行近似，这样处理起来会更容易一些，而且看起来也差不多一样。这些光照模型都是基于我们对光的物理特性的理解。其中一个模型被称为<strong>冯氏光照模型</strong>(Phong Lighting Model)。冯氏光照模型的主要结构由3个分量组成：<strong>环境</strong>(Ambient)、<strong>漫反射</strong>(Diffuse)和<strong>镜面</strong>(Specular)光照。下面这张图展示了这些光照分量看起来的样子：</p><div align="center"><p><img src="/images/learnopengl-c2-f3.jpg"></p></div><ul><li><strong>环境光照</strong>(Ambient Lighting)：即使在黑暗的情况下，世界上通常也仍然有一些光亮（月亮、远处的光），所以物体几乎永远不会是完全黑暗的。为了模拟这个，我们会使用一个环境光照常量，它永远会给物体一些颜色。</li><li><strong>漫反射光照</strong>(Diffuse Lighting)：模拟光源对物体的<strong>方向性影响</strong>(Directional Impact)。它是冯氏光照模型中视觉上<strong>最显著的分量</strong>。物体的<strong>某一部分越是正对着光源，它就会越亮</strong>。</li><li><strong>镜面光照</strong>(Specular Lighting)：模拟有<strong>光泽物体上面出现的亮点</strong>。镜面光照的颜色相比于物体的颜色会<strong>更倾向于光的颜色</strong>。</li></ul><h3 id="环境光照"><a href="#环境光照" class="headerlink" title="环境光照"></a>环境光照</h3><p>光通常都不是来自于同一个光源，而是来自于我们周围分散的很多光源，即使它们可能并不是那么显而易见。光的一个属性是，它可以向很多方向发散并反弹，从而能够到达不是非常直接临近的点。所以，光能够在其它的表面上反射，对一个物体产生间接的影响。考虑到这种情况的算法叫做<strong>全局照明</strong>(Global Illumination)算法，但是<strong>这种算法既开销高昂又极其复杂</strong>。</p><p>由于我们现在对那种又复杂又开销高昂的算法不是很感兴趣，所以我们将<strong>会先使用一个简化的全局照明模型，即环境光照</strong>。正如你在上一节所学到的，我们使用一个很小的常量（光照）颜色，添加到物体片段的最终颜色中，这样子的话即便场景中没有直接的光源也能看起来存在有一些发散的光。</p><p>把环境光照添加到场景里非常简单。我们用<strong>光的颜色乘以一个很小的常量环境因子</strong>，再<strong>乘以物体的颜色</strong>，然后将最终结果作为片段的颜色：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">float</span> ambientStrength = <span class="number">0.1</span>;</span><br><span class="line">    vec3 ambient = ambientStrength * lightColor;</span><br><span class="line">    vec3 result = ambient * objectColor;</span><br><span class="line">    FragColor = vec4(result, <span class="number">1.0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><div align="center"><p><img src="/images/learnopengl-c2-f4.jpg"></p></div><h3 id="漫反射光照"><a href="#漫反射光照" class="headerlink" title="漫反射光照"></a>漫反射光照</h3><p>环境光照本身不能提供最有趣的结果，但是<strong>漫反射光照就能开始对物体产生显著的视觉影响了</strong>。漫反射光照使物体上与光线方向越接近的片段能从光源处获得更多的亮度。为了能够更好的理解漫反射光照，请看下图：</p><div align="center"><p><img src="/images/learnopengl-c2-f5.jpg"></p></div><p>图左上方有一个光源，它所发出的光线落在物体的一个片段上。<strong>我们需要测量这个光线是以什么角度接触到这个片段的</strong>。如果<strong>光线垂直于物体表面，这束光对物体的影响会最大化</strong>（译注：更亮）。为了测量光线和片段的角度，我们使用一个叫做<strong>法向量</strong>(Normal Vector)的东西，它是<strong>垂直于片段表面的一个向量</strong>（这里以黄色箭头表示），我们在后面再讲这个东西。<strong>这两个向量</strong>（光线方向向量和法向量）<strong>之间的角度很容易就能够通过点乘计算出来</strong>。</p><p>注意，<strong>为了得到两个向量夹角的余弦值</strong>，我们使用的是<strong>单位向量</strong>（长度为1的向量），所以我们需要确保所有的向量都是标准化的，否则点乘返回的就不仅仅是余弦值了。</p><p>所以，计算漫反射光照需要什么？</p><ul><li><strong>法向量</strong>：一个垂直于顶点表面的向量。</li><li><strong>定向的光线</strong>：作为光源的位置与片段的位置之间向量差的方向向量。为了计算这个光线，我们需要光的位置向量和片段的位置向量。</li></ul><h3 id="法向量"><a href="#法向量" class="headerlink" title="法向量"></a>法向量</h3><p>法向量是一个垂直于顶点表面的（单位）向量。<strong>由于顶点本身并没有表面</strong>（它只是空间中一个独立的点），我们利用它周围的顶点来计算出这个顶点的表面。我们能够使用一个小技巧，使用叉乘对立方体所有的顶点计算法向量，但是<strong>由于3D立方体不是一个复杂的形状</strong>，所以我们可以<strong>简单地把法线数据手工添加到顶点数据中</strong>。试着去想象一下，这些<strong>法向量真的是垂直于立方体各个平面的表面的</strong>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">float</span> vertices[] = &#123;</span><br><span class="line">    <span class="number">-0.5f</span>, <span class="number">-0.5f</span>, <span class="number">-0.5f</span>,  <span class="number">0.0f</span>,  <span class="number">0.0f</span>, <span class="number">-1.0f</span>,</span><br><span class="line">     <span class="number">0.5f</span>, <span class="number">-0.5f</span>, <span class="number">-0.5f</span>,  <span class="number">0.0f</span>,  <span class="number">0.0f</span>, <span class="number">-1.0f</span>,</span><br><span class="line">     <span class="number">0.5f</span>,  <span class="number">0.5f</span>, <span class="number">-0.5f</span>,  <span class="number">0.0f</span>,  <span class="number">0.0f</span>, <span class="number">-1.0f</span>,</span><br><span class="line">     <span class="number">0.5f</span>,  <span class="number">0.5f</span>, <span class="number">-0.5f</span>,  <span class="number">0.0f</span>,  <span class="number">0.0f</span>, <span class="number">-1.0f</span>,</span><br><span class="line">    <span class="number">-0.5f</span>,  <span class="number">0.5f</span>, <span class="number">-0.5f</span>,  <span class="number">0.0f</span>,  <span class="number">0.0f</span>, <span class="number">-1.0f</span>,</span><br><span class="line">    <span class="number">-0.5f</span>, <span class="number">-0.5f</span>, <span class="number">-0.5f</span>,  <span class="number">0.0f</span>,  <span class="number">0.0f</span>, <span class="number">-1.0f</span>,</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>由于我们向顶点数组添加了额外的数据，所以我们应该更新光照的顶点着色器：</p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#version 330 core</span></span><br><span class="line"><span class="keyword">layout</span> (<span class="keyword">location</span> = <span class="number">0</span>) <span class="keyword">in</span> <span class="type">vec3</span> aPos;</span><br><span class="line"><span class="keyword">layout</span> (<span class="keyword">location</span> = <span class="number">1</span>) <span class="keyword">in</span> <span class="type">vec3</span> aNormal;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>现在我们已经向每个顶点添加了一个法向量并更新了顶点着色器，<strong>我们还要更新顶点属性指针</strong>。注意，<strong>灯使用同样的顶点数组作为它的顶点数据，然而灯的着色器并没有使用新添加的法向量</strong>。我们不需要更新灯的着色器或者是属性的配置，<strong>但是我们必须至少修改一下顶点属性指针</strong>来适应新的顶点数组的大小：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">glVertexAttribPointer(<span class="number">0</span>, <span class="number">3</span>, GL_FLOAT, GL_FALSE, <span class="number">6</span> * <span class="keyword">sizeof</span>(<span class="keyword">float</span>), (<span class="keyword">void</span>*)<span class="number">0</span>);</span><br><span class="line">glEnableVertexAttribArray(<span class="number">0</span>);</span><br><span class="line">glVertexAttribPointer(<span class="number">1</span>, <span class="number">3</span>, GL_FLOAT, GL_FALSE, <span class="number">6</span> * <span class="keyword">sizeof</span>(<span class="keyword">float</span>), (<span class="keyword">void</span>*)(<span class="number">3</span> * <span class="keyword">sizeof</span>(<span class="keyword">float</span>)));</span><br><span class="line">glEnableVertexAttribArray(<span class="number">1</span>);</span><br><span class="line">...</span><br><span class="line">glVertexAttribPointer(<span class="number">0</span>, <span class="number">3</span>, GL_FLOAT, GL_FALSE, <span class="number">6</span> * <span class="keyword">sizeof</span>(<span class="keyword">float</span>), (<span class="keyword">void</span>*)<span class="number">0</span>);</span><br><span class="line">glEnableVertexAttribArray(<span class="number">0</span>);</span><br></pre></td></tr></table></figure><p>虽然对灯的着色器使用不能完全利用的顶点数据<strong>看起来不是那么高效</strong>，<strong>但这些顶点数据已经从箱子对象载入后开始就储存在GPU的内存里了</strong>，所以我们<strong>并不需要储存新数据到GPU内存中</strong>。这<strong>实际上比给灯专门分配一个新的VBO更高效了</strong>。</p><p>所有光照的计算都是在片段着色器里进行，所以我们需要将法向量由顶点着色器传递到片段着色器。我们这么做：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#version 330 core</span></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">out vec3 Normal;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    gl_Position = projection * view * model * vec4(aPos, <span class="number">1.0f</span>);</span><br><span class="line">    normal = aNormal;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>接下来，在片段着色器中定义相应的输入变量：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">in vec3 Normal;</span><br></pre></td></tr></table></figure><p><strong>计算漫反射光照</strong></p><p>我们现在对每个顶点都有了法向量，但是我们<strong>仍然需要光源的位置向量和片段的位置向量。</strong>由于光源的位置是一个静态变量，我们可以简单地在<strong>片段着色器中</strong>把它声明为uniform：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">uniform vec3 lightPos;</span><br></pre></td></tr></table></figure><p>然后在渲染循环中（渲染循环的外面也可以，因为它不会改变）更新uniform。我们使用在前面声明的<code>lightPos</code>向量作为光源位置：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lightingShader.setVec3(<span class="string">&quot;lightPos&quot;</span>, lightPos);</span><br></pre></td></tr></table></figure><p>最后，我们还需要片段的位置。我们会在世界空间中进行所有的光照计算，<strong>因此我们需要一个在世界空间中的顶点位置</strong>。我们可以通过把<strong>顶点位置属性乘以模型矩阵</strong>（不是观察和投影矩阵）来把它变换到<strong>世界空间坐标</strong>。这个在顶点着色器中很容易完成，所以我们<strong>声明一个输出变量</strong>，并计算它的世界空间坐标：</p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">out</span> <span class="type">vec3</span> Normal;</span><br><span class="line"><span class="keyword">out</span> <span class="type">vec3</span> FragPos;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> main() &#123;</span><br><span class="line">    <span class="built_in">gl_Position</span> = projection * view * model * <span class="type">vec4</span>(aPos, <span class="number">1.0</span>f);</span><br><span class="line">    FragPos = <span class="type">vec3</span>(model * <span class="type">vec4</span>(aPos, <span class="number">1.0</span>));</span><br><span class="line">    normal = aNormal;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>最后，在<strong>片段着色器中添加相应的输入变量</strong>。</p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">in</span> <span class="type">vec3</span> FragPos;</span><br></pre></td></tr></table></figure><p>现在，所有需要的变量都设置好了，我们可以在<strong>片段着色器中添加光照计算</strong>了。</p><p>我们需要做的<strong>第一件事</strong>是计算<strong>光源和片段位置之间的方向向量</strong>。前面提到，光的方向向量是光源位置向量与片段位置向量之间的向量差。你可能记得在变换教程中，我们能够简单地通过让两个向量相减的方式计算向量差。我们同样希望确保所有相关向量最后都转换为单位向量，所以我们把法线和最终的方向向量都进行标准化：</p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">vec3</span> norm = <span class="built_in">normalize</span>(Normal);</span><br><span class="line"><span class="type">vec3</span> lightDir = <span class="built_in">normalize</span>(lightPos - FragPos);</span><br></pre></td></tr></table></figure><p><strong>当计算光照时我们通常不关心一个向量的模长或它的位置，我们只关心它们的方向</strong>。所以，几乎所有的计算都使用<strong>单位向量完成</strong>，因为这简化了大部分的计算（比如点乘）。所以当进行光照计算时，确保你总是对相关向量进行标准化，来保证它们是真正地单位向量。<strong>忘记对向量进行标准化是一个十分常见的错误</strong>。</p><p>下一步，我们对norm和lightDir向量进行<strong>点乘</strong>，计算光源对当前片段实际的漫发射影响。<strong>结果值再乘以光的颜色，得到漫反射分量</strong>。两个向量之间的角度越大，漫反射分量就会越小：</p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">float</span> diff = <span class="built_in">max</span>(<span class="built_in">dot</span>(norm, lightDir), <span class="number">0.0</span>);</span><br><span class="line"><span class="type">vec3</span> diffuse = diff * lightColor;</span><br></pre></td></tr></table></figure><p>现在我们有了<strong>环境光分量和漫反射分量</strong>，我们把它们相加，然后把结果乘以物体的颜色，来获得片段最后的输出颜色。</p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">vec3</span> norm = <span class="built_in">normalize</span>(Normal);</span><br><span class="line"><span class="type">vec3</span> lightDir = <span class="built_in">normalize</span>(lightPos - FragPos);</span><br><span class="line"><span class="type">float</span> diff = <span class="built_in">max</span>(<span class="built_in">dot</span>(norm, lightDir), <span class="number">0.0</span>);</span><br><span class="line"><span class="type">vec3</span> diffuse = diff * lightColor;</span><br><span class="line"></span><br><span class="line"><span class="type">float</span> ambientStrength = <span class="number">0.1</span>;</span><br><span class="line"><span class="type">vec3</span> ambient = ambientStrength * lightColor;</span><br><span class="line"></span><br><span class="line"><span class="type">vec3</span> result = (ambient + diffuse) * objectColor;</span><br><span class="line">FragColor = <span class="type">vec4</span>(result, <span class="number">1.0</span>);</span><br></pre></td></tr></table></figure><div align="center"><p><img src="/images/learnopengl-c2-f6.jpg"></p></div><p>你可以看到使用了漫反射光照，立方体看起来就真的像个立方体了。尝试在你的脑中想象一下法向量，并在立方体周围移动，<strong>注意观察法向量和光的方向向量之间的夹角越大，片段就会越暗</strong>。</p><p><strong>最后一件事</strong></p><p>现在我们已经把<strong>法向量从顶点着色器传到了片段着色器</strong>。可是，目前片段着色器里的计算都是在<strong>世界空间坐标中进行的</strong>。所以，我们是不是<strong>应该把法向量也转换为世界空间坐标</strong>？基本正确，但是这<strong>不是简单地把它乘以一个模型矩阵就能搞定的</strong>。</p><p>首先，<strong>法向量只是一个方向向量</strong>，不能表达空间中的特定位置。同时，法向量没有齐次坐标（顶点位置中的w分量）。这意味着，<strong>位移不应该影响到法向量</strong>。因此，如果<strong>我们打算把法向量乘以一个模型矩阵，我们就要从矩阵中移除位移部分，只选用模型矩阵左上角3×3的矩阵</strong>（注意，我们也可以把法向量的w分量设置为0，再乘以4×4矩阵；这同样可以移除位移）。对于法向量，我们<strong>只希望对它实施缩放和旋转变换</strong>。</p><p>其次，<strong>如果模型矩阵执行了不等比缩放</strong>，顶点的改变会<strong>导致法向量不再垂直于表面了</strong>。因此，我们不能用这样的模型矩阵来变换法向量。下面的图展示了应用了不等比缩放的模型矩阵对法向量的影响：</p><div align="center"><p><img src="/images/learnopengl-c2-f7.jpg"></p></div><p>每当我们应用一个不等比缩放时（注意：<strong>等比缩放不会破坏法线</strong>，因为法线的方向没被改变，<strong>仅仅改变了法线的长度，而这很容易通过标准化来修复</strong>），法向量就不会再垂直于对应的表面了，这样光照就会被破坏。</p><p>修复这个行为的诀窍是<strong>使用一个为法向量专门定制的模型矩阵</strong>。这个矩阵称之为法线矩阵(Normal Matrix)，它使用了一些线性代数的操作来移除对法向量错误缩放的影响。</p><p>法线矩阵被定义为「模型矩阵左上角的<strong>逆矩阵的转置矩阵</strong>」。注意，大部分的资源都会将法线矩阵定义为应用到模型-观察矩阵(Model-view Matrix)上的操作，但是由于我们<strong>只在世界空间中进行操作</strong>（不是在观察空间），我们<strong>只使用模型矩阵</strong>。</p><p>在<strong>顶点着色器</strong>中，我们可以使用<code>inverse</code>和<code>transpose</code>函数自己生成这个法线矩阵，这两个函数对所有类型矩阵都有效。注意我们还要把被处理过的矩阵<strong>强制转换</strong>为<code>3×3</code>矩阵，来保证<strong>它失去了位移属性</strong>以及能够乘以vec3的法向量。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Normal = mat3(transpose(inverse(model))) * aNormal;</span><br></pre></td></tr></table></figure><p>在漫反射光照部分，光照表现并没有问题，<strong>这是因为我们没有对物体本身执行任何缩放操作，所以并不是必须要使用一个法线矩阵</strong>，仅仅让模型矩阵乘以法线也可以。可是，<strong>如果你进行了不等比缩放</strong>，使用法线矩阵去乘以法向量就是必不可少的了。</p><p>即使是对于着色器来说，<strong>逆矩阵也是一个开销比较大的运算</strong>，因此，只要可能就应该避免在着色器中进行逆矩阵运算，它们必须为你场景中的每个顶点都进行这样的处理。用作学习目这样做是可以的，<strong>但是对于一个对效率有要求的应用来说，在绘制之前你最好用CPU计算出法线矩阵</strong>，然后通过uniform<strong>把值传递给着色器</strong>（像模型矩阵一样）。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">glm::mat3 normal_model = (glm::mat3)glm::transpose(glm::inverse(model));</span><br><span class="line">shader.setMat3(<span class="string">&quot;normal_model&quot;</span>, normal_model);</span><br><span class="line">...</span><br><span class="line">normal_model = (glm::mat3)glm::transpose(glm::inverse(model));</span><br><span class="line">light_shader.setMat3(<span class="string">&quot;normal_model&quot;</span>, normal_model);</span><br></pre></td></tr></table></figure><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="keyword">uniform</span> <span class="type">mat3</span> normal_model;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> main() &#123;</span><br><span class="line">    <span class="built_in">gl_Position</span> = projection * view * model * <span class="type">vec4</span>(aPos, <span class="number">1.0</span>f);</span><br><span class="line">    FragPos = <span class="type">vec3</span>(model * <span class="type">vec4</span>(aPos, <span class="number">1.0</span>));</span><br><span class="line">    Normal = normal_model * aNormal;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="镜面光照"><a href="#镜面光照" class="headerlink" title="镜面光照"></a>镜面光照</h3><p>把<strong>镜面高光</strong>(Specular Highlight)加进来，这样冯氏光照才算完整。</p><p>和漫反射光照一样，<strong>镜面光照也是依据光的方向向量和物体的法向量来决定的</strong>，但是它也依赖于观察方向，例如玩家是从什么方向看着这个片段的。<strong>镜面光照是基于光的反射特性</strong>。如果我们想象物体表面像一面镜子一样，那么，无论我们从哪里去看那个表面所反射的光，镜面光照都会达到最大化。你可以从下面的图片看到效果：</p><div align="center"><p><img src="/images/learnopengl-c2-f8.jpg"></p></div><p>我们通过反射法向量周围光的方向来计算反射向量。然后我们计算<strong>反射向量和视线方向</strong>的角度差，如果夹角越小，那么镜面光的影响就会越大。它的作用效果就是，当我们去看光被物体所反射的那个方向的时候，我们会看到一个高光。</p><p><strong>观察向量是镜面光照附加的一个变量</strong>，我们可以使用<strong>观察者世界空间位置和片段的位置来计算它</strong>。之后，我们计算镜面光强度，用它乘以光源的颜色，再将它加上环境光和漫反射分量。</p><p>我们选择在<strong>世界空间进行光照计算</strong>，但是<strong>大多数人趋向于在观察空间进行光照计算</strong>。在观察空间计算的好处是，<strong>观察者的位置</strong>总是(0, 0, 0)，所以这样你直接就获得了观察者位置。可是我发现在学习的时候<strong>在世界空间中计算光照更符合直觉</strong>。如果你仍然希望在观察空间计算光照的话，你需要将所有相关的向量都用观察矩阵进行变换（记得也要改变法线矩阵）。</p><p>为了得到观察者的世界空间坐标，我们简单地使用<strong>摄像机对象的位置坐标代替</strong>。所以我们把另一个uniform添加到<strong>片段着色器</strong>，把相应的<strong>摄像机位置坐标</strong>传给片段着色器：</p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">uniform</span> <span class="type">vec3</span> viewPos;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lightingShader.setVec3(<span class="string">&quot;viewPos&quot;</span>, camera.Position);</span><br></pre></td></tr></table></figure><p>现在我们已经获得所有需要的变量，可以计算高光强度了。首先，我们定义一个<strong>镜面强度</strong>(Specular Intensity)变量，给镜面高光一个中等亮度颜色，让它不要产生过度的影响。</p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">float</span> specularStrength = <span class="number">0.5</span>;</span><br></pre></td></tr></table></figure><p>如果我们把它设置为<code>1.0f</code>，我们会得到一个非常亮的镜面光分量，这对于一个珊瑚色的立方体来说有点太多了。下一步，我们<strong>计算视线方向向量</strong>，和对应的<strong>沿着法线轴的反射向量</strong>：</p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">vec3</span> viewDir = <span class="built_in">normalize</span>(viewPos - FragPos);</span><br><span class="line"><span class="type">vec3</span> reflectDir = <span class="built_in">reflect</span>(-lightDir, norm);</span><br></pre></td></tr></table></figure><p>需要注意的是我们对<code>lightDir</code>向量<strong>进行了取反</strong>。<code>reflect</code>函数要求<strong>第一个向量是从光源指向片段位置的向量</strong>，但是<code>lightDir</code>当前正好相反，是<strong>从片段指向光源</strong>（由先前我们计算lightDir向量时，<strong>减法的顺序决定</strong>）。为了保证我们得到正确的reflect向量，我们通过对lightDir向量取反来获得相反的方向。<strong>第二个参数</strong>要求是一个法向量，所以我们提供的是<strong>已标准化的norm向量</strong>。</p><p>剩下要做的是<strong>计算镜面分量</strong>。下面的代码完成了这件事：</p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">float</span> spec = <span class="built_in">pow</span>(<span class="built_in">max</span>(<span class="built_in">dot</span>(viewDir, reflectDir), <span class="number">0.0</span>), <span class="number">32</span>);</span><br><span class="line"><span class="type">vec3</span> specular = specularStrength * spec * lightColor;</span><br></pre></td></tr></table></figure><p>我们先计算<strong>视线方向与反射方向的点乘</strong>（并确保它不是负值），然后<strong>取它的32次幂</strong>。这个32是高光的<strong>反光度</strong>(Shininess)。一个物体的<strong>反光度越高</strong>，反射光的能力越强，散射得越少，高光点就会越小。在下面的图片里，你会看到不同反光度的视觉效果影响：</p><div align="center"><p><img src="/images/learnopengl-c2-f9.jpg"></p></div><p>我们不希望镜面成分过于显眼，所以我们把指数保持为32。剩下的最后一件事情是把它加到环境光分量和漫反射分量里，再用结果乘以物体的颜色：</p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">vec3</span> result = (ambient + diffuse + specular) * objectColor;</span><br><span class="line">FragColor = <span class="type">vec4</span>(result, <span class="number">1.0</span>);</span><br></pre></td></tr></table></figure><p>我们现在为冯氏光照计算了全部的光照分量。</p><div align="center"><p><img src="/images/learnopengl-c2-f10.jpg"></p></div><p><strong>在光照着色器的早期</strong>，开发者曾经在<strong>顶点着色器中实现冯氏光照模型</strong>。在顶点着色器中做光照的优势是，相比片段来说，<strong>顶点要少得多，因此会更高效</strong>，所以（开销大的）光照计算频率会更低。然而，<strong>顶点着色器中的最终颜色值是仅仅只是那个顶点的颜色值</strong>，<strong>片段的颜色值是由插值光照颜色所得来的</strong>。结果就是这种光照看起来不会非常真实，<strong>除非使用了大量顶点</strong>。</p><div align="center"><p><img src="/images/learnopengl-c2-f11.jpg"></p></div><p>在<strong>顶点着色器中实现的冯氏光照模型</strong>叫做<strong>Gouraud着色</strong>(Gouraud Shading)，而不是冯氏着色(Phong Shading)。记住，由于插值，这种光照看起来有点逊色。<strong>冯氏着色能产生更平滑的光照效果</strong>。</p><h3 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h3><ul><li>目前，我们的光源时静止的，你可以尝试使用sin或cos函数让光源在场景中来回移动。观察光照随时间的改变能让你更容易理解冯氏光照模型；</li><li>尝试使用<strong>不同的环境光、漫反射和镜面强度</strong>，观察它们怎么是影响光照效果的。同样，尝试实验一下<strong>镜面光照的反光度因子</strong>。尝试理解为什么某一个值能够有着某一种视觉输出；</li><li>在观察空间（而不是世界空间）中计算冯氏光照；</li><li>尝试实现一个Gouraud着色（而不是冯氏着色）。如果你做对了话，立方体的光照应该会看起来有些奇怪，尝试推理为什么它会看起来这么奇怪。</li></ul><h2 id="材质"><a href="#材质" class="headerlink" title="材质"></a>材质</h2><p><strong>在现实世界里，每个物体会对光产生不同的反应</strong>。比如说，钢看起来通常会比陶瓷花瓶更闪闪发光，木头箱子也不会像钢制箱子那样对光产生很强的反射。每个物体对镜面高光也有不同的反应。有些物体反射光的时候不会有太多的散射(Scatter)，因而产生一个较小的高光点，而有些物体则会散射很多，产生一个有着更大半径的高光点。<strong>如果我们想要在OpenGL中模拟多种类型的物体</strong>，我们必须为<strong>每个物体分别定义一个材质</strong>(Material)<strong>属性</strong>。</p><p>在上一节中，我们指定了一个物体和光的颜色，以及结合环境光和镜面强度分量，来定义物体的视觉输出。<strong>当描述一个物体的时候</strong>，我们可以用这<strong>三个分量来定义一个材质颜色</strong>(Material Color)：<strong>环境光照</strong>(Ambient Lighting)、<strong>漫反射光照</strong>(Diffuse Lighting)和<strong>镜面光照</strong>(Specular Lighting)。通过为每个分量指定一个颜色，我们就能够对物体的颜色输出有着精细的控制了。现在，我们<strong>再添加反光度</strong>(Shininess)这个分量到上述的三个颜色中，这就有我们需要的所有材质属性了：</p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#version 330 core</span></span><br><span class="line">struct Material &#123;</span><br><span class="line">    <span class="type">vec3</span> ambient;</span><br><span class="line">    <span class="type">vec3</span> diffuse;</span><br><span class="line">    <span class="type">vec3</span> specular;</span><br><span class="line">    <span class="type">float</span> shininess;</span><br><span class="line">&#125;; </span><br><span class="line"></span><br><span class="line"><span class="keyword">uniform</span> Material material;</span><br></pre></td></tr></table></figure><p>在<strong>片段着色器</strong>中，我们创建一个<strong>结构体</strong>(Struct)来<strong>储存物体的材质属性</strong>。我们也可以把它们储存为独立的uniform值，<strong>但是作为一个结构体来储存会更有条理一些</strong>。我们首先定义结构体的<strong>布局</strong>(Layout)，然后使用刚创建的结构体为类型，简单地声明一个uniform变量。</p><p>你可以看到，<strong>我们为每个冯氏光照模型的分量都定义一个颜色向量</strong>。<strong>ambient材质</strong>向量定义了在<strong>环境光照下这个物体反射得是什么颜色</strong>，<strong>通常这是和物体颜色相同的颜色</strong>。<strong>diffuse材质</strong>向量定义了在漫反射光照下物体的颜色。（和环境光照一样）漫反射颜色也要<strong>设置为我们需要的物体颜色</strong>。<strong>specular材质</strong>向量设置的是镜面光照对物体的颜色影响（或者甚至可能反射一个物体特定的镜面高光颜色）。最后，<strong>shininess影响镜面高光的散射/半径</strong>。</p><p>这<strong>四个元素定义了一个物体的材质</strong>，通过它们我们能够模拟很多现实世界中的材质。<a href="http://devernay.free.fr/cours/opengl/materials.html">devernay.free.fr</a>上的一个表格展示了几种材质属性，它们模拟了现实世界中的真实材质。下面的图片展示了几种现实世界的材质对我们的立方体的影响：</p><div align="center"><p><img src="/images/cpp-c2-f22.jpg"></p></div><p>可以看到，通过正确地指定一个物体的材质属性，我们对这个物体的感知也就不同了。效果非常明显，<strong>但是要想获得更真实的效果，我们最终需要更加复杂的形状，而不单单是一个立方体</strong>。在后面的教程中，我们会讨论更复杂的形状。</p><p>首先，让我们在着色器中实现这样的一个材质系统。</p><h3 id="设置材质"><a href="#设置材质" class="headerlink" title="设置材质"></a>设置材质</h3><p>我们在片段着色器中创建了一个材质结构体的uniform，所以下面我们希望<strong>修改一下光照的计算来顺应新的材质属性</strong>。由于所有材质变量都储存在结构体中，我们可以从uniform变量material中访问它们：</p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> main() &#123;</span><br><span class="line">    <span class="comment">// 环境光</span></span><br><span class="line">    <span class="type">vec3</span> ambient = lightColor * material.ambient;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 漫反射</span></span><br><span class="line">    <span class="type">vec3</span> norm = <span class="built_in">normalize</span>(Normal);</span><br><span class="line">    <span class="type">vec3</span> lightDir = <span class="built_in">normalize</span>(lightPos - FragPos);</span><br><span class="line">    <span class="type">float</span> diff = <span class="built_in">max</span>(<span class="built_in">dot</span>(norm, lightDir), <span class="number">0.0</span>);</span><br><span class="line">    <span class="type">vec3</span> diffuse = lightColor * (diff * material.diffuse);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 镜面光</span></span><br><span class="line">    <span class="type">vec3</span> viewDir = <span class="built_in">normalize</span>(viewPos - FragPos);</span><br><span class="line">    <span class="type">vec3</span> reflectDir = <span class="built_in">reflect</span>(-lightDir, norm);</span><br><span class="line">    <span class="type">float</span> spec = <span class="built_in">pow</span>(<span class="built_in">max</span>(<span class="built_in">dot</span>(viewDir, reflectDir), <span class="number">0.0</span>), material.shininess);</span><br><span class="line">    <span class="type">vec3</span> specular = lightColor * (spec * material.specular);</span><br><span class="line"></span><br><span class="line">    <span class="type">vec3</span> result = ambient + diffuse + specular;</span><br><span class="line">    FragColor = <span class="type">vec4</span>(result, <span class="number">1.0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，我们现在在需要的地方访问了材质结构体中的所有属性，并且这次是根据材质的颜色来计算最终的输出颜色的。<strong>物体的每个材质属性都乘上了它们对应的光照分量</strong>。</p><p>我们现在可以在程序中设置适当的uniform，对物体设置材质了。GLSL中的结构体在设置uniform时并没有什么特别之处。<strong>结构体只是作为uniform变量的一个封装</strong>，所以如果想填充这个结构体的话，<strong>我们仍需要对每个单独的uniform进行设置</strong>，但这次要<strong>带上结构体名的前缀</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">lightingShader.setVec3(<span class="string">&quot;material.ambient&quot;</span>, <span class="number">1.0f</span>, <span class="number">0.5f</span>, <span class="number">0.31f</span>);</span><br><span class="line">lightingShader.setVec3(<span class="string">&quot;material.diffuse&quot;</span>, <span class="number">1.0f</span>, <span class="number">0.5f</span>, <span class="number">0.31f</span>);</span><br><span class="line">lightingShader.setVec3(<span class="string">&quot;material.specular&quot;</span>, <span class="number">0.5f</span>, <span class="number">0.5f</span>, <span class="number">0.5f</span>);</span><br><span class="line">lightingShader.setFloat(<span class="string">&quot;material.shininess&quot;</span>, <span class="number">32.0f</span>);</span><br></pre></td></tr></table></figure><p>我们将<strong>环境光和漫反射分量设置成我们想要让物体所拥有的颜色</strong>，而将<strong>镜面分量设置为一个中等亮度的颜色</strong>，我们不希望镜面分量在这个物体上过于强烈。我们将反光度保持为32。现在我们能够程序中非常容易地修改物体的材质了。</p><p>运行程序，你应该会得到下面这样的结果：</p><div align="center"><p><img src="/images/learnopengl-c2-f12.jpg"></p></div><p>但它看起来很奇怪不是吗？</p><h3 id="光的属性"><a href="#光的属性" class="headerlink" title="光的属性"></a>光的属性</h3><p>这个物体太亮了。<strong>物体过亮的原因是环境光、漫反射和镜面光这三个颜色对任何一个光源都会去全力反射</strong>。光源对环境光、漫反射和镜面光分量<strong>也具有着不同的强度</strong>。前面的教程，我们通过使用一个强度值改变环境光和镜面光强度的方式解决了这个问题。我们想做一个类似的系统，但是这次是要为<strong>每个光照分量都指定一个强度向量</strong>。</p><p><strong>我们希望为光照属性创建一个与材质结构体类似的结构体</strong>：</p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">struct Light &#123;</span><br><span class="line">    <span class="type">vec3</span> position;</span><br><span class="line"></span><br><span class="line">    <span class="type">vec3</span> ambient;</span><br><span class="line">    <span class="type">vec3</span> diffuse;</span><br><span class="line">    <span class="type">vec3</span> specular;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">uniform</span> Light light;</span><br></pre></td></tr></table></figure><p>一个光源对它的<code>ambient</code>、<code>diffuse</code>和<code>specular</code><strong>光照有着不同的强度</strong>。环境光照通常会设置为一个比较低的强度，因为我们不希望环境光颜色太过显眼。光源的漫反射分量通常设置为光所具有的颜色，通常是一个比较明亮的白色。镜面光分量通常会保持为vec3(1.0)，以最大强度发光。注意我们也将光源的位置添加到了结构体中。</p><p>和材质uniform一样，我们需要更新片段着色器：</p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">vec3</span> ambient  = light.ambient * material.ambient;</span><br><span class="line"><span class="type">vec3</span> diffuse  = light.diffuse * (diff * material.diffuse);</span><br><span class="line"><span class="type">vec3</span> specular = light.specular * (spec * material.specular);</span><br></pre></td></tr></table></figure><p>我们接下来在程序中设置光照强度：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">lightingShader.setVec3(<span class="string">&quot;light.position&quot;</span>, lightPos);</span><br><span class="line">lightingShader.setVec3(<span class="string">&quot;light.ambient&quot;</span>,  <span class="number">0.2f</span>, <span class="number">0.2f</span>, <span class="number">0.2f</span>);</span><br><span class="line">lightingShader.setVec3(<span class="string">&quot;light.diffuse&quot;</span>,  <span class="number">0.5f</span>, <span class="number">0.5f</span>, <span class="number">0.5f</span>); <span class="comment">// 将光照调暗了一些以搭配场景</span></span><br><span class="line">lightingShader.setVec3(<span class="string">&quot;light.specular&quot;</span>, <span class="number">1.0f</span>, <span class="number">1.0f</span>, <span class="number">1.0f</span>);</span><br></pre></td></tr></table></figure><p>现在我们调整了光照对物体材质的影响，我们应该能得到一个更类似于上一节的视觉效果。但这次我们有了对光照和物体材质的完全掌控：</p><div align="center"><p><img src="/images/learnopengl-c2-f13.jpg"></p></div><h3 id="不同的光源颜色"><a href="#不同的光源颜色" class="headerlink" title="不同的光源颜色"></a>不同的光源颜色</h3><p>到目前为止，我们都只对光源设置了从白到灰到黑范围内的颜色，这样只会改变物体各个分量的强度，而不是它的真正颜色。<strong>由于现在能够非常容易地访问光照的属性了，我们可以随着时间改变它们的颜色，从而获得一些非常有意思的效果</strong>。由于所有的东西都在片段着色器中配置好了，修改光源的颜色非常简单，我们能够立刻创造一些很有趣的效果。</p><p>我们可以利用sin和glfwGetTime函数<strong>改变光源的环境光和漫反射颜色</strong>，从而很容易地让光源的颜色随着时间变化：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">glm::vec3 lightColor;</span><br><span class="line">lightColor.x = <span class="built_in">sin</span>(glfwGetTime() * <span class="number">2.0f</span>);</span><br><span class="line">lightColor.y = <span class="built_in">sin</span>(glfwGetTime() * <span class="number">0.7f</span>);</span><br><span class="line">lightColor.z = <span class="built_in">sin</span>(glfwGetTime() * <span class="number">1.3f</span>);</span><br><span class="line"></span><br><span class="line">glm::vec3 diffuseColor = lightColor   * glm::vec3(<span class="number">0.5f</span>); <span class="comment">// 降低影响</span></span><br><span class="line">glm::vec3 ambientColor = diffuseColor * glm::vec3(<span class="number">0.2f</span>); <span class="comment">// 很低的影响</span></span><br><span class="line"></span><br><span class="line">lightingShader.setVec3(<span class="string">&quot;light.ambient&quot;</span>, ambientColor);</span><br><span class="line">lightingShader.setVec3(<span class="string">&quot;light.diffuse&quot;</span>, diffuseColor);</span><br></pre></td></tr></table></figure><div align="center"><p><img src="/images/learnopengl-c2-f14.jpg"></p></div><h3 id="练习-1"><a href="#练习-1" class="headerlink" title="练习"></a>练习</h3><ul><li>你能像教程一开始那样，定义相应的材质来模拟现实世界的物体吗？注意材质表格中的环境光值可能与漫反射值不一样，它们没有考虑光照的强度。要想纠正这一问题，你需要将所有的光照强度都设置为vec3(1.0)，这样才能得到正确的输出。</li></ul><h2 id="光照贴图"><a href="#光照贴图" class="headerlink" title="光照贴图"></a>光照贴图</h2><p>在上一节中，我们讨论了让每个物体都拥有自己独特的材质从而对光照做出不同的反应的方法。这样子能够很容易在一个光照的场景中给每个物体一个独特的外观，<strong>但是这仍不能对一个物体的视觉输出提供足够多的灵活性</strong>。</p><p>在上一节中，<strong>我们将整个物体的材质定义为一个整体</strong>，但现实世界中的物体通常并不只包含有一种材质，<strong>而是由多种材质所组成</strong>。想想一辆汽车：它的外壳非常有光泽，车窗会部分反射周围的环境，轮胎不会那么有光泽，所以它没有镜面高光，轮毂非常闪亮（如果你洗车了的话）。汽车同样会有漫反射和环境光颜色，它们在整个物体上也不会是一样的，汽车有着许多种不同的环境光/漫反射颜色。<strong>总之，这样的物体在不同的部件上都有不同的材质属性</strong>。</p><p>所以，上一节中的那个材质系统是肯定不够的，它只是一个最简单的模型，所以我们需要拓展之前的系统，引入<strong>漫反射贴图</strong>和<strong>镜面光贴图</strong>。这允许我们<strong>对物体的漫反射分量</strong>（以及间接地对环境光分量，它们几乎总是一样的）和<strong>镜面光分量有着更精确的控制</strong>。</p><h3 id="漫反射贴图"><a href="#漫反射贴图" class="headerlink" title="漫反射贴图"></a>漫反射贴图</h3><p>我们希望通过<strong>某种方式对物体的每个片段单独设置漫反射颜色</strong>。有能够让我们根据片段在物体上的位置来获取颜色值得系统吗？</p><p>这可能听起来很熟悉，而且<strong>事实上这个系统我们已经使用很长时间了</strong>。这听起来很像在之前教程中详细讨论过的纹理，而这基本就是这样：<strong>一个纹理</strong>。我们仅仅是对同样的原理使用了不同的名字：<strong>其实都是使用一张覆盖物体的图像</strong>，让我们能够逐片段索引其独立的颜色值。在光照场景中，它通常叫做一个<strong>漫反射贴图</strong>(Diffuse Map)（3D艺术家通常都这么叫它），它是一个表现了物体<strong>所有的漫反射颜色的纹理图像</strong>。</p><p>为了演示漫反射贴图，我们将会使用下面的图片，它是一个有钢边框的木箱：</p><div align="center"><p><img src="/images/learnopengl-c2-f15.jpg"></p></div><p>在着色器中使用漫反射贴图的方法和纹理教程中是完全一样的。但<strong>这次我们会将纹理储存</strong>为<strong>Material结构体</strong>中的一个<strong>sampler2D</strong>。我们将<strong>之前定义的vec3漫反射颜色向量替换为漫反射贴图</strong>。</p><p>注意sampler2D是所谓的<strong>不透明类型</strong>(Opaque Type)，也就是说我们<strong>不能将它实例化</strong>，只能通过uniform来<strong>定义它</strong>。如果我们使用除uniform以外的方法（比如函数的参数）实例化这个结构体，GLSL会抛出一些奇怪的错误。这同样<strong>也适用于任何封装了不透明类型的结构体</strong>。</p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">struct Material &#123;</span><br><span class="line">    <span class="type">sampler2D</span> diffuse;</span><br><span class="line">    <span class="type">vec3</span>      specular;</span><br><span class="line">    <span class="type">float</span>     shininess;</span><br><span class="line">&#125;; </span><br><span class="line">...</span><br><span class="line"><span class="keyword">in</span> <span class="type">vec2</span> TexCoords;</span><br></pre></td></tr></table></figure><p>如果你非常固执，仍想将环境光颜色设置为一个（漫反射值之外）不同的值，你也可以保留这个环境光的vec3，<strong>但整个物体仍只能拥有一个环境光颜色</strong>。如果想要对不同片段有不同的环境光值，你需要对环境光值单独使用另外一个纹理。</p><p>注意我们将在片段着色器中<strong>再次需要纹理坐标</strong>，所以我们声明一个额外的输入变量。接下来我们只需要从纹理中采样片段的漫反射颜色值即可：</p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">vec3</span> diffuse = light.diffuse * diff * <span class="type">vec3</span>(<span class="built_in">texture</span>(material.diffuse, TexCoords));</span><br></pre></td></tr></table></figure><p>不要忘记将环境光得材质颜色设置为漫反射材质颜色同样的值。</p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">vec3</span> ambient = light.ambient * <span class="type">vec3</span>(<span class="built_in">texture</span>(material.diffuse, TexCoords));</span><br></pre></td></tr></table></figure><p>这就是使用漫反射贴图的全部步骤了。你可以看到，这并不是什么新的东西，但这能够极大地提高视觉品质。为了让它正常工作，<strong>我们还需要使用纹理坐标更新顶点数据，将它们作为顶点属性传递到片段着色器，加载材质并绑定材质到合适的纹理单元</strong>。</p><p>更新后的顶点数据：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">float</span> vertices[] = &#123;</span><br><span class="line">    <span class="comment">// positions          // normals           // texture coords</span></span><br><span class="line">    <span class="number">-0.5f</span>, <span class="number">-0.5f</span>, <span class="number">-0.5f</span>,  <span class="number">0.0f</span>,  <span class="number">0.0f</span>, <span class="number">-1.0f</span>,  <span class="number">0.0f</span>, <span class="number">0.0f</span>,</span><br><span class="line">     <span class="number">0.5f</span>, <span class="number">-0.5f</span>, <span class="number">-0.5f</span>,  <span class="number">0.0f</span>,  <span class="number">0.0f</span>, <span class="number">-1.0f</span>,  <span class="number">1.0f</span>, <span class="number">0.0f</span>,</span><br><span class="line">     <span class="number">0.5f</span>,  <span class="number">0.5f</span>, <span class="number">-0.5f</span>,  <span class="number">0.0f</span>,  <span class="number">0.0f</span>, <span class="number">-1.0f</span>,  <span class="number">1.0f</span>, <span class="number">1.0f</span>,</span><br><span class="line">     <span class="number">0.5f</span>,  <span class="number">0.5f</span>, <span class="number">-0.5f</span>,  <span class="number">0.0f</span>,  <span class="number">0.0f</span>, <span class="number">-1.0f</span>,  <span class="number">1.0f</span>, <span class="number">1.0f</span>,</span><br><span class="line">    <span class="number">-0.5f</span>,  <span class="number">0.5f</span>, <span class="number">-0.5f</span>,  <span class="number">0.0f</span>,  <span class="number">0.0f</span>, <span class="number">-1.0f</span>,  <span class="number">0.0f</span>, <span class="number">1.0f</span>,</span><br><span class="line">    <span class="number">-0.5f</span>, <span class="number">-0.5f</span>, <span class="number">-0.5f</span>,  <span class="number">0.0f</span>,  <span class="number">0.0f</span>, <span class="number">-1.0f</span>,  <span class="number">0.0f</span>, <span class="number">0.0f</span>,</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>顶点数据现在包含了<strong>顶点位置、法向量和立方体顶点处的纹理坐标</strong>。让我们<strong>更新顶点着色器</strong>来以顶点属性的形式接受纹理坐标，并将它们传递到片段着色器中：</p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#version 330 core</span></span><br><span class="line"><span class="keyword">layout</span> (<span class="keyword">location</span> = <span class="number">0</span>) <span class="keyword">in</span> <span class="type">vec3</span> aPos;</span><br><span class="line"><span class="keyword">layout</span> (<span class="keyword">location</span> = <span class="number">1</span>) <span class="keyword">in</span> <span class="type">vec3</span> aNormal;</span><br><span class="line"><span class="keyword">layout</span> (<span class="keyword">location</span> = <span class="number">2</span>) <span class="keyword">in</span> <span class="type">vec2</span> aTexCoords;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">out</span> <span class="type">vec2</span> TexCoords;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> main() &#123;</span><br><span class="line">    ...</span><br><span class="line">    TexCoords = aTexCoords;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>记得去<strong>更新两个VAO的顶点属性指针来匹配新的顶点数据</strong>，并<strong>加载箱子图像为一个纹理</strong>。在绘制箱子之前，我们希望将要用的纹理单元赋值到material.diffuse这个uniform采样器，并绑定箱子的纹理到这个纹理单元：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">lightingShader.setInt(<span class="string">&quot;material.diffuse&quot;</span>, <span class="number">0</span>);</span><br><span class="line">...</span><br><span class="line">glActiveTexture(GL_TEXTURE0);</span><br><span class="line">glBindTexture(GL_TEXTURE_2D, diffuseMap);</span><br></pre></td></tr></table></figure><p>使用了漫反射贴图之后，细节再一次得到惊人的提升，这次箱子有了光照开始闪闪发光了。你的箱子看起来可能像这样：</p><div align="center"><p><img src="/images/learnopengl-c2-f16.jpg"></p></div><h3 id="镜面光贴图"><a href="#镜面光贴图" class="headerlink" title="镜面光贴图"></a>镜面光贴图</h3><p>你可能会注意到，<strong>镜面高光看起来有些奇怪，因为我们的物体大部分都是木头，我们知道木头不应该有这么强的镜面高光的</strong>。我们可以将物体的镜面光材质设置为vec3(0.0)来解决这个问题，但这也意味着箱子钢制的边框将不再能够显示镜面高光了，我们知道<strong>钢铁应该是有一些镜面高光的</strong>。所以，<strong>我们想要让物体的某些部分以不同的强度显示镜面高光</strong>。这个问题看起来和漫反射贴图非常相似。是巧合吗？我想不是。</p><p>我们同样可以使用一个<strong>专门用于镜面高光的纹理贴图</strong>。这也就意味着我们需要生成一个<strong>黑白的</strong>（如果你想得话也可以是彩色的）纹理，来定义<strong>物体每部分的镜面光强度</strong>。下面是一个<strong>镜面光贴图</strong>(Specular Map)的例子：</p><div align="center"><p><img src="/images/learnopengl-c2-f17.jpg"></p></div><p>镜面高光的强度<strong>可以通过图像每个像素的亮度来获取</strong>。镜面光贴图上的每个像素都可以由一个颜色向量来表示，比如说黑色代表颜色向量vec3(0.0)，灰色代表颜色向量vec3(0.5)。在片段着色器中，我们接下来会<strong>取样对应的颜色值并将它乘以光源的镜面强度</strong>。一个像素越「白」，<strong>乘积就会越大，物体的镜面光分量就会越亮</strong>。</p><p>由于箱子大部分都由木头所组成，而且木头材质应该没有镜面高光，<strong>所以漫反射纹理的整个木头部分全部都转换成了黑色。箱子钢制边框的镜面光强度是有细微变化的，钢铁本身会比较容易受到镜面高光的影响，而裂缝则不会</strong>。</p><p>从实际角度来说，木头其实也有镜面高光，尽管它的<strong>反光度</strong>(Shininess)<strong>很小</strong>（更多的光被散射），影响也比较小，但是为了教学目的，我们可以假设木头不会对镜面光有任何反应。</p><p>使用Photoshop或Gimp之类的工具，<strong>将漫反射纹理转换为镜面光纹理还是比较容易的</strong>，只需要剪切掉一些部分，<strong>将图像转换为黑白的</strong>，并<strong>增加亮度/对比度</strong>就好了。</p><p><strong>采样镜面光贴图</strong></p><p>镜面光贴图和其它的纹理非常类似，所以代码也和漫反射贴图的代码很类似。记得要保证正确地加载图像并生成一个纹理对象。<strong>由于我们正在同一个片段着色器中使用另一个纹理采样器，我们必须要对镜面光贴图使用一个不同的纹理单元</strong>，所以我们在渲染之前先把它绑定到合适的纹理单元上：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">lightingShader.setInt(<span class="string">&quot;material.specular&quot;</span>, <span class="number">1</span>);</span><br><span class="line">...</span><br><span class="line">glActiveTexture(GL_TEXTURE1);</span><br><span class="line">glBindTexture(GL_TEXTURE_2D, specularMap);</span><br></pre></td></tr></table></figure><p>接下来更新<strong>片段着色器的材质属性</strong>，让其接受一个sampler2D而不是vec3作为镜面光分量：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Material</span> &#123;</span></span><br><span class="line">    sampler2D diffuse;</span><br><span class="line">    sampler2D specular;</span><br><span class="line">    <span class="keyword">float</span>     shininess;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>最后我们希望采样镜面光贴图，来获取片段所对应的镜面光强度：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vec3 specular = light.specular * spec * vec3(texture(material.specular, TexCoords));</span><br></pre></td></tr></table></figure><p>通过使用镜面光贴图我们可以可以对物体设置大量的细节，<strong>比如物体的哪些部分需要有闪闪发光的属性，我们甚至可以设置它们对应的强度</strong>。镜面光贴图能够在漫反射贴图之上给予我们更高一层的控制。</p><p>如果你想另辟蹊径，你<strong>也可以在镜面光贴图中使用真正的颜色</strong>，不仅设置每个片段的镜面光强度，还设置了镜面高光的颜色。<strong>从现实角度来说，镜面高光的颜色大部分</strong>（甚至全部）<strong>都是由光源本身所决定的</strong>，所以这样<strong>并不能生成非常真实的视觉效果</strong>（这也是为什么图像通常是黑白的，我们只关心强度）。</p><p>如果你现在运行程序的话，你可以清楚地看到箱子的材质现在和真实的钢制边框箱子非常类似了：</p><div align="center"><p><img src="/images/learnopengl-c2-f18.jpg"></p></div><p><strong>通过使用漫反射和镜面光贴图，我们可以给相对简单的物体添加大量的细节</strong>。我们甚至可以使用<strong>法线/凹凸贴图</strong>(Normal/Bump Map)或者<strong>反射贴图</strong>(Reflection Map)给物体添加更多的细节，但这些将会留到之后的教程中。</p><h3 id="练习题"><a href="#练习题" class="headerlink" title="练习题"></a>练习题</h3><ul><li>调整光源的环境光、漫反射和镜面光向量，看看它们如何影响箱子的视觉输出。</li><li>尝试在片段着色器中反转镜面光贴图的颜色值，让木头显示镜面高光而钢制边缘不反光（由于钢制边缘中有一些裂缝，边缘仍会显示一些镜面高光，虽然强度会小很多）。</li><li>使用漫反射贴图创建一个彩色而不是黑白的镜面光贴图，看看结果看起来并不是那么真实了。如果你不会生成的话，可以使用这张彩色的镜面光贴图。</li><li>添加一个叫做<strong>放射光贴图</strong>(Emission Map)的东西，它是一个<strong>储存了每个片段的发光值</strong>(Emission Value)的贴图。发光值是一个包含（假设）<strong>光源的物体发光</strong>(Emit)<strong>时可能显现的颜色</strong>，这样的话物体就能够<strong>忽略光照条件进行发光</strong>(Glow)。游戏中某个物体在发光的时候，你通常看到的就是<strong>放射光贴图</strong>（比如 机器人的眼，或是箱子上的灯带）。将这个纹理（作者为 creativesam）作为<strong>放射光贴图添加到箱子上，产生这些字母都在发光的效果</strong>。</li></ul><h2 id="投光物"><a href="#投光物" class="headerlink" title="投光物"></a>投光物</h2><p>我们目前使用的光照都来自于空间中的一个点。它能给我们不错的效果，但现实世界中，我们有很多种类的光照，每种的表现都不同。将<strong>光投射</strong>(Cast)到物体的光源叫做<strong>投光物</strong>(Light Caster)。在这一节中，我们将会讨论几种<strong>不同类型的投光物</strong>。学会模拟不同种类的光源是又一个能够进一步丰富场景的工具。</p><p>我们首先将会讨论<strong>定向光</strong>(Directional Light)，接下来是<strong>点光源</strong>(Point Light)，它是我们之前学习的光源的拓展，最后我们将会讨论<strong>聚光</strong>(Spotlight)。在下一节中我们将讨论如何将这些不同种类的光照类型整合到一个场景之中。</p><h3 id="平行光"><a href="#平行光" class="headerlink" title="平行光"></a>平行光</h3><p><strong>当一个光源处于很远的地方时，来自光源的每条光线就会近似于互相平行</strong>。不论物体和/或者观察者的位置，看起来好像所有的光都来自于同一个方向。当我们使用一个假设光源处于无限远处的模型时，它就被称为定向光，因为它的所有光线都有着相同的方向，它与光源的位置是没有关系的。</p><p><strong>定向光非常好的一个例子就是太阳</strong>。太阳距离我们并不是无限远，但它已经远到在光照计算中可以把它视为无限远了。所以来自太阳的所有光线将被模拟为平行光线，我们可以在下图看到：</p><div align="center"><p><img src="/images/learnopengl-c2-f19.jpg"></p></div><p>因为所有的光线都是平行的，所以物体与光源的相对位置是不重要的，因为对场景中每一个物体光的方向都是一致的。<strong>由于光的位置向量保持一致，场景中每个物体的光照计算将会是类似的</strong>。</p><p>我们可以<strong>定义一个光线方向向量而不是位置向量来模拟一个定向光</strong>。着色器的计算基本保持不变，但这次我们将直接使用光的direction向量而不是通过direction来计算lightDir向量。</p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">struct Light &#123;</span><br><span class="line">    <span class="comment">// vec3 position; // 使用定向光就不再需要了</span></span><br><span class="line">    <span class="type">vec3</span> direction;</span><br><span class="line"></span><br><span class="line">    <span class="type">vec3</span> ambient;</span><br><span class="line">    <span class="type">vec3</span> diffuse;</span><br><span class="line">    <span class="type">vec3</span> specular;</span><br><span class="line">&#125;;</span><br><span class="line">...</span><br><span class="line"><span class="type">void</span> main() &#123;</span><br><span class="line">  <span class="type">vec3</span> lightDir = <span class="built_in">normalize</span>(-light.direction);</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意我们首先对<code>light.direction</code><strong>向量取反</strong>。我们目前使用的光照计算需求<strong>一个从片段至光源的光线方向</strong>，但人们更习惯定义<strong>定向光为一个从光源出发的全局方向</strong>。所以我们需要对全局光照方向向量取反来改变它的方向，它现在是一个指向光源的方向向量了。而且，记得对向量进行标准化，假设输入向量为一个单位向量是很不明智的。</p><p>最终的<code>lightDir</code>向量将和以前一样用在漫反射和镜面光计算中。</p><p>为了清楚地展示定向光对多个物体具有相同的影响，我们将会再次使用坐标系统章节最后的那个箱子派对的场景。如果你错过了派对，<strong>我们先定义了十个不同的箱子位置，并对每个箱子都生成了一个不同的模型矩阵，每个模型矩阵都包含了对应的局部-世界坐标变换</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">unsigned</span> <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">    glm::mat4 model;</span><br><span class="line">    model = glm::translate(model, cubePositions[i]);</span><br><span class="line">    <span class="keyword">float</span> angle = <span class="number">20.0f</span> * i;</span><br><span class="line">    model = glm::rotate(model, glm::radians(angle), glm::vec3(<span class="number">1.0f</span>, <span class="number">0.3f</span>, <span class="number">0.5f</span>));</span><br><span class="line">    lightingShader.setMat4(<span class="string">&quot;model&quot;</span>, model);</span><br><span class="line"></span><br><span class="line">    glDrawArrays(GL_TRIANGLES, <span class="number">0</span>, <span class="number">36</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同时，不要忘记定义光源的方向（注意我们将方向定义为从光源出发的方向，你可以很容易看到光的方向朝下）。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lightingShader.setVec3(<span class="string">&quot;light.direction&quot;</span>, <span class="number">-0.2f</span>, <span class="number">-1.0f</span>, <span class="number">-0.3f</span>);</span><br></pre></td></tr></table></figure><p>我们一直将光的位置和位置向量定义为vec3，<strong>但一些人会喜欢将所有的向量都定义为vec4</strong>。当我们将<strong>位置向量</strong>定义为一个vec4时，<strong>很重要的一点是要将w分量设置为1.0</strong>，这样变换和投影才能正确应用。然而，当我们定义一个<strong>方向向量为vec4的时候</strong>，我们不想让位移有任何的效果（因为它仅仅代表的是方向），所以我们将<strong>w分量设置为0.0</strong>。</p><p>方向向量就会像这样来表示：vec4(0.2f, 1.0f, 0.3f, <strong>0.0f</strong>)。这也可以作为一个快速检测光照类型的工具：你可以检测w分量是否等于1.0，来检测它是否是光的位置向量；w分量等于0.0，则它是光的方向向量，这样就能根据这个来调整光照计算了：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(lightVector.w == <span class="number">0.0</span>) <span class="comment">// 注意浮点数据类型的误差</span></span><br><span class="line">  <span class="comment">// 执行定向光照计算</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(lightVector.w == <span class="number">1.0</span>)</span><br><span class="line">  <span class="comment">// 根据光源的位置做光照计算（与上一节一样）</span></span><br></pre></td></tr></table></figure><p>这正是旧OpenGL（固定函数式）<strong>决定光源是定向光还是位置光源</strong>(Positional Light Source)的方法，并根据它来调整光照。</p><p>如果你现在编译程序，在场景中自由移动，你就可以看到好像有一个太阳一样的光源对所有的物体投光。</p><div align="center"><p><img src="/images/learnopengl-c2-f20.jpg"></p></div><h3 id="点光源"><a href="#点光源" class="headerlink" title="点光源"></a>点光源</h3><p><strong>定向光对于照亮整个场景的全局光源是非常棒的</strong>，但除了定向光之外我们也需要一些<strong>分散在场景中的点光源</strong>(Point Light)。点光源是处于世界中某一个位置的光源，它会<strong>朝着所有方向发光</strong>，<strong>但光线会随着距离逐渐衰减</strong>。想象作为投光物的灯泡和火把，它们都是点光源。</p><div align="center"><p><img src="/images/learnopengl-c2-f21.jpg"></p></div><p>在之前的教程中，我们一直都在使用一个<strong>简化的点光源</strong>。我们在给定位置有一个光源，它会从它的光源位置开始朝着所有方向散射光线。<strong>然而，我们定义的光源模拟的是永远不会衰减的光线，这看起来像是光源亮度非常的强</strong>。在大部分的3D模拟中，我们都希望<strong>模拟的光源仅照亮光源附近的区域而不是整个场景</strong>。</p><p>如果你将10个箱子加入到上一节光照场景中，你会注意到在最后面的箱子和在灯面前的箱子都以相同的强度被照亮，并没有定义一个公式来将光随距离衰减。<strong>我们希望在后排的箱子与前排的箱子相比仅仅是被轻微地照亮</strong>。</p><p><strong>衰减</strong></p><p><strong>随着光线传播距离的增长逐渐削减光的强度通常叫做衰减</strong>(Attenuation)。随距离减少光强度的<strong>一种方式是使用一个线性方程</strong>。这样的方程能够随着距离的增长线性地减少光的强度，从而让远处的物体更暗。然而，<strong>这样的线性方程通常会看起来比较假</strong>。在现实世界中，<strong>灯在近处通常会非常亮，但随着距离的增加光源的亮度一开始会下降非常快</strong>，但在<strong>远处时剩余的光强度就会下降的非常缓慢了</strong>。所以，我们需要一个不同的公式来减少光的强度。</p><p>幸运的是一些聪明的人已经帮我们解决了这个问题。下面这个公式根据片段距光源的距离计算了衰减值，之后我们会将它乘以光的强度向量：</p><div align="center"><p><img src="/images/learnopengl-c2-f22.jpg"></p></div><p>在这里d代表了片段距光源的距离。接下来为了计算衰减值，我们定义3个（可配置的）项：<strong>常数项Kc</strong>、<strong>一次项Kl</strong>和<strong>二次项Kq</strong>。</p><ul><li>常数项通常保持为1.0，<strong>它的主要作用是保证分母永远不会比1小</strong>，否则的话在某些距离上它反而会增加强度，这肯定不是我们想要的效果。</li><li>一次项会与距离值相乘，以线性的方式减少强度。</li><li>二次项会与距离的平方相乘，让光源以二次递减的方式减少强度。二次项在距离比较小的时候影响会比一次项小很多，但当距离值比较大的时候它就会比一次项更大了。</li></ul><p>由于二次项的存在，<strong>光线会在大部分时候以线性的方式衰退，直到距离变得足够大，让二次项超过一次项，光的强度会以更快的速度下降</strong>。这样的结果就是，<strong>光在近距离时亮度很高，但随着距离变远亮度迅速降低，最后会以更慢的速度减少亮度</strong>。下面这张图显示了在100的距离内衰减的效果：</p><div align="center"><p><img src="/images/learnopengl-c2-f23.jpg"></p></div><p>原例中的图其实很难看出来在其描述的“距离变得足够大，光的强度会以更快的速度下降”，其实这只有在最初的一部分才是这样的，在那之后强度下降的速度就开始放缓了，在下面数学画图中可以更加清楚的看到这样的现象。</p><div align="center"><p><img src="/images/learnopengl-c2-f25.jpg"></p></div><p>你可以看到光在近距离的时候有着最高的强度，但随着距离增长，它的强度明显减弱，并缓慢地在距离大约100的时候强度接近0。这正是我们想要的。</p><p><strong>选择正确地值</strong></p><p>但是，该对这三个项设置什么值呢？<strong>正确地设定它们的值取决于很多因素</strong>：<strong>环境、希望光覆盖的距离、光的类型等</strong>。在大多数情况下，这都是经验的问题，以及适量的调整。下面这个表格显示了模拟一个（大概）真实的，覆盖特定半径（距离）的光源时，这些项可能取的一些值。<strong>第一列</strong>指定的是在给定的三项时光所<strong>能覆盖的距离</strong>。这些值是大多数光源很好的起始点，它们由Ogre3D的Wiki所提供：</p><div align="center"><p><img src="/images/learnopengl-c2-f24.jpg"></p></div><p>你可以看到，<strong>常数项Kc在所有的情况下都是1.0</strong>。一次项Kl为了覆盖更远的距离通常都很小，二次项Kq甚至更小。尝试对这些值进行实验，看看它们在你的实现中有什么效果。在我们的环境中，32到100的距离对大多数的光源都足够了。</p><p><strong>实现衰减</strong></p><p>为了实现衰减，在<strong>片段着色器中</strong>我们还需要<strong>三个额外的值</strong>：也就是公式中的<strong>常数项、一次项和二次项</strong>。它们最好储存在之前定义的Light结构体中。注意我们使用<strong>上一节中计算lightDir的方法</strong>，而不是上面定向光部分的。</p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">struct Light &#123;</span><br><span class="line">    <span class="type">vec3</span> position;</span><br><span class="line"></span><br><span class="line">    <span class="type">vec3</span> ambient;</span><br><span class="line">    <span class="type">vec3</span> diffuse;</span><br><span class="line">    <span class="type">vec3</span> specular;</span><br><span class="line"></span><br><span class="line">    <span class="type">float</span> constant;</span><br><span class="line">    <span class="type">float</span> linear;</span><br><span class="line">    <span class="type">float</span> quadratic;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>然后我们将在OpenGL中设置这些项。我们希望光源能够覆盖50的距离，所以我们会使用表格中对应的常数项、一次项和二次项：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">lightingShader.setFloat(<span class="string">&quot;light.constant&quot;</span>,  <span class="number">1.0f</span>);</span><br><span class="line">lightingShader.setFloat(<span class="string">&quot;light.linear&quot;</span>,    <span class="number">0.09f</span>);</span><br><span class="line">lightingShader.setFloat(<span class="string">&quot;light.quadratic&quot;</span>, <span class="number">0.032f</span>);</span><br></pre></td></tr></table></figure><p>在片段着色器中实现衰减还是比较直接的：我们根据公式计算衰减值，之后再分别乘以环境光、漫反射和镜面光分量。</p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">float</span> <span class="built_in">distance</span>    = <span class="built_in">length</span>(light.position - FragPos);</span><br><span class="line"><span class="type">float</span> attenuation = <span class="number">1.0</span> / (light.constant + light.linear * <span class="built_in">distance</span> + </span><br><span class="line">                light.quadratic * (<span class="built_in">distance</span> * <span class="built_in">distance</span>));</span><br></pre></td></tr></table></figure><p>接下来，我们将包含这个衰减值到光照计算中，将它分别乘以环境光、漫反射和镜面光颜色。</p><p><strong>我们可以将环境光分量保持不变</strong>，让环境光照不会随着距离减少，<strong>但是如果我们使用多于一个的光源，所有的环境光分量将会开始叠加</strong>，所以在这种情况下我们也希望衰减环境光照。</p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">vec3</span> result = attenuation * (ambient + diffuse + specular);</span><br></pre></td></tr></table></figure><div align="center"><p><img src="/images/learnopengl-c2-f26.jpg"></p></div><p>你可以看到，只有前排的箱子被照亮的，距离最近的箱子是最亮的。后排的箱子一点都没有照亮，因为它们离光源实在是太远了。你可以在这里找到程序的代码。</p><p>点光源就是一个能够配置位置和衰减的光源。它是我们光照工具箱中的又一个光照类型。</p><h3 id="聚光"><a href="#聚光" class="headerlink" title="聚光"></a>聚光</h3><p>我们要讨论的最后一种类型的光是<strong>聚光</strong>(Spotlight)。聚光是位于环境中某个位置的光源，<strong>它只朝一个特定方向而不是所有方向照射光线</strong>。这样的结果就是只有在聚光方向的<strong>特定半径内的物体才会被照亮</strong>，其它的物体都会保持黑暗。聚光很好的例子就是路灯或手电筒。</p><p>OpenGL中聚光是用一个<strong>世界空间位置</strong>、一个<strong>方向</strong>和一个<strong>切光角</strong>(Cutoff Angle)来表示的，<strong>切光角指定了聚光的半径</strong>（译注：是<strong>圆锥的半径不是距光源距离那个半径</strong>）。对于每个片段，我们会计算片段是否位于聚光的切光方向之间（也就是在锥形内），如果是的话，我们就会相应地照亮片段。下面这张图会让你明白聚光是如何工作的：</p><div align="center"><p><img src="/images/learnopengl-c2-f27.jpg"></p></div><ul><li>LightDir：从片段指向光源的向量。</li><li>SpotDir：聚光所指向的方向。</li><li><strong>Phi</strong>ϕ：指定了聚光半径的切光角。落在这个角度之外的物体都不会被这个聚光所照亮。</li><li><strong>Theta</strong>θ：LightDir向量和SpotDir向量之间的夹角。<strong>在聚光内部的话θ值应该比ϕ值小</strong>。</li></ul><p>所以我们要做的就是<strong>计算LightDir向量和SpotDir向量之间的点积</strong>（还记得它会返回两个单位向量夹角的余弦值吗？），并将它与<strong>切光角ϕ值对比</strong>。你现在应该了解聚光究竟是什么了，下面我们将以手电筒的形式创建一个聚光。</p><p><strong>手电筒</strong></p><p>手电筒(Flashlight)是一个<strong>位于观察者位置的聚光</strong>，通常它都会<strong>瞄准玩家视角的正前方</strong>。基本上说，手电筒就是普通的聚光，但它的位置和方向会随着玩家的位置和朝向不断更新。</p><p>所以，在<strong>片段着色器中</strong>我们需要的值有<strong>聚光的位置向量</strong>（来计算光的方向向量）、<strong>聚光的方向向量和一个切光角</strong>。我们可以将它们储存在Light结构体中：</p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">struct Light &#123;</span><br><span class="line">    <span class="type">vec3</span>  position;</span><br><span class="line">    <span class="type">vec3</span>  direction;</span><br><span class="line">    <span class="type">float</span> cutOff;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>接下来我们将合适的值传到着色器中：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">lightingShader.setVec3(<span class="string">&quot;light.position&quot;</span>,  camera.Position);</span><br><span class="line">lightingShader.setVec3(<span class="string">&quot;light.direction&quot;</span>, camera.Front);</span><br><span class="line">lightingShader.setFloat(<span class="string">&quot;light.cutOff&quot;</span>,   glm::<span class="built_in">cos</span>(glm::radians(<span class="number">12.5f</span>)));</span><br></pre></td></tr></table></figure><p>你可以看到，<strong>我们并没有给切光角设置一个角度值，反而是用角度值计算了一个余弦值，将余弦结果传递到片段着色器中</strong>。这样做的原因是在片段着色器中，我们会计算LightDir和SpotDir向量的点积，<strong>这个点积返回的将是一个余弦值而不是角度值，所以我们不能直接使用角度值和余弦值进行比较</strong>。为了获取角度值我们需要计算点积结果的反余弦，这是一个开销很大的计算。所以<strong>为了节约一点性能开销，我们将会计算切光角对应的余弦值，并将它的结果传入片段着色器中</strong>。由于这两个角度现在都由余弦角来表示了，我们可以直接对它们进行比较而不用进行任何开销高昂的计算。</p><p>接下来就是<strong>计算θ值</strong>，并将它和切光角ϕ对比，来决定是否在聚光的内部：</p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> main() &#123;</span><br><span class="line">    <span class="type">vec3</span> norm = <span class="built_in">normalize</span>(Normal);</span><br><span class="line">    <span class="type">vec3</span> lightDir = <span class="built_in">normalize</span>(light.position - FragPos);</span><br><span class="line">    ...</span><br><span class="line">    <span class="type">float</span> theta = <span class="built_in">dot</span>(lightDir, <span class="built_in">normalize</span>(-light.direction));</span><br><span class="line">    <span class="type">vec3</span> result;</span><br><span class="line">    <span class="keyword">if</span>(theta &gt; light.cutOff) &#123;</span><br><span class="line">        <span class="comment">// 执行光照计算</span></span><br><span class="line">        ...</span><br><span class="line">        <span class="type">float</span> <span class="built_in">distance</span> = <span class="built_in">length</span>(light.position - FragPos);</span><br><span class="line">        <span class="type">float</span> attenuation = <span class="number">1.0</span> / (light.constant + light.linear * <span class="built_in">distance</span> + </span><br><span class="line">                    light.quadratic * (<span class="built_in">distance</span> * <span class="built_in">distance</span>));</span><br><span class="line">    </span><br><span class="line">        result = attenuation * (ambient + diffuse + specular);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 否则，使用环境光，让场景在聚光之外时不至于完全黑暗</span></span><br><span class="line">        result = ambient;</span><br><span class="line">    &#125;</span><br><span class="line">    FragColor = <span class="type">vec4</span>(result, <span class="number">1.0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们首先计算了<strong>lightDir和取反的direction向量</strong>（取反的是因为我们想<strong>让向量指向光源而不是从光源出发</strong>）之间的点积。记住要对所有的相关向量标准化。</p><p>运行程序，你将会看到一个聚光，它仅会照亮聚光圆锥内的片段。看起来像是这样的：</p><div align="center"><p><img src="/images/learnopengl-c2-f28.jpg"></p></div><p>但这仍看起来有些假，<strong>主要是因为聚光有一圈硬边</strong>。当一个片段遇到聚光圆锥的边缘时，它会完全变暗，<strong>没有一点平滑的过渡</strong>。<strong>一个真实的聚光将会在边缘处逐渐减少亮度。</strong></p><p><strong>平滑/软化边缘</strong></p><p>为了创建一种看起来边缘平滑的聚光，我们需要模拟聚光有一个<strong>内圆锥</strong>(Inner Cone)和一个<strong>外圆锥</strong>(Outer Cone)。我们可以将内圆锥设置为上一部分中的那个圆锥，但我们也<strong>需要一个外圆锥，来让光从内圆锥逐渐减暗，直到外圆锥的边界</strong>。</p><p>为了创建一个外圆锥，我们只需要再定义一个余弦值来代表聚光方向向量和外圆锥向量（等于它的半径）的夹角。然后，<strong>如果一个片段处于内外圆锥之间，将会给它计算出一个0.0到1.0之间的强度值</strong>。如果片段在内圆锥之内，它的强度就是1.0，如果在外圆锥之外强度值就是0.0。</p><p>我们可以用下面这个公式来计算这个值：</p><div align="center"><p><img src="/images/learnopengl-c2-f29.jpg"></p></div><p>这里<strong>ϵ</strong>(Epsilon)是<strong>内</strong>（ϕ）和<strong>外圆锥</strong>（γ）之间的<strong>余弦值差</strong>（ϵ=ϕ−γ）。最终的<strong>I值就是在当前片段聚光的强度</strong>。</p><p>这基本上就是在内外余弦值之间根据θ插值。</p><p>我们现在有了一个<strong>在聚光外是负的，在内圆锥内大于1.0的，在边缘处于两者之间的强度值了</strong>。如果我们正确地<strong>约束(Clamp)这个值</strong>，在片段着色器中就不再需要if-else了，我们能够使用<strong>计算出来的强度值直接乘以光照分量</strong>：</p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> main() &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="type">float</span> theta = <span class="built_in">dot</span>(lightDir, <span class="built_in">normalize</span>(-light.direction));</span><br><span class="line">    <span class="type">float</span> epsilon = light.cutOff - light.outerCutOff;</span><br><span class="line">    <span class="type">float</span> intensity = <span class="built_in">clamp</span>((theta - light.outerCutOff) / epsilon, <span class="number">0.0</span>, <span class="number">1.0</span>);</span><br><span class="line">    ...</span><br><span class="line">    <span class="type">vec3</span> result = attenuation * (ambient + diffuse * intensity + specular * intensity);</span><br><span class="line"></span><br><span class="line">    FragColor = <span class="type">vec4</span>(result, <span class="number">1.0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意我们使用了clamp函数，它把第一个参数约束(Clamp)在了0.0到1.0之间。这保证强度值不会在[0, 1]区间之外。</p><p>确定你将outerCutOff值添加到了Light结构体之中，并在程序中设置它的uniform值。下面的图片中，我们使用的内切光角是12.5，外切光角是17.5：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">lightingShader.setFloat(<span class="string">&quot;light.cutOff&quot;</span>, glm::<span class="built_in">cos</span>(glm::radians(<span class="number">12.5f</span>)));</span><br><span class="line">lightingShader.setFloat(<span class="string">&quot;light.outerCutOff&quot;</span>, glm::<span class="built_in">cos</span>(glm::radians(<span class="number">17.5f</span>)));</span><br></pre></td></tr></table></figure><div align="center"><p><img src="/images/learnopengl-c2-f30.jpg"></p></div><p>啊，这样看起来就好多了。</p><h2 id="多光源"><a href="#多光源" class="headerlink" title="多光源"></a>多光源</h2><p>我们在前面的教程中已经学习了许多关于OpenGL中光照的知识，其中包括冯氏着色(Phong Shading)、材质(Material)、光照贴图(Lighting Map)以及不同种类的投光物(Light Caster)。在这一节中，我们将结合之前学过的所有知识，<strong>创建一个包含六个光源的场景</strong>。我们将模拟一个<strong>类似太阳的定向光</strong>(Directional Light)光源，<strong>四个分散在场景中的点光源</strong>(Point Light)，以及一个<strong>手电筒</strong>(Flashlight)。</p><p>为了在场景中使用多个光源，我们希望将<strong>光照计算封装到GLSL函数中</strong>。这样做的原因是，<strong>每一种光源都需要一种不同的计算方法</strong>，而一旦我们想对多个光源进行光照计算时，代码很快就会变得非常复杂。<strong>如果我们只在main函数中进行所有的这些计算，代码很快就会变得难以理解</strong>。</p><p>GLSL中的函数和C函数很相似，它有一个<strong>函数名</strong>、一个<strong>返回值类型</strong>，如果函数不是在main函数之前声明的，我们还必须在代码文件顶部声明一个原型。我们<strong>对每个光照类型都创建一个不同的函数</strong>：<strong>定向光、点光源和聚光</strong>。</p><p>当我们在场景中使用多个光源时，通常使用以下方法：我们需要有一个<strong>单独的颜色向量代表片段的输出颜色</strong>。对于<strong>每一个光源</strong>，它对片段的贡献颜色将会<strong>加到片段的输出颜色向量上</strong>。所以场景中的每个光源都会计算它们各自对片段的影响，并结合为一个最终的输出颜色。大体的结构会像是这样：</p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">out</span> <span class="type">vec4</span> FragColor;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> main()</span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// 定义一个输出颜色值</span></span><br><span class="line">  <span class="type">vec3</span> output;</span><br><span class="line">  <span class="comment">// 将定向光的贡献加到输出中</span></span><br><span class="line">  output += someFunctionToCalculateDirectionalLight();</span><br><span class="line">  <span class="comment">// 对所有的点光源也做相同的事情</span></span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; nr_of_point_lights; i++)</span><br><span class="line">    output += someFunctionToCalculatePointLight();</span><br><span class="line">  <span class="comment">// 也加上其它的光源（比如聚光）</span></span><br><span class="line">  output += someFunctionToCalculateSpotLight();</span><br><span class="line"></span><br><span class="line">  FragColor = <span class="type">vec4</span>(output, <span class="number">1.0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实际的代码对每一种实现都可能不同，但大体的结构都是差不多的。我们定义了几个函数，用来计算每个光源的影响，并将最终的结果颜色加到输出颜色向量上。<strong>例如，如果两个光源都很靠近一个片段，那么它们所结合的贡献将会形成一个比单个光源照亮时更加明亮的片段</strong>。</p><h3 id="定向光"><a href="#定向光" class="headerlink" title="定向光"></a>定向光</h3><p>我么需要在<strong>片段着色器中</strong>定义一个<strong>函数来计算定向光</strong>对相应片段的贡献：它接受<strong>一些参数并计算一个定向光照颜色</strong>。</p><p>首先，我们需要<strong>定义一个定向光源最少所需要的变量</strong>。我们可以将这些变量储存在一个叫做DirLight的结构体中，并将它定义为一个uniform。需要的变量在上一节中都介绍过：</p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">struct DirLight &#123;</span><br><span class="line">    <span class="type">vec3</span> direction;</span><br><span class="line"></span><br><span class="line">    <span class="type">vec3</span> ambient;</span><br><span class="line">    <span class="type">vec3</span> diffuse;</span><br><span class="line">    <span class="type">vec3</span> specular;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">uniform</span> DirLight dirLight;</span><br></pre></td></tr></table></figure><p>接下来我们可以将dirLight传入一个函数：</p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">vec3</span> CalcDirLight(DirLight light, <span class="type">vec3</span> normal, <span class="type">vec3</span> viewDir);</span><br></pre></td></tr></table></figure><p>和C/C++一样，<strong>如果我们想调用一个函数</strong>（这里是在main函数中调用），<strong>这个函数需要在调用者的行数之前被定义过</strong>。在这个例子中我们更喜欢在main函数以下定义函数，所以上面要求就不满足了。所以，我们需要在main函数之上定义函数的原型，这和C语言中是一样的。</p><p>你可以看到，这个函数需要一个DirLight结构体和其它两个向量来进行计算。如果你认真完成了上一节的话，这个函数的内容应该理解起来很容易：</p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">vec3</span> CalcDirLight(DirLight light, <span class="type">vec3</span> normal, <span class="type">vec3</span> viewDir) &#123;</span><br><span class="line">    <span class="type">vec3</span> lightDir = <span class="built_in">normalize</span>(-light.direction);</span><br><span class="line">    <span class="comment">// 漫反射着色</span></span><br><span class="line">    <span class="type">float</span> diff = <span class="built_in">max</span>(<span class="built_in">dot</span>(normal, lightDir), <span class="number">0.0</span>);</span><br><span class="line">    <span class="comment">// 镜面光着色</span></span><br><span class="line">    <span class="type">vec3</span> reflectDir = <span class="built_in">reflect</span>(-lightDir, normal);</span><br><span class="line">    <span class="type">float</span> spec = <span class="built_in">pow</span>(<span class="built_in">max</span>(<span class="built_in">dot</span>(viewDir, reflectDir), <span class="number">0.0</span>), material.shininess);</span><br><span class="line">    <span class="comment">// 合并结果</span></span><br><span class="line">    <span class="type">vec3</span> ambient  = light.ambient  * <span class="type">vec3</span>(<span class="built_in">texture</span>(material.diffuse, TexCoords));</span><br><span class="line">    <span class="type">vec3</span> diffuse  = light.diffuse  * diff * <span class="type">vec3</span>(<span class="built_in">texture</span>(material.diffuse, TexCoords));</span><br><span class="line">    <span class="type">vec3</span> specular = light.specular * spec * <span class="type">vec3</span>(<span class="built_in">texture</span>(material.specular, TexCoords));</span><br><span class="line">    <span class="keyword">return</span> (ambient + diffuse + specular);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="点光源-1"><a href="#点光源-1" class="headerlink" title="点光源"></a>点光源</h3><p>和定向光一样，我们也希望<strong>定义一个用于计算点光源对相应片段贡献</strong>，以及<strong>衰减</strong>，的函数。同样，我们定义一个包含了点光源所需所有变量的结构体：</p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">struct PointLight &#123;</span><br><span class="line">    <span class="type">vec3</span> position;</span><br><span class="line"></span><br><span class="line">    <span class="type">float</span> constant;</span><br><span class="line">    <span class="type">float</span> linear;</span><br><span class="line">    <span class="type">float</span> quadratic;</span><br><span class="line"></span><br><span class="line">    <span class="type">vec3</span> ambient;</span><br><span class="line">    <span class="type">vec3</span> diffuse;</span><br><span class="line">    <span class="type">vec3</span> specular;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">#define NR_POINT_LIGHTS 4</span></span><br><span class="line"><span class="keyword">uniform</span> PointLight pointLights[NR_POINT_LIGHTS];</span><br></pre></td></tr></table></figure><p>你可以看到，我们在GLSL中使用了<strong>预处理指令来定义了我们场景中点光源的数量</strong>。接着我们使用了这个<code>NR_POINT_LIGHTS</code>常量来创建了一个<code>PointLight</code><strong>结构体的数组</strong>。GLSL中的数组和C数组一样，可以使用一对方括号来创建。现在我们有<strong>四个待填充数据的PointLight结构体</strong>。</p><p>点光源函数的原型如下：</p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">vec3</span> CalcPointLight(PointLight light, <span class="type">vec3</span> normal, <span class="type">vec3</span> fragPos, <span class="type">vec3</span> viewDir);</span><br></pre></td></tr></table></figure><p>这个函数从参数中获取所需的所有数据，并返回一个代表该点光源对片段的颜色贡献的vec3。我们再一次聪明地从之前的教程中复制粘贴代码，完成了下面这样的函数：</p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">vec3</span> CalcPointLight(PointLight light, <span class="type">vec3</span> normal, <span class="type">vec3</span> fragPos, <span class="type">vec3</span> viewDir) &#123;</span><br><span class="line">    <span class="type">vec3</span> lightDir = <span class="built_in">normalize</span>(light.position - fragPos);</span><br><span class="line">    <span class="comment">// 漫反射着色</span></span><br><span class="line">    <span class="type">float</span> diff = <span class="built_in">max</span>(<span class="built_in">dot</span>(normal, lightDir), <span class="number">0.0</span>);</span><br><span class="line">    <span class="comment">// 镜面光着色</span></span><br><span class="line">    <span class="type">vec3</span> reflectDir = <span class="built_in">reflect</span>(-lightDir, normal);</span><br><span class="line">    <span class="type">float</span> spec = <span class="built_in">pow</span>(<span class="built_in">max</span>(<span class="built_in">dot</span>(viewDir, reflectDir), <span class="number">0.0</span>), material.shininess);</span><br><span class="line">    <span class="comment">// 衰减</span></span><br><span class="line">    <span class="type">float</span> <span class="built_in">distance</span>    = <span class="built_in">length</span>(light.position - fragPos);</span><br><span class="line">    <span class="type">float</span> attenuation = <span class="number">1.0</span> / (light.constant + light.linear * <span class="built_in">distance</span> + </span><br><span class="line">                 light.quadratic * (<span class="built_in">distance</span> * <span class="built_in">distance</span>));    </span><br><span class="line">    <span class="comment">// 合并结果</span></span><br><span class="line">    <span class="type">vec3</span> ambient  = light.ambient  * <span class="type">vec3</span>(<span class="built_in">texture</span>(material.diffuse, TexCoords));</span><br><span class="line">    <span class="type">vec3</span> diffuse  = light.diffuse  * diff * <span class="type">vec3</span>(<span class="built_in">texture</span>(material.diffuse, TexCoords));</span><br><span class="line">    <span class="type">vec3</span> specular = light.specular * spec * <span class="type">vec3</span>(<span class="built_in">texture</span>(material.specular, TexCoords));</span><br><span class="line">    <span class="keyword">return</span> attenuation * (ambient + diffuse + specular);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将这些功能抽象到这样一个函数中的优点是，我们<strong>能够不用重复的代码而很容易地计算多个点光源的光照了</strong>。在main函数中，我们<strong>只需要创建一个循环</strong>，遍历整个点光源数组，对每个点光源调用CalcPointLight就可以了。</p><h3 id="聚光-1"><a href="#聚光-1" class="headerlink" title="聚光"></a>聚光</h3><p>类似的：</p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">struct SpotLight &#123;</span><br><span class="line">    <span class="type">vec3</span> position;</span><br><span class="line">    <span class="type">vec3</span> direction;</span><br><span class="line">    <span class="type">float</span> cutOff;</span><br><span class="line">    <span class="type">float</span> outerCutOff;</span><br><span class="line"></span><br><span class="line">    <span class="type">float</span> constant;</span><br><span class="line">    <span class="type">float</span> linear;</span><br><span class="line">    <span class="type">float</span> quadratic;</span><br><span class="line"></span><br><span class="line">    <span class="type">vec3</span> ambient;</span><br><span class="line">    <span class="type">vec3</span> diffuse;</span><br><span class="line">    <span class="type">vec3</span> specular;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">uniform</span> SpotLight spotLight;</span><br></pre></td></tr></table></figure><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> CalcSpotLight(SpotLight light, <span class="type">vec3</span> normal, <span class="type">vec3</span> fragPos, <span class="type">vec3</span> viewDir) &#123;</span><br><span class="line">    <span class="type">vec3</span> lightDir = <span class="built_in">normalize</span>(light.position - fragPos);</span><br><span class="line">    <span class="type">float</span> theta = <span class="built_in">dot</span>(lightDir, <span class="built_in">normalize</span>(-light.direction));</span><br><span class="line">    <span class="type">float</span> epsilon = light.cutOff - light.outerCutOff;</span><br><span class="line">    <span class="type">float</span> intensity = <span class="built_in">clamp</span>((theta - light.outerCutOff) / epsilon, <span class="number">0.0</span>, <span class="number">1.0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 环境光</span></span><br><span class="line">    <span class="type">vec3</span> ambient = light.ambient * <span class="type">vec3</span>(<span class="built_in">texture</span>(material.diffuse, TexCoords));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 漫反射</span></span><br><span class="line">    <span class="type">float</span> diff = <span class="built_in">max</span>(<span class="built_in">dot</span>(norm, lightDir), <span class="number">0.0</span>);</span><br><span class="line">    <span class="type">vec3</span> diffuse = light.diffuse * diff * <span class="type">vec3</span>(<span class="built_in">texture</span>(material.diffuse, TexCoords));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 镜面光</span></span><br><span class="line">    <span class="type">vec3</span> viewDir = <span class="built_in">normalize</span>(viewPos - FragPos);</span><br><span class="line">    <span class="type">vec3</span> reflectDir = <span class="built_in">reflect</span>(-lightDir, norm);</span><br><span class="line">    <span class="type">float</span> spec = <span class="built_in">pow</span>(<span class="built_in">max</span>(<span class="built_in">dot</span>(viewDir, reflectDir), <span class="number">0.0</span>), material.shininess);</span><br><span class="line">    <span class="type">vec3</span> specular = light.specular * spec * <span class="type">vec3</span>(<span class="built_in">texture</span>(material.specular, TexCoords));</span><br><span class="line"></span><br><span class="line">    <span class="type">float</span> <span class="built_in">distance</span> = <span class="built_in">length</span>(light.position - FragPos);</span><br><span class="line">    <span class="type">float</span> attenuation = <span class="number">1.0</span> / (light.constant + light.linear * <span class="built_in">distance</span> + </span><br><span class="line">                light.quadratic * (<span class="built_in">distance</span> * <span class="built_in">distance</span>));</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> attenuation * (ambient + diffuse * intensity + specular * intensity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="合并结果"><a href="#合并结果" class="headerlink" title="合并结果"></a>合并结果</h3><p>现在我们已经定义了一个计算定向光的函数和一个计算点光源的函数了，我们可以将它们合并放到main函数中。</p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> main() &#123;</span><br><span class="line">    <span class="comment">// 属性</span></span><br><span class="line">    <span class="type">vec3</span> norm = <span class="built_in">normalize</span>(Normal);</span><br><span class="line">    <span class="type">vec3</span> viewDir = <span class="built_in">normalize</span>(viewPos - FragPos);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 第一阶段：定向光照</span></span><br><span class="line">    <span class="type">vec3</span> result = CalcDirLight(dirLight, norm, viewDir);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; NR_POINT_LIGHTS; i++) &#123;</span><br><span class="line">        result += CalcPointLight(pointLights[i], norm, FragPos, viewDir);</span><br><span class="line">    &#125;</span><br><span class="line">    result += CalcSpotLight(spotLight, norm, FragPos, viewDir);  </span><br><span class="line"></span><br><span class="line">    FragColor = <span class="type">vec4</span>(result, <span class="number">1.0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>每个光源类型都将它们的贡献加到了最终的输出颜色上，直到所有的光源都处理完了。<strong>最终的颜色包含了场景中所有光源的颜色影响所合并的结果</strong>。</p><p>设置定向光结构体的uniform应该非常熟悉了，<strong>但是你可能会在想我们该如何设置点光源的uniform值，因为点光源的uniform现在是一个PointLight的数组了</strong>。这并不是我们以前讨论过的话题。</p><p>很幸运的是，这并不是很复杂，<strong>设置一个结构体数组的uniform和设置一个结构体的uniform是很相似的</strong>，但是这一次在访问uniform位置的时候，我们需要<strong>定义对应的数组下标值</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lightingShader.setFloat(<span class="string">&quot;pointLights[0].constant&quot;</span>, <span class="number">1.0f</span>);</span><br></pre></td></tr></table></figure><p>在这里我们索引了pointLights数组中的第一个PointLight，并获取了constant变量的位置。但这也意味着不幸的是我们<strong>必须对这四个点光源手动设置uniform值，这让点光源本身就产生了28个uniform调用，非常冗长</strong>。你也可以尝试将这些抽象出去一点，定义一个点光源类，让它来为你设置uniform值，但最后你仍然要用这种方式设置所有光源的uniform值。</p><p>别忘了，<strong>我们还需要为每个点光源定义一个位置向量</strong>，所以我们让它们在场景中分散一点。我们会定义另一个<code>glm::vec3</code>数组来包含点光源的位置：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">glm::vec3 pointLightPositions[] = &#123;</span><br><span class="line">    glm::vec3( <span class="number">0.7f</span>,  <span class="number">0.2f</span>,  <span class="number">2.0f</span>),</span><br><span class="line">    glm::vec3( <span class="number">2.3f</span>, <span class="number">-3.3f</span>, <span class="number">-4.0f</span>),</span><br><span class="line">    glm::vec3(<span class="number">-4.0f</span>,  <span class="number">2.0f</span>, <span class="number">-12.0f</span>),</span><br><span class="line">    glm::vec3( <span class="number">0.0f</span>,  <span class="number">0.0f</span>, <span class="number">-3.0f</span>)</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>接下来我们从<code>pointLights</code>数组中索引对应的<code>PointLight</code>，将它的<code>position</code>值设置为刚刚定义的位置值数组中的其中一个。同时我们还要保证<strong>现在绘制的是四个灯立方体而不是仅仅一个</strong>。只要对每个灯物体创建一个不同的模型矩阵就可以了，和我们之前对箱子的处理类似。</p><p>如果你还使用了手电筒的话，所有光源组合的效果将看起来和下图差不多：</p><div align="center"><p><img src="/images/learnopengl-c2-f31.jpg"></p></div><p>你可以看到，很显然天空中有一个全局照明（像一个太阳），我们有四个光源分散在场景中，以及玩家视角的手电筒。看起来是不是非常不错？</p><p>上面图片中的所有光源都是使用上一节中所使用的默认属性，但如果你愿意实验这些数值的话，你能够得到很多有意思的结果。<strong>艺术家和关卡设计师通常都在编辑器中不断的调整这些光照参数，保证光照与环境相匹配。</strong>在我们刚刚创建的简单光照环境中，你可以简单地调整一下光源的属性，创建很多有意思的视觉效果：</p><p>我们也改变了清屏的颜色来更好地反应光照。你可以看到，只需要简单地调整一些光照参数，你就能创建完全不同的氛围。</p><div align="center"><p><img src="/images/learnopengl-c2-f32.jpg"></p></div><h2 id="复习"><a href="#复习" class="headerlink" title="复习"></a>复习</h2><p>总的来说我们在学习光照教程的时候，<strong>关于OpenGL本身并没有什么新东西</strong>，除了想访问uniform数组这样细枝末节的知识。目前为止的所有教程都是关于使用一些技巧或者公式来操作着色器，达到真实的光照效果。<strong>这再一次想你展示了着色器的威力。着色器是非常灵活的，你也亲眼见证了我们仅仅使用一些3D向量和可配置的变量就能够创造出惊人的图像这一点</strong>。</p><p>在前面的几个教程中，你学习了<strong>颜色、冯氏光照模型</strong>（包括环境光照、漫反射光照和镜面光照）、<strong>物体的材质、可配置的光照属性、漫反射和镜面光贴图、不同种类的光</strong>，并且学习了怎样将所有所学知识融会贯通，合并到一个程序当中。记得去实验一下不同的光照、材质颜色、光照属性，并且试着利用你无穷的创造力创建自己的环境。</p><p>在下一节当中，我们在我们的场景当中加入更高级的形状，这些形状将会在我们之前讨论过的光照模型中非常好看。</p><p>词汇表：</p><ul><li><strong>颜色向量</strong>(Color Vector)：一个通过红绿蓝(RGB)分量的组合描绘大部分真实颜色的向量。<strong>一个物体的颜色实际上是该物体所不能吸收的反射颜色分量</strong>。</li><li><strong>冯氏光照模型</strong>(Phong Lighting Model)：一个通过计算<strong>环境光，漫反射，和镜面光分量的值</strong>来估计真实光照的模型。</li><li><strong>环境光照</strong>(Ambient Lighting)：通过给每个没有被光照的物体很小的亮度，使其不是完全黑暗的，从而对全局光照进行估计。</li><li><strong>漫反射着色</strong>(Diffuse Shading)：一个<strong>顶点/片段与光线方向越接近，光照会越强</strong>。使用了法向量来计算角度。</li><li><strong>法向量</strong>(Normal Vector)：一个垂直于平面的单位向量。</li><li><strong>法线矩阵</strong>(Normal Matrix)：一个3x3矩阵，或者说是没有平移的模型（或者模型-观察）矩阵。它也被以某种方式修改（逆转置），<strong>从而在应用非统一缩放时，保持法向量朝向正确的方向</strong>。否则法向量会在使用非统一缩放时被扭曲。</li><li><strong>镜面光照</strong>(Specular Lighting)：当<strong>观察者视线靠近光源在表面的反射线时会显示的镜面高光</strong>。镜面光照是由观察者的方向，光源的方向和设定高光分散量的反光度值三个量共同决定的。</li><li><strong>冯氏着色</strong>(Phong Shading)：冯氏光照模型应用在片段着色器。</li><li><strong>Gouraud着色</strong>(Gouraud shading)：冯氏光照模型应用在顶点着色器上。在使用很少数量的顶点时会产生明显的瑕疵。会得到效率提升但是损失了视觉质量。</li><li><strong>GLSL结构体</strong>(GLSL struct)：一个类似于C的结构体，用作着色器变量的容器。大部分时间用来管理输入/输出/uniform。</li><li><strong>材质</strong>(Material)：一个<strong>物体反射的环境光，漫反射，镜面光颜色</strong>。这些东西设定了物体所拥有的颜色。</li><li><strong>光照属性</strong>(Light(properties))：一个<strong>光的环境光，漫反射，镜面光的强度</strong>。可以使用任何颜色值，对每一个冯氏分量(Phong Component)定义光源发出的颜色/强度。</li><li><strong>漫反射贴图</strong>(Diffuse Map)：一个设定了每个片段中<strong>漫反射颜色的纹理贴图</strong>。</li><li><strong>镜面光贴图</strong>(Specular Map)：一个设定了每一个片段的<strong>镜面光强度/颜色的纹理贴图</strong>。仅在物体的特定区域显示镜面高光。</li><li><strong>定向光</strong>(Directional Light)：只有一个方向的光源。它被建模为不管距离有多长所有光束都是平行而且其方向向量在整个场景中保持不变。</li><li><strong>点光源</strong>(Point Light)：一个在场景中有位置的，光线逐渐衰减的光源。</li><li><strong>衰减</strong>(Attenuation)：光随着距离减少强度的过程，通常使用在<strong>点光源和聚光下</strong>。</li><li><strong>聚光</strong>(Spotlight)：一个被定义为在某一个方向上的锥形的光源。</li><li><strong>手电筒</strong>(Flashlight)：一个摆放在观察者视角的聚光。</li><li><strong>GLSL uniform数组</strong>(GLSL Uniform Array)：一个uniform值数组。它的工作原理和C语言数组大致一样，<strong>只是不能动态分配内存</strong>。</li></ul>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;上帝说，要有光，于是便有了光。&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="LearnOpenGL" scheme="https://yumi-cn.github.io/categories/LearnOpenGL/"/>
    
    
    <category term="笔记" scheme="https://yumi-cn.github.io/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>《LeetCode》精选200题计划</title>
    <link href="https://yumi-cn.github.io/2021/01/24/leetcode-200-select/"/>
    <id>https://yumi-cn.github.io/2021/01/24/leetcode-200-select/</id>
    <published>2021-01-24T01:26:52.000Z</published>
    <updated>2021-01-24T02:02:23.459Z</updated>
    
    <content type="html"><![CDATA[<p>之后一个月(1.25~2.28)准备刷一下LeetCode的精选200题，题目大部分都是中等或者困难。</p><p>到时候会按照标签来刷，也会按标签总结这类题目的一些规律。</p><div align="center"><p><img src="/images/leetcode-200-select.jpg"></p></div>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;之后一个月(1.25~2.28)准备刷一下LeetCode的精选200题，题目大部分都是中等或者困难。&lt;/p&gt;
&lt;p&gt;到时候会按照标签来刷，也会按标签总结这类题目的一些规律。&lt;/p&gt;
&lt;div align=&quot;center&quot;&gt;

&lt;p&gt;&lt;img src=&quot;/images/le</summary>
      
    
    
    
    <category term="计划-Flags" scheme="https://yumi-cn.github.io/categories/%E8%AE%A1%E5%88%92-Flags/"/>
    
    
  </entry>
  
  <entry>
    <title>《LearnOpenGL》入门 笔记</title>
    <link href="https://yumi-cn.github.io/2021/01/23/learnopengl-c1/"/>
    <id>https://yumi-cn.github.io/2021/01/23/learnopengl-c1/</id>
    <published>2021-01-23T11:46:18.000Z</published>
    <updated>2021-01-23T11:46:37.961Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>Hello OpenGL!</p></blockquote><a id="more"></a><blockquote><p>笔记摘录源地址：<a href="https://learnopengl-cn.github.io/">LearnOpenGL CN</a></p></blockquote><h2 id="OpenGL"><a href="#OpenGL" class="headerlink" title="OpenGL"></a>OpenGL</h2><h2 id="创建窗口"><a href="#创建窗口" class="headerlink" title="创建窗口"></a>创建窗口</h2><h2 id="你好，窗口"><a href="#你好，窗口" class="headerlink" title="你好，窗口"></a>你好，窗口</h2><div align="center"><p><img src="/images/learnopengl-c1-f0.jpg"></p></div><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="comment">// GLAD must be include before GLFW</span></span><br><span class="line"><span class="comment">// GL/GLES/EGL/GLX/WGL Loader-Generator based on the official specs.</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;glad/glad.h&gt; </span></span></span><br><span class="line"><span class="comment">// GLFW is an Open Source, multi-platform library for OpenGL, OpenGL ES and Vulkan application development.</span></span><br><span class="line"><span class="comment">// It provides a simple, platform-independent API for creating windows, contexts and surfaces, reading input, handling events, etc.</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;GLFW/glfw3.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">framebuffer_size_callback</span><span class="params">(GLFWwindow* window, <span class="keyword">int</span> width, <span class="keyword">int</span> height)</span> </span>&#123;</span><br><span class="line">    glViewport(<span class="number">0</span>, <span class="number">0</span>, width, height);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 望能够在GLFW中实现一些输入控制，可以通过使用GLFW的几个输入函数来完成</span></span><br><span class="line"><span class="comment">// 使用GLFW的glfwGetKey函数，它需要一个窗口以及一个按键作为输入</span></span><br><span class="line"><span class="comment">// 这个函数将会返回这个按键是否正在被按下</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">process_input</span><span class="params">(GLFWwindow *window)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 检查用户是否按下了返回键(Esc)，如果没有按下，glfwGetKey将会返回GLFW_RELEASE</span></span><br><span class="line">    <span class="keyword">if</span> (glfwGetKey(window, GLFW_KEY_ESCAPE) == GLFW_PRESS) &#123;</span><br><span class="line">        glfwSetWindowShouldClose(window, <span class="literal">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    glfwInit();</span><br><span class="line">    glfwWindowHint(GLFW_CONTEXT_VERSION_MAJOR, <span class="number">3</span>);</span><br><span class="line">    glfwWindowHint(GLFW_CONTEXT_VERSION_MINOR, <span class="number">3</span>);</span><br><span class="line">    glfwWindowHint(GLFW_OPENGL_PROFILE, GLFW_OPENGL_CORE_PROFILE);</span><br><span class="line">    <span class="comment">// glfwWindowHint(GLFW_OPENGL_FORWARD_COMPAT, GL_TRUE); // for max os x</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// glfwCreateWindow(width, height, title, ..., ...)</span></span><br><span class="line">    GLFWwindow* window = glfwCreateWindow(<span class="number">800</span>, <span class="number">600</span>, <span class="string">&quot;LearnOpenGL&quot;</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (window == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Failed to create GLFW window&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">        glfwTerminate();</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    glfwMakeContextCurrent(window);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// GLAD是用来管理OpenGL的函数指针的</span></span><br><span class="line">    <span class="comment">// 所以在调用任何OpenGL的函数之前我们需要初始化GLAD</span></span><br><span class="line">    <span class="comment">// 给GLAD传入了用来加载系统相关的OpenGL函数指针地址的函数</span></span><br><span class="line">    <span class="comment">// GLFW给我们的是glfwGetProcAddress</span></span><br><span class="line">    <span class="comment">// 它根据我们编译的系统定义了正确的函数</span></span><br><span class="line">    <span class="keyword">if</span> (!gladLoadGLLoader((GLADloadproc)glfwGetProcAddress)) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Failed to initialize GLAD&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 告诉OpenGL渲染窗口的尺寸大小, 视口 Viewport</span></span><br><span class="line">    <span class="comment">// 窗口左下角的位置，宽度，高度</span></span><br><span class="line">    glViewport(<span class="number">0</span>, <span class="number">0</span>, <span class="number">800</span>, <span class="number">600</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当用户改变窗口的大小的时候，视口也应该被调整</span></span><br><span class="line">    <span class="comment">// 可以对窗口注册一个回调函数(Callback Function)</span></span><br><span class="line">    <span class="comment">// 它会在每次窗口大小被调整的时候被调用</span></span><br><span class="line">    <span class="comment">// void framebuffer_size_callback(GLFWwindow* window, int width, int height);</span></span><br><span class="line">    <span class="comment">// 需要注册这个函数，告诉GLFW我们希望每当窗口调整大小的时候调用这个函数</span></span><br><span class="line">    glfwSetFramebufferSizeCallback(window, framebuffer_size_callback);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Render Loop</span></span><br><span class="line">    <span class="comment">// glfwWindowShouldClose函数在我们每次循环的开始前检查一次GLFW是否被要求退出</span></span><br><span class="line">    <span class="comment">// 如果是的话该函数返回true然后渲染循环便结束了，之后为我们就可以关闭应用程序了</span></span><br><span class="line">    <span class="keyword">while</span> (!glfwWindowShouldClose(window)) &#123;</span><br><span class="line">        <span class="comment">// 检测用户输入</span></span><br><span class="line">        process_input(window);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 渲染指令</span></span><br><span class="line">        <span class="comment">// 使用一个自定义的颜色清空屏幕</span></span><br><span class="line">        <span class="comment">// 调用了glClearColor来设置清空屏幕所用的颜色</span></span><br><span class="line">        glClearColor(<span class="number">0.2f</span>, <span class="number">0.3f</span>, <span class="number">0.3f</span>, <span class="number">1.0f</span>); <span class="comment">// 状态设置函数</span></span><br><span class="line">        <span class="comment">// 调用glClear函数来清空屏幕的颜色缓冲，它接受一个缓冲位(Buffer Bit)来指定要清空的缓冲</span></span><br><span class="line">        <span class="comment">// 可能的缓冲位有GL_COLOR_BUFFER_BIT，GL_DEPTH_BUFFER_BIT和GL_STENCIL_BUFFER_BIT</span></span><br><span class="line">        glClear(GL_COLOR_BUFFER_BIT); <span class="comment">// 状态使用函数</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// glfwSwapBuffers函数会交换颜色缓冲</span></span><br><span class="line">        <span class="comment">// 它是一个储存着GLFW窗口每一个像素颜色值的大缓冲</span></span><br><span class="line">        <span class="comment">// 它在这一迭代中被用来绘制，并且将会作为输出显示在屏幕上。</span></span><br><span class="line">        glfwSwapBuffers(window);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// glfwPollEvents函数检查有没有触发什么事件</span></span><br><span class="line">        <span class="comment">// 比如键盘输入、鼠标移动、更新窗口状态等</span></span><br><span class="line">        <span class="comment">// 并调用对应的回调函数（可以通过回调方法手动设置）</span></span><br><span class="line">        glfwPollEvents();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当渲染循环结束后我们需要正确释放/删除之前的分配的所有资源</span></span><br><span class="line">    <span class="comment">// 在main函数的最后调用glfwTerminate函数来完成</span></span><br><span class="line">    glfwTerminate();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="你好，三角形"><a href="#你好，三角形" class="headerlink" title="你好，三角形"></a>你好，三角形</h2><ul><li>顶点数组对象：Vertex Array Object，VAO</li><li>顶点缓冲对象：Vertex Buffer Object，VBO</li><li>索引缓冲对象：Element Buffer Object，EBO或Index Buffer Object，IBO</li></ul><p>3D坐标转为2D坐标的处理过程是由OpenGL的图形渲染管线（Graphics Pipeline，大多译为管线，实际上指的是一堆原始图形数据途经一个输送管道，期间经过各种变化处理最终出现在屏幕的过程）管理的。</p><p>图形渲染管线可以被划分为两个主要部分：</p><ul><li>第一部分把你的3D坐标转换为2D坐标；</li><li>第二部分是把2D坐标转变为实际的有颜色的像素。</li></ul><p>2D坐标和像素也是不同的，2D坐标精确表示（通常是浮点数的形式）一个点在2D空间中的位置，而2D像素是这个点的近似值，2D像素受到你的屏幕/窗口分辨率的限制。</p><p>图形渲染管线可以被划分为几个阶段，每个阶段将会把前一个阶段的输出作为输入。所有这些阶段都是高度专门化的（它们都有一个特定的函数），并且很容易并行执行。正是由于它们具有并行执行的特性，当今大多数显卡都有成千上万的小处理核心，它们在GPU上为每一个（渲染管线）阶段运行各自的小程序，从而在图形渲染管线中快速处理你的数据。这些小程序叫做着色器(Shader)。</p><p>有些着色器允许开发者自己配置，这就允许我们用自己写的着色器来替换默认的。这样我们就可以更细致地控制图形渲染管线中的特定部分了，而且因为它们运行在GPU上，所以它们可以给我们节约宝贵的CPU时间。OpenGL着色器是用OpenGL着色器语言(OpenGL Shading Language, GLSL)写成的，在下一节中我们再花更多时间研究它。</p><div align="center"><p><img src="/images/learnopengl-c1-f1.jpg" alt="蓝色部分代表可以注入自定义的着色器"></p></div><p>首先，我们以数组的形式传递3个3D坐标作为图形渲染管线的输入，用来表示一个三角形，这个数组叫做顶点数据(Vertex Data)；顶点数据是一系列顶点的集合。一个顶点(Vertex)是一个3D坐标的数据的集合。而顶点数据是用顶点属性(Vertex Attribute)表示的，它可以包含任何我们想用的数据。</p><p>为了让OpenGL知道我们的坐标和颜色值构成的到底是什么，OpenGL需要你去指定这些数据所表示的渲染类型。是希望把这些数据渲染成一系列的点？一系列的三角形？还是仅仅是一个长长的线？做出的这些提示叫做图元(Primitive)，任何一个绘制指令的调用都将把图元传递给OpenGL。这是其中的几个：GL_POINTS、GL_TRIANGLES、GL_LINE_STRIP。</p><p>图形渲染管线的第一个部分是<strong>顶点着色器</strong>(Vertex Shader)，它把一个单独的顶点作为输入。顶点着色器主要的目的是把3D坐标转为另一种3D坐标（后面会解释），同时顶点着色器允许我们对顶点属性进行一些基本处理。</p><p><strong>图元装配</strong>(Primitive Assembly)阶段将顶点着色器输出的所有顶点作为输入（如果是GL_POINTS，那么就是一个顶点），并所有的点装配成指定图元的形状。</p><p>图元装配阶段的输出会传递给<strong>几何着色器</strong>(Geometry Shader)。几何着色器把图元形式的一系列顶点的集合作为输入，它可以通过产生新顶点构造出新的（或是其它的）图元来生成其他形状。</p><p>几何着色器的输出会被传入<strong>光栅化阶段</strong>(Rasterization Stage)，这里它会把图元映射为最终屏幕上相应的像素，生成供片段着色器(Fragment Shader)使用的片段(Fragment)。在片段着色器运行之前会<strong>执行裁切</strong>(Clipping)。裁切会丢弃超出你的视图以外的所有像素，用来提升执行效率。</p><p>OpenGL中的一个片段(Fragment)是OpenGL渲染一个像素所需的所有数据。</p><p><strong>片段着色器</strong>(Fragment Shader or Pixel Shader)的主要目的是计算一个像素的最终颜色，这也是所有OpenGL高级效果产生的地方。通常，<strong>片段着色器包含3D场景的数据（比如光照、阴影、光的颜色等等）</strong>，这些数据可以被用来计算最终像素的颜色。</p><p>在所有对应颜色值确定以后，最终的对象将会被传到最后一个阶段，我们叫做<strong>Alpha测试和混合</strong>(Blending)阶段。这个阶段检测片段的对应的<strong>深度</strong>（和模板(Stencil)）值（后面会讲），用它们来判断这个像素是其它物体的前面还是后面，决定是否应该丢弃。这个阶段也会检查<strong>alpha值</strong>（alpha值定义了一个物体的透明度）并对物体进行<strong>混合</strong>(Blend)。所以，即使在片段着色器中计算出来了一个像素输出的颜色，在渲染多个三角形的时候最后的像素颜色也可能完全不同。</p><p>可以看到，图形渲染管线非常复杂，它包含很多可配置的部分。<strong>然而，对于大多数场合</strong>，我们只需要配置<strong>顶点和片段着色器</strong>就行了，<strong>几何着色器是可选的</strong>，通常使用它默认的着色器就行了。</p><p>在<strong>现代OpenGL中</strong>，我们必须定义<strong>至少一个顶点着色器和一个片段着色器</strong>（因为<strong>GPU中没有默认的顶点/片段着色器</strong>）。出于这个原因，刚开始学习现代OpenGL的时候可能会非常困难，因为在你能够渲染自己的第一个三角形之前已经需要了解一大堆知识了。</p><h3 id="顶点输入"><a href="#顶点输入" class="headerlink" title="顶点输入"></a>顶点输入</h3><p>开始绘制图形之前，我们必须先给OpenGL输入一些顶点数据。OpenGL是一个3D图形库，所以我们在OpenGL中指定的所有坐标都是3D坐标（x、y和z）。OpenGL仅当3D坐标在3个轴（x、y和z）上都为-1.0到1.0的范围内时才处理它。所有在所谓的<strong>标准化设备坐标</strong>(Normalized Device Coordinates)范围内的坐标才会最终呈现在屏幕上（在这个范围<strong>以外的坐标都不会显示</strong>）。</p><p>由于我们希望渲染一个三角形，我们一共要指定<strong>三个顶点</strong>，每个顶点都有一个3D位置。我们会将它们以标准化设备坐标的形式（OpenGL的可见区域）定义为一个float数组。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">float</span> vertices[] = &#123;</span><br><span class="line">    <span class="number">-0.5f</span>, <span class="number">-0.5f</span>, <span class="number">0.0f</span>,</span><br><span class="line">     <span class="number">0.5f</span>, <span class="number">-0.5f</span>, <span class="number">0.0f</span>,</span><br><span class="line">     <span class="number">0.0f</span>,  <span class="number">0.5f</span>, <span class="number">0.0f</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>由于OpenGL是在3D空间中工作的，而我们渲染的是一个2D三角形，我们将它顶点的z坐标设置为0.0。这样子的话三角形每一点的深度(Depth)都是一样的，从而使它看上去像是2D的。</p><p><strong>标准化设备坐标</strong>(Normalized Device Coordinates, NDC)：一旦你的顶点坐标已经在顶点着色器中处理过，它们就应该是标准化设备坐标了，标准化设备坐标是一个x、y和z值在-1.0到1.0的一小段空间。任何落在范围外的坐标都会被丢弃/裁剪，不会显示在你的屏幕上。下面你会看到我们定义的在标准化设备坐标中的三角形(忽略z轴)：</p><div align="center"><p><img src="/images/learnopengl-c1-f2.jpg"></p></div><p>与通常的屏幕坐标不同，<strong>y轴正方向为向上</strong>，(0, 0)坐标是这个图像的中心，而不是左上角。最终你希望所有(变换过的)坐标都在这个坐标空间中，否则它们就不可见了。</p><p>你的标准化设备坐标接着会变换为<strong>屏幕空间坐标</strong>(Screen-space Coordinates)，这是使用你通过glViewport函数提供的数据，进行<strong>视口变换</strong>(Viewport Transform)完成的。所得的屏幕空间坐标又会被变换为片段输入到片段着色器中。</p><p>定义这样的顶点数据以后，我们会把它作为输入发送给图形渲染管线的第一个处理阶段：<strong>顶点着色器</strong>。它会在GPU上<strong>创建内存用于储存我们的顶点数据</strong>，还要配置OpenGL如何解释这些内存，并且指定其如何发送给显卡。顶点着色器接着会<strong>处理我们在内存中指定数量的顶点</strong>。</p><p>我们通过<strong>顶点缓冲对象</strong>(Vertex Buffer Objects, VBO)管理这个内存，它会在<strong>GPU内存</strong>（通常被称为显存）中储存大量顶点。使用这些<strong>缓冲对象</strong>的好处是我们可以<strong>一次性的发送一大批数据到显卡上</strong>，而不是每个顶点发送一次。从CPU把数据发送到显卡相对较慢，所以只要可能我们都要尝试<strong>尽量一次性发送尽可能多的数据</strong>。当数据发送至显卡的内存中后，顶点着色器几乎能立即访问顶点，这是个非常快的过程。</p><p><strong>顶点缓冲对象</strong>是我们在OpenGL教程中第一个出现的OpenGL对象。就像OpenGL中的其它对象一样，这个缓冲有一个独一无二的ID，所以我们可以使用glGenBuffers函数和一个缓冲ID生成一个VBO对象：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> VBO;</span><br><span class="line">glGenBuffers(<span class="number">1</span>, &amp;VBO);</span><br></pre></td></tr></table></figure><p>OpenGL有很多缓冲对象类型，<strong>顶点缓冲对象</strong>的缓冲类型是<code>GL_ARRAY_BUFFER</code>。OpenGL允许我们<strong>同时绑定多个缓冲</strong>，只要它们是不同的缓冲类型。我们可以使用glBindBuffer函数把<strong>新创建的缓冲</strong>绑定到GL_ARRAY_BUFFER目标上：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">glBindBuffer(GL_ARRAY_BUFFER, VBO);</span><br></pre></td></tr></table></figure><p>从这一刻起，我们使用的任何（在GL_ARRAY_BUFFER目标上的）<strong>缓冲调用</strong>都会用来<strong>配置当前绑定的缓冲</strong>(VBO)。然后我们可以调用glBufferData函数，它会把之前定义的<strong>顶点数据复制到缓冲的内存中</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">glBufferData(GL_ARRAY_BUFFER, <span class="keyword">sizeof</span>(vertices), vertices, GL_STATIC_DRAW);</span><br></pre></td></tr></table></figure><p>glBufferData是一个专门用来把<strong>用户定义的数据</strong>复制到<strong>当前绑定缓冲</strong>的函数。</p><ul><li><strong>第一个参数</strong>是目标缓冲的<strong>类型</strong>：顶点缓冲对象当前绑定到<strong>GL_ARRAY_BUFFER目标上</strong>；</li><li><strong>第二个参数</strong>指定传输数据的大小(<strong>以字节为单位</strong>)；用一个简单的sizeof计算出顶点数据大小就行；</li><li><strong>第三个参数</strong>是我们希望发送的实际数据；</li><li><strong>第四个参数</strong>指定了我们希望显卡<strong>如何管理给定的数据</strong>。它有三种形式：<ul><li>GL_STATIC_DRAW：数据不会或几乎不会改变；</li><li>GL_DYNAMIC_DRAW：数据会被改变很多；</li><li>GL_STREAM_DRAW：数据每次绘制时都会改变。</li><li>三角形的位置数据不会改变，每次渲染调用时都保持原样，所以它的使用类型最好是GL_STATIC_DRAW；</li><li>如果，比如说一个缓冲中的数据将频繁被改变，那么使用的类型就是GL_DYNAMIC_DRAW或GL_STREAM_DRAW，这样就能确保<strong>显卡把数据放在能够高速写入的内存部分</strong>。</li></ul></li></ul><p>现在我们已经把<strong>顶点数据储存在显卡的内存中</strong>，用<strong>VBO</strong>这个顶点缓冲对象管理。下面我们会创建一个<strong>顶点和片段着色器</strong>来真正处理这些数据。</p><h3 id="顶点着色器-Vertex-Shader"><a href="#顶点着色器-Vertex-Shader" class="headerlink" title="顶点着色器 Vertex Shader"></a>顶点着色器 Vertex Shader</h3><p>我们需要做的第一件事是用<strong>着色器语言GLSL</strong>(OpenGL Shading Language)编写顶点着色器，然后<strong>编译这个着色器</strong>，这样我们就可以在程序中使用它了。下面你会看到一个非常基础的GLSL顶点着色器的源代码：</p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#version 330 core</span></span><br><span class="line"><span class="keyword">layout</span> (<span class="keyword">location</span> = <span class="number">0</span>) <span class="keyword">in</span> <span class="type">vec3</span> aPos;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> main() &#123;</span><br><span class="line">    <span class="built_in">gl_Position</span> = <span class="type">vec4</span>(aPos.x, aPos.y, aPos.z, <span class="number">1.0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>GLSL看起来很像C语言。每个着色器都起始于一个版本声明。OpenGL 3.3以及和更高版本中，<strong>GLSL版本号和OpenGL的版本是匹配的</strong>（比如说GLSL 420版本对应于OpenGL 4.2）。我们同样明确表示我们会使用核心模式。</p><p>下一步，使用<code>in</code>关键字，在顶点着色器中声明<strong>所有的输入顶点属性</strong>(Input Vertex Attribute)。现在我们只关心<strong>位置</strong>(Position)数据，所以我们只需要<strong>一个顶点属性</strong>。GLSL有一个<strong>向量数据类型</strong>，它包含1到4个float分量，包含的数量可以从它的后缀数字看出来。由于每个顶点都有<strong>一个3D坐标</strong>，我们就创建一个vec3输入变量aPos。我们同样也通过<code>layout (location = 0)</code>设定了输入变量的位置值(Location)你后面会看到为什么我们会需要这个位置值。</p><p><strong>向量</strong>(Vector)：在GLSL中一个向量有最多4个分量，每个分量值都代表空间中的一个坐标，它们可以通过<code>vec.x、vec.y、vec.z</code>和<code>vec.w</code>来获取。注意<code>vec.w</code>分量不是用作表达空间中的位置的（我们处理的是3D不是4D），而是用在所谓<strong>透视除法</strong>(Perspective Division)上。</p><p>为了设置顶点着色器的输出，我们必须把<strong>位置数据赋值</strong>给预定义的<strong>gl_Position</strong>变量，它在幕后是vec4类型的。在main函数的最后，gl_Position设置的值会成为该顶点着色器的输出。</p><p>当前这个顶点着色器可能是我们能想到的最简单的顶点着色器了，因为我们<strong>对输入数据什么都没有处理就把它传到着色器的输出了</strong>。在真实的程序里<strong>输入数据通常都不是标准化设备坐标</strong>，所以我们首先必须先把它们转换至OpenGL的可视区域内。</p><h3 id="编译着色器"><a href="#编译着色器" class="headerlink" title="编译着色器"></a>编译着色器</h3><p>上面写的顶点着色器源码存储在一个C字符串中，为了能让OpenGL能使用它，我们必须在运行时动态编译它的源码。</p><p>我们首先要做的是<strong>创建一个着色器对象</strong>，注意还是用<strong>ID来引用的</strong>。所以我们储存这个顶点着色器为<code>unsigned int</code>，然后用glCreateShader创建这个着色器：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> vertexShader;</span><br><span class="line">vertexShader = glCreateShader(GL_VERTEX_SHADER);</span><br></pre></td></tr></table></figure><p>我们把需要创建的着色器类型以参数形式提供给<code>glCreateShader</code>。由于我们正在创建一个顶点着色器，传递的参数是<code>GL_VERTEX_SHADER</code>。</p><p>下一步我们把这个着色器源码附加到着色器对象上，然后编译它：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">glShaderSource(vertexShader, <span class="number">1</span>, &amp;vertexShaderSource, <span class="literal">NULL</span>);</span><br><span class="line">glCompileShader(vertexShader);</span><br></pre></td></tr></table></figure><p><code>glShaderSource</code>函数：</p><ul><li>把要<strong>编译的着色器对象</strong>作为第一个参数；</li><li>第二参数指定了传递的<strong>源码字符串数量</strong>，这里<strong>只有一个</strong>；</li><li>第三个参数是<strong>顶点着色器真正的源码</strong>；</li><li>第四个参数我们先设置为NULL。</li></ul><p>检测编译时错误可以通过以下代码来实现：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>  success;</span><br><span class="line"><span class="keyword">char</span> infoLog[<span class="number">512</span>];</span><br><span class="line">glGetShaderiv(vertexShader, GL_COMPILE_STATUS, &amp;success);</span><br></pre></td></tr></table></figure><p>首先我们定义一个<strong>整型变量来表示是否成功编译</strong>，还定义了一个储存错误消息（如果有的话）的容器。然后我们用<code>glGetShaderiv</code>检查是否编译成功。<strong>如果编译失败</strong>，我们会用<code>glGetShaderInfoLog</code>获取错误消息，然后打印它。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(!success) &#123;</span><br><span class="line">    glGetShaderInfoLog(vertexShader, <span class="number">512</span>, <span class="literal">NULL</span>, infoLog);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;ERROR::SHADER::VERTEX::COMPILATION_FAILED\n&quot;</span> &lt;&lt; infoLog &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果编译的时候没有检测到任何错误，顶点着色器就被编译成功了。</p><h3 id="片段着色器"><a href="#片段着色器" class="headerlink" title="片段着色器"></a>片段着色器</h3><p>片段着色器(Fragment Shader)是第二个也是最后一个我们打算创建的，用于渲染三角形的着色器。段着色器所做的是计算像素最后的颜色输出。为了让事情更简单，我们的片段着色器将会一直输出橘黄色(1.0f, 0.5f, 0.2f)。</p><p>在计算机图形中颜色被表示为有<strong>4个元素的数组</strong>：红色(R)、绿色(G)、蓝色(B)和alpha(透明度)分量(A)，通常缩写为RGBA。当在OpenGL或GLSL中定义一个颜色的时候，我们把颜色每个分量的强度设置在0.0到1.0之间。比如说我们设置红为1.0f，绿为1.0f，我们会得到两个颜色的混合色，即黄色。这三种颜色分量的不同调配可以生成超过1600万种不同的颜色！</p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#version 330 core</span></span><br><span class="line"><span class="keyword">out</span> <span class="type">vec4</span> FragColor;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> main() &#123;</span><br><span class="line">    FragColor = <span class="type">vec4</span>(<span class="number">1.0</span>f, <span class="number">0.5</span>f, <span class="number">0.2</span>f, <span class="number">1.0</span>f);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>片段着色器只需要一个输出变量，这个变量是一个4分量向量</strong>，它表示的是最终的输出颜色，我们应该自己将其计算出来。我们可以用<code>out</code>关键字<strong>声明输出变量</strong>，这里我们命名为<code>FragColor</code>。下面，我们将一个<code>alpha</code>值为<code>1.0</code>(1.0代表完全不透明)的橘黄色的vec4赋值给颜色输出。</p><p><strong>编译片段着色器</strong>的过程与顶点着色器类似，只不过我们使用<code>GL_FRAGMENT_SHADER</code>常量作为着色器类型：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> fragmentShader;</span><br><span class="line">fragmentShader = glCreateShader(GL_FRAGMENT_SHADER);</span><br><span class="line">glShaderSource(fragmentShader, <span class="number">1</span>, &amp;fragmentShaderSource, <span class="literal">NULL</span>);</span><br><span class="line">glCompileShader(fragmentShader);</span><br></pre></td></tr></table></figure><p>两个着色器现在都编译了，剩下的事情是把<strong>两个着色器对象链接</strong>到<strong>一个用来渲染的着色器程序</strong>(Shader Program)中。</p><h3 id="着色器程序"><a href="#着色器程序" class="headerlink" title="着色器程序"></a>着色器程序</h3><p><strong>着色器程序对象</strong>(Shader Program Object)是<strong>多个着色器合并之后并最终链接完成的版本</strong>。如果要使用刚才编译的着色器（顶点、片段），我们必须把它们<strong>链接</strong>(Link)为一个着色器程序对象，然后在<strong>渲染对象的时候激活这个着色器程序</strong>。<strong>已激活</strong>着色器程序的着色器将在我们发送<strong>渲染调用</strong>(draw call)的时候被使用。</p><p>当链接着色器至一个程序的时候，它会把每个着色器的输出链接到下个着色器的输入。当<strong>输出和输入不匹配的时候，你会得到一个连接错误</strong>。</p><p>创建一个程序对象：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> shaderProgram;</span><br><span class="line">shaderProgram = glCreateProgram();</span><br></pre></td></tr></table></figure><p>glCreateProgram函数创建一个程序，<strong>并返回新创建程序对象的ID引用</strong>。现在我们需要把之前编译的着色器附加(glAttachShader)到程序对象上，然后用<code>glLinkProgram</code>链接它们：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">glAttachShader(shaderProgram, vertexShader);</span><br><span class="line">glAttachShader(shaderProgram, fragmentShader);</span><br><span class="line">glLinkProgram(shaderProgram);</span><br></pre></td></tr></table></figure><p>代码应该很清楚，我们把着色器附加到了程序上，然后用glLinkProgram链接。</p><p>就像着色器的编译一样，我们也可以<strong>检测链接着色器程序是否失败</strong>，并获取相应的日志。与上面不同，我们不会调用glGetShaderiv和glGetShaderInfoLog，现在我们使用：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>  success;</span><br><span class="line"><span class="keyword">char</span> infoLog[<span class="number">512</span>];</span><br><span class="line">glGetProgramiv(shaderProgram, GL_LINK_STATUS, &amp;success);</span><br><span class="line"><span class="keyword">if</span>(!success) &#123;</span><br><span class="line">    glGetProgramInfoLog(shaderProgram, <span class="number">512</span>, <span class="literal">NULL</span>, infoLog);</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>得到的结果就是一个程序对象，我们可以调<code>用glUseProgram</code>函数，用刚创建的程序对象作为它的参数，以<strong>激活</strong>这个程序对象：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">glUseProgram(shaderProgram);</span><br></pre></td></tr></table></figure><p>在glUseProgram函数调用之后，<strong>每个着色器调用和渲染调用</strong>都会使用<strong>这个程序对象</strong>（也就是之前写的着色器)了。</p><p>对了，在把着色器对象<strong>链接到程序对象以后</strong>，记得<strong>删除着色器对象</strong>，我们不再需要它们了：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">glDeleteShader(vertexShader);</span><br><span class="line">glDeleteShader(fragmentShader);</span><br></pre></td></tr></table></figure><p>现在，我们已经把<strong>输入顶点数据发送给了GPU</strong>，并指示了GPU如何在顶点和片段着色器中处理它。就快要完成了，但还没结束，<strong>OpenGL还不知道它该如何解释内存中的顶点数据</strong>，以及它该如何<strong>将顶点数据链接到顶点着色器的属性上</strong>。我们需要告诉OpenGL怎么做。</p><h3 id="链接顶点属性"><a href="#链接顶点属性" class="headerlink" title="链接顶点属性"></a>链接顶点属性</h3><p>顶点着色器允许我们<strong>指定任何以顶点属性为形式的输入</strong>。这使其具有很强的灵活性的同时，它还的确意味着我们<strong>必须手动指定输入数据的哪一个部分</strong>对应顶点着色器的<strong>哪一个顶点属性</strong>。所以，我们必须在<strong>渲染前指定</strong>OpenGL该如何解释顶点数据。</p><p>顶点缓冲数据会被解析为下面这样子：</p><div align="center"><p><img src="/images/learnopengl-c1-f3.jpg"></p></div><ul><li>位置数据被储存为32位（4字节）浮点值；</li><li>每个位置包含3个这样的值；</li><li>这几个值在数组中紧密排列(Tightly Packed)；</li><li>数据中第一个值在缓冲开始的位置。</li></ul><p>有了这些信息我们就可以使用<code>glVertexAttribPointer</code>函数告诉OpenGL该如何解析顶点数据（应用到逐个顶点属性上）了：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">glVertexAttribPointer(<span class="number">0</span>, <span class="number">3</span>, GL_FLOAT, GL_FALSE, <span class="number">3</span> * <span class="keyword">sizeof</span>(<span class="keyword">float</span>), (<span class="keyword">void</span>*)<span class="number">0</span>);</span><br><span class="line">glEnableVertexAttribArray(<span class="number">0</span>);</span><br></pre></td></tr></table></figure><p><code>glVertexAttribPointer</code>函数的参数非常多，所以我会逐一介绍它们：</p><ul><li><strong>第一个参数</strong>指定我们要配置的顶点属性。还记得我们在顶点着色器中使用<code>layout(location = 0)</code>定义了<code>position</code>顶点属性的位置值(Location)吗？它可以把<strong>顶点属性的位置值</strong>设置为0。因为我们希望把<strong>数据传递到这一个顶点属性</strong>中，所以这里我们传入0；</li><li><strong>第二个参数</strong>指定顶点属性的大小。顶点属性是一个vec3，它由<code>3</code>个值组成，所以大小是3；</li><li><strong>第三个参数</strong>指定数据的类型，这里是GL_FLOAT(GLSL中vec*都是由浮点数值组成的)。</li><li><strong>第四个参数</strong>定义我们是否希望数据被<strong>标准化</strong>(Normalize)。如果我们设置为GL_TRUE，所有数据都会<strong>被映射到</strong>0（对于<strong>有符号型</strong>signed数据是-1）到1之间。我们把它设置为GL_FALSE，所有数据不会被处理。</li><li><strong>第五个参数叫做步长</strong>(Stride)，它告诉我们在<strong>连续的顶点属性组之间的间隔</strong>。由于下个组位置数据在3个float之后，我们把步长设置为<code>3 * sizeof(float)</code>。要注意的是由于我们知道这个数组是紧密排列的（在两个顶点属性之间没有空隙）我们也可以设置为<code>0</code>来<strong>让OpenGL决定具体步长是多少</strong>（只有当数值是紧密排列时才可用）。一旦我们<strong>有更多的顶点属性</strong>，我们就必须更<strong>小心地定义每个顶点属性之间的间隔</strong>，我们在后面会看到更多的例子（译注: 这个参数的意思简单说就是从这个属性<strong>第二次出现的地方到整个数组0位置之间有多少字节</strong>）；</li><li><strong>最后一个参数</strong>的类型是<code>void*</code>，所以需要我们进行<strong>这个奇怪的强制类型转换</strong>。它表示<strong>位置数据在缓冲中起始位置的偏移量</strong>(Offset)。由于位置数据在数组的开头，所以这里是0。我们会在后面详细解释这个参数。</li></ul><p>每个顶点属性从一个<strong>VBO管理的内存</strong>中获得它的数据，而具体是从哪个VBO（<strong>程序中可以有多个VBO</strong>）获取则是通过在调用<code>glVertexAttribPointer</code>时绑定到<code>GL_ARRAY_BUFFER</code>的VBO决定的。由于在调用<code>glVertexAttribPointer</code>之前绑定的是先前定义的VBO对象，<strong>顶点属性0现在会链接到它的顶点数据</strong>。</p><p>现在我们已经定义了OpenGL该如何解释顶点数据，我们现在应该使用<code>glEnableVertexAttribArray</code>，以<strong>顶点属性位置值作为参数</strong>，<strong>启用顶点属性</strong>；顶点属性默认是禁用的。</p><p>自此，<strong>所有东西都已经设置好了</strong>：</p><ul><li>我们使用一个顶点缓冲对象将顶点数据初始化至缓冲中；</li><li>建立了一个<strong>顶点</strong>和一个<strong>片段着色器</strong>；</li><li>告诉了OpenGL<strong>如何把顶点数据链接到顶点着色器的顶点属性</strong>上。</li></ul><p>在OpenGL中绘制一个物体，代码会像是这样：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 0. 复制顶点数组到缓冲中供OpenGL使用</span></span><br><span class="line">glBindBuffer(GL_ARRAY_BUFFER, VBO);</span><br><span class="line">glBufferData(GL_ARRAY_BUFFER, <span class="keyword">sizeof</span>(vertices), vertices, GL_STATIC_DRAW);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1. 设置顶点属性指针</span></span><br><span class="line">glVertexAttribPointer(<span class="number">0</span>, <span class="number">3</span>, GL_FLOAT, GL_FALSE, <span class="number">3</span> * <span class="keyword">sizeof</span>(<span class="keyword">float</span>), (<span class="keyword">void</span>*)<span class="number">0</span>);</span><br><span class="line">glEnableVertexAttribArray(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 当我们渲染一个物体时要使用着色器程序，已经编译链接好</span></span><br><span class="line">glUseProgram(shaderProgram);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 绘制物体</span></span><br><span class="line">drawCall();</span><br></pre></td></tr></table></figure><p>每当我们<strong>绘制一个物体的时候都必须重复这一过程</strong>。这看起来可能不多，但是如果有超过5个顶点属性，上百个不同物体呢（这其实并不罕见）。<strong>绑定正确的缓冲对象，为每个物体配置所有顶点属性很快就变成一件麻烦事</strong>。</p><p>有没有一些方法可以使我们把<strong>所有这些状态配置储存在一个对象</strong>中，并且可以<strong>通过绑定这个对象</strong>来恢复状态呢？</p><h3 id="顶点数组对象"><a href="#顶点数组对象" class="headerlink" title="顶点数组对象"></a>顶点数组对象</h3><p>顶点数组对象(Vertex Array Object, VAO)可以像顶点缓冲对象那样被绑定，<strong>任何随后的顶点属性调用</strong>都会储存在这个VAO中。这样的好处就是，当配置顶点属性指针时，你<strong>只需要将那些调用执行一次</strong>，之后<strong>再绘制物体的时候只需要绑定相应的VAO</strong>就行了。这使在<strong>不同顶点数据和属性配置之间切换变得非常简单</strong>，只需要绑定不同的VAO就行了。</p><p><strong>OpenGL的核心模式要求我们使用VAO</strong>，所以它知道该如何处理我们的顶点输入。如果我们绑定VAO失败，OpenGL会拒绝绘制任何东西。</p><p>一个顶点数组对象会储存以下这些内容：</p><ul><li>glEnableVertexAttribArray和glDisableVertexAttribArray的调用；</li><li>通过glVertexAttribPointer设置的顶点属性配置；</li><li>通过glVertexAttribPointer调用与顶点属性关联的顶点缓冲对象。</li></ul><div align="center"><p><img src="/images/learnopengl-c1-f4.jpg"></p></div><p>创建一个VAO和创建一个VBO很类似：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> VAO;</span><br><span class="line">glGenVertexArrays(<span class="number">1</span>, &amp;VAO);</span><br></pre></td></tr></table></figure><p>要想使用VAO，要做的只是使用glBindVertexArray<strong>绑定VAO</strong>。从绑定之后起，我们应该<strong>绑定和配置对应的VBO和属性指针，之后解绑VAO供之后使用</strong>。当我们打算绘制一个物体的时候，我们只要在<strong>绘制物体前</strong>简单地把<strong>VAO绑定到希望使用的设定</strong>上就行了：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ..:: 初始化代码（只运行一次 (除非你的物体频繁改变)） :: ..</span></span><br><span class="line"><span class="comment">// 1. 绑定VAO</span></span><br><span class="line">glBindVertexArray(VAO);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 把顶点数组复制到缓冲中供OpenGL使用</span></span><br><span class="line">glBindBuffer(GL_ARRAY_BUFFER, VBO);</span><br><span class="line">glBufferData(GL_ARRAY_BUFFER, <span class="keyword">sizeof</span>(vertices), vertices, GL_STATIC_DRAW);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 设置顶点属性指针</span></span><br><span class="line">glVertexAttribPointer(<span class="number">0</span>, <span class="number">3</span>, GL_FLOAT, GL_FALSE, <span class="number">3</span> * <span class="keyword">sizeof</span>(<span class="keyword">float</span>), (<span class="keyword">void</span>*)<span class="number">0</span>);</span><br><span class="line">glEnableVertexAttribArray(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ..:: 绘制代码（渲染循环中） :: ..</span></span><br><span class="line"><span class="comment">// 4. 绘制物体</span></span><br><span class="line">glUseProgram(shaderProgram);</span><br><span class="line">glBindVertexArray(VAO);</span><br><span class="line">drawCall();</span><br></pre></td></tr></table></figure><p>就这么多了！前面做的一切都是等待这一刻，一个<strong>储存了</strong>我们<strong>顶点属性配置</strong>和<strong>应使用的VBO</strong>的<strong>顶点数组对象</strong>。一般当你打算<strong>绘制多个物体时</strong>，你首先要生成/配置<strong>所有的VAO（和必须的VBO及属性指针)**，然后</strong>储存它们供后面使用<strong>。当我们打算</strong>绘制物体的时候就拿出相应的VAO，绑定它，绘制完物体后，再解绑VAO**。</p><h3 id="一直期待的三角形"><a href="#一直期待的三角形" class="headerlink" title="一直期待的三角形"></a>一直期待的三角形</h3><p>要想绘制我们想要的物体，OpenGL给我们提供了<code>glDrawArrays</code>函数，<strong>它使用当前激活的着色器</strong>，之前定义的顶点属性配置，和VBO的顶点数据（通过VAO间接绑定）来绘制图元。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">glUseProgram(shaderProgram);</span><br><span class="line">glBindVertexArray(VAO);</span><br><span class="line">glDrawArrays(GL_TRIANGLES, <span class="number">0</span>, <span class="number">3</span>);</span><br></pre></td></tr></table></figure><p><code>glDrawArrays</code>函数：</p><ul><li><strong>第一个参数</strong>是我们打算绘制的<strong>OpenGL图元的类型</strong>。由于我们在一开始时说过，我们希望绘制的是一个三角形，这里传递GL_TRIANGLES给它；</li><li><strong>第二个参数</strong>指定了<strong>顶点数组的起始索引</strong>，我们这里填0；</li><li><strong>最后一个参数</strong>指定我们打算<strong>绘制多少个顶点</strong>，这里是3（我们只从我们的数据中渲染一个三角形，它只有3个顶点长）。</li></ul><div align="center"><p><img src="/images/learnopengl-c1-f5.jpg"></p></div><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ... 其他代码没有修改</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span>* vertexShaderSource = <span class="string">&quot;#version 330 core\n&quot;</span></span><br><span class="line">    <span class="string">&quot;layout (location = 0) in vec3 aPos;\n&quot;</span></span><br><span class="line">    <span class="string">&quot;void main() &#123;\n&quot;</span></span><br><span class="line">    <span class="string">&quot;   gl_Position = vec4(aPos.x, aPos.y, aPos.z, 1.0);\n&quot;</span></span><br><span class="line">    <span class="string">&quot;&#125;\0&quot;</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span>* fragmentShaderSource = <span class="string">&quot;#version 330 core\n&quot;</span></span><br><span class="line">    <span class="string">&quot;out vec4 FragColor;\n&quot;</span></span><br><span class="line">    <span class="string">&quot;void main() &#123;\n&quot;</span></span><br><span class="line">    <span class="string">&quot;   FragColor = vec4(1.0f, 0.5f, 0.2f, 1.0f);\n&quot;</span></span><br><span class="line">    <span class="string">&quot;&#125;\n\0&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">get_shader_program</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建顶点着色器 VertexShader</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> vertexShader = glCreateShader(GL_VERTEX_SHADER);</span><br><span class="line">    <span class="comment">// 把着色器源码附加到着色器对象上</span></span><br><span class="line">    glShaderSource(vertexShader, <span class="number">1</span>, &amp;vertexShaderSource, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="comment">// 编译着色器</span></span><br><span class="line">    glCompileShader(vertexShader);</span><br><span class="line">    <span class="comment">// 检测编译错误</span></span><br><span class="line">    <span class="keyword">int</span> success;</span><br><span class="line">    <span class="keyword">char</span> infoLog[<span class="number">512</span>];</span><br><span class="line">    glGetShaderiv(vertexShader, GL_COMPILE_STATUS, &amp;success);</span><br><span class="line">    <span class="keyword">if</span> (!success) &#123;</span><br><span class="line">        glGetShaderInfoLog(vertexShader, <span class="number">512</span>, <span class="literal">NULL</span>, infoLog);</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;ERROR::SHADER::VERTEX::COMPILATION_FAILED\n&quot;</span> &lt;&lt; infoLog &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 创建片段着色器 FragmentShader</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> fragmentShader = glCreateShader(GL_FRAGMENT_SHADER);</span><br><span class="line">    <span class="comment">// 着色器源码附加到着色器对象上</span></span><br><span class="line">    glShaderSource(fragmentShader, <span class="number">1</span>, &amp;fragmentShaderSource, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="comment">// 编译着色器</span></span><br><span class="line">    glCompileShader(fragmentShader);</span><br><span class="line">    <span class="comment">// 检测编译错误</span></span><br><span class="line">    glGetShaderiv(fragmentShader, GL_COMPILE_STATUS, &amp;success);</span><br><span class="line">    <span class="keyword">if</span> (!success) &#123;</span><br><span class="line">        glGetShaderInfoLog(fragmentShader, <span class="number">512</span>, <span class="literal">NULL</span>, infoLog);</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;ERROR::SHADER::FRAGMENT::COMPILATION_FAILED\n&quot;</span> &lt;&lt; infoLog &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 创建程序对象</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> shaderProgram = glCreateProgram();</span><br><span class="line">    <span class="comment">// 着色器附加到程序对象上</span></span><br><span class="line">    glAttachShader(shaderProgram, vertexShader);</span><br><span class="line">    glAttachShader(shaderProgram, fragmentShader);</span><br><span class="line">    <span class="comment">// 链接</span></span><br><span class="line">    glLinkProgram(shaderProgram);</span><br><span class="line">    <span class="comment">// 检测链接错误</span></span><br><span class="line">    glGetProgramiv(shaderProgram, GL_LINK_STATUS, &amp;success);</span><br><span class="line">    <span class="keyword">if</span> (!success) &#123;</span><br><span class="line">        glGetProgramInfoLog(shaderProgram, <span class="number">512</span>, <span class="literal">NULL</span>, infoLog);</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;ERROR::SHADER::PROGRAM::LINKING_FAILED\n&quot;</span> &lt;&lt; infoLog &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 删除创建的着色器（已经不再需要了）</span></span><br><span class="line">    glDeleteShader(vertexShader);</span><br><span class="line">    glDeleteShader(fragmentShader);</span><br><span class="line">    <span class="keyword">return</span> shaderProgram;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">get_vbo_and_vao</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> &amp;VBO, <span class="keyword">unsigned</span> <span class="keyword">int</span> &amp;VAO)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">float</span> vertices[] = &#123;</span><br><span class="line">        <span class="number">-0.5f</span>, <span class="number">-0.5f</span>, <span class="number">0.0f</span>, <span class="comment">// left</span></span><br><span class="line">         <span class="number">0.5f</span>, <span class="number">-0.5f</span>, <span class="number">0.0f</span>, <span class="comment">// right</span></span><br><span class="line">         <span class="number">0.0f</span>,  <span class="number">0.5f</span>, <span class="number">0.0f</span> <span class="comment">// top</span></span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">// 创建顶点属性对象</span></span><br><span class="line">    glGenVertexArrays(<span class="number">1</span>, &amp;VAO);</span><br><span class="line">    <span class="comment">// 创建顶点缓冲对象</span></span><br><span class="line">    glGenBuffers(<span class="number">1</span>, &amp;VBO);</span><br><span class="line">    <span class="comment">// 先绑定VAO，再绑定VBO，然后再配置顶点属性</span></span><br><span class="line">    glBindVertexArray(VAO);</span><br><span class="line">    <span class="comment">// 绑定VBO到GL_ARRAY_BUFFER</span></span><br><span class="line">    glBindBuffer(GL_ARRAY_BUFFER, VBO);</span><br><span class="line">    <span class="comment">// 顶点数据复制到缓冲的内存中</span></span><br><span class="line">    glBufferData(GL_ARRAY_BUFFER, <span class="keyword">sizeof</span>(vertices), vertices, GL_STATIC_DRAW);</span><br><span class="line">    <span class="comment">// 告诉OpenGL如何解析顶点数据</span></span><br><span class="line">    glVertexAttribPointer(<span class="number">0</span>, <span class="number">3</span>, GL_FLOAT, GL_FALSE, <span class="number">3</span> * <span class="keyword">sizeof</span>(<span class="keyword">float</span>), (<span class="keyword">void</span>*)<span class="number">0</span>);</span><br><span class="line">    <span class="comment">// 以顶点属性值作为参数，启动顶点属性</span></span><br><span class="line">    glEnableVertexAttribArray(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 先解绑VAO</span></span><br><span class="line">    glBindVertexArray(<span class="number">0</span>);</span><br><span class="line">    <span class="comment">// 解绑VBO</span></span><br><span class="line">    glBindBuffer(GL_ARRAY_BUFFER, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    glfwInit();</span><br><span class="line">    glfwWindowHint(GLFW_CONTEXT_VERSION_MAJOR, <span class="number">3</span>);</span><br><span class="line">    glfwWindowHint(GLFW_CONTEXT_VERSION_MINOR, <span class="number">3</span>);</span><br><span class="line">    glfwWindowHint(GLFW_OPENGL_PROFILE, GLFW_OPENGL_CORE_PROFILE);</span><br><span class="line">    <span class="comment">// glfwWindowHint(GLFW_OPENGL_FORWARD_COMPAT, GL_TRUE); // for max os x</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// glfwCreateWindow(width, height, title, ..., ...)</span></span><br><span class="line">    GLFWwindow* window = glfwCreateWindow(<span class="number">800</span>, <span class="number">600</span>, <span class="string">&quot;LearnOpenGL&quot;</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (window == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Failed to create GLFW window&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">        glfwTerminate();</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    glfwMakeContextCurrent(window);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// GLAD是用来管理OpenGL的函数指针的</span></span><br><span class="line">    <span class="comment">// 所以在调用任何OpenGL的函数之前我们需要初始化GLAD</span></span><br><span class="line">    <span class="comment">// 给GLAD传入了用来加载系统相关的OpenGL函数指针地址的函数</span></span><br><span class="line">    <span class="comment">// GLFW给我们的是glfwGetProcAddress</span></span><br><span class="line">    <span class="comment">// 它根据我们编译的系统定义了正确的函数</span></span><br><span class="line">    <span class="keyword">if</span> (!gladLoadGLLoader((GLADloadproc)glfwGetProcAddress)) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Failed to initialize GLAD&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 告诉OpenGL渲染窗口的尺寸大小, 视口 Viewport</span></span><br><span class="line">    <span class="comment">// 窗口左下角的位置，宽度，高度</span></span><br><span class="line">    glViewport(<span class="number">0</span>, <span class="number">0</span>, <span class="number">800</span>, <span class="number">600</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当用户改变窗口的大小的时候，视口也应该被调整</span></span><br><span class="line">    <span class="comment">// 可以对窗口注册一个回调函数(Callback Function)</span></span><br><span class="line">    <span class="comment">// 它会在每次窗口大小被调整的时候被调用</span></span><br><span class="line">    <span class="comment">// void framebuffer_size_callback(GLFWwindow* window, int width, int height);</span></span><br><span class="line">    <span class="comment">// 需要注册这个函数，告诉GLFW我们希望每当窗口调整大小的时候调用这个函数</span></span><br><span class="line">    glfwSetFramebufferSizeCallback(window, framebuffer_size_callback);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 准备ShaderProgram和VBO、VAO</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> shaderProgram = get_shader_program();</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> VBO, VAO;</span><br><span class="line">    get_vbo_and_vao(VBO, VAO);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Render Loop</span></span><br><span class="line">    <span class="comment">// glfwWindowShouldClose函数在我们每次循环的开始前检查一次GLFW是否被要求退出</span></span><br><span class="line">    <span class="comment">// 如果是的话该函数返回true然后渲染循环便结束了，之后为我们就可以关闭应用程序了</span></span><br><span class="line">    <span class="keyword">while</span> (!glfwWindowShouldClose(window)) &#123;</span><br><span class="line">        <span class="comment">// 检测用户输入</span></span><br><span class="line">        process_input(window);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 渲染指令</span></span><br><span class="line">        <span class="comment">// 使用一个自定义的颜色清空屏幕</span></span><br><span class="line">        <span class="comment">// 调用了glClearColor来设置清空屏幕所用的颜色</span></span><br><span class="line">        glClearColor(<span class="number">0.2f</span>, <span class="number">0.3f</span>, <span class="number">0.3f</span>, <span class="number">1.0f</span>); <span class="comment">// 状态设置函数</span></span><br><span class="line">        <span class="comment">// 调用glClear函数来清空屏幕的颜色缓冲，它接受一个缓冲位(Buffer Bit)来指定要清空的缓冲</span></span><br><span class="line">        <span class="comment">// 可能的缓冲位有GL_COLOR_BUFFER_BIT，GL_DEPTH_BUFFER_BIT和GL_STENCIL_BUFFER_BIT</span></span><br><span class="line">        glClear(GL_COLOR_BUFFER_BIT); <span class="comment">// 状态使用函数</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 激活程序对象</span></span><br><span class="line">        glUseProgram(shaderProgram);</span><br><span class="line">        <span class="comment">// 绑定VAO</span></span><br><span class="line">        glBindVertexArray(VAO);</span><br><span class="line">        <span class="comment">// 绘制</span></span><br><span class="line">        glDrawArrays(GL_TRIANGLES, <span class="number">0</span>, <span class="number">3</span>);</span><br><span class="line">        <span class="comment">// 解绑VAO</span></span><br><span class="line">        glBindVertexArray(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// glfwSwapBuffers函数会交换颜色缓冲</span></span><br><span class="line">        <span class="comment">// 它是一个储存着GLFW窗口每一个像素颜色值的大缓冲</span></span><br><span class="line">        <span class="comment">// 它在这一迭代中被用来绘制，并且将会作为输出显示在屏幕上。</span></span><br><span class="line">        glfwSwapBuffers(window);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// glfwPollEvents函数检查有没有触发什么事件</span></span><br><span class="line">        <span class="comment">// 比如键盘输入、鼠标移动、更新窗口状态等</span></span><br><span class="line">        <span class="comment">// 并调用对应的回调函数（可以通过回调方法手动设置）</span></span><br><span class="line">        glfwPollEvents();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 可选，程序结束前释放申请的资源</span></span><br><span class="line">    glDeleteVertexArrays(<span class="number">1</span>, &amp;VAO);</span><br><span class="line">    glDeleteBuffers(<span class="number">1</span>, &amp;VBO);</span><br><span class="line">    glDeleteProgram(shaderProgram);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当渲染循环结束后我们需要正确释放/删除之前的分配的所有资源</span></span><br><span class="line">    <span class="comment">// 在main函数的最后调用glfwTerminate函数来完成</span></span><br><span class="line">    glfwTerminate();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="索引缓冲对象"><a href="#索引缓冲对象" class="headerlink" title="索引缓冲对象"></a>索引缓冲对象</h3><p>在渲染顶点这一话题上我们还有最后一个需要讨论的东西——<strong>索引缓冲对象</strong>(Element Buffer Object，EBO，也叫Index Buffer Object，IBO)。要解释索引缓冲对象的工作方式最好还是举个例子：假设我们<strong>不再绘制一个三角形而是绘制一个矩形</strong>。我们可以绘制两个三角形来组成一个矩形（OpenGL主要处理三角形）。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">float</span> vertices[] = &#123;</span><br><span class="line">    <span class="comment">// 第一个三角形</span></span><br><span class="line">    <span class="number">0.5f</span>, <span class="number">0.5f</span>, <span class="number">0.0f</span>,   <span class="comment">// 右上角</span></span><br><span class="line">    <span class="number">0.5f</span>, <span class="number">-0.5f</span>, <span class="number">0.0f</span>,  <span class="comment">// 右下角</span></span><br><span class="line">    <span class="number">-0.5f</span>, <span class="number">0.5f</span>, <span class="number">0.0f</span>,  <span class="comment">// 左上角</span></span><br><span class="line">    <span class="comment">// 第二个三角形</span></span><br><span class="line">    <span class="number">0.5f</span>, <span class="number">-0.5f</span>, <span class="number">0.0f</span>,  <span class="comment">// 右下角</span></span><br><span class="line">    <span class="number">-0.5f</span>, <span class="number">-0.5f</span>, <span class="number">0.0f</span>, <span class="comment">// 左下角</span></span><br><span class="line">    <span class="number">-0.5f</span>, <span class="number">0.5f</span>, <span class="number">0.0f</span>   <span class="comment">// 左上角</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>可以看到，<strong>有几个顶点叠加了</strong>。我们指定了右下角和左上角两次！一个矩形只有4个而不是6个顶点，这样就产生50%的额外开销。当我们有包括上千个三角形的模型之后这个问题会更糟糕，这会产生一大堆浪费。<strong>更好的解决方案是只储存不同的顶点，并设定绘制这些顶点的顺序</strong>。这样子我们只要<strong>储存4个顶点</strong>就能绘制矩形了，之后只要指定绘制的顺序就行了。如果OpenGL提供这个功能就好了，对吧？</p><p>很幸运，<strong>索引缓冲对象</strong>的工作方式正是这样的。和顶点缓冲对象一样，EBO也是一个缓冲，它<strong>专门储存索引</strong>，OpenGL调用这些<strong>顶点的索引来决定该绘制哪个顶点</strong>。所谓的<strong>索引绘制</strong>(Indexed Drawing)正是我们问题的解决方案。</p><p>首先，我们<strong>先要定义（不重复的）顶点</strong>，和绘制出矩形<strong>所需的索引</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 顶点</span></span><br><span class="line"><span class="keyword">float</span> vertices[] = &#123;</span><br><span class="line">    <span class="number">0.5f</span>, <span class="number">0.5f</span>, <span class="number">0.0f</span>,   <span class="comment">// 右上角</span></span><br><span class="line">    <span class="number">0.5f</span>, <span class="number">-0.5f</span>, <span class="number">0.0f</span>,  <span class="comment">// 右下角</span></span><br><span class="line">    <span class="number">-0.5f</span>, <span class="number">-0.5f</span>, <span class="number">0.0f</span>, <span class="comment">// 左下角</span></span><br><span class="line">    <span class="number">-0.5f</span>, <span class="number">0.5f</span>, <span class="number">0.0f</span>   <span class="comment">// 左上角</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 索引</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> indices[] = &#123; <span class="comment">// 注意索引从0开始! </span></span><br><span class="line">    <span class="number">0</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="comment">// 第一个三角形</span></span><br><span class="line">    <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>  <span class="comment">// 第二个三角形</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>下一步我们需要<strong>创建索引缓冲对象</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> EBO;</span><br><span class="line">glGenBuffers(<span class="number">1</span>, &amp;EBO);</span><br></pre></td></tr></table></figure><p>与VBO类似，我们<strong>先绑定EBO</strong>然后用<code>glBufferData</code>把<strong>索引复制到缓冲里</strong>。同样，和VBO类似，我们会<strong>把这些函数调用放在绑定和解绑函数调用之间</strong>，只不过这次我们把<strong>缓冲的类型定义</strong>为GL_ELEMENT_ARRAY_BUFFER。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, EBO);</span><br><span class="line">glBufferData(GL_ELEMENT_ARRAY_BUFFER, <span class="keyword">sizeof</span>(indices), indices, GL_STATIC_DRAW);</span><br></pre></td></tr></table></figure><p>要注意的是，我们传递了GL_ELEMENT_ARRAY_BUFFER当作缓冲目标。最后一件要做的事是<strong>用glDrawElements来替换glDrawArrays函数</strong>，来指明我们<strong>从索引缓冲渲染</strong>。使用glDrawElements时，我们会使用<strong>当前绑定的索引缓冲对象中的索引</strong>进行绘制：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, EBO);</span><br><span class="line">glDrawElements(GL_TRIANGLES, <span class="number">6</span>, GL_UNSIGNED_INT, <span class="number">0</span>);</span><br></pre></td></tr></table></figure><p><code>glDrawElements</code>的参数说明：</p><ul><li><strong>第一个参数</strong>指定了我们<strong>绘制的模式</strong>，这个和glDrawArrays的一样；</li><li><strong>第二个参数</strong>是我们打算<strong>绘制顶点的个数</strong>，这里填6，也就是说我们一共需要绘制6个顶点；</li><li><strong>第三个参数</strong>是<strong>索引的类型</strong>，这里是GL_UNSIGNED_INT；</li><li><strong>最后一个参数</strong>里我们可以指定<strong>EBO中的偏移量</strong>（或者传递一个索引数组，但是这是当你不在使用索引缓冲对象的时候），但是我们会在这里填写0。</li></ul><p><code>glDrawElements</code>函数从当前绑定到GL_ELEMENT_ARRAY_BUFFER目标的EBO中获取索引。这意味着我们必须在每次要用索引渲染一个物体时绑定相应的EBO，这还是有点麻烦。<strong>不过顶点数组对象VAO同样可以保存索引缓冲对象的绑定状态</strong>。VAO绑定时正在绑定的索引缓冲对象会被保存为VAO的元素缓冲对象。绑定VAO的同时也会自动绑定EBO。</p><div align="center"><p><img src="/images/learnopengl-c1-f6.jpg"></p></div><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ..:: 初始化代码 :: ..</span></span><br><span class="line"><span class="comment">// 1. 绑定顶点数组对象</span></span><br><span class="line">glBindVertexArray(VAO);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 把我们的顶点数组复制到一个顶点缓冲中，供OpenGL使用</span></span><br><span class="line">glBindBuffer(GL_ARRAY_BUFFER, VBO);</span><br><span class="line">glBufferData(GL_ARRAY_BUFFER, <span class="keyword">sizeof</span>(vertices), vertices, GL_STATIC_DRAW);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 复制我们的索引数组到一个索引缓冲中，供OpenGL使用</span></span><br><span class="line">glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, EBO);</span><br><span class="line">glBufferData(GL_ELEMENT_ARRAY_BUFFER, <span class="keyword">sizeof</span>(indices), indices, GL_STATIC_DRAW);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 4. 设定顶点属性指针</span></span><br><span class="line">glVertexAttribPointer(<span class="number">0</span>, <span class="number">3</span>, GL_FLOAT, GL_FALSE, <span class="number">3</span> * <span class="keyword">sizeof</span>(<span class="keyword">float</span>), (<span class="keyword">void</span>*)<span class="number">0</span>);</span><br><span class="line">glEnableVertexAttribArray(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// [...]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ..:: 绘制代码（渲染循环中） :: ..</span></span><br><span class="line">glUseProgram(shaderProgram);</span><br><span class="line">glBindVertexArray(VAO);</span><br><span class="line">glDrawElements(GL_TRIANGLES, <span class="number">6</span>, GL_UNSIGNED_INT, <span class="number">0</span>);</span><br><span class="line">glBindVertexArray(<span class="number">0</span>);</span><br></pre></td></tr></table></figure><p>当<strong>目标是GL_ELEMENT_ARRAY_BUFFER的时候</strong>，VAO会<strong>储存glBindBuffer的函数调用</strong>。这也意味着它<strong>也会储存解绑调用</strong>，所以<strong>确保你没有在解绑VAO之前解绑索引数组缓冲，否则它就没有这个EBO配置了</strong>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ... 其他代码都没有修改</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">get_vbo_ebo_and_vao</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> &amp;VBO, <span class="keyword">unsigned</span> <span class="keyword">int</span> &amp;EBO, <span class="keyword">unsigned</span> <span class="keyword">int</span> &amp;VAO)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 顶点</span></span><br><span class="line">    <span class="keyword">float</span> vertices[] = &#123;</span><br><span class="line">        <span class="number">0.5f</span>, <span class="number">0.5f</span>, <span class="number">0.0f</span>,   <span class="comment">// 右上角</span></span><br><span class="line">        <span class="number">0.5f</span>, <span class="number">-0.5f</span>, <span class="number">0.0f</span>,  <span class="comment">// 右下角</span></span><br><span class="line">        <span class="number">-0.5f</span>, <span class="number">-0.5f</span>, <span class="number">0.0f</span>, <span class="comment">// 左下角</span></span><br><span class="line">        <span class="number">-0.5f</span>, <span class="number">0.5f</span>, <span class="number">0.0f</span>   <span class="comment">// 左上角</span></span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">// 索引</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> indices[] = &#123; <span class="comment">// 注意索引从0开始! </span></span><br><span class="line">        <span class="number">0</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="comment">// 第一个三角形</span></span><br><span class="line">        <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>  <span class="comment">// 第二个三角形</span></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建顶点属性对象</span></span><br><span class="line">    glGenVertexArrays(<span class="number">1</span>, &amp;VAO);</span><br><span class="line">    <span class="comment">// 创建顶点缓冲对象和索引缓冲对象</span></span><br><span class="line">    glGenBuffers(<span class="number">1</span>, &amp;VBO);</span><br><span class="line">    glGenBuffers(<span class="number">1</span>, &amp;EBO);</span><br><span class="line">    <span class="comment">// 先绑定VAO，再绑定VBO，然后再配置顶点属性</span></span><br><span class="line">    glBindVertexArray(VAO);</span><br><span class="line">    <span class="comment">// 绑定VBO到GL_ARRAY_BUFFER</span></span><br><span class="line">    glBindBuffer(GL_ARRAY_BUFFER, VBO);</span><br><span class="line">    <span class="comment">// 顶点数据复制到缓冲的内存中</span></span><br><span class="line">    glBufferData(GL_ARRAY_BUFFER, <span class="keyword">sizeof</span>(vertices), vertices, GL_STATIC_DRAW);</span><br><span class="line">    <span class="comment">// 绑定EBO到GL_ELEMENT_ARRAY_BUFFER</span></span><br><span class="line">    glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, EBO);</span><br><span class="line">    <span class="comment">// 索引数据复制到缓冲的内存中</span></span><br><span class="line">    glBufferData(GL_ELEMENT_ARRAY_BUFFER, <span class="keyword">sizeof</span>(indices), indices, GL_STATIC_DRAW);</span><br><span class="line">    <span class="comment">// 告诉OpenGL如何解析顶点数据</span></span><br><span class="line">    glVertexAttribPointer(<span class="number">0</span>, <span class="number">3</span>, GL_FLOAT, GL_FALSE, <span class="number">3</span> * <span class="keyword">sizeof</span>(<span class="keyword">float</span>), (<span class="keyword">void</span>*)<span class="number">0</span>);</span><br><span class="line">    <span class="comment">// 以顶点属性值作为参数，启动顶点属性</span></span><br><span class="line">    glEnableVertexAttribArray(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 先解绑VAO</span></span><br><span class="line">    glBindVertexArray(<span class="number">0</span>);</span><br><span class="line">    <span class="comment">// 解绑VBO和EBO</span></span><br><span class="line">    glBindBuffer(GL_ARRAY_BUFFER, <span class="number">0</span>);</span><br><span class="line">    glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ... 其他代码都没有修改，不再赘述</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 准备ShaderProgram和VBO、VAO</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> shaderProgram = get_shader_program();</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> VBO, EBO, VAO;</span><br><span class="line">    get_vbo_ebo_and_vao(VBO, EBO, VAO);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// glPolygonMode(GL_FRONT_AND_BACK, GL_LINE);</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Render Loop</span></span><br><span class="line">    <span class="comment">// glfwWindowShouldClose函数在我们每次循环的开始前检查一次GLFW是否被要求退出</span></span><br><span class="line">    <span class="comment">// 如果是的话该函数返回true然后渲染循环便结束了，之后为我们就可以关闭应用程序了</span></span><br><span class="line">    <span class="keyword">while</span> (!glfwWindowShouldClose(window)) &#123;</span><br><span class="line">        <span class="comment">// 检测用户输入</span></span><br><span class="line">        process_input(window);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 渲染指令</span></span><br><span class="line">        <span class="comment">// 使用一个自定义的颜色清空屏幕</span></span><br><span class="line">        <span class="comment">// 调用了glClearColor来设置清空屏幕所用的颜色</span></span><br><span class="line">        glClearColor(<span class="number">0.2f</span>, <span class="number">0.3f</span>, <span class="number">0.3f</span>, <span class="number">1.0f</span>); <span class="comment">// 状态设置函数</span></span><br><span class="line">        <span class="comment">// 调用glClear函数来清空屏幕的颜色缓冲，它接受一个缓冲位(Buffer Bit)来指定要清空的缓冲</span></span><br><span class="line">        <span class="comment">// 可能的缓冲位有GL_COLOR_BUFFER_BIT，GL_DEPTH_BUFFER_BIT和GL_STENCIL_BUFFER_BIT</span></span><br><span class="line">        glClear(GL_COLOR_BUFFER_BIT); <span class="comment">// 状态使用函数</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 激活程序对象</span></span><br><span class="line">        glUseProgram(shaderProgram);</span><br><span class="line">        <span class="comment">// 绑定VAO</span></span><br><span class="line">        glBindVertexArray(VAO);</span><br><span class="line">        <span class="comment">// 绘制</span></span><br><span class="line">        glDrawElements(GL_TRIANGLES, <span class="number">6</span>, GL_UNSIGNED_INT, <span class="number">0</span>);</span><br><span class="line">        <span class="comment">// 解绑VAO</span></span><br><span class="line">        glBindVertexArray(<span class="number">0</span>); </span><br><span class="line"></span><br><span class="line">        <span class="comment">// glfwSwapBuffers函数会交换颜色缓冲</span></span><br><span class="line">        <span class="comment">// 它是一个储存着GLFW窗口每一个像素颜色值的大缓冲</span></span><br><span class="line">        <span class="comment">// 它在这一迭代中被用来绘制，并且将会作为输出显示在屏幕上。</span></span><br><span class="line">        glfwSwapBuffers(window);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// glfwPollEvents函数检查有没有触发什么事件</span></span><br><span class="line">        <span class="comment">// 比如键盘输入、鼠标移动、更新窗口状态等</span></span><br><span class="line">        <span class="comment">// 并调用对应的回调函数（可以通过回调方法手动设置）</span></span><br><span class="line">        glfwPollEvents();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// glPolygonMode(GL_FRONT_AND_BACK, GL_FILL);</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 可选，程序结束前释放申请的资源</span></span><br><span class="line">    glDeleteVertexArrays(<span class="number">1</span>, &amp;VAO);</span><br><span class="line">    glDeleteBuffers(<span class="number">1</span>, &amp;VBO);</span><br><span class="line">    glDeleteBuffers(<span class="number">1</span>, &amp;EBO);</span><br><span class="line">    glDeleteProgram(shaderProgram);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当渲染循环结束后我们需要正确释放/删除之前的分配的所有资源</span></span><br><span class="line">    <span class="comment">// 在main函数的最后调用glfwTerminate函数来完成</span></span><br><span class="line">    glfwTerminate();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><div align="center"><p><img src="/images/learnopengl-c1-f7.jpg"></p></div><p><strong>线框模式</strong>(Wireframe Mode)：要想用线框模式绘制你的三角形，你可以通过<code>glPolygonMode(GL_FRONT_AND_BACK, GL_LINE)</code>函数配置OpenGL如何绘制图元。<strong>第一个参数</strong>表示我们打算将其应用到所有的三角形的正面和背面，<strong>第二个参数</strong>告诉我们用线来绘制。之后的绘制调用会一直以线框模式绘制三角形，直到我们用<code>glPolygonMode(GL_FRONT_AND_BACK, GL_FILL)</code>将其设置回默认模式。</p><h3 id="练习题"><a href="#练习题" class="headerlink" title="练习题"></a>练习题</h3><ol><li>添加更多顶点到数据中，使用glDrawArrays，尝试绘制两个彼此相连的三角形；</li><li>创建相同的两个三角形，但对它们的数据使用不同的VAO和VBO；</li><li>创建两个着色器程序，第二个程序使用一个不同的片段着色器，输出黄色；再次绘制这两个三角形，让其中一个输出为黄色。</li></ol><p>（咕咕，之后再做）</p><hr><h2 id="着色器"><a href="#着色器" class="headerlink" title="着色器"></a>着色器</h2><p>从基本意义上来说，着色器只是一种把输入转化为输出的程序。着色器也是一种非常独立的程序，因为它们之间不能相互通信；它们之间唯一的沟通只有通过输入和输出。</p><p>现在我们会用一种更加广泛的形式详细解释着色器，特别是OpenGL着色器语言(GLSL)。</p><h3 id="GLSL"><a href="#GLSL" class="headerlink" title="GLSL"></a>GLSL</h3><p>着色器是使用一种叫<strong>GLSL的类C语言</strong>写成的。<strong>GLSL是为图形计算量身定制的</strong>，它包含一些针对向量和矩阵操作的有用特性。</p><p>着色器的开头总是要<strong>声明版本</strong>，接着是<strong>输入和输出变量、uniform和main函数</strong>。每个着色器的入口点都是main函数，在这个函数中我们处理所有的输入变量，并将结果输出到输出变量中。如果你不知道什么是uniform也不用担心，我们后面会进行讲解。</p><p>一个典型的着色器有下面的结构：</p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#version version_number</span></span><br><span class="line"><span class="keyword">in</span> type in_variable_name;</span><br><span class="line"><span class="keyword">in</span> type in_variable_name;</span><br><span class="line"></span><br><span class="line"><span class="keyword">out</span> type out_variable_name;</span><br><span class="line"></span><br><span class="line"><span class="keyword">uniform</span> type uniform_name;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> main()</span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// 处理输入并进行一些图形操作</span></span><br><span class="line">  ...</span><br><span class="line">  <span class="comment">// 输出处理过的结果到输出变量</span></span><br><span class="line">  out_variable_name = weird_stuff_we_processed;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当我们特别谈论到<strong>顶点着色器</strong>的时候，每个输入变量也叫<strong>顶点属性</strong>(Vertex Attribute)。我们能声明的<strong>顶点属性是有上限的，它一般由硬件来决定</strong>。OpenGL确保<strong>至少有16个包含4分量的顶点属性可用</strong>，但是有些硬件或许允许更多的顶点属性，你可以查询<code>GL_MAX_VERTEX_ATTRIBS</code>来获取具体的上限：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> nrAttributes;</span><br><span class="line">glGetIntegerv(GL_MAX_VERTEX_ATTRIBS, &amp;nrAttributes);</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Maximum nr of vertex attributes supported: &quot;</span> &lt;&lt; nrAttributes &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure><p>通常情况下它至少会返回16个，大部分情况下是够用了。</p><h3 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h3><p>和其他编程语言一样，GLSL有数据类型可以来指定变量的种类。GLSL中包含C等其它语言大部分的默认基础数据类型：<code>int</code>、<code>float</code>、<code>double</code>、<code>uint</code>和<code>bool</code>。GLSL也有<strong>两种容器类型</strong>，它们会在这个教程中使用很多，分别是<strong>向量</strong>(Vector)和<strong>矩阵</strong>(Matrix)，其中矩阵我们会在之后的教程里再讨论。</p><p><strong>向量</strong>(Vector)：GLSL中的向量是一个可以包含有1、2、3或者4个分量的容器，分量的类型可以是前面默认基础类型的任意一个。它们可以是下面的形式（<code>n</code>代表分量的数量）：</p><ul><li><code>vecn</code>：包含<code>n</code>个<code>float</code>分量的默认向量；</li><li><code>bvecn</code>：包含<code>n</code>个<code>bool</code>分量的向量；</li><li><code>ivecn</code>：包含<code>n</code>个<code>int</code>分量的向量；</li><li><code>uvecn</code>：包含<code>n</code>个<code>unsigned int</code>分量的向量；</li><li><code>dvecn</code>：包含<code>n</code>个<code>double</code>分量的向量。</li></ul><p>大多数时候我们使用<code>vecn</code>，因为<code>float</code>足够满足大多数要求了。</p><p>一个向量的分量可以通过<code>vec.x</code>这种方式获取，这里<code>x</code>是指这个向量的第一个分量。你可以分别使用<code>.x、.y、.z</code>和<code>.w</code>来获取它们的第<code>1、2、3、4</code>个分量。GLSL也允许你对颜色使用<code>rgba</code>，或是对纹理坐标使用<code>stpq</code>访问相同的分量。</p><p>向量这一数据类型也允许一些有趣而灵活的分量选择方式，叫做<strong>重组</strong>(Swizzling)。重组允许这样的语法：</p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">vec2</span> someVec;</span><br><span class="line"><span class="type">vec4</span> differentVec = someVec.xyxx;</span><br><span class="line"><span class="type">vec3</span> anotherVec = differentVec.zyw;</span><br><span class="line"><span class="type">vec4</span> otherVec = someVec.xxxx + anotherVec.yxzy;</span><br></pre></td></tr></table></figure><p>你可以使用上面<strong>4个字母任意组合</strong>来创建一个和原来向量一样长的（同类型）新向量，只要原来向量有那些分量即可；然而，<strong>你不允许在一个vec2向量中去获取.z元素</strong>。我们也可以<strong>把一个向量作为一个参数传给不同的向量构造函数</strong>，以减少需求参数的数量：</p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">vec2</span> vect = <span class="type">vec2</span>(<span class="number">0.5</span>, <span class="number">0.7</span>);</span><br><span class="line"><span class="type">vec4</span> result = <span class="type">vec4</span>(vect, <span class="number">0.0</span>, <span class="number">0.0</span>);</span><br><span class="line"><span class="type">vec4</span> otherResult = <span class="type">vec4</span>(result.xyz, <span class="number">1.0</span>);</span><br></pre></td></tr></table></figure><p>向量是一种灵活的数据类型，我们可以把用在各种输入和输出上。</p><h3 id="输入与输出"><a href="#输入与输出" class="headerlink" title="输入与输出"></a>输入与输出</h3><p>我们希望<strong>每个着色器都有输入和输出</strong>，这样才能进行数据交流和传递。GLSL定义了<code>in</code>和<code>out</code>关键字专门来实现这个目的。每个着色器使用这两个关键字设定输入和输出，<strong>只要一个输出变量与下一个着色器阶段的输入匹配</strong>，它就会传递下去。但在<strong>顶点和片段着色器</strong>中会有点不同。</p><p><strong>顶点着色器</strong>应该接收的是一种<strong>特殊形式的输入</strong>，否则就会效率低下。顶点着色器的输入特殊在，它<strong>从顶点数据中直接接收输入</strong>。为了定义顶点数据该如何管理，我们使用<code>location</code>这一<strong>元数据指定输入变量</strong>，这样我们才可以在CPU上配置顶点属性。我们已经在前面的教程看过这个了，<code>layout (location = 0)</code>。顶点着色器需要为它的输入提供一个<strong>额外的layout标识</strong>，这样我们才能把它链接到顶点数据。</p><p>你也可以忽略layout (location = 0)标识符，通过在OpenGL代码中使用<code>glGetAttribLocation</code>查询属性位置值(Location)，但是我更喜欢在着色器中设置它们，这样会更容易理解而且节省你（和OpenGL）的工作量。</p><p>另一个例外是<strong>片段着色器</strong>，它需要一个<code>vec4</code>颜色输出变量，因为片段着色器需要生成一个最终输出的颜色。如果你在片段着色器没有定义输出颜色，OpenGL会把你的物体渲染为黑色（或白色）。</p><p>所以，如果我们打算从一个着色器向另一个着色器发送数据，我们必须在<strong>发送方着色器中声明一个输出</strong>，在<strong>接收方着色器中声明一个类似的输入</strong>。当<strong>类型和名字</strong>都一样的时候，OpenGL就会把两个变量链接到一起，它们之间就能发送数据了（这是在<strong>链接程序对象</strong>时完成的）。</p><p>为了展示这是如何工作的，我们会稍微改动一下之前教程里的那个着色器，让顶点着色器为片段着色器决定颜色。</p><p>顶点着色器：</p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#version 330 core</span></span><br><span class="line"><span class="keyword">layout</span> (<span class="keyword">location</span> = <span class="number">0</span>) <span class="keyword">in</span> <span class="type">vec3</span> aPos; <span class="comment">// 位置变量的属性位置值为0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">out</span> <span class="type">vec4</span> vertexColor; <span class="comment">// 为片段着色器指定一个颜色输出</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> main() &#123;</span><br><span class="line">    <span class="built_in">gl_Position</span> = <span class="type">vec4</span>(aPos, <span class="number">1.0</span>); <span class="comment">// 把一个vec3作为vec4的构造器的参数</span></span><br><span class="line">    vertexColor = <span class="type">vec4</span>(<span class="number">0.5</span>, <span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">1.0</span>); <span class="comment">// 把输出变量设置为暗红色</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>片段着色器：</p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#version 330 core</span></span><br><span class="line"><span class="keyword">out</span> <span class="type">vec4</span> FragColor;</span><br><span class="line"></span><br><span class="line"><span class="keyword">in</span> <span class="type">vec4</span> vertexColor; <span class="comment">// 从顶点着色器传来的输入变量（名称相同、类型相同）</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> main() &#123;</span><br><span class="line">    FragColor = vertexColor;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>你可以看到我们在顶点着色器中声明了一个vertexColor变量作为vec4输出，并在片段着色器中声明了一个类似的vertexColor。由于它们<strong>名字相同且类型相同</strong>，片段着色器中的vertexColor就和顶点着色器中的vertexColor链接了。由于我们在顶点着色器中将颜色设置为深红色，最终的片段也是深红色的。</p><p>让我们更上一层楼，看看能否从应用程序中直接给片段着色器发送一个颜色！</p><h3 id="Uniform"><a href="#Uniform" class="headerlink" title="Uniform"></a>Uniform</h3><p><strong>Uniform</strong>是一种<strong>从CPU中的应用</strong>向<strong>GPU中的着色器</strong>发送数据的方式，但uniform和顶点属性有些不同。首先，uniform是<strong>全局的</strong>(Global)。全局意味着uniform变量<strong>必须在每个着色器程序对象中都是独一无二的</strong>(只有一个，而不是每个着色器都有单独一个的意思)，而且它可以被着色器程序的<strong>任意着色器在任意阶段访问</strong>。第二，无论你把uniform值设置成什么，<strong>uniform会一直保存它们的数据</strong>，直到它们被重置或更新。</p><p>我们可以在一个着色器中添加<code>uniform</code>关键字至<strong>类型和变量名前</strong>来声明一个GLSL的uniform。从此处开始我们就可以在着色器中使用新声明的uniform了。我们来看看这次是否能通过uniform设置三角形的颜色：</p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#version 330 core</span></span><br><span class="line"><span class="keyword">out</span> <span class="type">vec4</span> FragColor;</span><br><span class="line"></span><br><span class="line"><span class="keyword">uniform</span> <span class="type">vec4</span> ourColor; <span class="comment">// 在OpenGL程序代码中设定这个变量</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> main() &#123;</span><br><span class="line">    FragColor = ourColor;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们在<strong>片段着色器</strong>中声明了一个<code>uniform vec4</code>的ourColor，并把片段着色器的输出颜色设置为uniform值的内容。因为uniform是全局变量，我们可以在<strong>任何着色器中定义它们</strong>，而无需通过顶点着色器作为中介。顶点着色器中不需要这个uniform，所以我们不用在那里定义它。</p><p>如果你声明了一个uniform却在GLSL代码中没用过，<strong>编译器会静默移除这个变量</strong>，导致最后编译出的版本中并不会包含它，这可能导致几个非常麻烦的错误，记住这点！</p><p>这个uniform现在还是空的；我们还没有给它添加任何数据，所以下面我们就做这件事。我们首先需要<strong>找到着色器中</strong>uniform属性的<strong>索引/位置值</strong>。当我们得到uniform的索引/位置值后，我们就可以<strong>更新它的值了</strong>。这次我们不去给像素传递单独一个颜色，而是让它随着时间改变颜色：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">float</span> timeValue = glfwGetTime();</span><br><span class="line"><span class="keyword">float</span> greenValue = (<span class="built_in">sin</span>(timeValue) / <span class="number">2.0f</span>) + <span class="number">0.5f</span>;</span><br><span class="line"><span class="keyword">int</span> vertexColorLocation = glGetUniformLocation(shaderProgram, <span class="string">&quot;ourColor&quot;</span>);</span><br><span class="line">glUseProgram(shaderProgram);</span><br><span class="line">glUniform4f(vertexColorLocation, <span class="number">0.0f</span>, greenValue, <span class="number">0.0f</span>, <span class="number">1.0f</span>);</span><br></pre></td></tr></table></figure><p>首先我们通过glfwGetTime()获取运行的秒数。然后我们使用sin函数让颜色在0.0到1.0之间改变，最后将结果储存到greenValue里。</p><p>接着，我们用glGetUniformLocation查询uniform ourColor的位置值。我们为查询函数提供着色器程序和uniform的名字（这是我们希望获得的位置值的来源）。如果glGetUniformLocation返回-1就代表没有找到这个位置值。最后，我们可以通过glUniform4f函数设置uniform值。注意，<strong>查询uniform地址不要求你之前使用过着色器程序</strong>，但是<strong>更新一个uniform之前你必须先使用程序</strong>（调用glUseProgram)，因为它是在<strong>当前激活的着色器程序中设置uniform的</strong>。</p><p>因为OpenGL在其核心是一个C库，所以<strong>它不支持类型重载</strong>，<strong>在函数参数不同的时候就要为其定义新的函数</strong>；<code>glUniform</code>是一个典型例子。这个函数有一个特定的后缀，标识设定的uniform的类型。可能的后缀有：</p><ul><li><code>f</code>：函数需要一个float作为它的值；</li><li><code>i</code>：函数需要一个int作为它的值；</li><li><code>ui</code>：函数需要一个unsigned int作为它的值；</li><li><code>3f</code>：函数需要3个float作为它的值；</li><li><code>fv</code>：函数需要一个float向量/数组作为它的值。</li></ul><p>每当你打算配置一个OpenGL的选项时就可以简单地根据这些规则选择适合你的数据类型的重载函数。在我们的例子里，我们希望分别设定uniform的4个float值，所以我们通过glUniform4f传递我们的数据(注意，我们也可以使用fv版本，一维向量)。</p><p>现在你知道如何设置uniform变量的值了，我们可以使用它们来渲染了。如果我们打算让颜色慢慢变化，我们就要在游戏循环的<strong>每一次迭代中</strong>（所以他会逐帧改变）<strong>更新这个</strong>uniform，否则三角形就不会改变颜色。</p><p>uniform对于<strong>设置一个在渲染迭代中会改变的属性是一个非常有用的工具</strong>，它也是一个在<strong>程序和着色器间数据交互的很好工具</strong>，但假如我们打算为<strong>每个顶点设置一个颜色</strong>的时候该怎么办？这种情况下，我们就不得不声明和顶点数目一样多的uniform了。在这一问题上<strong>更好的解决方案是在顶点属性中包含更多的数据</strong>，这是我们接下来要做的事情。</p><h3 id="更多属性"><a href="#更多属性" class="headerlink" title="更多属性"></a>更多属性</h3><p>在前面的教程中，我们了解了如何填充VBO、配置顶点属性指针以及如何把它们都储存到一个VAO里。这次，我们同样打算把颜色数据加进顶点数据中。我们将把颜色数据添加为3个float值至vertices数组。我们将把三角形的三个角分别指定为红色、绿色和蓝色：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">float</span> vertices[] = &#123;</span><br><span class="line">    <span class="comment">// 位置              // 颜色</span></span><br><span class="line">     <span class="number">0.5f</span>, <span class="number">-0.5f</span>, <span class="number">0.0f</span>,  <span class="number">1.0f</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span>,   <span class="comment">// 右下</span></span><br><span class="line">    <span class="number">-0.5f</span>, <span class="number">-0.5f</span>, <span class="number">0.0f</span>,  <span class="number">0.0f</span>, <span class="number">1.0f</span>, <span class="number">0.0f</span>,   <span class="comment">// 左下</span></span><br><span class="line">     <span class="number">0.0f</span>,  <span class="number">0.5f</span>, <span class="number">0.0f</span>,  <span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">1.0f</span>    <span class="comment">// 顶部</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>由于现在有更多的数据要发送到顶点着色器，我们有必要去<strong>调整一下顶点着色器</strong>，使它能够<strong>接收颜色值作为一个顶点属性输入</strong>。需要注意的是我们用<code>layout</code>标识符来把<code>aColor</code>属性的位置值设置为<code>1</code>：</p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#version 330 core</span></span><br><span class="line"><span class="keyword">layout</span> (<span class="keyword">location</span> = <span class="number">0</span>) <span class="keyword">in</span> <span class="type">vec3</span> aPos;   <span class="comment">// 位置变量的属性位置值为 0</span></span><br><span class="line"><span class="keyword">layout</span> (<span class="keyword">location</span> = <span class="number">1</span>) <span class="keyword">in</span> <span class="type">vec3</span> aColor; <span class="comment">// 颜色变量的属性位置值为 1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">out</span> <span class="type">vec3</span> ourColor; <span class="comment">// 向片段着色器输出一个颜色</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> main() &#123;</span><br><span class="line">    <span class="built_in">gl_Position</span> = <span class="type">vec4</span>(aPos, <span class="number">1.0</span>);</span><br><span class="line">    ourColor = aColor; <span class="comment">// 将ourColor设置为我们从顶点数据那里得到的输入颜色</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于我们不再使用uniform来传递片段的颜色了，现在使用ourColor输出变量，我们必须再修改一下片段着色器：</p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#version 330 core</span></span><br><span class="line"><span class="keyword">out</span> <span class="type">vec4</span> FragColor;  </span><br><span class="line"><span class="keyword">in</span> <span class="type">vec3</span> ourColor;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> main() &#123;</span><br><span class="line">    FragColor = <span class="type">vec4</span>(ourColor, <span class="number">1.0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为我们添加了另一个顶点属性，并且更新了VBO的内存，我们就必须<strong>重新配置顶点属性指针</strong>。更新后的VBO内存中的数据现在看起来像这样：</p><div align="center"><p><img src="/images/learnopengl-c1-f8.jpg"></p></div><p>知道了现在使用的布局，我们就可以使用<code>glVertexAttribPointer</code>函数更新顶点格式，</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 位置属性</span></span><br><span class="line">glVertexAttribPointer(<span class="number">0</span>, <span class="number">3</span>, GL_FLOAT, GL_FALSE, <span class="number">6</span> * <span class="keyword">sizeof</span>(<span class="keyword">float</span>), (<span class="keyword">void</span>*)<span class="number">0</span>);</span><br><span class="line">glEnableVertexAttribArray(<span class="number">0</span>);</span><br><span class="line"><span class="comment">// 颜色属性</span></span><br><span class="line">glVertexAttribPointer(<span class="number">1</span>, <span class="number">3</span>, GL_FLOAT, GL_FALSE, <span class="number">6</span> * <span class="keyword">sizeof</span>(<span class="keyword">float</span>), (<span class="keyword">void</span>*)(<span class="number">3</span>* <span class="keyword">sizeof</span>(<span class="keyword">float</span>)));</span><br><span class="line">glEnableVertexAttribArray(<span class="number">1</span>);</span><br></pre></td></tr></table></figure><p>glVertexAttribPointer函数的前几个参数比较明了。这次我们配置属性位置值为1的顶点属性。颜色值有3个float那么大，我们不去标准化这些值。</p><p>由于我们现在有了两个顶点属性，我们不得不<strong>重新计算步长值</strong>。为获得数据队列中下一个属性值（比如位置向量的下个x分量）我们必须向右移动6个float，其中3个是位置值，另外3个是颜色值。这使我们的步长值为<strong>6乘以float的字节数**</strong>（=24字节）。</p><p>同样，这次我们必须指定一个偏移量。对于每个顶点来说，位置顶点属性在前，所以它的偏移量是0。颜色属性紧随位置数据之后，所以<strong>偏移量</strong>就是3 * sizeof(float)，用字节来计算就是12字节。</p><div align="center"><p><img src="/images/learnopengl-c1-f9.jpg" alt="沿用了上一节的矩形渲染"></p></div><p>这个图片可能不是你所期望的那种，因为我们只提供了3个颜色，而不是我们现在看到的大调色板。这是在片段着色器中进行的所谓<strong>片段插值</strong>(Fragment Interpolation)的结果。当渲染一个三角形时，<strong>光栅化</strong>(Rasterization)阶段通常会造成比原指定顶点<strong>更多的片段</strong>。光栅会根据<strong>每个片段在三角形形状上所处相对位置</strong>决定这些片段的位置（属性？）。</p><h3 id="我们自己的着色器类"><a href="#我们自己的着色器类" class="headerlink" title="我们自己的着色器类"></a>我们自己的着色器类</h3><p>编写、编译、管理着色器是件麻烦事。在着色器主题的最后，我们会<strong>写一个类</strong>来让我们的生活轻松一点，它可以<strong>从硬盘读取着色器</strong>，然后<strong>编译并链接它们</strong>，并对它们进行错误检测，这就变得很好用了。这也会让你了解该如何封装目前所学的知识到一个抽象对象中。</p><p>我们会把<strong>着色器类全部放在在头文件里</strong>，主要是为了学习用途，当然也方便移植。我们先来添加必要的include，并定义类结构：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> SHADER_H <span class="comment">// 避免重复include</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SHADER_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;glad/glad.h&gt;; // 包含glad来获取所有的必须OpenGL头文件</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Shader</span> &#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="comment">// 程序ID</span></span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">int</span> ID;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 构造器读取并构建着色器</span></span><br><span class="line">        Shader(<span class="keyword">const</span> GLchar* vertexPath, <span class="keyword">const</span> GLchar* fragmentPath);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 使用/激活程序</span></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">use</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// uniform工具函数</span></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">setBool</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp;name, <span class="keyword">bool</span> value)</span> <span class="keyword">const</span></span>;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">setInt</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp;name, <span class="keyword">int</span> value)</span> <span class="keyword">const</span></span>;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">setFloat</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp;name, <span class="keyword">float</span> value)</span> <span class="keyword">const</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>在上面，我们在<strong>头文件顶部使用了几个预处理指令</strong>(Preprocessor Directives)。这些预处理指令(<code>#ifndef SHADER_H</code>)会告知你的编译器<strong>只在它没被包含过的情况下才包含和编译这个头文件</strong>，<strong>即使多个文件都包含了这个着色器头文件</strong>。它是用来防止链接冲突的。</p><p><strong>着色器类储存了着色器程序的ID</strong>。它的构造器需要顶点和片段着色器源代码的文件路径，这样我们就可以把源码的文本文件储存在硬盘上了。除此之外，为了让我们的生活更轻松一点，还加入了一些工具函数：<code>use</code>用来激活着色器程序，所有的<code>set…</code>函数能够查询一个<code>unform</code>的位置值并设置它的值。</p><h3 id="从文件读取"><a href="#从文件读取" class="headerlink" title="从文件读取"></a>从文件读取</h3><p>我们使用C++文件流读取着色器内容，储存到几个string对象里：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 构造器读取并构建着色器</span></span><br><span class="line">Shader(<span class="keyword">const</span> GLchar* vertexPath, <span class="keyword">const</span> GLchar* fragmentPath) &#123;</span><br><span class="line">    <span class="comment">// 1. 从文件路径中获取顶点/片段着色器</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> vertexCode;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> fragmentCode;</span><br><span class="line">    <span class="built_in">std</span>::ifstream vShaderFile;</span><br><span class="line">    <span class="built_in">std</span>::ifstream fShaderFile;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 保证ifstream对象可以抛出异常</span></span><br><span class="line">    vShaderFile.exceptions(<span class="built_in">std</span>::ifstream::failbit | <span class="built_in">std</span>::ifstream::badbit);</span><br><span class="line">    fShaderFile.exceptions(<span class="built_in">std</span>::ifstream::failbit | <span class="built_in">std</span>::ifstream::badbit);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 打开文件</span></span><br><span class="line">        vShaderFile.open(vertexPath);</span><br><span class="line">        fShaderFile.open(fragmentPath);</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">stringstream</span> vShaderStream, fShaderStream;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 读取文件的缓冲内容到数据流中</span></span><br><span class="line">        vShaderStream &lt;&lt; vShaderFile.rdbuf();</span><br><span class="line">        fShaderStream &lt;&lt; fShaderFile.rdbuf();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 关闭文件处理器</span></span><br><span class="line">        vShaderFile.close();</span><br><span class="line">        fShaderFile.close();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 转换数据流到string</span></span><br><span class="line">        vertexCode = vShaderStream.str();</span><br><span class="line">        fragmentCode = fShaderStream.str();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (<span class="built_in">std</span>::ifstream::failure e) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;ERROR::SHADER::FILE_NOT_SUCCESFULLY_READ&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>* vShaderCode = vertexCode.c_str();</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>* fShaderCode = fragmentCode.c_str();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ... 后续代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下一步，我们需要<strong>编译和链接着色器</strong>。注意，我们也将检查编译/链接是否失败，如果失败则打印编译时错误，调试的时候这些错误输出会及其重要（你总会需要这些错误日志的）：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 构造器读取并构建着色器</span></span><br><span class="line">Shader(<span class="keyword">const</span> GLchar* vertexPath, <span class="keyword">const</span> GLchar* fragmentPath) &#123;</span><br><span class="line">    <span class="comment">// 1. 从文件路径中获取顶点/片段着色器</span></span><br><span class="line">    <span class="comment">// ... 这部分代码见上面</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 编译着色器</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> vertexShader, fragmentShader;</span><br><span class="line">    <span class="keyword">int</span> success;</span><br><span class="line">    <span class="keyword">char</span> infoLog[<span class="number">512</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 顶点着色器</span></span><br><span class="line">    vertexShader = glCreateShader(GL_VERTEX_SHADER);</span><br><span class="line">    glShaderSource(vertexShader, <span class="number">1</span>, &amp;vShaderCode, <span class="literal">NULL</span>);</span><br><span class="line">    glCompileShader(vertexShader);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打印编译错误（如果有的话）</span></span><br><span class="line">    glGetShaderiv(vertexShader, GL_COMPILE_STATUS, &amp;success);</span><br><span class="line">    <span class="keyword">if</span> (!success) &#123;</span><br><span class="line">        glGetShaderInfoLog(vertexShader, <span class="number">512</span>, <span class="literal">NULL</span>, infoLog);</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;ERROR::SHADER::VERTEX::COMPILATION_FAILED\n&quot;</span> &lt;&lt; infoLog &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 片段着色器</span></span><br><span class="line">    fragmentShader = glCreateShader(GL_FRAGMENT_SHADER);</span><br><span class="line">    glShaderSource(fragmentShader, <span class="number">1</span>, &amp;fShaderCode, <span class="literal">NULL</span>);</span><br><span class="line">    glCompileShader(fragmentShader);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打印编译错误（如果有的话）</span></span><br><span class="line">    glGetShaderiv(fragmentShader, GL_COMPILE_STATUS, &amp;success);</span><br><span class="line">    <span class="keyword">if</span> (!success) &#123;</span><br><span class="line">        glGetShaderInfoLog(fragmentShader, <span class="number">512</span>, <span class="literal">NULL</span>, infoLog);</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;ERROR::SHADER::VERTEX::COMPILATION_FAILED\n&quot;</span> &lt;&lt; infoLog &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    ID = glCreateProgram();</span><br><span class="line">    glAttachShader(ID, vertexShader);</span><br><span class="line">    glAttachShader(ID, fragmentShader);</span><br><span class="line">    glLinkProgram(ID);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打印连接错误（如果有的话）</span></span><br><span class="line">    glGetProgramiv(ID, GL_LINK_STATUS, &amp;success);</span><br><span class="line">    <span class="keyword">if</span> (!success) &#123;</span><br><span class="line">        glGetProgramInfoLog(ID, <span class="number">512</span>, <span class="literal">NULL</span>, infoLog);</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;ERROR::SHADER::PROGRAM::LINKING_FAILED\n&quot;</span> &lt;&lt; infoLog &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 删除着色器，它们已经链接到我们的程序中了，已经不再需要了</span></span><br><span class="line">    glDeleteShader(vertexShader);</span><br><span class="line">    glDeleteShader(fragmentShader);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>use函数非常简单：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用/激活程序</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">use</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    glUseProgram(ID);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>uniform的setter函数也很类似：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// uniform工具函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setBool</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp;name, <span class="keyword">bool</span> value)</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">    glUniform1i(glGetUniformLocation(ID, name.c_str()), (<span class="keyword">int</span>)value);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setInt</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp;name, <span class="keyword">int</span> value)</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">    glUniform1i(glGetUniformLocation(ID, name.c_str()), value);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setFloat</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp;name, <span class="keyword">float</span> value)</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">    glUniform1f(glGetUniformLocation(ID, name.c_str()), value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在我们就写完了一个完整的着色器类。使用这个着色器类很简单；只要创建一个着色器对象，从那一点开始我们就可以开始使用了：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ... GLFW GLAD初始化</span></span><br><span class="line"><span class="comment">// ... VBO EBO VAO初始化</span></span><br><span class="line"><span class="function">Shader <span class="title">ourShader</span><span class="params">(<span class="string">&quot;shader.vs&quot;</span>, <span class="string">&quot;shader.fs&quot;</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(...) &#123;</span><br><span class="line">    <span class="comment">// ... 其他操作</span></span><br><span class="line">    ourShader.use(); <span class="comment">// 代替了原本的glUseProgram(shaderProgram);</span></span><br><span class="line">    <span class="comment">// 绑定VAO</span></span><br><span class="line">    glBindVertexArray(VAO);</span><br><span class="line">    <span class="comment">// 绘制</span></span><br><span class="line">    glDrawElements(GL_TRIANGLES, <span class="number">6</span>, GL_UNSIGNED_INT, <span class="number">0</span>);</span><br><span class="line">    <span class="comment">// 解绑VAO</span></span><br><span class="line">    glBindVertexArray(<span class="number">0</span>);</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们把顶点和片段着色器储存为两个叫做<code>shader.vs</code>和<code>shader.fs</code>的文件。你可以使用自己喜欢的名字命名着色器文件；我自己觉得用<code>.vs</code>和<code>.fs</code>作为扩展名很直观。</p><h2 id="纹理"><a href="#纹理" class="headerlink" title="纹理"></a>纹理</h2><p>我们已经了解到，我们可以为每个顶点添加颜色来增加图形的细节，从而创建出有趣的图像。但是，如果<strong>想让图形看起来更真实</strong>，我们就必须有足够多的顶点，从而指定足够多的颜色。这将会产生很多额外开销，因为每个模型都会需求更多的顶点，每个顶点又需求一个颜色属性。</p><p>艺术家和程序员更喜欢使用<strong>纹理</strong>(Texture)。纹理是一个2D图片（甚至也有1D和3D的纹理），它可以用来添加物体的细节；你可以想象纹理是一张绘有砖块的纸，无缝折叠贴合到你的3D的房子上，这样你的房子看起来就像有砖墙外表了。因为我们可以在一张图片上插入非常多的细节，这样就可以让物体非常精细而不用指定额外的顶点。</p><p>除了图像以外，<strong>纹理也可以被用来储存大量的数据，这些数据可以发送到着色器上</strong>（例如纹理深度信息），但是这不是我们现在的主题。</p><p>为了能够把<strong>纹理映射</strong>(Map)到三角形上，我们需要<strong>指定三角形的每个顶点各自对应纹理的哪个部分</strong>。这样每个顶点就会关联着一个<strong>纹理坐标</strong>(Texture Coordinate)，用来标明该<strong>从纹理图像的哪个部分采样</strong>（译注：采集片段颜色）。之后在图形的<strong>其它片段上进行片段插值</strong>(Fragment Interpolation)（插值纹理坐标）。</p><p>纹理坐标在<code>x</code>和<code>y</code>轴上，范围为<code>0</code>到<code>1</code>之间（注意我们使用的是<strong>2D纹理图像</strong>）。使用<strong>纹理坐标获取纹理颜色</strong>叫做<strong>采样</strong>(Sampling)。<strong>纹理坐标起始于</strong>(0, 0)，也就是<strong>纹理图片的左下角</strong>，终于(1, 1)，即纹理图片的<strong>右上角</strong>。下面的图片展示了我们是如何把纹理坐标映射到三角形上的。</p><div align="center"><p><img src="/images/learnopengl-c1-f10.jpg"></p></div><p>我们为三角形指定了<strong>3个纹理坐标点</strong>。如上图所示，我们希望三角形的<strong>左下角对应纹理的左下角</strong>，因此我们把三角形<strong>左下角</strong>顶点的纹理坐标设置为<code>(0, 0)</code>；三角形的上顶点对应于图片的上中位置所以我们把它的纹理坐标设置为<code>(0.5, 1.0)</code>；同理右下方的顶点设置为<code>(1, 0)</code>。我们只要给<strong>顶点着色器传递这三个纹理坐标就行了</strong>，接下来<strong>它们会被传片段着色器</strong>中，它会为<strong>每个片段进行纹理坐标的插值</strong>。</p><p>纹理坐标看起来就像这样：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">float</span> texCoords[] = &#123;</span><br><span class="line">    <span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="comment">// 左下角</span></span><br><span class="line">    <span class="number">1.0f</span>, <span class="number">0.0f</span>, <span class="comment">// 右下角</span></span><br><span class="line">    <span class="number">0.5f</span>, <span class="number">1.0f</span> <span class="comment">// 上中</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>对纹理采样的解释非常宽松，它可以<strong>采用几种不同的插值方式</strong>。所以我们<strong>需要自己告诉OpenGL该怎样对纹理采样</strong>。</p><h3 id="纹理环绕方式"><a href="#纹理环绕方式" class="headerlink" title="纹理环绕方式"></a>纹理环绕方式</h3><p>纹理坐标的范围通常是从(0, 0)到(1, 1)，那<strong>如果我们把纹理坐标设置在范围之外会发生什么</strong>？OpenGL默认的行为是<strong>重复这个纹理图像</strong>（我们基本上忽略浮点纹理坐标的整数部分），但OpenGL提供了更多的选择：</p><ul><li><code>GL_REPEAT</code>：对纹理的默认行为。重复纹理图像；</li><li><code>GL_MIRRORED_REPEAT</code>：和GL_REPEAT一样，但每次重复图片是镜像放置的；</li><li><code>GL_CLAMP_TO_EDGE</code>：纹理坐标会被约束在0到1之间，超出的部分会重复纹理坐标的边缘，产生一种边缘被拉伸的效果；</li><li><code>GL_CLAMP_TO_BORDER</code>：超出的坐标为用户指定的边缘颜色。</li></ul><p>当纹理坐标超出默认范围时，每个选项都有不同的视觉效果输出。我们来看看这些纹理图像的例子：</p><div align="center"><p><img src="/images/learnopengl-c1-f11.jpg"></p></div><p>前面提到的每个选项都可以使用<code>glTexParameter*</code>函数(*不是指针，是不同类型的重载，看后面代码就知道了)对<strong>单独的一个坐标轴(str)设置</strong>（s、t（如果是使用3D纹理那么还有一个r）它们和x、y、z是等价的）：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_MIRRORED_REPEAT);</span><br><span class="line">glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_MIRRORED_REPEAT);</span><br></pre></td></tr></table></figure><ul><li><strong>第一个参数</strong>指定了纹理目标；我们使用的是2D纹理，因此纹理目标是GL_TEXTURE_2D；</li><li><strong>第二个参数</strong>需要我们指定设置的选项与应用的纹理轴。我们打算配置的是WRAP选项，并且指定S和T轴；</li><li><strong>最后一个参数</strong>需要我们传递一个环绕方式(Wrapping)，在这个例子中OpenGL会给当前激活的纹理设定纹理环绕方式为GL_MIRRORED_REPEAT。</li></ul><p>如果我们选择<code>GL_CLAMP_TO_BORDER</code>选项，我们还需要指定一个边缘的颜色。这需要使用<code>glTexParameter</code>函数的<code>fv</code>后缀形式(float vector)，用<code>GL_TEXTURE_BORDER_COLOR</code>作为它的选项，并且传递一个float数组作为边缘的颜色值：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">float</span> borderColor[] = &#123; <span class="number">1.0f</span>, <span class="number">1.0f</span>, <span class="number">0.0f</span>, <span class="number">1.0f</span> &#125;;</span><br><span class="line">glTexParameterfv(GL_TEXTURE_2D, GL_TEXTURE_BORDER_COLOR, borderColor);</span><br></pre></td></tr></table></figure><h3 id="纹理过滤"><a href="#纹理过滤" class="headerlink" title="纹理过滤"></a>纹理过滤</h3><p><strong>纹理坐标</strong>不依赖于分辨率(Resolution)，它可以是任意浮点值，所以OpenGL需要知道怎样将<strong>纹理像素</strong>(Texture Pixel，也叫Texel，译注1)映射到<strong>纹理坐标</strong>。</p><p>当你有一个<strong>很大的物体</strong>但是<strong>纹理的分辨率很低</strong>的时候这就变得很重要了。你可能已经猜到了，OpenGL也有对于<strong>纹理过滤</strong>(Texture Filtering)的选项。纹理过滤有很多个选项，但是现在我们只讨论最重要的两种：<code>GL_NEAREST</code>和<code>GL_LINEAR</code>。</p><p><code>Texture Pixel</code>也叫<code>Texel</code>，你可以想象你打开一张.jpg格式图片，不断放大你会发现它是由无数像素点组成的，这个<strong>点就是纹理像素</strong>；注意不要和纹理坐标搞混，<strong>纹理坐标是你给模型顶点设置的那个数组</strong>，OpenGL以这个顶点的纹理坐标数据去查找纹理图像上的像素，然后进行采样提取纹理像素的颜色。</p><p><code>GL_NEAREST</code>（也叫<strong>邻近过滤</strong>，Nearest Neighbor Filtering）是<strong>OpenGL默认的纹理过滤方式</strong>。当设置为GL_NEAREST的时候，OpenGL会选择<strong>中心点最接近纹理坐标的那个像素</strong>。下图中你可以看到四个像素，加号代表纹理坐标。左上角那个纹理像素的中心距离纹理坐标最近，所以它会被选择为样本颜色：</p><div align="center"><p><img src="/images/learnopengl-c1-f12.jpg"></p></div><p><code>GL_LINEAR</code>（也叫线性过滤，(Bi)linear Filtering）它会基于纹理坐标附近的纹理像素，<strong>计算出一个插值</strong>，近似出这些纹理像素之间的颜色。<strong>一个纹理像素的中心距离纹理坐标越近，那么这个纹理像素的颜色对最终的样本颜色的贡献越大</strong>。下图中你可以看到返回的颜色是邻近像素的混合色：</p><div align="center"><p><img src="/images/learnopengl-c1-f13.jpg"></p></div><p>那么这两种纹理过滤方式有怎样的视觉效果呢？让我们看看在一个很大的物体上应用一张低分辨率的纹理会发生什么吧（纹理被放大了，每个纹理像素都能看到）：</p><div align="center"><p><img src="/images/learnopengl-c1-f14.jpg"></p></div><p><code>GL_NEAREST</code>产生了<strong>颗粒状的图案</strong>，我们能够清晰看到组成纹理的像素，而<code>GL_LINEAR</code>能够产生<strong>更平滑的图案</strong>，很难看出单个的纹理像素（但是变得有点模糊了）。GL_LINEAR可以产生更真实的输出，但有些开发者更喜欢8-bit风格，所以他们会用GL_NEAREST选项。</p><p>当进行<strong>放大</strong>(Magnify)和<strong>缩小</strong>(Minify)操作的时候可以设置纹理过滤的选项，比如你可以在<strong>纹理被缩小的时候使用邻近过滤</strong>，<strong>被放大时使用线性过滤</strong>。我们需要使用<code>glTexParameter*</code>函数为放大和缩小指定过滤方式。这段代码看起来会和纹理环绕方式的设置很相似：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_NEAREST);</span><br><span class="line">glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);</span><br></pre></td></tr></table></figure><h3 id="多级渐远纹理"><a href="#多级渐远纹理" class="headerlink" title="多级渐远纹理"></a>多级渐远纹理</h3><p>假设我们有一个包含着上千物体的大房间，每个物体上都有纹理。<strong>有些物体会很远，但其纹理会拥有与近处物体同样高的分辨率</strong>。由于<strong>远处的物体可能只产生很少的片段，OpenGL从高分辨率纹理中为这些片段获取正确的颜色值就很困难</strong>，因为它需要对一个<strong>跨过纹理很大部分的片段只拾取一个纹理颜色</strong>。在<strong>小物体上这会产生不真实的感觉</strong>，更不用说对它们使用<strong>高分辨率纹理浪费内存</strong>的问题了。</p><p>OpenGL使用一种叫做<strong>多级渐远纹理</strong>(Mipmap)的概念来解决这个问题，它简单来说就是一系列的纹理图像，<strong>后一个纹理图像是前一个的二分之一</strong>（宽高同时二分之一，总面积四分之一）。多级渐远纹理背后的理念很简单：<strong>距观察者的距离超过一定的阈值</strong>，OpenGL会使用<strong>不同的多级渐远纹理</strong>，即最适合物体的距离的那个。由于距离远，解析度不高也不会被用户注意到。同时，<strong>多级渐远纹理另一加分之处是它的性能非常好</strong>。让我们看一下多级渐远纹理是什么样子的：</p><div align="center"><p><img src="/images/learnopengl-c1-f15.jpg"></p></div><p>手工为每个纹理图像创建一系列多级渐远纹理很麻烦，幸好OpenGL有一个<code>glGenerateMipmaps</code>函数，在创建完一个纹理后调用它，<strong>OpenGL就会承担接下来的所有工作了</strong>。</p><p>在渲染中切换多级渐远纹理级别(Level)时，OpenGL在<strong>两个不同级别的多级渐远纹理层之间会产生不真实的生硬边界</strong>。就像普通的纹理过滤一样，切换多级渐远纹理级别时你也可以在<strong>两个不同多级渐远纹理级别之间使用NEAREST和LINEAR过滤</strong>。</p><p>为了指定不同多级渐远纹理级别之间的过滤方式，你可以使用下面<strong>四个选项中的一个代替原有的过滤方式</strong>：</p><ul><li><code>GL_NEAREST_MIPMAP_NEAREST</code>：使用<strong>最邻近的多级渐远纹理</strong>来匹配像素大小，并使用<strong>邻近插值进行纹理采样</strong>；</li><li><code>GL_LINEAR_MIPMAP_NEAREST</code>：使用<strong>最邻近的多级渐远纹理</strong>级别，并使用<strong>线性插值进行采样</strong>；</li><li><code>GL_NEAREST_MIPMAP_LINEAR</code>：在<strong>两个</strong>最匹配像素大小的<strong>多级渐远纹理之间进行线性插值</strong>，使用<strong>邻近插值进行采样</strong>；</li><li><code>GL_LINEAR_MIPMAP_LINEAR</code>：在<strong>两个</strong>邻近的<strong>多级渐远纹理之间使用线性插值</strong>，并使用<strong>线性插值进行采样</strong>。</li></ul><p>就像纹理过滤一样，我们可以使用<code>glTexParameteri</code>将过滤方式设置为前面四种提到的方法之一：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR_MIPMAP_LINEAR);</span><br><span class="line">glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);</span><br></pre></td></tr></table></figure><p>一个<strong>常见的错误</strong>是，将<strong>放大过滤</strong>的选项设置为<strong>多级渐远纹理过滤选项之一</strong>。<strong>这样没有任何效果</strong>，因为多级渐远纹理主要是使用在<strong>纹理被缩小的情况下</strong>的：<strong>纹理放大不会使用多级渐远纹理</strong>，为放大过滤设置多级渐远纹理的选项会产生一个GL_INVALID_ENUM错误代码。</p><h3 id="加载与创建纹理"><a href="#加载与创建纹理" class="headerlink" title="加载与创建纹理"></a>加载与创建纹理</h3><p>使用纹理之前要做的第一件事是把它们加载到我们的应用中。<strong>纹理图像可能被储存为各种各样的格式，每种都有自己的数据结构和排列</strong>，所以我们如何才能把这些图像加载到应用中呢？一个解决方案是选一个需要的文件格式，比如.PNG，然后自己写一个图像加载器，把图像转化为字节序列。<strong>写自己的图像加载器虽然不难，但仍然挺麻烦的</strong>，而且如果要支持更多文件格式呢？你就不得不为每种你希望支持的格式写加载器了。</p><p>另一个解决方案也许是一种更好的选择，使用一个<strong>支持多种流行格式的图像加载库</strong>来为我们解决这个问题。比如说我们要用的<code>stb_image.h</code>库。</p><p><code>stb_image.h</code>是Sean Barrett的一个非常流行的<strong>单头文件图像加载库</strong>，它能够加载<strong>大部分流行的文件格式</strong>，并且能够很简单得整合到你的工程之中。下载这一个头文件，将它以<code>stb_image.h</code>的名字加入你的工程，并另创建一个新的C++文件，输入以下代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> STB_IMAGE_IMPLEMENTATION</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;stb_image.h&quot;</span></span></span><br></pre></td></tr></table></figure><p>通过定义<code>STB_IMAGE_IMPLEMENTATION</code>，<strong>预处理器会修改头文件</strong>，让其<strong>只包含相关的函数定义源码</strong>，等于是将这个头文件变为一个 <code>.cpp</code> 文件了。现在只需要在你的程序中包含<code>stb_image.h</code>并编译就可以了。</p><p>下面的教程中，我们会使用一张木箱的图片。要使用<code>stb_image.h</code>加载图片，我们需要使用它的<code>stbi_load</code>函数：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> width, height, nrChannels;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span> *data = stbi_load(<span class="string">&quot;container.jpg&quot;</span>, &amp;width, &amp;height, &amp;nrChannels, <span class="number">0</span>);</span><br></pre></td></tr></table></figure><p>这个函数首先接受一个<strong>图像文件的位置</strong>作为输入。接下来它需要三个<code>int</code>作为它的第二、第三和第四个参数，<code>stb_image.h</code>将会用图像的<strong>宽度</strong>、<strong>高度</strong>和<strong>颜色通道的个数</strong>填充这三个变量。我们之后生成纹理的时候会用到的<strong>图像的宽度和高度的</strong>。</p><h3 id="生成纹理"><a href="#生成纹理" class="headerlink" title="生成纹理"></a>生成纹理</h3><p>和之前生成的OpenGL对象一样，<strong>纹理也是使用ID引用的</strong>。让我们来创建一个：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> texture;</span><br><span class="line">glGenTextures(<span class="number">1</span>, &amp;texture);</span><br></pre></td></tr></table></figure><p>glGenTextures函数<strong>首先需要输入生成纹理的数量</strong>（本例子中是1），然后把它们储存在<strong>第二个参数</strong>的unsigned int<strong>数组</strong>中（我们的例子中<strong>只是单独的一个</strong>unsigned int），就像其他对象一样，我们<strong>需要绑定它</strong>，<strong>让之后任何的纹理指令</strong>都可以<strong>配置当前绑定的纹理</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">glBindTexture(GL_TEXTURE_2D, texture);</span><br></pre></td></tr></table></figure><p>现在纹理已经绑定了，我们可以使用<strong>前面载入的图片数据生成一个纹理</strong>了。纹理可以通过<code>glTexImage2D</code>来生成：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">glTexImage2D(GL_TEXTURE_2D, <span class="number">0</span>, GL_RGB, width, height, <span class="number">0</span>, GL_RGB, GL_UNSIGNED_BYTE, data);</span><br><span class="line">glGenerateMipmap(GL_TEXTURE_2D);</span><br></pre></td></tr></table></figure><p><code>glTexImage2D</code>参数不少，所以我们一个一个地讲解：</p><ul><li><strong>第一个参数</strong>指定了<strong>纹理目标</strong>(Target)。设置为GL_TEXTURE_2D意味着会生成与<strong>当前绑定的纹理对象在同一个目标上的纹理</strong>（任何绑定到GL_TEXTURE_1D和GL_TEXTURE_3D的纹理<strong>不会受到影响</strong>）；</li><li><strong>第二个参数</strong>为纹理指定<strong>多级渐远纹理的级别</strong>，如果你希望<strong>单独手动设置每个多级渐远纹理的级别的话</strong>。这里我们填0，也就是基本级别。</li><li><strong>第三个参数</strong>告诉OpenGL我们希望把<strong>纹理储存为何种格式</strong>。我们的图像只有RGB值，因此我们也把纹理储存为RGB值。</li><li><strong>第四个和第五个参数</strong>设置<strong>最终的纹理</strong>的<strong>宽度和高度</strong>。我们之前加载图像的时候储存了它们，所以我们使用对应的变量；</li><li>第六个参数总是被设置为0（历史遗留的问题）；</li><li><strong>第七第八个参数</strong>定义了源图的<strong>格式和数据类型</strong>。我们使用<strong>RGB值加载这个图像</strong>，并把它们储存为<code>char(byte)</code>数组，我们将会传入对应值；</li><li><strong>最后一个参数</strong>是<strong>真正的图像数据</strong>（之前stbi_load加载的图像数据，<code>unsigned char* data</code>）。</li></ul><p>当调用glTexImage2D时，当前<strong>绑定的纹理对象</strong>就会被<strong>附加上纹理图像</strong>。然而，目前只有<strong>基本级别</strong>(Base-level)的纹理图像被加载了，如果要使用多级渐远纹理，我们<strong>必须手动设置所有不同的图像</strong>（不断递增<strong>第二个参数</strong>）。<strong>或者</strong>，直接在生成纹理之后调用<code>glGenerateMipmap</code>。这会为当前绑定的纹理<strong>自动生成所有需要的多级渐远纹理</strong>。</p><p>生成了纹理和相应的多级渐远纹理后，释放图像的内存是一个很好的习惯。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">stbi_image_free(data);</span><br></pre></td></tr></table></figure><p>生成一个纹理的过程应该看起来像这样：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> texture;</span><br><span class="line">glGenTextures(<span class="number">1</span>, &amp;texture);</span><br><span class="line">glBindTexture(GL_TEXTURE_2D, texture);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 为当前绑定的纹理对象设置环绕、过滤方式</span></span><br><span class="line">glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_REPEAT);</span><br><span class="line">glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_REPEAT);</span><br><span class="line">glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);</span><br><span class="line">glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 加载并生成纹理</span></span><br><span class="line"><span class="keyword">int</span> width, height, nrChannels;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span> *data = stbi_load(<span class="string">&quot;container.jpg&quot;</span>, &amp;width, &amp;height, &amp;nrChannels, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (data) &#123;</span><br><span class="line">    glTexImage2D(GL_TEXTURE_2D, <span class="number">0</span>, GL_RGB, width, height, <span class="number">0</span>, GL_RGB, GL_UNSIGNED_BYTE, data);</span><br><span class="line">    glGenerateMipmap(GL_TEXTURE_2D);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Failed to load texture&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 释放之前加载的图像</span></span><br><span class="line">stbi_image_free(data);</span><br><span class="line"><span class="comment">// glBindTexture(GL_TEXTURE_2D, 0); // 可选的解绑操作</span></span><br></pre></td></tr></table></figure><h3 id="应用纹理"><a href="#应用纹理" class="headerlink" title="应用纹理"></a>应用纹理</h3><p>后面的这部分我们会使用<code>glDrawElements</code>绘制「你好，三角形」教程最后一部分的矩形。我们需要告知OpenGL如何采样纹理，所以我们必须使用纹理坐标更新顶点数据：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">float</span> vertices[] = &#123;</span><br><span class="line"><span class="comment">//     ---- 位置 ----       ---- 颜色 ----     - 纹理坐标 -</span></span><br><span class="line">     <span class="number">0.5f</span>,  <span class="number">0.5f</span>, <span class="number">0.0f</span>,   <span class="number">1.0f</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span>,   <span class="number">1.0f</span>, <span class="number">1.0f</span>,   <span class="comment">// 右上</span></span><br><span class="line">     <span class="number">0.5f</span>, <span class="number">-0.5f</span>, <span class="number">0.0f</span>,   <span class="number">0.0f</span>, <span class="number">1.0f</span>, <span class="number">0.0f</span>,   <span class="number">1.0f</span>, <span class="number">0.0f</span>,   <span class="comment">// 右下</span></span><br><span class="line">    <span class="number">-0.5f</span>, <span class="number">-0.5f</span>, <span class="number">0.0f</span>,   <span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">1.0f</span>,   <span class="number">0.0f</span>, <span class="number">0.0f</span>,   <span class="comment">// 左下</span></span><br><span class="line">    <span class="number">-0.5f</span>,  <span class="number">0.5f</span>, <span class="number">0.0f</span>,   <span class="number">1.0f</span>, <span class="number">1.0f</span>, <span class="number">0.0f</span>,   <span class="number">0.0f</span>, <span class="number">1.0f</span>    <span class="comment">// 左上</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>由于我们添加了一个额外的顶点属性，我们必须告诉OpenGL我们新的顶点格式：</p><div align="center"><p><img src="/images/learnopengl-c1-f16.jpg"></p></div><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">glVertexAttribPointer(<span class="number">2</span>, <span class="number">2</span>, GL_FLOAT, GL_FALSE, <span class="number">8</span> * <span class="keyword">sizeof</span>(<span class="keyword">float</span>), (<span class="keyword">void</span>*)(<span class="number">6</span> * <span class="keyword">sizeof</span>(<span class="keyword">float</span>)));</span><br><span class="line">glEnableVertexAttribArray(<span class="number">2</span>);</span><br></pre></td></tr></table></figure><p>注意，我们同样需要<strong>调整前面两个顶点属性的步长参数</strong>为<code>8 * sizeof(float)</code>。</p><p>接着我们需要<strong>调整顶点着色器</strong>使其能够<strong>接受顶点坐标为一个顶点属性</strong>，并把坐标传给片段着色器：</p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#version 330 core</span></span><br><span class="line"><span class="keyword">layout</span> (<span class="keyword">location</span> = <span class="number">0</span>) <span class="keyword">in</span> <span class="type">vec3</span> aPos;</span><br><span class="line"><span class="keyword">layout</span> (<span class="keyword">location</span> = <span class="number">1</span>) <span class="keyword">in</span> <span class="type">vec3</span> aColor;</span><br><span class="line"><span class="keyword">layout</span> (<span class="keyword">location</span> = <span class="number">2</span>) <span class="keyword">in</span> <span class="type">vec2</span> aTexCoord;</span><br><span class="line"></span><br><span class="line"><span class="keyword">out</span> <span class="type">vec3</span> ourColor;</span><br><span class="line"><span class="keyword">out</span> <span class="type">vec2</span> TexCoord;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> main() &#123;</span><br><span class="line">    <span class="built_in">gl_Position</span> = <span class="type">vec4</span>(aPos, <span class="number">1.0</span>);</span><br><span class="line">    ourColor = aColor;</span><br><span class="line">    TexCoord = aTexCoord;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>片段着色器应该接下来会把输出变量TexCoord作为输入变量。</p><p><strong>片段着色器也应该能访问纹理对象</strong>，但是我们<strong>怎样能把纹理对象传给片段着色器呢</strong>？GLSL有一个<strong>供纹理对象使用的内建数据类型，叫做采样器</strong>(Sampler)，它以<strong>纹理类型作为后缀</strong>，比如sampler1D、sampler3D，或在我们的例子中的sampler2D。我们可以简单声明一个<code>uniform sampler2D</code>把一个纹理添加到片段着色器中，稍后我们会把纹理赋值给这个uniform。</p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#version 330 core</span></span><br><span class="line"><span class="keyword">out</span> <span class="type">vec4</span> FragColor;</span><br><span class="line"></span><br><span class="line"><span class="keyword">in</span> <span class="type">vec3</span> ourColor;</span><br><span class="line"><span class="keyword">in</span> <span class="type">vec2</span> TexCoord;</span><br><span class="line"></span><br><span class="line"><span class="keyword">uniform</span> <span class="type">sampler2D</span> ourTexture;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> main() &#123;</span><br><span class="line">    FragColor = <span class="built_in">texture</span>(ourTexture, TexCoord);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们使用GLSL内建的<code>texture</code>函数来<strong>采样纹理的颜色</strong>，它<strong>第一个参数</strong>是纹理采样器，<strong>第二个参数</strong>是对应的纹理坐标。texture函数会使用之前设置的纹理参数对相应的颜色值进行采样。这个片段着色器的输出就是纹理的（插值）纹理坐标上的(过滤后的)颜色。</p><p>现在只剩下在调用<code>glDrawElements</code>之前<strong>绑定纹理</strong>了，它会<strong>自动把纹理赋值给片段着色器的采样器</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">glBindTexture(GL_TEXTURE_2D, texture);</span><br><span class="line">glBindVertexArray(VAO);</span><br><span class="line">glDrawElements(GL_TRIANGLES, <span class="number">6</span>, GL_UNSIGNED_INT, <span class="number">0</span>);</span><br></pre></td></tr></table></figure><div align="center"><p><img src="/images/learnopengl-c1-f17.jpg"></p></div><p>我们还可以把得到的纹理颜色与顶点颜色混合，来获得更有趣的效果。我们只需把<strong>纹理颜色与顶点颜色在片段着色器中相乘</strong>来混合二者的颜色：</p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">FragColor = <span class="built_in">texture</span>(ourTexture, TexCoord) * <span class="type">vec4</span>(ourColor, <span class="number">1.0</span>);</span><br></pre></td></tr></table></figure><div align="center"><p><img src="/images/learnopengl-c1-f18.jpg"></p></div><h3 id="纹理单元"><a href="#纹理单元" class="headerlink" title="纹理单元"></a>纹理单元</h3><p>你可能会奇怪为什么<code>sampler2D</code>变量是个uniform，我们却不用<code>glUniform</code>给它赋值。使用<code>glUniform1i</code>，我们可以给<strong>纹理采样器分配一个位置值</strong>，这样的话我们能<strong>够在一个片段着色器中设置多个纹理</strong>。一个纹理的<strong>位置值</strong>通常称为一个<strong>纹理单元</strong>(Texture Unit)。一个纹理的<strong>默认纹理单元是0</strong>，它是默认的激活纹理单元，所以教程前面部分我们没有分配一个位置值。</p><p>纹理单元的<strong>主要目的</strong>是让我们在着色器中可以<strong>使用多于一个的纹理</strong>。通过把<strong>纹理单元赋值给采样器</strong>，我们可以<strong>一次绑定多个纹理</strong>，只要我们首先激活对应的纹理单元。就像<code>glBindTexture</code>一样，我们可以使用<code>glActiveTexture</code>激活纹理单元，传入我们需要使用的纹理单元：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">glActiveTexture(GL_TEXTURE0); <span class="comment">// 在绑定纹理之前先激活纹理单元</span></span><br><span class="line">glBindTexture(GL_TEXTURE_2D, texture);</span><br></pre></td></tr></table></figure><p>激活纹理单元之后，接下来的<code>glBindTexture</code>函数调用<strong>会绑定这个纹理到当前激活的纹理单元</strong>，纹理单元<code>GL_TEXTURE0</code><strong>默认总是被激活</strong>，所以我们在前面的例子里当我们使用glBindTexture的时候，无需激活任何纹理单元。</p><p>OpenGL<strong>至少保证</strong>有<strong>16个纹理单元</strong>供你使用，也就是说你可以激活从<code>GL_TEXTURE0</code>到<code>GL_TEXTRUE15</code>。它们都是按顺序定义的，所以我们也可以通过<code>GL_TEXTURE0 + 8</code>的方式获得GL_TEXTURE8，这在当我们<strong>需要循环一些纹理单元的时候会很有用</strong>。</p><p>我们仍然需要编辑片段着色器来接收另一个采样器。这应该相对来说非常直接了：</p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#version 330 core</span></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="keyword">uniform</span> <span class="type">sampler2D</span> texture1;</span><br><span class="line"><span class="keyword">uniform</span> <span class="type">sampler2D</span> texture2;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> main() &#123;</span><br><span class="line">    FragColor = <span class="built_in">mix</span>(<span class="built_in">texture</span>(texture1, TexCoord), <span class="built_in">texture</span>(texture2, TexCoord), <span class="number">0.2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最终输出颜色现在是两个纹理的结合。GLSL内建的<code>mix</code>函数需要接受<strong>两个值作为参数</strong>，并对它们根据<strong>第三个参数进行线性插值</strong>。如果第三个值是<code>0.0</code>，<strong>它会返回第一个输入</strong>；如果是<code>1.0</code>，会返回<strong>第二个输入值</strong>。<code>0.2</code>会返回<strong>80%的第一个输入颜色和20%的第二个输入颜色</strong>，即返回两个纹理的混合色。</p><p>我们现在需要载入并创建另一个纹理；你应该对这些步骤很熟悉了。记得创建另一个纹理对象，载入图片，使用glTexImage2D生成最终纹理。对于第二个纹理我们使用一张你学习OpenGL时的面部表情图片（草）。</p><p>为了使用<strong>第二个纹理（以及第一个）</strong>，我们必须改变一点渲染流程，<strong>先绑定两个纹理到对应的纹理单元</strong>，然后<strong>定义哪个uniform采样器对应哪个纹理单元</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">glActiveTexture(GL_TEXTURE0);</span><br><span class="line">glBindTexture(GL_TEXTURE_2D, texture1);</span><br><span class="line">glActiveTexture(GL_TEXTURE1);</span><br><span class="line">glBindTexture(GL_TEXTURE_2D, texture2);</span><br><span class="line"></span><br><span class="line">glBindVertexArray(VAO);</span><br><span class="line">glDrawElements(GL_TRIANGLES, <span class="number">6</span>, GL_UNSIGNED_INT, <span class="number">0</span>);</span><br></pre></td></tr></table></figure><p>我们还要通过使用<code>glUniform1i</code><strong>设置每个采样器</strong>的方式告诉OpenGL<strong>每个着色器采样器属于哪个纹理单元</strong>。我们只需要设置一次即可，所以这个会放在渲染循环的前面：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ourShader.use(); <span class="comment">// 不要忘记在设置uniform变量之前激活着色器程序！</span></span><br><span class="line">glUniform1i(glGetUniformLocation(ourShader.ID, <span class="string">&quot;texture1&quot;</span>), <span class="number">0</span>); <span class="comment">// 手动设置</span></span><br><span class="line">ourShader.setInt(<span class="string">&quot;texture2&quot;</span>, <span class="number">1</span>); <span class="comment">// 或者使用着色器类设置</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(...) &#123;</span><br><span class="line">    <span class="comment">// [...]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过使用<code>glUniform1i</code>设置采样器，我们保证了每个<code>uniform</code>采样器对应着正确的纹理单元。你应该能得到下面的结果：</p><div align="center"><p><img src="/images/learnopengl-c1-f20.jpg"></p></div><p>你可能注意到纹理上下颠倒了！这是因为<strong>OpenGL要求y轴0.0坐标是在图片的底部的</strong>，但是<strong>图片的y轴0.0坐标通常在顶部</strong>。很幸运，<code>stb_image.h</code>能够在图像加载时帮助我们<strong>翻转y轴</strong>，只需要在<strong>加载任何图像</strong>前加入以下语句即可：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">stbi_set_flip_vertically_on_load(<span class="literal">true</span>);</span><br></pre></td></tr></table></figure><p>在让stb_image.h在加载图片时翻转y轴之后你就应该能够获得下面的结果了：</p><div align="center"><p><img src="/images/learnopengl-c1-f21.jpg"></p></div><h3 id="练习题-1"><a href="#练习题-1" class="headerlink" title="练习题"></a>练习题</h3><ul><li>修改片段着色器，仅让笑脸图案朝另一个方向看；</li><li>尝试用不同的纹理环绕方式，设定一个从0.0f到2.0f范围内的（而不是原来的0.0f到1.0f）纹理坐标。试试看能不能在箱子的角落放置4个笑脸：参考解答，结果。记得一定要试试其它的环绕方式；</li><li>尝试在矩形上只显示纹理图像的中间一部分，修改纹理坐标，达到能看见单个的像素的效果。尝试使用GL_NEAREST的纹理过滤方式让像素显示得更清晰；</li><li>使用一个uniform变量作为mix函数的第三个参数来改变两个纹理可见度，使用上和下键来改变箱子或笑脸的可见度。</li></ul><h2 id="变换"><a href="#变换" class="headerlink" title="变换"></a>变换</h2><p>尽管我们现在已经知道了如何创建一个物体、着色、加入纹理，给它们一些细节的表现，但因为它们都还是静态的物体，仍是不够有趣。我们可以尝试着在<strong>每一帧改变物体的顶点并且重配置缓冲区从而使它们移动</strong>，但这<strong>太繁琐了</strong>，而且<strong>会消耗很多的处理时间</strong>。</p><p><strong>矩阵</strong>(Matrix)对象可以更好的<strong>变换</strong>(Transform)一个物体。当然，这并不是说我们会去讨论武术和数字虚拟世界（译注：Matrix同样也是电影「黑客帝国」的英文名，电影中人类生活在数字虚拟世界，主角（基努·里维斯）会武术）（草）。</p><p>为了深入了解变换，我们首先要在讨论矩阵之前进一步了解一下向量。这一节的目标是让你拥有将来需要的最基础的数学背景知识。如果你发现这节十分困难，尽量尝试去理解它们，当你以后需要它们的时候回过头来复习这些概念。</p><h3 id="向量"><a href="#向量" class="headerlink" title="向量"></a>向量</h3><p>向量最基本的定义就是一个方向。或者更正式的说，向量有一个方向(Direction)和大小(Magnitude，也叫做强度或长度)。向量可以在任意维度(Dimension)上，但是我们通常只使用2至4维。如果一个向量有2个维度，它表示一个平面的方向(想象一下2D的图像)，当它有3个维度的时候它可以表达一个3D世界的方向。</p><p>由于向量是一个方向，所以有些时候会很难形象地将它们用位置(Position)表示出来。为了让其更为直观，我们通常设定这个方向的原点为(0, 0, 0)，然后指向一个方向，对应一个点，使其变为位置向量(Position Vector)（你也可以把起点设置为其他的点，然后说：这个向量从这个点起始指向另一个点）。</p><p>注意，<strong>数学上是没有向量与标量相加这个运算的</strong>，但是很多线性代数的库都对它有支持（比如说我们用的GLM）。如果你使用过numpy的话，可以把它理解为Broadcasting。</p><p>我们使用**勾股定理(**Pythagoras Theorem)来获取向量的长度(Length)/大小(Magnitude)。</p><p>有一个特殊类型的向量叫做<strong>单位向量</strong>(Unit Vector)。单位向量有一个特别的性质——它的<strong>长度是1</strong>。我们可以用任意向量的每个分量除以向量的长度得到它的单位向量。我们把这种方法叫做一个<strong>向量的标准化</strong>(Normalizing)。单位向量头上有一个^样子的记号。</p><p>在相乘的时候我们有两种特定情况可以选择：一个是<strong>点乘</strong>(Dot Product)，记作<code>v⋅k</code>，另一个是<strong>叉乘</strong>(Cross Product)，记作<code>v×k</code>。</p><p>两个向量的<strong>点乘</strong>等于它们的<strong>数乘结果</strong>乘以<strong>两个向量之间夹角的余弦值</strong>。使用点乘可以很容易测试两个向量是否正交(Orthogonal)或平行（正交意味着两个向量互为直角）。你也可以通过点乘的结果计算<strong>两个非单位向量的夹角</strong>，点乘的结果除以两个向量的长度之积，得到的结果就是夹角的余弦值，即cosθ。点乘是通过将对应分量逐个相乘，然后再把所得积相加来计算的。</p><p><strong>叉乘只在3D空间中有定义</strong>，它需要两个不平行向量作为输入，生成一个正交于两个输入向量的第三个向量。如果输入的两个向量也是正交的，那么叉乘之后将会产生3个互相正交的向量。</p><div align="center"><p><img src="/images/learnopengl-c1-f22.jpg"></p></div><h3 id="矩阵"><a href="#矩阵" class="headerlink" title="矩阵"></a>矩阵</h3><p>矩阵中每一项叫做矩阵的元素(Element)。</p><p>矩阵可以通过(i, j)进行索引，i是行，j是列。矩阵有几个运算，分别是：矩阵加法、减法和乘法。</p><p>矩阵与标量之间的加减要处理到每一个元素上，和向量类似。</p><p>注意，<strong>数学上是没有矩阵与标量相加减的运算的</strong>，但是很多线性代数的库都对它有支持（比如说我们用的GLM）。如果你使用过numpy的话，可以把它理解为Broadcasting。</p><p><strong>矩阵与矩阵之间的加减</strong>就是两个矩阵<strong>对应元素的加减运算</strong>，所以总体的规则和与标量运算是差不多的，只不过在相同索引下的元素才能进行运算。这也就是说加法和减法<strong>只对同维度的矩阵才是有定义的</strong>。</p><p>和矩阵与标量的加减一样，矩阵与标量之间的乘法也是矩阵的<strong>每一个元素分别乘以该标量</strong>。现在我们也就能明白为什么这些<strong>单独的数字</strong>要叫做<strong>标量</strong>(Scalar)了。简单来说，<strong>标量就是用它的值缩放</strong>(Scale)<strong>矩阵的所有元素</strong>（译注：注意Scalar是由Scale + -ar演变过来的）。</p><p>矩阵之间的<strong>乘法</strong>不见得有多复杂，但的确很难让人适应。矩阵乘法基本上意味着遵照规定好的法则进行相乘。当然，相乘还有一些限制：</p><ol><li>只有当<strong>左侧</strong>矩阵的<strong>列数</strong>与<strong>右侧</strong>矩阵的<strong>行数</strong>相等，两个矩阵才能相乘；</li><li><strong>矩阵相乘不遵守交换律</strong>(Commutative)，也就是说A⋅B≠B⋅A。</li></ol><p>假设A ⋅ B = C，那么Cij的值为A矩阵的第i行向量与B矩阵的第j列向量的点积结果，这基本上就是矩阵乘法的内核。</p><h3 id="矩阵与向量相乘"><a href="#矩阵与向量相乘" class="headerlink" title="矩阵与向量相乘"></a>矩阵与向量相乘</h3><p>目前为止，通过这些教程我们已经相当了解向量了。我们用<strong>向量来表示位置，表示颜色，甚至是纹理坐标</strong>。如果我们有一个<code>M×N</code>维矩阵，我们可以用这个矩阵乘以我们的<code>N×1</code>向量，因为这个矩阵的列数等于向量的行数，所以它们就能相乘。</p><h3 id="单位矩阵"><a href="#单位矩阵" class="headerlink" title="单位矩阵"></a>单位矩阵</h3><p>在OpenGL中，由于某些原因（齐次坐标系，为了能够方便地在变换矩阵中加入平移变换）我们通常使用4×4的变换矩阵，而其中最重要的原因就是大部分的向量都是4分量的。我们能想到的最简单的变换矩阵就是单<strong>位矩阵</strong>(Identity Matrix)。这种变换矩阵使一个向量完全不变。</p><h3 id="缩放"><a href="#缩放" class="headerlink" title="缩放"></a>缩放</h3><p>对一个向量进行缩放(Scaling)就是对向量的长度进行缩放，而保持它的方向不变。由于我们进行的是2维或3维操作，我们可以分别定义一个有2或3个缩放变量的向量，每个变量缩放一个轴(x、y或z)。</p><p><strong>不均匀</strong>(Non-uniform)缩放，因为<strong>每个轴的缩放因子</strong>(Scaling Factor)<strong>都不一样</strong>。如果每个轴的缩放因子都一样那么就叫<strong>均匀缩放</strong>(Uniform Scale)。</p><div align="center"><p><img src="/images/learnopengl-c1-f23.jpg"></p></div><p>注意，第四个缩放向量仍然是1，因为在3D空间中缩放w分量是无意义的。w分量另有其他用途，在后面我们会看到。</p><h3 id="位移"><a href="#位移" class="headerlink" title="位移"></a>位移</h3><p>位移(Translation)是在原始向量的基础上加上另一个向量从而获得一个在不同位置的新向量的过程，从而在位移向量基础上移动了原始向量。</p><div align="center"><p><img src="/images/learnopengl-c1-f24.jpg"></p></div><p><strong>齐次坐标</strong>(Homogeneous Coordinates)：向量的w分量也叫<strong>齐次坐标</strong>。想要<strong>从齐次向量得到3D向量</strong>，我们<strong>可以把x、y和z坐标分别除以w坐标</strong>。我们通常不会注意这个问题，因为w分量通常是1.0。使用齐次坐标有几点好处：它允许我们在3D向量上进行位移（如果没有w分量我们是不能位移向量的），而且下一章我们会用w值创建3D视觉效果。如果一个向量的齐次坐标是0，这个坐标就是<strong>方向向量</strong>(Direction Vector)，因为w坐标是0，<strong>这个向量就不能位移</strong>（译注：这也就是我们说的不能位移一个方向）。</p><h3 id="旋转"><a href="#旋转" class="headerlink" title="旋转"></a>旋转</h3><p>首先我们来定义一个向量的旋转到底是什么。2D或3D空间中的旋转用<strong>角</strong>(Angle)来表示。角可以是<strong>角度制或弧度制的</strong>，<strong>周角</strong>是<strong>360角度</strong>或<strong>2PI弧度</strong>。我个人更喜欢用角度，因为它们看起来更直观。</p><p>大多数旋转函数需要用<strong>弧度制的角</strong>，但幸运的是角度制的角也可以很容易地转化为弧度制的：</p><ul><li><strong>弧度转角度</strong>：<code>角度 = (弧度 / PI) * 180.0f</code>；</li><li><strong>角度转弧度</strong>：<code>弧度 = (角度 / 180.0f) * PI</code>。</li></ul><p>PI约等于<code>3.14159265359</code>。</p><p>在3D空间中旋转需要定义一个<strong>角</strong>和一个<strong>旋转轴</strong>(Rotation Axis)，物体会沿着给定的旋转轴旋转特定角度。</p><p>旋转矩阵在3D空间中每个单位轴都有不同定义，旋转角度用θ表示。</p><p>沿x轴旋转：</p><div align="center"><p><img src="/images/learnopengl-c1-f25.jpg"></p></div><p>沿y轴旋转：</p><div align="center"><p><img src="/images/learnopengl-c1-f26.jpg"></p></div><p>沿z轴旋转：</p><div align="center"><p><img src="/images/learnopengl-c1-f27.jpg"></p></div><p>利用旋转矩阵我们可以把任意位置向量<strong>沿一个单位旋转轴进行旋转</strong>。也可以将多个矩阵复合，比如先沿着x轴旋转再沿着y轴旋转。但是这会很快导致一个问题——<strong>万向节死锁</strong>（Gimbal Lock）。在这里我们不会讨论它的细节，但是对于3D空间中的旋转，一个<strong>更好的模型是沿着任意的一个轴</strong>，而不是对一系列旋转矩阵进行复合。样的一个（超级麻烦的）矩阵是存在的，见下面这个公式，其中(Rx,Ry,Rz)代表任意旋转轴：</p><div align="center"><p><img src="/images/learnopengl-c1-f28.jpg"></p></div><p>在数学上讨论如何生成这样的矩阵仍然超出了本节内容。但是记住，<strong>即使这样一个矩阵也不能完全解决万向节死锁问题</strong>（尽管会极大地避免）。<strong>避免万向节死锁的真正解决方案是使用四元数</strong>(Quaternion)，它不仅更安全，而且计算会更有效率。</p><p>对四元数的理解会用到非常多的数学知识。如果你想了解四元数与3D旋转之间的关系，可以来阅读这篇的教程<a href="https://krasjet.github.io/quaternion/quaternion.pdf">四元数与三维旋转</a>。如果你对万向节死锁的概念仍不是那么清楚，可以来阅读教程的Bonus章节()。现在3Blue1Brown也已经开始了一个四元数的视频系列，他采用球极平面投影(Stereographic Projection)的方式将四元数投影到3D空间，同样有助于理解四元数的概念<a href="https://www.youtube.com/watch?v=d4EgbgTm0Bg">Visualizing quaternions</a>。</p><h3 id="矩阵的组合"><a href="#矩阵的组合" class="headerlink" title="矩阵的组合"></a>矩阵的组合</h3><p>使用矩阵进行变换的真正力量在于，根据矩阵之间的乘法，我们可以把<strong>多个变换组合到一个矩阵中</strong>。让我们看看我们是否能生成一个变换矩阵，让它组合多个变换。假设我们有一个顶点(x, y, z)，我们希望将其缩放2倍，然后位移(1, 2, 3)个单位。我们需要一个位移和缩放矩阵来完成这些变换。结果的变换矩阵看起来像这样：</p><div align="center"><p><img src="/images/learnopengl-c1-f29.jpg"></p></div><p>注意，<strong>当矩阵相乘时我们先写位移再写缩放变换的</strong>。矩阵乘法是不遵守交换律的，这意味着它们的顺序很重要。当矩阵相乘时，<strong>在最右边的矩阵是第一个与向量相乘的</strong>，所以你应该从右向左读这个乘法。建议您在组合矩阵时，<strong>先进行缩放操作，然后是旋转，最后才是位移</strong>，否则它们会（消极地）互相影响。比如，如果<strong>你先位移再缩放，位移的向量也会同样被缩放</strong>（译注：比如向某方向移动2米，2米也许会被缩放成1米）！</p><p>用最终的变换矩阵左乘我们的向量会得到以下结果：</p><div align="center"><p><img src="/images/learnopengl-c1-f30.jpg"></p></div><h3 id="实践"><a href="#实践" class="headerlink" title="实践"></a>实践</h3><p><strong>OpenGL没有自带任何的矩阵和向量知识</strong>，所以我们必须定义自己的数学类和函数。在教程中我们更希望抽象所有的数学细节，使用已经做好了的数学库。幸运的是，有个易于使用，<strong>专门为OpenGL量身定做的数学库，那就是GLM</strong>。</p><p>GLM是<code>OpenGL Mathematics</code>的缩写，它是一个只有头文件的库，也就是说我们只需包含对应的头文件就行了，不用链接和编译。GLM可以在它们的网站上下载<a href="https://github.com/g-truc/glm">OpenGL Mathematics</a>。把头文件的根目录复制到你的includes文件夹，然后你就可以使用这个库了。</p><p>PS：GLM库从0.9.9版本起，<strong>默认会将矩阵类型初始化为一个零矩阵</strong>（所有元素均为0），而<strong>不是单位矩阵</strong>（对角元素为1，其它元素为0）。如果你使用的是0.9.9或0.9.9以上的版本，你需要将所有的<strong>矩阵初始化</strong>改为 <code>glm::mat4 mat = glm::mat4(1.0f)</code>。如果你想与本教程的代码保持一致，请使用低于0.9.9版本的GLM，或者改用上述代码初始化所有的矩阵。</p><p>我们需要的GLM的大多数功能都可以从下面这3个头文件中找到：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;glm/glm.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;glm/gtc/matrix_transform.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;glm/gtc/type_ptr.hpp&gt;</span></span></span><br></pre></td></tr></table></figure><p>我们来看看是否可以利用我们刚学的变换知识把一个向量<code>(1, 0, 0)</code>位移<code>(1, 1, 0)</code>个单位（注意，我们把它定义为一个<code>glm::vec4</code>类型的值，齐次坐标设定为<code>1.0</code>）：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">glm::vec4 <span class="title">vec</span><span class="params">(<span class="number">1.0f</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">1.0f</span>)</span></span>;</span><br><span class="line"><span class="comment">// 译注：下面就是矩阵初始化的一个例子，如果使用的是0.9.9及以上版本</span></span><br><span class="line"><span class="comment">// 下面这行代码就需要改为:</span></span><br><span class="line">glm::mat4 trans = glm::mat4(<span class="number">1.0f</span>);</span><br><span class="line"><span class="comment">// 0.9.9以下的版本矩阵初始化为：</span></span><br><span class="line"><span class="comment">// glm::mat4 trans; // 会初始化为单位阵</span></span><br><span class="line">trans = glm::translate(trans, glm::vec3(<span class="number">1.0f</span>, <span class="number">1.0f</span>, <span class="number">0.0f</span>));</span><br><span class="line">vec = trans * vec;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; vec.x &lt;&lt; vec.y &lt;&lt; vec.z &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure><p>我们先用GLM内建的向量类定义一个叫做<code>vec</code>的向量。接下来定义一个<code>mat4</code>类型的<code>trans</code>，默认是一个<code>4×4</code>单位矩阵。下一步是创建一个变换矩阵，我们是把<strong>单位矩阵</strong>和<strong>一个位移向量</strong>传递给<code>glm::translate</code>函数来完成这个工作的（然后用给定的矩阵乘以位移矩阵就能获得最后需要的矩阵）。</p><p>之后我们把<strong>向量乘以位移矩阵并且输出最后的结果</strong>。如果你仍记得位移矩阵是如何工作的话，得到的向量应该是(1 + 1, 0 + 1, 0 + 0)，也就是(2, 1, 0)。这个代码片段将会输出210，所以这个位移矩阵是正确的。</p><p>我们来做些更有意思的事情，让我们来旋转和缩放之前教程中的那个箱子。首先我们把<strong>箱子逆时针旋转90度</strong>。然后<strong>缩放0.5倍</strong>，使它变成原来的一半大。我们先来创建变换矩阵：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">glm::mat4 trans = glm::mat4(<span class="number">1.0f</span>);</span><br><span class="line">trans = glm::rotate(trans, glm::radians(<span class="number">90.0f</span>), glm::vec3(<span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">1.0</span>));</span><br><span class="line">trans = glm::scale(trans, glm::vec3(<span class="number">0.5</span>, <span class="number">0.5</span>, <span class="number">0.5</span>));</span><br><span class="line"><span class="comment">// 注意这里的顺序 identity · rotate · scale · vector</span></span><br><span class="line"><span class="comment">// 感觉glm的函数是在原矩阵后面追加矩阵</span></span><br></pre></td></tr></table></figure><p>首先，我们把箱子在<strong>每个轴都缩放到0.5倍</strong>，然后<strong>沿z轴旋转90度</strong>。GLM希望它的角度是<strong>弧度制的</strong>(Radian)，所以我们使用<code>glm::radians</code>将角度转化为弧度。注意<strong>有纹理的那面矩形是在XY平面上的</strong>，所以我们需要把它绕着z轴旋转。因为我们把这个矩阵传递给了GLM的每个函数，<strong>GLM会自动将矩阵相乘</strong>，返回的结果是一个包括了多个变换的变换矩阵。</p><p><strong>下一个大问题是：如何把矩阵传递给着色器？</strong>我们在前面简单提到过GLSL里也有一个<code>mat4</code>类型。所以我们将修改<strong>顶点着色器</strong>让其接收一个<code>mat4</code>的<code>uniform</code>变量，然后再用矩阵<code>uniform</code>乘以位置向量：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#version 330 core</span></span><br><span class="line">layout (location = <span class="number">0</span>) in vec3 aPos;</span><br><span class="line">layout (location = <span class="number">1</span>) in vec2 aTexCoord;</span><br><span class="line"></span><br><span class="line">out vec2 TexCoord;</span><br><span class="line"></span><br><span class="line">uniform mat4 transform;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    gl_Position = transform * vec4(aPos, <span class="number">1.0f</span>);</span><br><span class="line">    TexCoord = vec2(aTexCoord.x, <span class="number">1.0</span> - aTexCoord.y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>GLSL也有<code>mat2</code>和<code>mat3</code>类型，从而允许了<strong>像向量一样的混合运算</strong>。前面提到的所有数学运算（像是<strong>标量-矩阵相乘</strong>，<strong>矩阵-向量相乘</strong>和<strong>矩阵-矩阵相乘</strong>）在矩阵类型里都可以使用。当出现特殊的矩阵运算的时候我们会特别说明。</p><p>在把位置向量传给gl_Position之前，我们先添加一个uniform，并且将其与变换矩阵相乘。我们的箱子现在应该是原来的二分之一大小并（向左）旋转了90度。当然，我们仍需要把变换矩阵传递给着色器：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> transformLoc = glGetUniformLocation(ourShader.ID, <span class="string">&quot;transform&quot;</span>);</span><br><span class="line">glUniformMatrix4fv(transformLoc, <span class="number">1</span>, GL_FALSE, glm::value_ptr(trans));</span><br></pre></td></tr></table></figure><p>我们首先查询uniform变量的地址，然后用有Matrix4fv后缀的glUniform函数把矩阵数据发送给着色器。<strong>第一个参数</strong>你现在应该很熟悉了，它是uniform的位置值。<strong>第二个参数</strong>告诉OpenGL我们将要<strong>发送多少个矩阵</strong>，这里是1。<strong>第三个参数</strong>询问我们我们是否希望<strong>对我们的矩阵进行置换</strong>(Transpose)，也就是说交换我们矩阵的行和列。OpenGL开发者通常使用一种<strong>内部矩阵布局</strong>，叫做<strong>列主序</strong>(Column-major Ordering)布局。<strong>GLM的默认布局就是列主序</strong>，所以并不需要置换矩阵，我们填<code>GL_FALSE</code>。<strong>最后一个参数</strong>是真正的矩阵数据，但是GLM并不是把它们的矩阵储存为OpenGL所希望接受的那种，因此我们要先用GLM的自带的函数<code>value_ptr</code>来变换这些数据。</p><p>我们创建了一个变换矩阵，在顶点着色器中声明了一个uniform，并把矩阵发送给了着色器，<strong>着色器会变换我们的顶点坐标</strong>。最后的结果应该看起来像这样：</p><div align="center"><p><img src="/images/learnopengl-c1-f31.jpg"></p></div><p>完美！我们的箱子向左侧旋转，并是原来的一半大小，所以变换成功了。我们现在做些更有意思的，<strong>看看我们是否可以让箱子随着时间旋转</strong>，我们还会重新把箱子放在窗口的右下角。要让箱子随着时间推移旋转，我们必须<strong>在游戏循环中更新变换矩阵</strong>，因为它在每一次渲染迭代中都要更新。我们使用<strong>GLFW的时间函数</strong>来获取不同时间的角度：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">glm::mat4 trans = glm::mat4(<span class="number">1.0f</span>);</span><br><span class="line">trans = glm::translate(trans, glm::vec3(<span class="number">0.5f</span>, <span class="number">-0.5f</span>, <span class="number">0.0f</span>));</span><br><span class="line">trans = glm::rotate(trans, (<span class="keyword">float</span>)glfwGetTime(), glm::vec3(<span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">1.0f</span>));</span><br></pre></td></tr></table></figure><p>要记住的是前面的例子中我们可以在任何地方声明变换矩阵，<strong>但是现在我们必须在每一次迭代中创建它</strong>，从而保证我们能够不断更新旋转角度。这也就意味着<strong>我们不得不在每次游戏循环的迭代中重新创建变换矩阵</strong>。通常在渲染场景的时候，我们也会有多个需要在每次渲染迭代中都<strong>用新值重新创建的变换矩阵</strong>。</p><p>在这里我们先把<strong>箱子围绕原点(0, 0, 0)旋转</strong>，之后，我们把<strong>旋转过后的箱子位移到屏幕的右下角</strong>。记住，<strong>实际的变换顺序应该与阅读顺序相反</strong>：尽管在代码中我们先位移再旋转，实际的变换却是先应用旋转再是位移的。</p><div align="center"><p><img src="/images/learnopengl-c1-f32.jpg"></p></div><p>下一节中，我们会讨论<strong>怎样使用矩阵为顶点定义不同的坐标空间</strong>。这将是我们进入实时3D图像的第一步！</p><h2 id="坐标系统"><a href="#坐标系统" class="headerlink" title="坐标系统"></a>坐标系统</h2><p>在上一个教程中，我们学习了如何有效地利用矩阵的变换来对所有顶点进行变换。OpenGL希望在<strong>每次顶点着色器运行后</strong>，我们<strong>可见的所有顶点都为标准化设备坐标</strong>(Normalized Device Coordinate, <strong>NDC</strong>)。也就是说，每个顶点的<code>x，y，z</code>坐标都应该在<code>-1.0</code>到<code>1.0</code>之间，超出这个坐标范围的顶点都将不可见。我们通常会自己设定一个坐标的范围，之后再在<strong>顶点着色器中</strong>将这些坐标变换为标准化设备坐标。然后将这些<strong>标准化设备坐标</strong>传入<strong>光栅器</strong>(Rasterizer)，将它们变换为屏幕上的二维坐标或像素。</p><p>将<strong>坐标变换为标准化设备坐标</strong>，接着<strong>再转化为屏幕坐标</strong>的过程通常是分步进行的，也就是类似于流水线那样子。在流水线中，物体的顶点在最终转化为屏幕坐标之前还会被变换到多个<strong>坐标系统</strong>(Coordinate System)。将物体的坐标变换到几个<strong>过渡坐标系</strong>(Intermediate Coordinate System)的优点在于，在这些特定的坐标系统中，一些操作或运算更加方便和容易，这一点很快就会变得很明显。对我们来说比较重要的总共有5个不同的坐标系统：</p><ul><li><strong>局部空间</strong>(Local Space，或者称为<strong>物体空间</strong>(Object Space))；</li><li><strong>世界空间</strong>(World Space)；</li><li><strong>观察空间</strong>(View Space，或者称为<strong>视觉空间</strong>(Eye Space))；</li><li><strong>裁剪空间</strong>(Clip Space)；</li><li><strong>屏幕空间</strong>(Screen Space)。</li></ul><p>这就是一个顶点在最终被转化为片段之前需要经历的所有不同状态。</p><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>为了将坐标<strong>从一个坐标系变换到另一个坐标系</strong>，我们需要用到<strong>几个变换矩阵</strong>，最重要的几个分别是<strong>模型</strong>(Model)、<strong>观察</strong>(View)、<strong>投影</strong>(Projection)三个矩阵。</p><p>我们的顶点坐标起始于<strong>局部空间</strong>(Local Space)，在这里它称为局部坐标(Local Coordinate)，它在之后会变为<strong>世界坐标</strong>(World Coordinate)，<strong>观察坐标</strong>(View Coordinate)，<strong>裁剪坐标</strong>(Clip Coordinate)，并最后以<strong>屏幕坐标</strong>(Screen Coordinate)的形式结束。下面的这张图展示了整个流程以及各个变换过程做了什么：</p><div align="center"><p><img src="/images/learnopengl-c1-f33.jpg"></p></div><ol><li><strong>局部坐标</strong>是对象相对于局部原点的坐标，也是<strong>物体起始的坐标</strong>；</li><li>下一步是将<strong>局部坐标变换为世界空间坐标</strong>，世界空间坐标是处于一个更大的空间范围的。这些坐<strong>标相对于世界的全局原点</strong>，它们会和其它物体一起相对于世界的原点进行摆放；</li><li>接下来我们将<strong>世界坐标变换为观察空间坐标</strong>，使得每个坐标都是<strong>从摄像机或者说观察者的角度进行观察的</strong>；</li><li>坐标到达观察空间之后，我们需要将其<strong>投影到裁剪坐标</strong>。裁剪坐标会被处理至<code>-1.0</code>到<code>1.0</code>的范围内，并<strong>判断哪些顶点将会出现在屏幕上</strong>（深度测试）；</li><li>最后，我们将<strong>裁剪坐标变换为屏幕坐标</strong>，我们将使用一个叫做<strong>视口变换</strong>(Viewport Transform)的过程。<strong>视口变换</strong>将位于<code>-1.0</code>到<code>1.0</code>范围的坐标变换到由<code>glViewport</code>函数所定义的坐标范围内。最后变换出来的坐标将会送到光栅器，将其转化为片段。</li></ol><p>我们之所以将顶点变换到各个不同的空间的原因是，<strong>有些操作在特定的坐标系统中才有意义且更方便</strong>。例如，<strong>当需要对物体进行修改的时候，在局部空间中来操作会更说得通</strong>；如果要<strong>对一个物体做出一个相对于其它物体位置</strong>的操作时，在<strong>世界坐标系</strong>中来做这个才更说得通，等等。</p><p>接下来我们将要更仔细地讨论各个坐标系统。</p><h3 id="局部空间"><a href="#局部空间" class="headerlink" title="局部空间"></a>局部空间</h3><p>局部空间是指物体所在的坐标空间，即对象最开始所在的地方。</p><p>模型的所有顶点都是在局部空间中：它们相对于你的物体来说都是局部的。</p><p>我们一直使用的那个箱子的顶点是被设定在-0.5到0.5的坐标范围中，<code>(0, 0)</code>是它的原点。这些都是局部坐标。</p><h3 id="世界空间"><a href="#世界空间" class="headerlink" title="世界空间"></a>世界空间</h3><p>如果我们将我们所有的物体导入到程序当中，它们有可能会全挤在世界的原点(0, 0, 0)上，这并不是我们想要的结果。<strong>我们想为每一个物体定义一个位置</strong>，从而能在更大的世界当中放置它们。世界空间中的坐标正如其名：<strong>是指顶点相对于世界的坐标</strong>。如果你希望将物体分散在世界上摆放（特别是非常真实的那样），这就是你希望物体变换到的空间。物体的坐标将会<strong>从局部变换到世界空间</strong>；该变换是由<strong>模型矩阵</strong>(Model Matrix)实现的。</p><p><strong>模型矩阵是一种变换矩阵</strong>，它能通过对物体进行<strong>位移、缩放、旋转</strong>来将它置于它本应该在的位置或朝向。你可以将它想像为变换一个房子，你需要先将它<strong>缩小</strong>（它在局部空间中太大了），并将其<strong>位移至郊区的一个小镇</strong>，然后在<strong>y轴上往左旋转一点以搭配附近的房子</strong>。你也可以把上一节将箱子到处摆放在场景中用的那个矩阵大致看作一个模型矩阵；我们将箱子的局部坐标变换到场景/世界中的不同位置。</p><h3 id="观察空间"><a href="#观察空间" class="headerlink" title="观察空间"></a>观察空间</h3><p><strong>观察空间</strong>经常被人们称之OpenGL的<strong>摄像机</strong>(Camera)（所以有时也称为摄像机空间(Camera Space)或视觉空间(Eye Space)）。<strong>观察空间</strong>是将世界空间坐标转化为<strong>用户视野前方的坐标而产生的结果</strong>。因此<strong>观察空间就是从摄像机的视角所观察到的空间</strong>。而这通常是由<strong>一系列的位移和旋转</strong>的组合来完成，平移/旋转场景从而使得特定的对象被变换到摄像机的前方。这些组合在一起的变换通常存储在一个<strong>观察矩阵</strong>(View Matrix)里，它被用来将世界坐标变换到观察空间。在下一节中我们将深入讨论如何创建一个这样的观察矩阵来模拟一个摄像机。</p><h3 id="裁剪空间"><a href="#裁剪空间" class="headerlink" title="裁剪空间"></a>裁剪空间</h3><p>在一个<strong>顶点着色器运行的最后</strong>，OpenGL期望所有的坐标都能落在一个特定的范围内，且<strong>任何在这个范围之外的点都应该被裁剪掉</strong>(Clipped)。被裁剪掉的坐标就会被忽略，所以<strong>剩下的坐标就将变为屏幕上可见的片段</strong>。这也就是<strong>裁剪空间</strong>(Clip Space)名字的由来。</p><p>为了将顶点坐标<strong>从观察变换到裁剪空间</strong>，我们需要定义一个<strong>投影矩阵</strong>(Projection Matrix)，它指定了一个<strong>范围的坐标</strong>，比如在<strong>每个维度上的-1000到1000</strong>。投影矩阵接着会将在这个指定的范围内的坐标变换为标准化设备坐标的范围<code>(-1.0, 1.0)</code>。所有在范围外的坐标不会被映射到在<code>-1.0</code>到<code>1.0</code>的范围之间，所以会被裁剪掉。在上面这个投影矩阵所指定的范围内，坐标<code>(1250, 500, 750)</code>将是不可见的，这是由于它的<strong>x坐标超出了范围</strong>，它被转化为一个大于<code>1.0</code>的标准化设备坐标，所以被裁剪掉了。</p><p>如果只是<strong>图元</strong>(Primitive)，例如三角形，的<strong>一部分超出了裁剪体积</strong>(Clipping Volume)，则OpenGL会<strong>重新构建这个三角形为一个或多个三角形让其能够适合这个裁剪范围</strong>。</p><p>由投影矩阵创建的<strong>观察箱</strong>(Viewing Box)被称为<strong>平截头体</strong>(Frustum)，每个出现在平截头体范围内的坐标都会最终出现在用户的屏幕上。将<strong>特定范围内的坐标转化到标准化设备坐标系的过程</strong>（而且它很容易被映射到2D观察空间坐标）被称之为<strong>投影</strong>(Projection)，因为使用投影矩阵能将<strong>3D坐标投影</strong>(Project)到很容易映射到<strong>2D的标准化设备坐标系中</strong>。</p><p>一旦所有顶点被变换到裁剪空间，最终的操作——<strong>透视除法</strong>(Perspective Division)将会执行，在这个过程中我们将位置向量的<code>x，y，z</code>分量分别除以向量的齐次<code>w</code>分量；透视除法是将<strong>4D裁剪空间坐标变换为3D标准化设备坐标的过程</strong>。这一步会在<strong>每一个顶点着色器运行的最后被自动执行</strong>。</p><p>在这一阶段之后，最终的坐标将会被映射到屏幕空间中（使用glViewport中的设定），并被<strong>变换成片段</strong>。</p><p>将<strong>观察坐标变换为裁剪坐标的投影矩阵</strong>可以为两种不同的形式，每种形式都定义了不同的平截头体。我们可以选择创建一个<strong>正射投影矩阵</strong>(Orthographic Projection Matrix)或一个<strong>透视投影矩阵</strong>(Perspective Projection Matrix)。</p><h3 id="正射投影"><a href="#正射投影" class="headerlink" title="正射投影"></a>正射投影</h3><p>正射投影矩阵定义了一个<strong>类似立方体的平截头箱，它定义了一个裁剪空间</strong>，在这空间之外的顶点都会被裁剪掉。创建一个正射投影矩阵需要指定<strong>可见平截头体</strong>的<strong>宽、高和长度</strong>。在使用正射投影矩阵变换至裁剪空间之后处于这个平截头体内的所有坐标将不会被裁剪掉。它的平截头体看起来像一个容器：</p><div align="center"><p><img src="/images/learnopengl-c1-f34.jpg"></p></div><p>上面的平截头体定义了可见的坐标，它由由<strong>宽、高</strong>、<strong>近</strong>(Near)<strong>平面和远</strong>(Far)<strong>平面</strong>所指定。任何出现在近平面之前或远平面之后的坐标都会被裁剪掉。正射平截头体<strong>直接将平截头体内部的所有坐标映射为标准化设备坐标</strong>，因为<strong>每个向量的w分量都没有进行改变</strong>；如果w分量等于1.0，透视除法则不会改变这个坐标。</p><p>要创建一个正射投影矩阵，我们可以使用GLM的内置函数<code>glm::ortho</code>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">glm::ortho(<span class="number">0.0f</span>, <span class="number">800.0f</span>, <span class="number">0.0f</span>, <span class="number">600.0f</span>, <span class="number">0.1f</span>, <span class="number">100.0f</span>);</span><br><span class="line"><span class="comment">//         left, right,  bottom, top,  near,  far</span></span><br></pre></td></tr></table></figure><p><strong>前两个参数</strong>指定了平截头体的<strong>左右坐标</strong>，<strong>第三和第四参数</strong>指定了平截头体的<strong>底部和顶部</strong>。通过这四个参数我们定义了<strong>近平面和远平面的大小</strong>，然后<strong>第五和第六个参数</strong>则定义了近平面和远平面的距离。这个投影矩阵会将处于这些<code>x，y，z</code>值范围内的坐标变换为标准化设备坐标。</p><p>正射投影矩阵直接将坐标映射到2D平面中，即你的屏幕，但实际上一个直接的投影矩阵<strong>会产生不真实的结果</strong>，因为这个投影<strong>没有将透视</strong>(Perspective)考虑进去。所以我们需要透视投影矩阵来解决这个问题。</p><h3 id="透视投影"><a href="#透视投影" class="headerlink" title="透视投影"></a>透视投影</h3><p>如果你曾经体验过实际生活给你带来的景象，你就会注意到<strong>离你越远的东西看起来更小</strong>。这个奇怪的效果称之为<strong>透视</strong>(Perspective)。<strong>透视的效果在我们看一条无限长的高速公路或铁路时尤其明显</strong>，正如下面图片显示的那样：</p><div align="center"><p><img src="/images/learnopengl-c1-f35.jpg"></p></div><p>正如你看到的那样，由于透视，<strong>这两条线在很远的地方看起来会相交</strong>。这正是透视投影想要模仿的效果，它是使用<strong>透视投影矩阵来完成的</strong>。这个投影矩阵将给定的平截头体范围映射到裁剪空间，除此之外还<strong>修改了每个顶点坐标的w值</strong>，从而<strong>使得离观察者越远的顶点坐标w分量越大</strong>。被变换到裁剪空间的坐标都会在<code>-w</code>到<code>w</code>的范围之间（<strong>任何大于这个范围的坐标都会被裁剪掉</strong>）。OpenGL要求所有可见的坐标都落在<code>-1.0</code>到<code>1.0</code>范围内，作为顶点着色器最后的输出，因此，一旦坐标在裁剪空间内之后，<strong>透视除法就会被应用到裁剪空间坐标上</strong>：</p><div align="center"><p><img src="/images/learnopengl-c1-f36.jpg"></p></div><p>顶点坐标的每个分量都会除以它的w分量，距离观察者越远顶点坐标就会越小。这是也是w分量非常重要的另一个原因，它能够帮助我们进行透视投影。最后的结果坐标就是处于标准化设备空间中的。如果你对正射投影矩阵和透视投影矩阵是如何计算的很感兴趣（且不会对数学感到恐惧的话）我推荐这篇由Songho写的<a href="http://www.songho.ca/opengl/gl_projectionmatrix.html">文章</a>。</p><p>在GLM中可以这样创建一个透视投影矩阵：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">glm::perspective(glm::radians(<span class="number">45.0f</span>), (<span class="keyword">float</span>)width/(<span class="keyword">float</span>)height, <span class="number">0.1f</span>, <span class="number">100.0f</span>);</span><br></pre></td></tr></table></figure><p>同样，<code>glm::perspective</code>所做的其实就是<strong>创建了一个定义了可视空间的大平截头体</strong>，任何在这个平截头体以外的东西最后都不会出现在裁剪空间体积内，并且将会受到裁剪。一个透视平截头体可以被看作一个<strong>不均匀形状的箱子</strong>，在这个箱子内部的每个坐标都会被映射到裁剪空间上的一个点。下面是一张透视平截头体的图片：</p><div align="center"><p><img src="/images/learnopengl-c1-f37.jpg"></p></div><p><code>glm::perspective</code>的第一个参数定义了<code>fov</code>的值，它表示的是<strong>视野</strong>(Field of View)，并且设置了<strong>观察空间的大小</strong>。如果想要一个真实的观察效果，它的值通常设置为<code>45.0f</code>，但想要一个末日风格的结果你可以将其设置一个更大的值。第二个参数设置了<strong>宽高比</strong>，<strong>由视口的宽除以高所得</strong>。<strong>第三和第四个参数</strong>设置了平截头体的<strong>近和远平面</strong>。我们通常设置近距离为<code>0.1f</code>，而远距离设为<code>100.0f</code>。所有在近平面和远平面内且处于平截头体内的顶点都会被渲染。</p><p>当你把透视矩阵的 <code>near</code> 值设置太大时（如<code>10.0f</code>），OpenGL会将靠近摄像机的坐标（在0.0f和10.0f之间）都裁剪掉，这会导致一个你在游戏中很熟悉的视觉效果：<strong>在太过靠近一个物体的时候你的视线会直接穿过去</strong>。</p><p>当使用正射投影时，每一个顶点坐标都会直接映射到裁剪空间中而不经过任何精细的透视除法（它仍然会进行透视除法，只是w分量没有被改变（它保持为1），因此没有起作用）。因为正射投影没有使用透视，远处的物体不会显得更小，所以产生奇怪的视觉效果。由于这个原因，正射投影主要用于二维渲染以及一些建筑或工程的程序，在这些场景中我们更希望顶点不会被透视所干扰。某些如 Blender 等进行三维建模的软件有时在建模时也会使用正射投影，因为它在各个维度下都更准确地描绘了每个物体。下面你能够看到在Blender里面使用两种投影方式的对比：</p><div align="center"><p><img src="/images/learnopengl-c1-f38.jpg"></p></div><h3 id="把它们都组合到一起"><a href="#把它们都组合到一起" class="headerlink" title="把它们都组合到一起"></a>把它们都组合到一起</h3><p>我们为上述的每一个步骤都创建了一个变换矩阵：<strong>模型矩阵</strong>、<strong>观察矩阵</strong>和<strong>投影矩阵</strong>。一个顶点坐标将会根据以下过程<strong>被变换到裁剪坐标</strong>：</p><div align="center"><p><img src="/images/learnopengl-c1-f39.jpg"></p></div><p>注意矩阵运算的顺序是相反的（<strong>记住我们需要从右往左阅读矩阵的乘法</strong>）。最后的顶点应该被赋值到顶点着色器中的<code>gl_Position</code>，OpenGL将会<strong>自动进行透视除法和裁剪</strong>。</p><p>然后呢？<strong>顶点着色器的输出要求所有的顶点都在裁剪空间内</strong>，这正是我们刚才使用变换矩阵所做的。OpenGL然后<strong>对裁剪坐标执行透视除法</strong>从而将<strong>它们变换到标准化设备坐标。</strong>OpenGL会使用<code>glViewPort</code>内部的参数来将标准化设备坐标映射到屏幕坐标，每个坐标都关联了一个屏幕上的点（在我们的例子中是一个800x600的屏幕）。这个过程称为<strong>视口变换</strong>。</p><h3 id="进入3D"><a href="#进入3D" class="headerlink" title="进入3D"></a>进入3D</h3><p>既然我们知道了如何将3D坐标变换为2D坐标，我们可以开始使用真正的3D物体，而不是枯燥的2D平面了。</p><p>在开始进行3D绘图时，我们首先<strong>创建一个模型矩阵</strong>。这个模型矩阵包含了<strong>位移、缩放与旋转操作</strong>，它们会被应用到所有物体的顶点上，<strong>以变换它们到全局的世界空间</strong>。让我们变换一下我们的平面，将其绕着<code>x</code>轴旋转，<strong>使它看起来像放在地上一样</strong>。这个模型矩阵看起来是这样的：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">glm::mat4 model = glm::mat4(<span class="number">1.0f</span>);</span><br><span class="line">model = glm::rotate(model, glm::radians(<span class="number">-55.0f</span>), glm::vec3(<span class="number">1.0f</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span>));</span><br></pre></td></tr></table></figure><p>通过将顶点坐标乘以这个模型矩阵，我们将该顶点坐标变换到世界坐标。我们的平面看起来就是在地板上，代表全局世界里的平面。</p><p>接下来我们需要创建一个<strong>观察矩阵</strong>。我们想要在场景里面<strong>稍微往后移动</strong>，以使得物体变成可见的（当在世界空间时，我们位于原点(0,0,0)）。要想在场景里面移动，先仔细想一想下面这个句子：</p><ul><li><strong>将摄像机向后移动，和将整个场景向前移动是一样的</strong>。</li></ul><p>这正是<strong>观察矩阵</strong>所做的，我们<strong>以相反于摄像机移动的方向移动整个场景</strong>。因为我们想要往后移动，并且OpenGL是一个<strong>右手坐标系</strong>(Right-handed System)，所以我们（摄像机）需要沿着<code>z</code>轴的正方向移动。我们会通过将场景沿着<code>z</code>轴负方向平移来实现。它会给我们一种<strong>我们在往后移动的感觉</strong>。</p><p><strong>右手坐标系</strong>(Right-handed System)：按照惯例，<strong>OpenGL是一个右手坐标系</strong>。简单来说，就是<strong>正x轴在你的右手边</strong>，<strong>正y轴朝上</strong>，而<strong>正z轴是朝向后方的</strong>。想象你的屏幕处于三个轴的中心，则正z轴穿过你的屏幕朝向你。坐标系画起来如下：</p><div align="center"><p><img src="/images/learnopengl-c1-f40.jpg"></p></div><p>为了理解为什么被称为右手坐标系，按如下的步骤做：</p><ul><li>沿着正y轴方向伸出你的右臂，手指着上方；</li><li>大拇指指向右方；</li><li>食指指向上方；</li><li>中指向下弯曲90度。</li></ul><p>如果你的动作正确，那么你的大拇指指向正x轴方向，食指指向正y轴方向，中指指向正z轴方向。<strong>如果你用左臂来做这些动作，你会发现z轴的方向是相反的</strong>。这个叫做<strong>左手坐标系</strong>，它被DirectX广泛地使用。注意在<strong>标准化设备坐标系</strong>中<strong>OpenGL实际上使用的是左手坐标系</strong>（投影矩阵交换了左右手）。</p><p>就目前来说，观察矩阵是这样的：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">glm::mat4 view = glm::mat4(<span class="number">1.0f</span>);</span><br><span class="line"><span class="comment">// 注意，我们将矩阵向我们要进行移动场景的反方向移动</span></span><br><span class="line"><span class="comment">// 因为这里真正移动的东西是场景而不是相机</span></span><br><span class="line">view = glm::translate(view, glm::vec3(<span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">-3.0f</span>));</span><br></pre></td></tr></table></figure><p>最后我们需要做的是定义一个<strong>投影矩阵</strong>。我们希望在场景中使用<strong>透视投影</strong>，所以像这样声明一个投影矩阵：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">glm::mat4 projection = glm::mat4(<span class="number">1.0f</span>);</span><br><span class="line">projection = glm::perspective(glm::radians(<span class="number">45.0f</span>), screenWidth / screenHeight, <span class="number">0.1f</span>, <span class="number">100.0f</span>);</span><br></pre></td></tr></table></figure><p>既然我们已经创建了<strong>变换矩阵</strong>，我们应该将它们<strong>传入顶点着色器</strong>。首先，让我们在顶点着色器中声明一个<code>uniform</code><strong>变换矩阵</strong>然后将它乘以顶点坐标：</p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#version 330 core</span></span><br><span class="line"><span class="keyword">layout</span> (<span class="keyword">location</span> = <span class="number">0</span>) <span class="keyword">in</span> <span class="type">vec3</span> aPos;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">uniform</span> <span class="type">mat4</span> model;</span><br><span class="line"><span class="keyword">uniform</span> <span class="type">mat4</span> view;</span><br><span class="line"><span class="keyword">uniform</span> <span class="type">mat4</span> projection;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> main() &#123;</span><br><span class="line">    <span class="comment">// 注意乘法要从右向左读</span></span><br><span class="line">    <span class="built_in">gl_Position</span> = projection * view * model * <span class="type">vec4</span>(aPos, <span class="number">1.0</span>);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们还应该将矩阵传入顶点着色器（这通常在每次的渲染迭代中进行，因为变换矩阵会经常变动）：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> modelLoc = glGetUniformLocation(ourShader.ID, <span class="string">&quot;model&quot;</span>);</span><br><span class="line">glUniformMatrix4fv(modelLoc, <span class="number">1</span>, GL_FALSE, glm::value_ptr(model));</span><br><span class="line"><span class="keyword">int</span> viewLoc = glGetUniformLocation(ourShader.ID, <span class="string">&quot;view&quot;</span>);</span><br><span class="line">glUniformMatrix4fv(viewLoc, <span class="number">1</span>, GL_FALSE, glm::value_ptr(view));</span><br><span class="line"><span class="keyword">int</span> projectionLoc = glGetUniformLocation(ourShader.ID, <span class="string">&quot;projection&quot;</span>);</span><br><span class="line">glUniformMatrix4fv(projectionLoc, <span class="number">1</span>, GL_FALSE, glm::value_ptr(projection));</span><br></pre></td></tr></table></figure><p>我们的顶点坐标已经使用模型、观察和投影矩阵进行变换了，最终的物体应该会：</p><ul><li>稍微向后倾斜至地板方向；</li><li>离我们有一些距离；</li><li>有透视效果（顶点越远，变得越小）。</li></ul><div align="center"><p><img src="/images/learnopengl-c1-f41.jpg"></p></div><h3 id="更多的3D"><a href="#更多的3D" class="headerlink" title="更多的3D"></a>更多的3D</h3><p>到目前为止，我们一直都在使用一个2D平面，而且甚至是在3D空间里！所以，让我们大胆地<strong>拓展我们的2D平面为一个3D立方体</strong>。要想渲染一个立方体，<strong>我们一共需要36个顶点</strong>（<code>6</code>个面 x 每个面有<code>2</code>个三角形组成 x 每个三角形有<code>3</code>个顶点）。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">float</span> vertices[] = &#123;</span><br><span class="line">    <span class="number">-0.5f</span>, <span class="number">-0.5f</span>, <span class="number">-0.5f</span>,  <span class="number">0.0f</span>, <span class="number">0.0f</span>,</span><br><span class="line">     <span class="number">0.5f</span>, <span class="number">-0.5f</span>, <span class="number">-0.5f</span>,  <span class="number">1.0f</span>, <span class="number">0.0f</span>,</span><br><span class="line">     <span class="number">0.5f</span>,  <span class="number">0.5f</span>, <span class="number">-0.5f</span>,  <span class="number">1.0f</span>, <span class="number">1.0f</span>,</span><br><span class="line">     <span class="number">0.5f</span>,  <span class="number">0.5f</span>, <span class="number">-0.5f</span>,  <span class="number">1.0f</span>, <span class="number">1.0f</span>,</span><br><span class="line">    <span class="number">-0.5f</span>,  <span class="number">0.5f</span>, <span class="number">-0.5f</span>,  <span class="number">0.0f</span>, <span class="number">1.0f</span>,</span><br><span class="line">    <span class="number">-0.5f</span>, <span class="number">-0.5f</span>, <span class="number">-0.5f</span>,  <span class="number">0.0f</span>, <span class="number">0.0f</span>,</span><br><span class="line"></span><br><span class="line">    <span class="number">-0.5f</span>, <span class="number">-0.5f</span>,  <span class="number">0.5f</span>,  <span class="number">0.0f</span>, <span class="number">0.0f</span>,</span><br><span class="line">     <span class="number">0.5f</span>, <span class="number">-0.5f</span>,  <span class="number">0.5f</span>,  <span class="number">1.0f</span>, <span class="number">0.0f</span>,</span><br><span class="line">     <span class="number">0.5f</span>,  <span class="number">0.5f</span>,  <span class="number">0.5f</span>,  <span class="number">1.0f</span>, <span class="number">1.0f</span>,</span><br><span class="line">     <span class="number">0.5f</span>,  <span class="number">0.5f</span>,  <span class="number">0.5f</span>,  <span class="number">1.0f</span>, <span class="number">1.0f</span>,</span><br><span class="line">    <span class="number">-0.5f</span>,  <span class="number">0.5f</span>,  <span class="number">0.5f</span>,  <span class="number">0.0f</span>, <span class="number">1.0f</span>,</span><br><span class="line">    <span class="number">-0.5f</span>, <span class="number">-0.5f</span>,  <span class="number">0.5f</span>,  <span class="number">0.0f</span>, <span class="number">0.0f</span>,</span><br><span class="line"></span><br><span class="line">    <span class="number">-0.5f</span>,  <span class="number">0.5f</span>,  <span class="number">0.5f</span>,  <span class="number">1.0f</span>, <span class="number">0.0f</span>,</span><br><span class="line">    <span class="number">-0.5f</span>,  <span class="number">0.5f</span>, <span class="number">-0.5f</span>,  <span class="number">1.0f</span>, <span class="number">1.0f</span>,</span><br><span class="line">    <span class="number">-0.5f</span>, <span class="number">-0.5f</span>, <span class="number">-0.5f</span>,  <span class="number">0.0f</span>, <span class="number">1.0f</span>,</span><br><span class="line">    <span class="number">-0.5f</span>, <span class="number">-0.5f</span>, <span class="number">-0.5f</span>,  <span class="number">0.0f</span>, <span class="number">1.0f</span>,</span><br><span class="line">    <span class="number">-0.5f</span>, <span class="number">-0.5f</span>,  <span class="number">0.5f</span>,  <span class="number">0.0f</span>, <span class="number">0.0f</span>,</span><br><span class="line">    <span class="number">-0.5f</span>,  <span class="number">0.5f</span>,  <span class="number">0.5f</span>,  <span class="number">1.0f</span>, <span class="number">0.0f</span>,</span><br><span class="line"></span><br><span class="line">     <span class="number">0.5f</span>,  <span class="number">0.5f</span>,  <span class="number">0.5f</span>,  <span class="number">1.0f</span>, <span class="number">0.0f</span>,</span><br><span class="line">     <span class="number">0.5f</span>,  <span class="number">0.5f</span>, <span class="number">-0.5f</span>,  <span class="number">1.0f</span>, <span class="number">1.0f</span>,</span><br><span class="line">     <span class="number">0.5f</span>, <span class="number">-0.5f</span>, <span class="number">-0.5f</span>,  <span class="number">0.0f</span>, <span class="number">1.0f</span>,</span><br><span class="line">     <span class="number">0.5f</span>, <span class="number">-0.5f</span>, <span class="number">-0.5f</span>,  <span class="number">0.0f</span>, <span class="number">1.0f</span>,</span><br><span class="line">     <span class="number">0.5f</span>, <span class="number">-0.5f</span>,  <span class="number">0.5f</span>,  <span class="number">0.0f</span>, <span class="number">0.0f</span>,</span><br><span class="line">     <span class="number">0.5f</span>,  <span class="number">0.5f</span>,  <span class="number">0.5f</span>,  <span class="number">1.0f</span>, <span class="number">0.0f</span>,</span><br><span class="line"></span><br><span class="line">    <span class="number">-0.5f</span>, <span class="number">-0.5f</span>, <span class="number">-0.5f</span>,  <span class="number">0.0f</span>, <span class="number">1.0f</span>,</span><br><span class="line">     <span class="number">0.5f</span>, <span class="number">-0.5f</span>, <span class="number">-0.5f</span>,  <span class="number">1.0f</span>, <span class="number">1.0f</span>,</span><br><span class="line">     <span class="number">0.5f</span>, <span class="number">-0.5f</span>,  <span class="number">0.5f</span>,  <span class="number">1.0f</span>, <span class="number">0.0f</span>,</span><br><span class="line">     <span class="number">0.5f</span>, <span class="number">-0.5f</span>,  <span class="number">0.5f</span>,  <span class="number">1.0f</span>, <span class="number">0.0f</span>,</span><br><span class="line">    <span class="number">-0.5f</span>, <span class="number">-0.5f</span>,  <span class="number">0.5f</span>,  <span class="number">0.0f</span>, <span class="number">0.0f</span>,</span><br><span class="line">    <span class="number">-0.5f</span>, <span class="number">-0.5f</span>, <span class="number">-0.5f</span>,  <span class="number">0.0f</span>, <span class="number">1.0f</span>,</span><br><span class="line"></span><br><span class="line">    <span class="number">-0.5f</span>,  <span class="number">0.5f</span>, <span class="number">-0.5f</span>,  <span class="number">0.0f</span>, <span class="number">1.0f</span>,</span><br><span class="line">     <span class="number">0.5f</span>,  <span class="number">0.5f</span>, <span class="number">-0.5f</span>,  <span class="number">1.0f</span>, <span class="number">1.0f</span>,</span><br><span class="line">     <span class="number">0.5f</span>,  <span class="number">0.5f</span>,  <span class="number">0.5f</span>,  <span class="number">1.0f</span>, <span class="number">0.0f</span>,</span><br><span class="line">     <span class="number">0.5f</span>,  <span class="number">0.5f</span>,  <span class="number">0.5f</span>,  <span class="number">1.0f</span>, <span class="number">0.0f</span>,</span><br><span class="line">    <span class="number">-0.5f</span>,  <span class="number">0.5f</span>,  <span class="number">0.5f</span>,  <span class="number">0.0f</span>, <span class="number">0.0f</span>,</span><br><span class="line">    <span class="number">-0.5f</span>,  <span class="number">0.5f</span>, <span class="number">-0.5f</span>,  <span class="number">0.0f</span>, <span class="number">1.0f</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>为了有趣一点，我们将让立方体随着时间旋转：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">model = glm::rotate(model, (<span class="keyword">float</span>)glfwGetTime() * glm::radians(<span class="number">50.0f</span>), glm::vec3(<span class="number">0.5f</span>, <span class="number">1.0f</span>, <span class="number">0.0f</span>));</span><br></pre></td></tr></table></figure><p>然后我们使用glDrawArrays来绘制立方体，但这一次总共有36个顶点：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">glDrawArrays(GL_TRIANGLES, <span class="number">0</span>, <span class="number">36</span>);</span><br></pre></td></tr></table></figure><div align="center"><p><img src="/images/learnopengl-c1-f42.jpg"></p></div><p>这的确有点像是一个立方体，但又有种说不出的奇怪。<strong>立方体的某些本应被遮挡住的面被绘制在了这个立方体其他面之上</strong>。之所以这样是因为OpenGL是<strong>一个三角形一个三角形地来绘制你的立方体的</strong>，所以即便之前那里有东西它也会覆盖之前的像素。因为这个原因，有些三角形会被绘制在其它三角形上面，虽然它们本不应该是被覆盖的。</p><p>幸运的是，OpenGL存储深度信息在一个叫做<strong>Z缓冲</strong>(Z-buffer)的缓冲中，它允许OpenGL决定<strong>何时覆盖一个像素而何时不覆盖</strong>。通过使用<strong>Z缓冲</strong>，我们可以配置OpenGL来进行深度测试。</p><h3 id="Z缓冲"><a href="#Z缓冲" class="headerlink" title="Z缓冲"></a>Z缓冲</h3><p>OpenGL存储它的<strong>所有深度信息于一个Z缓冲</strong>(Z-buffer)中，也被称为深度缓冲(Depth Buffer)。<strong>GLFW会自动为你生成这样一个缓冲</strong>（就像它也有一个颜色缓冲来存储输出图像的颜色）。深度值存储在<strong>每个片段里面</strong>（作为片段的z值），当片段想要输出它的颜色时，<strong>OpenGL会将它的深度值和z缓冲进行比较</strong>，如<strong>果当前的片段在其它片段之后，它将会被丢弃，否则将会覆盖</strong>。这个过程称为<strong>深度测试</strong>(Depth Testing)，它是由<strong>OpenGL自动完成的</strong>。</p><p>然而，如果我们想要确定OpenGL真的执行了深度测试，<strong>首先我们要告诉OpenGL我们想要启用深度测试，它默认是关闭的</strong>。我们可以通过<code>glEnable</code>函数来开启深度测试。<code>glEnable</code>和<code>glDisable</code>函数允许我们<strong>启用或禁用某个OpenGL功能</strong>。这个功能会一直保持启用/禁用状态，直到另一个调用来禁用/启用它。现在我们想启用深度测试，需要开启<code>GL_DEPTH_TEST</code>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">glEnable(GL_DEPTH_TEST);</span><br></pre></td></tr></table></figure><p>因为我们使用了深度测试，我们也想要在<strong>每次渲染迭代之前清除深度缓冲</strong>（否则前一帧的深度信息仍然保存在缓冲中）。就像清除颜色缓冲一样，我们可以通过在<code>glClear</code>函数中指定<code>DEPTH_BUFFER_BIT</code>位来清除深度缓冲：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);</span><br></pre></td></tr></table></figure><div align="center"><p><img src="/images/learnopengl-c1-f43.jpg"></p></div><h3 id="更多的立方体！"><a href="#更多的立方体！" class="headerlink" title="更多的立方体！"></a>更多的立方体！</h3><p>现在我们想在屏幕上<strong>显示10个立方体</strong>。每个立方体看起来都是一样的，区别在于它们在<strong>世界的位置及旋转角度不同</strong>。立方体的图形布局已经定义好了，所以当渲染更多物体的时候我们<strong>不需要改变我们的缓冲数组和属性数组</strong>，我们唯一需要做的<strong>只是改变每个对象的模型矩阵来将立方体变换到世界坐标系中</strong>。</p><p>首先，让我们<strong>为每个立方体定义一个位移向量来指定它在世界空间的位置</strong>。我们将在一个<code>glm::vec3</code>数组中定义<strong>10个立方体位置</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">glm::vec3 cubePositions[] = &#123;</span><br><span class="line">  glm::vec3( <span class="number">0.0f</span>,  <span class="number">0.0f</span>,  <span class="number">0.0f</span>), </span><br><span class="line">  glm::vec3( <span class="number">2.0f</span>,  <span class="number">5.0f</span>, <span class="number">-15.0f</span>), </span><br><span class="line">  glm::vec3(<span class="number">-1.5f</span>, <span class="number">-2.2f</span>, <span class="number">-2.5f</span>),  </span><br><span class="line">  glm::vec3(<span class="number">-3.8f</span>, <span class="number">-2.0f</span>, <span class="number">-12.3f</span>),  </span><br><span class="line">  glm::vec3( <span class="number">2.4f</span>, <span class="number">-0.4f</span>, <span class="number">-3.5f</span>),  </span><br><span class="line">  glm::vec3(<span class="number">-1.7f</span>,  <span class="number">3.0f</span>, <span class="number">-7.5f</span>),  </span><br><span class="line">  glm::vec3( <span class="number">1.3f</span>, <span class="number">-2.0f</span>, <span class="number">-2.5f</span>),  </span><br><span class="line">  glm::vec3( <span class="number">1.5f</span>,  <span class="number">2.0f</span>, <span class="number">-2.5f</span>), </span><br><span class="line">  glm::vec3( <span class="number">1.5f</span>,  <span class="number">0.2f</span>, <span class="number">-1.5f</span>), </span><br><span class="line">  glm::vec3(<span class="number">-1.3f</span>,  <span class="number">1.0f</span>, <span class="number">-1.5f</span>)  </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>现在，在游戏循环中，我们调用<code>glDrawArrays</code> 10次，但这次在我们渲染之前每次传入一个不同的模型矩阵到顶点着色器中。我们将会在<strong>游戏循环中创建一个小的循环用不同的模型矩阵渲染我们的物体10次</strong>。注意我们也对每个箱子加了一点旋转：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">glBindVertexArray(VAO);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">unsigned</span> <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">    glm::mat4 model = glm::mat4(<span class="number">1.0f</span>);;</span><br><span class="line">    model = glm::translate(model, cubePositions[i]);</span><br><span class="line">    <span class="keyword">float</span> angle = <span class="number">20.0f</span> * i;</span><br><span class="line">    model = glm::rotate(model, (<span class="keyword">float</span>)glfwGetTime() * glm::radians(angle), glm::vec3(<span class="number">1.0f</span>, <span class="number">0.3f</span>, <span class="number">0.5f</span>));</span><br><span class="line">    <span class="comment">// 这里需要给之前的Shader类添加一个setMat4函数 ，具体写法为：</span></span><br><span class="line">    <span class="comment">// glUniformMatrix4fv(glGetUniformLocation(ID, name.c_str()), 1, GL_FALSE, &amp;mat[0][0]);</span></span><br><span class="line">    ourShader.setMat4(<span class="string">&quot;model&quot;</span>, model);</span><br><span class="line"></span><br><span class="line">    glDrawArrays(GL_TRIANGLES, <span class="number">0</span>, <span class="number">36</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><div align="center"><p><img src="/images/learnopengl-c1-f44.jpg"></p></div><h3 id="练习题-2"><a href="#练习题-2" class="headerlink" title="练习题"></a>练习题</h3><ul><li>对GLM的projection函数中的FoV和aspect-ratio参数进行实验。看能否搞懂它们是如何影响透视平截头体的；</li><li>将观察矩阵在各个方向上进行位移，来看看场景是如何改变的。注意把观察矩阵当成摄像机对象；</li><li>使用模型矩阵只让是3倍数的箱子旋转（以及第1个箱子），而让剩下的箱子保持静止。</li></ul><h2 id="摄像机"><a href="#摄像机" class="headerlink" title="摄像机"></a>摄像机</h2><p>前面的教程中我们讨论了<strong>观察矩阵</strong>以及如何<strong>使用观察矩阵移动场景</strong>（我们向后移动了一点）。<strong>OpenGL本身没有摄像机</strong>(Camera)的概念，但我们<strong>可以通过把场景中的所有物体往相反方向移动的方式来模拟出摄像机</strong>，产生一种我们在移动的感觉，而不是场景在移动。</p><p>本节我们将会讨论如何在<strong>OpenGL中配置一个摄像机</strong>，并且将会讨论<strong>FPS风格的摄像机</strong>，让你能够在<strong>3D场景中自由移动</strong>。我们也会讨论<strong>键盘和鼠标输入</strong>，最终完成一个<strong>自定义的摄像机类</strong>。</p><h3 id="摄像机-观察空间"><a href="#摄像机-观察空间" class="headerlink" title="摄像机/观察空间"></a>摄像机/观察空间</h3><p>当我们讨论<strong>摄像机/观察空间</strong>(Camera/View Space)的时候，是在讨论<strong>以摄像机的视角作为场景原点时</strong>场景中所有的顶点坐标：观察矩阵把所有的世界坐标变换为相对于摄像机位置与方向的观察坐标。<strong>要定义一个摄像机</strong>，我们需要它在世界空间中的<strong>位置</strong>、<strong>观察的方向</strong>、一个<strong>指向它右侧的向量</strong>以及一个<strong>指向它上方的向量</strong>。细心的读者可能已经注意到我们实际上创建了一个<strong>三个单位轴相互垂直的</strong>、以<strong>摄像机的位置为原点的坐标系</strong>。</p><div align="center"><p><img src="/images/learnopengl-c1-f45.jpg"></p></div><ol><li>摄像机位置</li></ol><p>获取摄像机位置很简单。摄像机位置简单来说就是世界空间中一个<strong>指向摄像机位置的向量</strong>。我们把摄像机位置设置为上一节中的那个相同的位置：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">glm::vec3 cameraPos = glm::vec3(<span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">3.0f</span>);</span><br></pre></td></tr></table></figure><ol start="2"><li>摄像机方向</li></ol><p>下一个需要的向量是摄像机的方向，这里指的是摄像机指向哪个方向。<strong>现在我们让摄像机指向场景原点</strong>：``(0, 0, 0)。还记得如果将两个矢量相减，我们就能得到这两个矢量的差吗？<strong>用场景原点向量减去摄像机位置向量的结果就是摄像机的指向向量</strong>。由于我们知道<strong>摄像机指向z轴负方向</strong>，但我们<strong>希望方向向量</strong>(Direction Vector)<strong>指向摄像机的z轴正方向</strong>。如果我们交换相减的顺序，我们就会获得一个<strong>指向摄像机正z轴方向的向量</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">glm::vec3 cameraTarget = glm::vec3(<span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span>);</span><br><span class="line">glm::vec3 cameraDirection = glm::normalize(cameraPos - cameraTarget);</span><br></pre></td></tr></table></figure><p><strong>方向向量</strong>(Direction Vector)<strong>并不是最好的名字</strong>，因为它<strong>实际上指向从它到目标向量的相反方向</strong>（译注：注意看前面的那个图，蓝色的方向向量大概指向z轴的正方向，与摄像机实际指向的方向是正好相反的）。</p><ol start="3"><li>右轴</li></ol><p>我们需要的<strong>另一个向量是一个右向量</strong>(Right Vector)，它代表<strong>摄像机空间的x轴的正方向</strong>。为获取右向量我们需要先使用一个小技巧：先<strong>定义一个上向量</strong>(Up Vector)。接下来把<strong>上向量和第二步得到的方向向量进行叉乘</strong>。两个向量叉乘的结果会同时垂直于两向量，因此我们<strong>会得到指向x轴正方向的那个向量</strong>（如果我们交换两个向量叉乘的顺序就会得到相反的指向x轴负方向的向量）：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">glm::vec3 up = glm::vec3(<span class="number">0.0f</span>, <span class="number">1.0f</span>, <span class="number">0.0f</span>);</span><br><span class="line"><span class="comment">// 注意叉乘的顺序，右手系</span></span><br><span class="line">glm::vec3 cameraRight = glm::normalize(glm::cross(up, cameraDirection));</span><br></pre></td></tr></table></figure><ol start="4"><li>上轴</li></ol><p>现在我们已经有了x轴向量和z轴向量，获取一个指向摄像机的正y轴向量就相对简单了：我们把<strong>方向向量和右向量进行叉乘</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 注意叉乘顺序，右手系</span></span><br><span class="line">glm::vec3 cameraUp = glm::cross(cameraDirection, cameraRight);</span><br></pre></td></tr></table></figure><p>对于想学到更多数学原理的读者，提示一下，在线性代数中这个处理叫做<strong>格拉姆—施密特正交化</strong>(Gram-Schmidt Process)。使用这些<strong>摄像机向量</strong>我们就可以创建一个<code>LookAt</code>矩阵了，它在创建摄像机的时候非常有用。</p><h3 id="Look-At"><a href="#Look-At" class="headerlink" title="Look At"></a>Look At</h3><p>使用矩阵的好处之一是如果<strong>你使用3个相互垂直</strong>（或非线性）的<strong>轴</strong>定义了<strong>一个坐标空间</strong>，你可以用这<strong>3个轴</strong>外加<strong>一个平移向量</strong>来<strong>创建一个矩阵</strong>，并且你可以<strong>用这个矩阵乘以任何向量来将其变换到那个坐标空间</strong>。这正是LookAt矩阵所做的，现在我们有了3个相互垂直的轴和一个定义摄像机空间的位置坐标，我们可以创建我们自己的LookAt矩阵了：</p><div align="center"><p><img src="/images/learnopengl-c1-f46.jpg"></p></div><p>其中<strong>R是右向量</strong>，<strong>U是上向量</strong>，<strong>D是方向向量</strong>，<strong>P是摄像机位置向量</strong>。注意，<strong>位置向量是相反的</strong>，因为我们<strong>最终希望把世界平移到与我们自身移动的相反方向</strong>。把这个LookAt矩阵作为观察矩阵可以很高效地把<strong>所有世界坐标变换到刚刚定义的观察空间</strong>。LookAt矩阵就像它的名字表达的那样：它会创建一个看着(Look at)给定目标的观察矩阵。</p><p>幸运的是，<strong>GLM已经提供了这些支持</strong>。我们要做的<strong>只是定义一个摄像机位置</strong>，<strong>一个目标位置</strong>和<strong>一个表示世界空间中的上向量的向量</strong>（我们计算右向量使用的那个<strong>上向量</strong>）。接着GLM就会创建一个LookAt矩阵，我们可以把它当作我们的观察矩阵：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">glm::mat4 view = glm::mat4(<span class="number">1.0f</span>);</span><br><span class="line">view = glm::lookAt(glm::vec3(<span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">3.0f</span>),  <span class="comment">// position</span></span><br><span class="line">                   glm::vec3(<span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span>),  <span class="comment">// target position</span></span><br><span class="line">                   glm::vec3(<span class="number">0.0f</span>, <span class="number">1.0f</span>, <span class="number">0.0f</span>)); <span class="comment">// up vector</span></span><br></pre></td></tr></table></figure><p><code>glm::LookAt</code>函数需要一个<strong>位置、目标和上向量</strong>。它会创建一个和在上一节使用的一样的观察矩阵。</p><p>在讨论用户输入之前，我们先来做些有意思的事，把我们的摄像机在场景中旋转。我们会将摄像机的注视点保持在(0, 0, 0)。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">float</span> radius = <span class="number">10.f</span>;</span><br><span class="line"><span class="keyword">float</span> camX = <span class="built_in">sin</span>(glfwGetTime()) * radius;</span><br><span class="line"><span class="keyword">float</span> camZ = <span class="built_in">cos</span>(glfwGetTime()) * radius;</span><br><span class="line">glm::mat4 view = glm::mat4(<span class="number">1.0f</span>);</span><br><span class="line">view = glm::lookAt(</span><br><span class="line">    glm::vec3(camX, <span class="number">0.0f</span>, camZ), <span class="comment">// position</span></span><br><span class="line">    glm::vec3(<span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span>), <span class="comment">// target</span></span><br><span class="line">    glm::vec3(<span class="number">0.0f</span>, <span class="number">1.0f</span>, <span class="number">0.0f</span>)  <span class="comment">// up-vec</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure><div align="center"><p><img src="/images/learnopengl-c1-f47.jpg"></p></div><h3 id="自由移动"><a href="#自由移动" class="headerlink" title="自由移动"></a>自由移动</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">glm::vec3 cameraPos   = glm::vec3(<span class="number">0.0f</span>, <span class="number">0.0f</span>,  <span class="number">3.0f</span>);</span><br><span class="line">glm::vec3 cameraFront = glm::vec3(<span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">-1.0f</span>);</span><br><span class="line">glm::vec3 cameraUp    = glm::vec3(<span class="number">0.0f</span>, <span class="number">1.0f</span>,  <span class="number">0.0f</span>);</span><br><span class="line">glm::vec3 cameraRight = glm::normalize(glm::cross(cameraFront, cameraUp));</span><br></pre></td></tr></table></figure><p>注意，我们对<strong>右向量进行了标准化</strong>。如果我们没对这个向量进行标准化，最后的叉乘结果会<strong>根据cameraFront变量返回大小不同的向量</strong>。如果我们不对向量进行标准化，我们就得<strong>根据摄像机的朝向不同加速或减速移动了</strong>，但如果进行了<strong>标准化移动就是匀速的</strong>。</p><p>LookAt函数现在成了：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">glm::mat4 view = glm::lookAt(cameraPos, cameraPos + cameraFront, cameraUp);</span><br></pre></td></tr></table></figure><p>我们已经为GLFW的键盘输入定义过一个<code>process_input</code>函数了，我们来新添加几个需要检查的按键命令：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">float</span> cameraSpeed = <span class="number">0.05f</span>; <span class="comment">// adjust accordingly</span></span><br><span class="line"><span class="keyword">if</span> (glfwGetKey(window, GLFW_KEY_W) == GLFW_PRESS) &#123;</span><br><span class="line">    cameraPos += cameraSpeed * cameraFront;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (glfwGetKey(window, GLFW_KEY_S) == GLFW_PRESS) &#123;</span><br><span class="line">    cameraPos -= cameraSpeed * cameraFront;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (glfwGetKey(window, GLFW_KEY_A) == GLFW_PRESS) &#123;</span><br><span class="line">    cameraPos -= cameraSpeed * cameraRight;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (glfwGetKey(window, GLFW_KEY_W) == GLFW_PRESS) &#123;</span><br><span class="line">    cameraPos += cameraSpeed * cameraRight;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><div align="center"><p><img src="/images/learnopengl-c1-f48.jpg"></p></div><h3 id="移动速度"><a href="#移动速度" class="headerlink" title="移动速度"></a>移动速度</h3><p>目前我们的移动速度是个常量。理论上没什么问题，但是<strong>实际情况下根据处理器的能力不同</strong>，有些人可能<strong>会比其他人每秒绘制更多帧</strong>，也就是以<strong>更高的频率调用</strong>process_input函数。结果就是，根据配置的不同，有些人可能移动很快，而有些人会移动很慢。当你发布你的程序的时候，你必须<strong>确保它在所有硬件上移动速度都一样</strong>。</p><p>图形程序和游戏通常会跟踪一个<strong>时间差</strong>(Deltatime)<strong>变量</strong>，<strong>它储存了渲染上一帧所用的时间</strong>。我们把<strong>所有速度</strong>都去乘以<code>deltaTime</code>值。结果就是，如果我们的<code>deltaTime</code>很大，就意味着<strong>上一帧的渲染花费了更多时间</strong>，所以<strong>这一帧的速度需要变得更高来平衡渲染所花去的时间</strong>。使用这种方法时，无论你的电脑快还是慢，摄像机的速度都会相应平衡，这样每个用户的体验就都一样了。</p><p>我们跟踪两个全局变量来计算出<code>deltaTime</code>值：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">float</span> deltaTime = <span class="number">0.0f</span>; <span class="comment">// 当前帧与上一帧的时间差</span></span><br><span class="line"><span class="keyword">float</span> lastFrame = <span class="number">0.0f</span>; <span class="comment">// 上一帧的时间</span></span><br></pre></td></tr></table></figure><p>在每一帧中我们计算出<strong>新的</strong><code>deltaTime</code>以备后用。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">float</span> currentFrame = glfwGetTime();</span><br><span class="line">deltaTime = currentFrame - lastFrame;</span><br><span class="line">lastFrame = currentFrame;</span><br></pre></td></tr></table></figure><p>现在我们有了<code>deltaTime</code>，在计算速度的时候可以将其考虑进去了：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">float</span> cameraSpeed = <span class="number">2.5f</span> * deltaTime;</span><br></pre></td></tr></table></figure><div align="center"><p><img src="/images/learnopengl-c1-f49.jpg"></p></div><p>现在我们有了一个<strong>在任何系统上移动速度都一样的摄像机</strong>（近似一样）。</p><h3 id="视角移动"><a href="#视角移动" class="headerlink" title="视角移动"></a>视角移动</h3><p>现在还不能转向，移动很受限制，是时候加入鼠标了！</p><p>为了能够改变视角，我们需要根据鼠标的输入来该表<code>cameraFront</code>向量，然而，根据鼠标移动改变方向向量有点复杂，需要一些三角学知识。</p><p><strong>欧拉角</strong></p><p>欧拉角(Euler Angle)是可以表示3D空间中<strong>任何旋转的3个值</strong>，由莱昂哈德·欧拉(Leonhard Euler)在18世纪提出。一共有<strong>3种欧拉角</strong>：<strong>俯仰角</strong>(Pitch)、<strong>偏航角</strong>(Yaw)和<strong>滚转角</strong>(Roll)，下面的图片展示了它们的含义：</p><div align="center"><p><img src="/images/learnopengl-c1-f50.jpg"></p></div><p><strong>俯仰角</strong>是描述我们如何<strong>往上或往下看的角</strong>，可以在第一张图中看到。第二张图展示了<strong>偏航角</strong>，偏航角表示我们<strong>往左和往右看</strong>的程度。<strong>滚转角</strong>代表我们如何翻滚摄像机，通常在太空飞船的摄像机中使用。<strong>每个欧拉角都有一个值来表示</strong>，把三个角结合起来我们就能够计算3D空间中任何的旋转向量了。</p><p>对于我们的摄像机系统来说，我们只关心<strong>俯仰角和偏航角</strong>，所以我们不会讨论滚转角。给定一个<strong>俯仰角和偏航角</strong>，我们可以把它们<strong>转换为一个代表新的方向向量的3D向量</strong>。俯仰角和偏航角转换为方向向量的处理需要一些三角学知识，我们先从最基本的情况开始：</p><div align="center"><p><img src="/images/learnopengl-c1-f51.jpg"></p></div><p>如果我们把斜边边长定义为<code>1</code>，我们就能知道邻边的长度是<code>cos(x/h)=cos(x/1)=cosx</code>，它的对边是<code>sin(y/h)=sin(y/1)=siny</code>。这样我们获得了能够得到x和y方向长度的通用公式，它们取决于所给的角度。我们使用它来计算方向向量的分量：</p><div align="center"><p><img src="/images/learnopengl-c1-f52.jpg"></p></div><p>这个三角形看起来和前面的三角形很像，所以如果我们想象<strong>自己在xz平面上</strong>，<strong>看向y轴</strong>，我们可以基于第一个三角形计算来计算它的<strong>长度</strong>/<strong>y方向的强度</strong>(Strength)（我们往上或往下看多少）。从图中我们可以看到对于一个给定<strong>俯仰角</strong>的y值等于sinθ：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">direction.y = <span class="built_in">sin</span>(glm::radians(pitch)); <span class="comment">// 注意我们先把角度转为弧度</span></span><br></pre></td></tr></table></figure><p>这里我们只更新了y值，仔细观察x和z分量也被影响了。从三角形中我们可以看到它们的值等于：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">direction.x = <span class="built_in">cos</span>(glm::radians(pitch));</span><br><span class="line">direction.z = <span class="built_in">cos</span>(glm::radians(pitch));</span><br></pre></td></tr></table></figure><p>看看我们是否能够为偏航角找到需要的分量：</p><div align="center"><p><img src="/images/learnopengl-c1-f53.jpg"></p></div><p>就像俯仰角的三角形一样，我们可以看到<strong>x分量</strong>取决于<code>cos(yaw)</code>的值，z值同样取决于偏航角的正弦值。把这个加到前面的值中，会得到<strong>基于俯仰角和偏航角的方向向量</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">direction.x = <span class="built_in">cos</span>(glm::radians(pitch)) * <span class="built_in">cos</span>(glm::radians(yaw));</span><br><span class="line"><span class="comment">// 译注：direction代表摄像机的前轴(Front)，这个前轴是和本文第一幅图片的第二个摄像机的方向向量是相反的</span></span><br><span class="line">direction.y = <span class="built_in">sin</span>(glm::radians(pitch));</span><br><span class="line">direction.z = <span class="built_in">cos</span>(glm::radians(pitch)) * <span class="built_in">sin</span>(glm::radians(yaw));</span><br></pre></td></tr></table></figure><p>这样我们就有了一个可以把<strong>俯仰角和偏航角</strong>转化为用来自由旋转视角的摄像机的<strong>3维方向向量</strong>了。<strong>你可能会奇怪：我们怎么得到俯仰角和偏航角？</strong></p><p><strong>鼠标输入</strong></p><p>偏航角和俯仰角是通过鼠标（或手柄）移动获得的，<strong>水平的移动影响偏航角</strong>，<strong>竖直的移动影响俯仰角</strong>。它的原理就是，<strong>储存上一帧鼠标的位置，在当前帧中我们当前计算鼠标位置与上一帧的位置相差多少</strong>。如果<strong>水平/竖直差别越大</strong>那么<strong>俯仰角或偏航角就改变越大</strong>，也就是摄像机需要移动更多的距离。</p><p>首先我们要告诉<strong>GLFW</strong>，它应该<strong>隐藏光标</strong>，并<strong>捕捉</strong>(Capture)它。捕捉光标表示的是，如果<strong>焦点在你的程序上</strong>（译注：即表示你正在操作这个程序，Windows中拥有焦点的程序标题栏通常是有颜色的那个，而失去焦点的程序标题栏则是灰色的），<strong>光标应该停留在窗口中</strong>（除非程序失去焦点或者退出）。我们可以用一个简单地配置调用来完成：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">glfwSetInputMode(window, GLFW_CURSOR, GLFW_CURSOR_DISABLED);</span><br></pre></td></tr></table></figure><p>在调用这个函数之后，<strong>无论我们怎么去移动鼠标，光标都不会显示了，它也不会离开窗口</strong>（避免移出窗口就不能再旋转摄像机了）。对于FPS摄像机系统来说非常完美。</p><p>为了计算俯仰角和偏航角，我们需要让GLFW<strong>监听鼠标移动事件</strong>。（和键盘输入相似）我们会用一个<strong>回调函数来完成</strong>，函数的原型如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mouse_callback</span><span class="params">(GLFWwindow* window, <span class="keyword">double</span> xpos, <span class="keyword">double</span> ypos)</span></span>;</span><br></pre></td></tr></table></figure><p>这里的<code>xpos</code>和<code>ypos</code>代表当前<strong>鼠标的位置</strong>。当我们用GLFW注册了回调函数之后，鼠标一移动mouse_callback函数就会被调用：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">glfwSetCursorPosCallback(window, mouse_callback);</span><br></pre></td></tr></table></figure><p>在处理FPS风格摄像机的鼠标输入的时候，我们必须在<strong>最终获取方向向量之前</strong>做下面这几步：</p><ol><li>计算鼠标距上一帧的偏移量；</li><li>把偏移量添加到摄像机的俯仰角和偏航角中；</li><li>对偏航角和俯仰角进行最大和最小值的限制（视野限制）；</li><li>计算方向向量。</li></ol><p>第一步是计算鼠标自上一帧的偏移量。我们必须先在程序中储存上一帧的鼠标位置，我们把它的<strong>初始值设置为屏幕的中心</strong>（屏幕的尺寸是800x600）：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">float</span> lastX = <span class="number">400</span>, lastY = <span class="number">300</span>;</span><br></pre></td></tr></table></figure><p>然后在鼠标的回调函数中我们计算当前帧和上一帧鼠标位置的偏移量：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">float</span> xoffset = xpos - lastX;</span><br><span class="line"><span class="comment">// 注意这里是相反的，因为y坐标是从底部往顶部依次增大的</span></span><br><span class="line"><span class="keyword">float</span> yoffset = lastY - ypos;</span><br><span class="line">lastX = xpos;</span><br><span class="line">lastY = ypos;</span><br><span class="line"></span><br><span class="line"><span class="keyword">float</span> sensitivity = <span class="number">0.05f</span>;</span><br><span class="line">xoffset *= sensitivity;</span><br><span class="line">yoffset *= sensitivity;</span><br></pre></td></tr></table></figure><p>注意我们把偏移量乘以了<code>sensitivity</code>（灵敏度）值。如果我们忽略这个值，鼠标移动就会太大了；你可以自己实验一下，找到适合自己的灵敏度值。</p><p>接下来我们把偏移量加到全局变量<code>pitch</code>和<code>yaw</code>上：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">yaw   += xoffset;</span><br><span class="line">pitch += yoffset;</span><br></pre></td></tr></table></figure><p>第三步，我们需要给摄像机添加一些限制，<strong>这样摄像机就不会发生奇怪的移动了</strong>（这样也会避免一些奇怪的问题）。对于俯仰角，要让用户<strong>不能看向高于89度的地方</strong>（在90度时视角会发生逆转，所以我们把89度作为极限），<strong>同样也不允许小于-89度</strong>。这样能够保证用户只能看到天空或脚下，但是不能超越这个限制。我们可以在值超过限制的时候将其改为极限值来实现：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(pitch &gt; <span class="number">89.0f</span>)</span><br><span class="line">    pitch = <span class="number">89.0f</span>;</span><br><span class="line"><span class="keyword">if</span>(pitch &lt; <span class="number">-89.0f</span>)</span><br><span class="line">    pitch = <span class="number">-89.0f</span>;</span><br></pre></td></tr></table></figure><p>注意我们<strong>没有给偏航角设置限制</strong>，这是因为我们不希望限制用户的水平旋转。当然，给偏航角设置限制也很容易，如果你愿意可以自己实现。</p><p>第四也是最后一步，就是通过俯仰角和偏航角来计算以得到真正的方向向量：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">glm::vec3 front;</span><br><span class="line">front.x = <span class="built_in">cos</span>(glm::radians(pitch)) * <span class="built_in">cos</span>(glm::radians(yaw));</span><br><span class="line">front.y = <span class="built_in">sin</span>(glm::radians(pitch));</span><br><span class="line">front.z = <span class="built_in">cos</span>(glm::radians(pitch)) * <span class="built_in">sin</span>(glm::radians(yaw));</span><br><span class="line">cameraFront = glm::normalize(front);</span><br></pre></td></tr></table></figure><p>计算出来的方向向量就会包含根据鼠标移动计算出来的所有旋转了。由于cameraFront向量已经包含在GLM的lookAt函数中，我们这就没什么问题了。</p><div align="center"><p><img src="/images/learnopengl-c1-f54.jpg"></p></div><p>如果你现在运行代码，你会发现在窗口<strong>第一次获取焦点的时候摄像机会突然跳一下</strong>。这个问题产生的原因是，在你的<strong>鼠标移动进窗口的那一刻</strong>，鼠标回调函数就会被调用，这时候的xpos和ypos会等于鼠标刚刚进入屏幕的那个位置。<strong>这通常是一个距离屏幕中心很远的地方</strong>，因而产生一个很大的偏移量，所以就会跳了。我们可以简单的使用一个<code>bool</code>变量检验我们<strong>是否是第一次获取鼠标输入</strong>，如果是，那么我们先把鼠标的初始位置更新为xpos和ypos值，这样就能解决这个问题；接下来的鼠标移动就会使用刚进入的鼠标位置坐标来计算偏移量了：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这个bool变量初始时是设定为true的</span></span><br><span class="line"><span class="keyword">if</span>(firstMouse) &#123;</span><br><span class="line">    lastX = xpos;</span><br><span class="line">    lastY = ypos;</span><br><span class="line">    firstMouse = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后<code>mouse_callback</code>的代码应该是这样的：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mouse_callback</span><span class="params">(GLFWwindow* window, <span class="keyword">double</span> xpos, <span class="keyword">double</span> ypos)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 这个bool变量初始时是设定为true的</span></span><br><span class="line">    <span class="keyword">if</span> (firstMouse) &#123;</span><br><span class="line">        lastX = xpos;</span><br><span class="line">        lastY = ypos;</span><br><span class="line">        firstMouse = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 偏航角从-90度开始，鼠标向左移动，值变的更小</span></span><br><span class="line">    <span class="comment">// 视角要朝左旋转的话，就要更小的偏航角值</span></span><br><span class="line">    <span class="comment">// 所以直接加上 xpose - lastX即可</span></span><br><span class="line">    <span class="keyword">float</span> xoffset = xpos - lastX;</span><br><span class="line">    <span class="comment">// 而俯仰角是相反的，鼠标向上移动，值变的更小</span></span><br><span class="line">    <span class="comment">// 视角要朝上旋转的话，就要更大的俯仰角</span></span><br><span class="line">    <span class="comment">// 所以要反过来减两个坐标的差值</span></span><br><span class="line">    <span class="keyword">float</span> yoffset = lastY - ypos;</span><br><span class="line">    lastX = xpos;</span><br><span class="line">    lastY = ypos;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">float</span> sensitivity = <span class="number">0.05f</span>;</span><br><span class="line">    xoffset *= sensitivity;</span><br><span class="line">    yoffset *= sensitivity;</span><br><span class="line"></span><br><span class="line">    yaw += xoffset;</span><br><span class="line">    pitch += yoffset;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (pitch &gt; <span class="number">89.0f</span>) &#123;</span><br><span class="line">        pitch = <span class="number">89.0f</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (pitch &lt; <span class="number">-89.0f</span>) &#123;</span><br><span class="line">        pitch = <span class="number">-89.0f</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    glm::vec3 front;</span><br><span class="line">    front.x = <span class="built_in">cos</span>(glm::radians(pitch)) * <span class="built_in">cos</span>(glm::radians(yaw));</span><br><span class="line">    front.y = <span class="built_in">sin</span>(glm::radians(pitch));</span><br><span class="line">    front.z = <span class="built_in">cos</span>(glm::radians(pitch)) * <span class="built_in">sin</span>(glm::radians(yaw));</span><br><span class="line">    cameraFront = glm::normalize(front);</span><br><span class="line">    <span class="comment">// 其实还要重新计算Right和Up向量</span></span><br><span class="line">    <span class="comment">// 否则变换角度后 左右移动会发生异常</span></span><br><span class="line">    cameraRight = glm::normalize(glm::cross(cameraFront, worldUp));</span><br><span class="line">    cameraUp = glm::normalize(glm::cross(cameraRight, cameraFront));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>计算<code>cameraFront</code>这部分放在<code>mouse_callback</code>中可能更适合一点，因为它只有在鼠标移动的时候才会发生改变，如果放在渲染循环中，计算可能是比较冗余的，因为其实有可能在几个帧中间鼠标并没有发生移动，所以没有必要去计算。</p><p><strong>缩放</strong></p><p>作为我们摄像机系统的一个附加内容，我们还会来实现一个<strong>缩放</strong>(Zoom)接口。在之前的教程中我们说<strong>视野</strong>(Field of View)或<code>fov</code>定义了我们可以看到场景中多大的范围。当<strong>视野变小</strong>时，场景投影出来的<strong>空间就会减小</strong>，产生<strong>放大</strong>(Zoom In)了的感觉。我们会使用鼠标的<strong>滚轮来放大和缩小</strong>。与鼠标移动、键盘输入一样，我们需要一个<strong>鼠标滚轮的回调函数</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">scroll_callback</span><span class="params">(GLFWwindow* window, <span class="keyword">double</span> xoffset, <span class="keyword">double</span> yoffset)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(fov &gt;= <span class="number">1.0f</span> &amp;&amp; fov &lt;= <span class="number">45.0f</span>)</span><br><span class="line">        fov -= yoffset;</span><br><span class="line">    <span class="keyword">if</span>(fov &lt;= <span class="number">1.0f</span>)</span><br><span class="line">        fov = <span class="number">1.0f</span>;</span><br><span class="line">    <span class="keyword">if</span>(fov &gt;= <span class="number">45.0f</span>)</span><br><span class="line">        fov = <span class="number">45.0f</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当滚动鼠标滚轮的时候，<code>yoffset</code>值代表我们<strong>竖直滚动的大小</strong>。当<code>scroll_callback</code>函数被调用后，我们改变全局变量<code>fov</code>变量的内容。因为<code>45.0f</code>是<strong>默认的视野值</strong>，我们将会把缩放级别(Zoom Level)限制在<code>1.0f</code>到<code>45.0f</code>。</p><p>我们现在在<strong>每一帧都必须把透视投影矩阵上传到GPU</strong>，但现在使用<code>fov</code>变量作为它的视野：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">projection = glm::perspective(glm::radians(fov), <span class="number">800.0f</span> / <span class="number">600.0f</span>, <span class="number">0.1f</span>, <span class="number">100.0f</span>);</span><br></pre></td></tr></table></figure><p>最后不要忘记注册鼠标滚轮的回调函数：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">glfwSetScrollCallback(window, scroll_callback);</span><br></pre></td></tr></table></figure><p>现在，我们就实现了一个简单的摄像机系统了，它能够让我们在3D环境中自由移动。</p><p>注意，<strong>使用欧拉角的摄像机系统并不完美</strong>。根据你的视角限制或者是配置，你<strong>仍然可能引入万向节死锁问题</strong>。最好的摄像机系统是使用<strong>四元数</strong>(Quaternions)的，但我们将会把这个留到后面讨论。</p><h3 id="摄像机类"><a href="#摄像机类" class="headerlink" title="摄像机类"></a>摄像机类</h3><p>接下来的教程中，我们将会<strong>一直使用一个摄像机来浏览场景，从各个角度观察结果</strong>。然而，由于一个摄像机会占用每篇教程很大的篇幅，我们将会从细节抽象出来，创建我们自己的摄像机对象，它会完成大多数的工作，而且还会提供一些附加的功能。与着色器教程不同，我们不会带你一步一步创建摄像机类，我们只会提供你一份（有完整注释的）代码，如果你想知道它的内部构造的话可以自己去阅读。</p><p>和着色器对象一样，我们把摄像机类写在一个单独的头文件中。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><p>我们介绍的摄像机系统是一个<strong>FPS风格的摄像机</strong>，它能够满足大多数情况需要，而且与欧拉角兼容，但是<strong>在创建不同的摄像机系统，比如飞行模拟摄像机，时就要当心</strong>。每个摄像机系统都有自己的优点和不足，所以确保对它们进行了详细研究。比如，这个FPS摄像机<strong>不允许俯仰角大于90度</strong>，而且我们使用了一个<strong>固定的上向量</strong>(0, 1, 0)，这在需要<strong>考虑滚转角的时候就不能用了</strong>。</p><h2 id="词汇复习"><a href="#词汇复习" class="headerlink" title="词汇复习"></a>词汇复习</h2><ul><li><strong>OpenGL</strong>：一个<strong>定义</strong>了函数布局和输出的图形API的<strong>正式规范</strong>；</li><li><strong>GLAD</strong>：一个<strong>拓展加载库</strong>，用来为我们<strong>加载并设定所有OpenGL函数指针</strong>，从而让我们能够使用所有（现代）OpenGL函数；</li><li><strong>视口</strong>(Viewport)：我们需要渲染的窗口；</li><li><strong>图形管线</strong>(Graphics Pipeline)：一个顶点在呈现为像素之前经过的全部过程；</li><li><strong>着色器</strong>(Shader)：一个运行在显卡上的小型程序，很多阶段的图形管道都可以使用<strong>自定义的着色器来代替原有的功能</strong>，在OpenGL有些部分是我们必须提供的；</li><li><strong>标准化设备坐标</strong>(Normalized Device Coordinates, NDC)：顶点在通过在剪裁坐标系中剪裁与透视除法后最终呈现在的坐标系。所有位置在NDC下-1.0到1.0的顶点将不会被丢弃并且可见；</li><li><strong>VBO-顶点缓冲对象</strong>(Vertex Buffer Object)：一个调用<strong>显存并存储所有顶点数据</strong>供显卡使用的<strong>缓冲对象</strong>；</li><li><strong>VAO-顶点数组对象</strong>(Vertex Array Object)：存储<strong>缓冲区</strong>和<strong>顶点属性状态</strong>；</li><li><strong>EBO-索引缓冲对象</strong>(Element Buffer Object)：一个<strong>存储索引</strong>供索引化绘制使用的缓冲对象；</li><li><strong>Uniform</strong>：一个特殊类型的GLSL变量。它是全局的（在一个着色器程序中每一个着色器都能够访问uniform变量），并且<strong>只需要被设定一</strong>次；</li><li><strong>纹理</strong>(Texture)：一种包裹着物体的特殊类型图像，给物体精细的视觉效果；</li><li><strong>纹理缠绕</strong>(Texture Wrapping)：定义了一种当<strong>纹理顶点超出范围</strong>(0, 1)时指定OpenGL如何采样纹理的模式；</li><li><strong>纹理过滤</strong>(Texture Filtering)：定义了一种当有多种纹素选择时指定OpenGL如何<strong>采样纹理的模式</strong>。<strong>这通常在纹理被放大情况下发生</strong>；</li><li><strong>多级渐远纹理</strong>(Mipmaps)：被存储的材质的一些缩小版本，<strong>根据距观察者的距离会使用材质的合适大小</strong>；</li><li><strong>stb_image.h</strong>：图像加载库；</li><li><strong>纹理单元</strong>(Texture Units)：通过<strong>绑定纹理到不同纹理单元</strong>从而<strong>允许多个纹理</strong>在同一对象上渲染；</li><li><strong>向量</strong>(Vector)：一个定义了在空间中方向和/或位置的数学实体；</li><li><strong>矩阵</strong>(Matrix)：一个矩形阵列的数学表达式；</li><li><strong>GLM</strong>：一个为OpenGL打造的数学库；</li><li><strong>局部空间</strong>(Local Space)：一个物体的<strong>初始空间</strong>。所有的坐标都是相对于物体的原点的；</li><li><strong>世界空间</strong>(World Space)：所有的坐标都<strong>相对于全局原点</strong>；</li><li><strong>观察空间</strong>(View Space)：所有的坐标都是<strong>从摄像机的视角观察的</strong>；</li><li><strong>裁剪空间</strong>(Clip Space)：所有的坐标都是从摄像机视角观察的，但是<strong>该空间应用了投影</strong>。这个空间应该是一个<strong>顶点坐标最终的空间，作为顶点着色器的输出</strong>。OpenGL负责处理剩下的事情（<strong>裁剪/透视除法</strong>）；</li><li><strong>屏幕空间</strong>(Screen Space)：所有的坐标都由屏幕视角来观察。<strong>坐标的范围是从0到屏幕的宽/高</strong>；</li><li><strong>LookAt矩阵</strong>：一种特殊类型的观察矩阵，它<strong>创建了一个坐标系</strong>，其中<strong>所有坐标都根据从一个位置正在观察目标的用户旋转或者平移</strong>；</li><li><strong>欧拉角</strong>(Euler Angles)：被定义为<strong>偏航角</strong>(Yaw)，<strong>俯仰角</strong>(Pitch)，和<strong>滚转角</strong>(Roll)从而允许我们通过这<strong>三个值构造任何3D方向</strong>。</li></ul>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;Hello OpenGL!&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="LearnOpenGL" scheme="https://yumi-cn.github.io/categories/LearnOpenGL/"/>
    
    
    <category term="笔记" scheme="https://yumi-cn.github.io/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>《剑指Offer》第6章笔记 各项能力</title>
    <link href="https://yumi-cn.github.io/2021/01/23/s2o-c6/"/>
    <id>https://yumi-cn.github.io/2021/01/23/s2o-c6/</id>
    <published>2021-01-23T08:04:48.000Z</published>
    <updated>2021-01-23T08:07:25.468Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>沟通和学习能力是面试中关键的考查点。</p></blockquote><a id="more"></a><h2 id="1-面试官谈能力"><a href="#1-面试官谈能力" class="headerlink" title="1 面试官谈能力"></a>1 面试官谈能力</h2><p>大佬们说的名言名句。</p><p>咕咕待更。</p><h2 id="2-沟通能力和学习能力"><a href="#2-沟通能力和学习能力" class="headerlink" title="2 沟通能力和学习能力"></a>2 沟通能力和学习能力</h2><ol><li>沟通能力</li></ol><p>随着软件、系统功能越来越复杂，开发团队的规模也随之扩张，开发者、测试者和项目经理之间的沟通交流也变得越来越重要。也正因如此，很多公司在面试的时候都会注意考查应聘者的沟通能力。这邀请应聘者无论是在<strong>介绍项目经验</strong>还是在<strong>介绍解题思路</strong>的时候，都需要<strong>逻辑清晰明了</strong>，<strong>语言详略得当</strong>，表述的时候<strong>重点突出、观点明确</strong>。</p><ol start="2"><li>学习能力</li></ol><p>计算机是一门更新速度很快的学科，每年都有新的技术不断涌现。因此，作为从业人员<strong>需要具备很强的学习能力</strong>，否则时间一长就会跟不上技术进步的步伐，也正是因为这个原因，IT公司在面试的时候，都会重视考查应聘者的学习能力。只有具备很强的学习能力及学习愿望的人，才能<strong>不断完善自己的知识结构，不断学习新的先进技术</strong>，让自己的职业生涯保持长久的生命力。</p><p>通常面试官有<strong>两种方法考查应聘者的学习能力</strong>。<strong>第一种方法</strong>是询问应聘者最近在<strong>看什么书或者在做什么项目、从中学到了哪些新技术</strong>。面试官可以用这个问题了解应聘者的学习愿望和学习能力。<strong>第二种方法是抛出一个新概念</strong>，接下来观察应聘者能不能在短时间内理解这个新概念并解决相关的问题。当面试官提出新概念时，他期待应聘者能够通过<strong>思考、提问、再思考的过程，理解它们并最终解决问题</strong>。</p><ol start="3"><li>善于学习、沟通的人也善于提问</li></ol><p>面试官提出一个新概念，应聘者没有听说过它，于是他在已有的理解基础上提出进一步地问题，在得到面试官答复之后，思考再提问，几个来回之后掌握了这个概念。这个过程就能体现应聘者的学习能力。建议应聘者在面试过程中遇到不明白的地方多提问，这样可以表现自己态度积极、求知欲望强烈（但是一些行业领域基础的东西不知道还是蛮尴尬的hhh）。</p><p>有些面试官故意一开始不把题目描述清楚，让题目存在一定的二义性，他期待应聘者可以一步步通过提问来弄明白题目的要求，这也是在考查应聘者的沟通能力（因为实际工作中也是这样的）。</p><h2 id="3-知识迁移能力"><a href="#3-知识迁移能力" class="headerlink" title="3 知识迁移能力"></a>3 知识迁移能力</h2><p>所谓学习能力，很重要的一点就是<strong>根据已经掌握的知识、技术，能够迅速学习、理解新的技术并运用到实际工作中去</strong>。大部分新的技术都不是凭空产生的，而是在已有技术的基础上发展起来的。这就要求我们能够把对已有技术的理解迁移到学习新技术的过程中去，也就是要具备很强的知识迁移能力。</p><p>面试官考查应聘者知识迁移能力的<strong>一种方法是把经典的问题稍作变换</strong>。这时候面试官期待应聘者能够找到和经典问题的联系，并从中受到启发，把解决经典问题的思路迁移过来解决新的问题。<strong>另一种方法是先问一个简单地问题</strong>，在应聘者答完简单地问题后，<strong>再追问一个相关的同时难度也更大的问题</strong>。这时候面试官希望应聘者能够总结前面解决简单问题的经验，把前面的思路、方法迁移过来。</p><p><strong>知识迁移能力的一种通俗的说法是“举一反三”的能力</strong>。<strong>面试题是刷不完的</strong>，不可能把所有的面试题都准备一遍，因此更重要的是每做一道面试题的时候，都要总结这道题的解法有什么特点，有哪些思路是可以应用到同类型的题目中去的。</p><h2 id="面试题53-59"><a href="#面试题53-59" class="headerlink" title="面试题53-59"></a>面试题53-59</h2><blockquote><p>面试题53：在排序数组中查找数字。</p></blockquote><p>题目一：数字在排序数组中出现的次数。</p><p>统计一个数字在排序数组中出现的次数，例如，输入排序数组<code>&#123;1,2,3,3,3,3,4,5&#125;</code>和3，由于3在这个数组中出现了4次，因此输出4。</p><p>最普通的遍历法时间复杂度<code>O(n)</code>，所以优化方法的时间复杂度肯定要优于<code>O(n)</code>。可以考虑用二分法方式寻找该数字的第一个位置和最后一个位置，然后就可以计算出出现次数了。在二分法时，首先找到有这个数的区间，当<code>mid</code>为寻找的目标数时，如果是寻找第一个位置，则看其左边是不是同样的数，如果是则在左侧继续寻找第一个位置，如果不是则<code>mid</code>就是第一个位置，寻找最后一个位置原理类似。</p><p>完整实现代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find_head</span><span class="params">(<span class="keyword">int</span>* data, <span class="keyword">int</span> start, <span class="keyword">int</span> end, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(start == end) &#123;</span><br><span class="line">        <span class="keyword">if</span>(data[start] == target) &#123;</span><br><span class="line">            <span class="keyword">return</span> start;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> mid = (start + end) / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span>(data[mid] == target) &#123;</span><br><span class="line">        <span class="keyword">if</span>(mid == <span class="number">0</span> || data[mid<span class="number">-1</span>] != target) &#123;</span><br><span class="line">            <span class="keyword">return</span> mid;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> find_head(data, start, mid<span class="number">-1</span>, target);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(data[mid] &lt; target) &#123;</span><br><span class="line">        <span class="keyword">return</span> find_head(data, mid+<span class="number">1</span>, end, target);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> find_head(data, start, mid<span class="number">-1</span>, target);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find_tail</span><span class="params">(<span class="keyword">int</span>* data, <span class="keyword">int</span> start, <span class="keyword">int</span> end, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(start == end) &#123;</span><br><span class="line">        <span class="keyword">if</span>(data[start] == target) &#123;</span><br><span class="line">            <span class="keyword">return</span> start;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> mid = (start + end) / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span>(data[mid] == target) &#123;</span><br><span class="line">        <span class="keyword">if</span>(mid == end || data[mid+<span class="number">1</span>] != target) &#123;</span><br><span class="line">            <span class="keyword">return</span> mid;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> find_tail(data, mid+<span class="number">1</span>, end, target);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(data[mid] &lt; target) &#123;</span><br><span class="line">        <span class="keyword">return</span> find_tail(data, mid+<span class="number">1</span>, end, target);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> find_tail(data, start, mid<span class="number">-1</span>, target);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">counts_in_order</span><span class="params">(<span class="keyword">int</span>* data, <span class="keyword">int</span> len, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(data == <span class="literal">nullptr</span> || len &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> head = find_head(data, <span class="number">0</span>, len<span class="number">-1</span>, target);</span><br><span class="line">    <span class="keyword">int</span> tail = find_tail(data, <span class="number">0</span>, len<span class="number">-1</span>, target);</span><br><span class="line">    <span class="keyword">if</span>(head == <span class="number">-1</span> || tail == <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> tail - head + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> data[] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Count:%d\n&quot;</span>, counts_in_order(data, <span class="number">8</span>, <span class="number">3</span>));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码中，<code>find_head</code>、<code>find_tail</code>都是二分查找算法在数组中查找数字，时间复杂度都是<code>O(logn)</code>，因此总的时间复杂度也是<code>O(logn)</code>。</p><p>题目二：<code>0~n-1</code>中缺失的数字。</p><p>一个长度<code>n-1</code>的递增排序数组中，所有数字都是唯一的，并且每个数字都在范围<code>0~n-1</code>中，在范围<code>0~n-1</code>内的n个数字中<strong>有且只有一个数字不在数组中</strong>，请找出这个数字。</p><p>最简单的方法是遍历数组求和，用<code>0~n-1</code>的总和<code>n(n-1)/2</code>相减就可以得到缺失的数字，但时间复杂度<code>O(n)</code>，可以观察<code>n-1</code>长度的数组，如果缺失了第<code>i</code>个数，由于排序的性质，对任意的<code>i&lt;j</code>第<code>j</code>个数会在<code>j-1</code>位置上，即不满足<code>j</code>在第<code>j</code>个位置上，所以问题转换为，找出第一个值和下标不相等的元素，利用二分法查找即可。</p><p>完整实现代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find_miss_num</span><span class="params">(<span class="keyword">int</span>* data, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(start == end) &#123;</span><br><span class="line">        <span class="keyword">if</span>(data[start] != start) &#123;</span><br><span class="line">            <span class="keyword">return</span> start;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> mid = (start + end) / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span>(data[mid] != mid) &#123;</span><br><span class="line">        <span class="keyword">if</span>(mid == start || data[mid<span class="number">-1</span>] == mid<span class="number">-1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> mid;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> find_miss_num(data, start, mid - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> find_miss_num(data, mid + <span class="number">1</span>, end);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find_miss_num</span><span class="params">(<span class="keyword">int</span>* data, <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(data == <span class="literal">nullptr</span> || len &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> find_miss_num(data, <span class="number">0</span>, len<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> data[] = &#123;<span class="number">0</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>&#125;;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Miss is %d\n&quot;</span>, find_miss_num(data, <span class="number">9</span>));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>题目三：数组中数值和下标相等的元素。</p><p>假设一个<strong>单调递增的数组</strong>里的每个元素都是整数并且<strong>唯一</strong>。请实现一个函数，找出数组中<strong>任意一个</strong>数值等于其下标的元素。例如，在数组<code>&#123;-3,-1,1,3,5&#125;</code>中，数字3和它的下标相等。</p><p>以<code>&#123;-3,-1,1,3,5&#125;</code>和<code>&#123;0,1,2,3,4&#125;</code>为例来分析，可以发现规律，<code>3</code>的左边都是<code>value &lt; index</code>，<code>3</code>的右边都是<code>value &gt; index</code>，根据这一点来判断二分查找的下一个位置。</p><p>完整实现代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find_index_eq_value</span><span class="params">(<span class="keyword">int</span>* data, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(start == end) &#123;</span><br><span class="line">        <span class="keyword">if</span>(data[start] == start) &#123;</span><br><span class="line">            <span class="keyword">return</span> start;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> mid = (start + end) / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span>(data[mid] == mid) &#123;</span><br><span class="line">        <span class="keyword">return</span> mid;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(data[mid] &lt; mid) &#123;</span><br><span class="line">        <span class="keyword">return</span> find_index_eq_value(data, mid + <span class="number">1</span>, end);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> find_index_eq_value(data, start, mid - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find_index_eq_value</span><span class="params">(<span class="keyword">int</span>* data, <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(data == <span class="literal">nullptr</span> || len &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> find_index_eq_value(data, <span class="number">0</span>, len<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> data[] = &#123;<span class="number">-3</span>, <span class="number">-1</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>&#125;;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Result: %d\n&quot;</span>, find_index_eq_value(data, <span class="number">5</span>));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><blockquote><p>面试题54：二叉搜索树的第K大节点。</p></blockquote><p>给定一棵二叉搜索树，请找出其中<strong>第K大的节点</strong>。例如在下图中的二叉搜索树，按节点数值大小顺序，第3大节点的值是4。</p><div align="center"><p><img src="/images/s2o-c6-f1.jpg"></p></div><p>书上的方法是直接简单的用二叉搜索树的性质，中序遍历即树中节点的递增排序，在中序遍历中找到第K大的节点。</p><p>完整实现代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> value;</span><br><span class="line">    node* pleft;</span><br><span class="line">    node* pright;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">node* <span class="title">init_node</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123; ... &#125;</span><br><span class="line"><span class="function">node* <span class="title">init_tree</span><span class="params">()</span> </span>&#123; ... &#125;</span><br><span class="line"></span><br><span class="line"><span class="function">node* <span class="title">find_kth_in_tree_core</span><span class="params">(node* proot, <span class="keyword">unsigned</span> <span class="keyword">int</span>&amp; k)</span> </span>&#123;</span><br><span class="line">    node* target = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="comment">// 中序遍历</span></span><br><span class="line">    <span class="keyword">if</span>(proot-&gt;pleft != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        target = find_kth_in_tree_core(proot-&gt;pleft, k);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(target == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="comment">// 没有在左子树中找到第k大</span></span><br><span class="line">        <span class="keyword">if</span>(k == <span class="number">1</span>) &#123;</span><br><span class="line">            target = proot;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 继续减少k</span></span><br><span class="line">        k--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(target == <span class="literal">nullptr</span> &amp;&amp; proot-&gt;pright != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        target = find_kth_in_tree_core(proot-&gt;pright, k);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> target;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">node* <span class="title">find_kth_in_tree</span><span class="params">(node* proot, <span class="keyword">unsigned</span> <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(proot == <span class="literal">nullptr</span> || k == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> find_kth_in_tree_core(proot, k);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    node* proot = init_tree();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%dth node is: %d&quot;</span>, <span class="number">3</span>, find_kth_in_tree(proot, <span class="number">3</span>)-&gt;value);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><blockquote><p>面试题55：二叉树的深度。</p></blockquote><p>题目一：二叉树的深度。</p><p>输入一棵二叉树的根节点，求该树的深度。从根节点到叶节点一次经过的节点（含根、叶节点）形成树的一条路径，<strong>最长路径的长度为树的深度</strong>。</p><p>节点定义如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> value;</span><br><span class="line">    node* pleft;</span><br><span class="line">    node* pright;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>思路比较简单，就是<strong>节点的深度等于左右子树的最大深度+1</strong>，递归地实现即可。</p><p>完整实现代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> value;</span><br><span class="line">    node* pleft;</span><br><span class="line">    node* pright;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">node* <span class="title">init_node</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123; ... &#125;</span><br><span class="line"><span class="function">node* <span class="title">init_tree</span><span class="params">()</span> </span>&#123; ... &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">tree_depth</span><span class="params">(node* proot)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(proot == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> left_depth = tree_depth(proot-&gt;pleft);</span><br><span class="line">    <span class="keyword">int</span> right_depth = tree_depth(proot-&gt;pright);</span><br><span class="line">    <span class="keyword">return</span> (left_depth &gt; right_depth) ? (left_depth + <span class="number">1</span>) : (right_depth + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    node* proot = init_tree();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Tree depth:%d\n&quot;</span>, tree_depth(proot));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>题目二：平衡二叉树。</p><p>输入一棵二叉树的根节点，<strong>判断该树是不是平衡二叉树</strong>。如果某二叉树中任意节点的左、右子树的深度相差不超过1，那么它就是一棵平衡二叉树。例如，下图就是一颗平衡二叉树。</p><div align="center"><p><img src="/images/s2o-c6-f2.jpg"></p></div><p>在题目一的基础上，在每个节点上一边判断是否平衡，同时一边返回他们的深度，如果是先检查深度，再去检查子树是否平衡，就会频繁多次的访问子节点，导致时间上的浪费。</p><p>完整实现代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> value;</span><br><span class="line">    node* pleft;</span><br><span class="line">    node* pright;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">node* <span class="title">init_node</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123; ... &#125;</span><br><span class="line"><span class="function">node* <span class="title">init_tree</span><span class="params">()</span> </span>&#123; ... &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">is_balanced</span><span class="params">(node* proot, <span class="keyword">int</span>* pdepth)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(proot == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        *pdepth = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> left, right;</span><br><span class="line">    <span class="keyword">if</span>(is_balanced(proot-&gt;pleft, &amp;left)</span><br><span class="line">       &amp;&amp; is_balanced(proot-&gt;pright, &amp;right)) &#123;</span><br><span class="line">        <span class="keyword">int</span> diff = left - right;</span><br><span class="line">        <span class="keyword">if</span>(diff &lt;= <span class="number">1</span> &amp;&amp; diff &gt;= <span class="number">-1</span>) &#123;</span><br><span class="line">            *pdepth = <span class="number">1</span> + (left &gt; right ? left : right);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">is_balanced</span><span class="params">(node* proot)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> depth = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> is_balanced(proot, &amp;depth);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    node* proot = init_tree();</span><br><span class="line">    <span class="keyword">if</span>(is_balanced(proot)) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Is Balanced.\n&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Is Not Balanced.\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><blockquote><p>面试题56：数组中数字出现的次数。</p></blockquote><p><strong>题目一</strong>：数组中只出现一次的两个数字。</p><p><strong>一个整型数组里除两个数字之外，其他数字都出现了两次</strong>。请写程序找出这<strong>两个只出现一次</strong>的数字。要求时间复杂度是<code>O(n)</code>，空间复杂度是<code>O(1)</code>。</p><p>这个题常规思路很难解决，需要使用到<strong>两个相同的数的异或为0</strong>这种知识点，首先把问题分解为<strong>在一个整数数组中，除了一个数字之外，其他都出现两次</strong>的一个子问题，对于这个子问题的求解方式是对所有数进行异或操作，最后结果数就是出现一次的数字（其中使用到了异或操作的交换律以及结合律，这里不再证明）。</p><p>再回到原始问题，看看有没有相同的思路。还是从头到尾异或每个数字，结果是两个只出现一次的数字的异或结果，因为其他数字都出现两次，在异或中全部抵消了。<strong>由于这两个数字不一样，所以异或的结果肯定不为0，至少有一位是1</strong>（这代表这两个数，一个在该位上为1，一个在该位上为0），我们在结果数字中找到第一个为1的位的位置，记为第n位。现在我们<strong>以第n位是不是1位标准把原数组中的数字分为两个子数组</strong>，第一个子数组中每个数字的第n位都是1，第二个子数组中每个数字的第n位都是0，这样两个不同的数字就分到了两个数组中，并且相同的数字一定会被分到一个数组中，也就<strong>拆分成了两个可以解决的子问题了</strong>。</p><p>完整实现代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 找到从右边数起的第一个1位（方便一点）</span></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">find_first_1_bit</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>((num &amp; <span class="number">1</span>) == <span class="number">0</span> &amp;&amp; index &lt; <span class="number">8</span> * <span class="keyword">sizeof</span>(<span class="keyword">int</span>)) &#123;</span><br><span class="line">        num = num &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        index++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> index;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">is_bit_1</span><span class="params">(<span class="keyword">int</span> num, <span class="keyword">unsigned</span> <span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    num = num &gt;&gt; index; <span class="comment">// 直接右移</span></span><br><span class="line">    <span class="keyword">return</span> (num &amp; <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> g_invalid_input = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">find_nums_appear_once</span><span class="params">(<span class="keyword">int</span> data[], <span class="keyword">int</span> len, <span class="keyword">int</span>* num1, <span class="keyword">int</span>* num2)</span> </span>&#123;</span><br><span class="line">    g_invalid_input = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span>(data == <span class="literal">nullptr</span> || len &lt; <span class="number">2</span> || len % <span class="number">2</span> != <span class="number">0</span>) &#123;</span><br><span class="line">        g_invalid_input = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> xor_result = <span class="number">0</span>; <span class="comment">// 异或初始值0</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">        xor_result ^= data[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> index_of_1 = find_first_1_bit(xor_result);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这里直接用一次O(n)来遍历，并不是显式地分为两个部分</span></span><br><span class="line">    <span class="comment">// 而是直接地根据位的情况来选择性异或，最后结果也一样</span></span><br><span class="line">    *num1 = *num2 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(is_bit_1(data[i], index_of_1)) &#123;</span><br><span class="line">            *num1 ^= data[i];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            *num2 ^= data[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> data[] = &#123;<span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">5</span>, <span class="number">3</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> num1 = <span class="number">0</span>, num2 = <span class="number">0</span>;</span><br><span class="line">    find_nums_appear_once(data, <span class="number">10</span>, &amp;num1, &amp;num2);</span><br><span class="line">    <span class="keyword">if</span>(g_invalid_input) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Error: Invalid Input.\n&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Num1: %d, Num2: %d\n&quot;</span>, num1, num2);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>题目二</strong>：数组中唯一只出现一次的数字。</p><p>在一个数组中<strong>除一个数字只出现一次之外</strong>，其他数字都<strong>出现了三次</strong>。请找出那个只出现一次的数字。</p><p><strong>如果一个数字出现三次，那么它的二进制表示的每一位（0或者1）也出现3次</strong>，如果把所有出现三次的数字的二进制表示的每一位分别都加起来，那么每一位的和都能被3整除。这样我们把数组中所有数字的二进制表示的每一位都加起来。如果某一位的和能被3整除，那么那个只出现一次的数字的二进制表示中对应的那一位就是0，否则是1。</p><p>完整实现代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> g_invalid_input = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find_num_appear_once</span><span class="params">(<span class="keyword">int</span> data[], <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">    g_invalid_input = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span>(data == <span class="literal">nullptr</span> || len &lt;= <span class="number">0</span> || len % <span class="number">3</span> != <span class="number">1</span>) &#123;</span><br><span class="line">        g_invalid_input = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 0 是最高位， 31 是最低位</span></span><br><span class="line">    <span class="comment">// 注意int的最高位是符号位，这里连同符号位一起处理了</span></span><br><span class="line">    <span class="keyword">int</span> bit_sum[<span class="number">32</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> bit_mask = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">31</span>; j &gt;= <span class="number">0</span>; j--) &#123;</span><br><span class="line">            <span class="keyword">int</span> bit = data[i] &amp; bit_mask;</span><br><span class="line">            <span class="keyword">if</span>(bit != <span class="number">0</span>) &#123;</span><br><span class="line">                bit_sum[j]++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 这里是基于bit_mask=1的左移</span></span><br><span class="line">            bit_mask = bit_mask &lt;&lt; <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这里使用的还原法是基于位移操作的</span></span><br><span class="line">    <span class="comment">// 要比使用2幂级更加高效，同时符号位处理也更加自然</span></span><br><span class="line">    <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">32</span>; ++i) &#123;</span><br><span class="line">        result = result &lt;&lt; <span class="number">1</span>; <span class="comment">// 先左移，空出最低位</span></span><br><span class="line">        result += bit_sum[i] % <span class="number">3</span>; <span class="comment">// 载入当前最低位</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> data[] = &#123;<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">-2</span>, <span class="number">-2</span>, <span class="number">-2</span>, <span class="number">-100</span>, <span class="number">4</span>, <span class="number">4</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">5</span>, <span class="number">5</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> result = find_num_appear_once(data, <span class="number">13</span>);</span><br><span class="line">    <span class="keyword">if</span>(g_invalid_input) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Error: Invalid Input.\n&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Result: %d\n&quot;</span>, result);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种方法同样只需要<code>O(n)</code>的时间以及<code>O(1)</code>的空间，相比于其他方法有更好的时间效率(例如用排序需要<code>O(logn)</code>)，同时也不会有多余的空间开销(例如用哈希表，需要额外的<code>O(n)</code>空间)。</p><hr><blockquote><p>面试题57：和为s的数字。</p></blockquote><p>题目一：和为s的两个数字。</p><p>输入一个<strong>递增排序</strong>的数组和一个数字<code>s</code>，在数组中<strong>查找两个数</strong>，使得它们的和正好是<code>s</code>。如果有<strong>多对数字的和</strong>等于<code>s</code>，则输出任意一对即可。</p><p>PS：在面试的时候，很重要的一点是应聘者要表现出很快的反应能力。只要想到一种方法，应聘者就可以马上告诉面试官（仅限于面谈形式的），即使这种方法不一定是最好的。</p><p>根据已排序数组的特性，当指定数组中的两个数字时：</p><ul><li>如果两个数字的和小于<code>s</code>，需要一个更大的数字，这个时候可以在较小数字的<strong>右侧**</strong>或者<strong>是较大数字的</strong>右侧**去寻找；</li><li>如果两个数字的和大于<code>s</code>，需要一个更小的数字，这个时候可以在较小数字的<strong>左侧**</strong>或者<strong>是较大数字的</strong>左侧**去寻找；</li><li>如果两个数字的和等于<code>s</code>，则找到两个满足要求的数字。</li></ul><p>仅仅分析到这里是还不够的，如果每个位置都要考虑两种情况，最后的复杂度会是<code>O(2^n)</code>，在这种去情况时，可以考虑固定一个方向寻找，并且要能够覆盖到所有情况，例如本题中，可以初始化一头一尾两个指针，如果和小于<code>s</code>，移动头指针向右，如果和大于<code>s</code>，移动头指针向左，<strong>这样可以遍历到所有情况</strong>。</p><p>PS：<strong>为什么说这样可以遍历到所有情况？</strong>对于每一个头指针指向的数字，你不能在当前尾指针的右侧找到一个更适合的数（都是大于s）；对于每一个尾指针指向的数字，你不能在当前头指针的左侧找到一个更适合的数（都是小于s），所以这样逐步缩小范围，同时也考虑到了所有情况。</p><p>完整实现代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> g_invalid_input = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find_nums_with_sum</span><span class="params">(<span class="keyword">int</span> data[], <span class="keyword">int</span> len, <span class="keyword">int</span> sum, <span class="keyword">int</span>* num1, <span class="keyword">int</span>* num2)</span> </span>&#123;</span><br><span class="line">    g_invalid_input = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">bool</span> found = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span>(data == <span class="literal">nullptr</span> || len &lt; <span class="number">2</span> || !num1 || !num2) &#123;</span><br><span class="line">        g_invalid_input = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> found;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> head = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> tail = len - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(head &lt; tail) &#123;</span><br><span class="line">        <span class="comment">// 使用了long long来存储</span></span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> cur_sum = data[head] + data[tail];</span><br><span class="line">        <span class="keyword">if</span>(cur_sum == sum) &#123;</span><br><span class="line">            *num1 = data[head];</span><br><span class="line">            *num2 = data[tail];</span><br><span class="line">            found = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(cur_sum &gt; sum) &#123;</span><br><span class="line">            tail--;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            head++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> found;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> data[] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">7</span>, <span class="number">11</span>, <span class="number">15</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> num1, num2;</span><br><span class="line">    <span class="keyword">if</span>(find_nums_with_sum(data, <span class="number">6</span>, <span class="number">15</span>, &amp;num1, &amp;num2)) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Found! Num1: %d, Num2: %d\n&quot;</span>, num1, num2);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(g_invalid_input) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Error: Invalid Input.\n&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Not Found!\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>题目二</strong>：和为s的连续正数序列。</p><p>输入一个正数<code>s</code>，打印出所有和为s的<strong>连续正数序列</strong>（至少含有两个数）。例如，输入15，由于<code>1+2+3+4+5=4+5+6+7=7+8=15</code>，所以打印出3个连续序列<code>1~5</code>、<code>4~6</code>、<code>7~8</code>。</p><p>和题目一思路类似。</p><p>完整实现代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">find_seqs_with_sum</span><span class="params">(<span class="keyword">int</span> sum)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(sum &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> head = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> tail = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">int</span> cur_sum = head + tail;</span><br><span class="line">    <span class="keyword">while</span>(!(head == tail - <span class="number">1</span> &amp;&amp; cur_sum &gt; sum)) &#123;</span><br><span class="line">        <span class="keyword">if</span>(cur_sum == sum) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d~%d\n&quot;</span>, head, tail);</span><br><span class="line">            cur_sum -= head;</span><br><span class="line">            head++;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(cur_sum &gt; sum) &#123;</span><br><span class="line">            cur_sum -= head;</span><br><span class="line">            head++;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            tail++;</span><br><span class="line">            cur_sum += tail;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    find_seqs_with_sum(<span class="number">15</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><blockquote><p>面试题58：翻转字符串。</p></blockquote><p><strong>题目一</strong>：翻转单词顺序。</p><p>输入一个英语句子，翻转句子中单词的顺序，但单词内字符的顺序不变。简单起见，标点符号和字幕一样处理。例如输入<code>I am a student.</code>，则输出<code>student. a am I</code>.</p><p>普通方法的思路也不是特别难，不过这里说一下书上的两次翻转字符串的解法：</p><ul><li>第一步<strong>翻转句子中所有的字符</strong>；</li><li>第二步<strong>翻转每个单词中的字符的顺序</strong>，就得到了最终结果。</li></ul><p>完整实现代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">reverse</span><span class="params">(<span class="keyword">char</span>* pstart, <span class="keyword">char</span>* pend)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(pstart == <span class="literal">nullptr</span> || pend == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(pstart &lt; pend) &#123;</span><br><span class="line">        <span class="keyword">char</span> temp = *pstart;</span><br><span class="line">        *pstart = *pend;</span><br><span class="line">        *pend = temp;</span><br><span class="line">        pstart++;</span><br><span class="line">        pend--;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">str_reverse</span><span class="params">(<span class="keyword">char</span>* str)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(str == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">char</span>* pstart = str;</span><br><span class="line">    <span class="keyword">char</span>* pend = str;</span><br><span class="line">    <span class="keyword">while</span>(*pend != <span class="string">&#x27;\0&#x27;</span>) &#123;</span><br><span class="line">        pend++;</span><br><span class="line">    &#125;</span><br><span class="line">    pend--;</span><br><span class="line"></span><br><span class="line">    reverse(pstart, pend);</span><br><span class="line"></span><br><span class="line">    pstart = pend = str;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(*pstart != <span class="string">&#x27;\0&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span>(*pstart == <span class="string">&#x27; &#x27;</span>) &#123;</span><br><span class="line">            pstart++;</span><br><span class="line">            pend++;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(*pend == <span class="string">&#x27; &#x27;</span> || *pend == <span class="string">&#x27;\0&#x27;</span>) &#123;</span><br><span class="line">            reverse(pstart, pend - <span class="number">1</span>);</span><br><span class="line">            pstart = pend;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            pend++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> str[] = <span class="string">&quot;  I am a student.  &quot;</span>;</span><br><span class="line">    str_reverse(str);</span><br><span class="line">    <span class="keyword">if</span>(str != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>, str);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>题目二</strong>：左旋转字符串。</p><p>字符串的左旋转操作是把字符串<strong>前面的若干个字符</strong>转移到<strong>字符串的尾部</strong>。比如输入字符串<code>abcdefg</code>和数字<code>2</code>，函数返回左旋两位得到的结果<code>cdefgab</code>。</p><p>题目一中的翻转字符串，如果在本例中，可以类比于将<code>ab cdefg</code>翻转为<code>cdefg ab</code>，所以可以使用和题目一类似的思路。</p><p>完整实现代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">reverse</span><span class="params">(<span class="keyword">char</span>* pstart, <span class="keyword">char</span>* pend)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(pstart == <span class="literal">nullptr</span> || pend == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(pstart &lt; pend) &#123;</span><br><span class="line">        <span class="keyword">char</span> temp = *pstart;</span><br><span class="line">        *pstart = *pend;</span><br><span class="line">        *pend = temp;</span><br><span class="line">        pstart++;</span><br><span class="line">        pend--;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">str_left_rotate</span><span class="params">(<span class="keyword">char</span>* str, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len = <span class="built_in">strlen</span>(str);</span><br><span class="line">    <span class="keyword">if</span>(str == <span class="literal">nullptr</span> || n &lt; <span class="number">0</span> || n &gt;= len || len == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 三次翻转即可</span></span><br><span class="line">    <span class="keyword">char</span>* pstart;</span><br><span class="line">    <span class="keyword">char</span>* pend;</span><br><span class="line">    pstart = str;</span><br><span class="line">    pend = str + n - <span class="number">1</span>;</span><br><span class="line">    reverse(pstart, pend);</span><br><span class="line">    pstart = str + n;</span><br><span class="line">    pend = str + len - <span class="number">1</span>;</span><br><span class="line">    reverse(pstart, pend);</span><br><span class="line">    pstart = str;</span><br><span class="line">    pend = str + len - <span class="number">1</span>;</span><br><span class="line">    reverse(pstart, pend);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> str[] = <span class="string">&quot;abcdefg&quot;</span>;</span><br><span class="line">    str_left_rotate(str, <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">if</span>(str != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>, str);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><blockquote><p>面试题59：队列的最大值。</p></blockquote><p><strong>题目一</strong>：滑动窗口的最大值。</p><p>给定一个数组和滑动窗口大小，请找出所有滑动窗口里的最大值。例如<code>&#123;2,3,4,2,6,2,5,1&#125;</code>以及滑动窗口大小<code>3</code>，那么一共存在6个滑动窗口，他们的最大值分别是<code>&#123;4,4,6,6,6,5&#125;</code>。</p><p><strong>使用一个双端队列来保存当前窗口最大值以及可能的次最大值们</strong>；如果新入窗口的元素大于队列的头元素（最大值），则清空队列，头部入队新元素；如果新入窗口的元素小于队列的头元素，则出尾部所有小于该新元素的数字，并在尾部入队新元素；同时在队列中只需要保存元素的<code>index</code>，用来同时获取数字以及判断当前其是否在窗口内，如果不在窗口内就要进行出队。</p><p>完整实现代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;deque&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">windows_max</span><span class="params">(<span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; num, <span class="keyword">unsigned</span> <span class="keyword">int</span> size)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; maxs;</span><br><span class="line">    <span class="keyword">if</span>(num.size() &lt; size &amp;&amp; size &gt;= <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> maxs;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt; index;</span><br><span class="line">    <span class="comment">// 初始化第一个窗口的状态</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">unsigned</span> <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">        <span class="keyword">while</span>(!index.empty() &amp;&amp; num[i] &gt;= num[index.back()]) &#123;</span><br><span class="line">            index.pop_back();</span><br><span class="line">        &#125;</span><br><span class="line">        index.push_back(i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 开始滑动窗口</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">unsigned</span> <span class="keyword">int</span> i = size; i &lt; num.size(); i++) &#123;</span><br><span class="line">        maxs.push_back(num[index.front()]);</span><br><span class="line">        <span class="comment">// 清除所有尾部小于新元素的</span></span><br><span class="line">        <span class="keyword">while</span>(!index.empty() &amp;&amp; num[i] &gt;= num[index.back()]) &#123;</span><br><span class="line">            index.pop_back();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 清除所有头部已经不在窗口的</span></span><br><span class="line">        <span class="keyword">if</span>(!index.empty() &amp;&amp; index.front() &lt;= (<span class="keyword">int</span>)(i - size)) &#123;</span><br><span class="line">            index.pop_front();</span><br><span class="line">        &#125;</span><br><span class="line">        index.push_back(i);</span><br><span class="line">    &#125;</span><br><span class="line">    maxs.push_back(num[index.front()]);</span><br><span class="line">    <span class="keyword">return</span> maxs;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">num</span><span class="params">(&#123;<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">2</span>,<span class="number">6</span>,<span class="number">2</span>,<span class="number">5</span>,<span class="number">1</span>&#125;)</span></span>;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; maxs = windows_max(num, <span class="number">3</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; maxs.size(); i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, maxs[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>题目二</strong>：队列的最大值。</p><p>定义一个队列，并实现函数<code>max</code>得到队列里的最大值，要求函数<code>max</code>、<code>push_back</code>和<code>pop_front</code>的时间复杂度都是<code>O(1)</code>。</p><p>思路和题目一类似，使用一个双端队列实现<code>max</code>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;deque&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="class"><span class="keyword">class</span> <span class="title">QueueWithMAx</span> &#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        QueueWithMAx(): cur_index(<span class="number">0</span>) &#123;&#125;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">push_back</span><span class="params">(T num)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">while</span>(!maxs.empty() &amp;&amp; num &gt;= maxs.back().num) &#123;</span><br><span class="line">                maxs.pop_back();</span><br><span class="line">            &#125;</span><br><span class="line">            InternalData idata = &#123; num, cur_index &#125;;</span><br><span class="line">            data.push_back(idata);</span><br><span class="line">            maxs.push_back(idata);</span><br><span class="line">            cur_index++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">pop_front</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(maxs.empty()) &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;Error: queue is empty\n&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(maxs.front().index == data.front().index) &#123;</span><br><span class="line">                <span class="comment">// 如果要出队最大元素，maxs也要出队</span></span><br><span class="line">                maxs.pop_front();</span><br><span class="line">            &#125;</span><br><span class="line">            data.pop_front();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">int</span> <span class="title">front</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(data.empty()) &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;Error: queue is empty\n&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> data.front().num;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function">T <span class="title">max</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(maxs.empty()) &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;Error: queue is empty\n&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> maxs.front().num;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">InternalData</span> &#123;</span></span><br><span class="line">            T num;</span><br><span class="line">            <span class="keyword">int</span> index;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="built_in">deque</span>&lt;InternalData&gt; data;</span><br><span class="line">        <span class="built_in">deque</span>&lt;InternalData&gt; maxs;</span><br><span class="line">        <span class="keyword">int</span> cur_index;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> num[] = &#123;<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">2</span>,<span class="number">6</span>,<span class="number">2</span>,<span class="number">5</span>,<span class="number">1</span>&#125;;</span><br><span class="line">    QueueWithMAx&lt;<span class="keyword">int</span>&gt; <span class="built_in">queue</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">8</span>; i++) &#123;</span><br><span class="line">        <span class="built_in">queue</span>.push_back(num[i]);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;After push %d, max is %d\n&quot;</span>, num[i], <span class="built_in">queue</span>.max());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">7</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> front = <span class="built_in">queue</span>.front();</span><br><span class="line">        <span class="built_in">queue</span>.pop_front();</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;After pop %d, max is %d\n&quot;</span>, front, <span class="built_in">queue</span>.max());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-抽象建模能力"><a href="#4-抽象建模能力" class="headerlink" title="4 抽象建模能力"></a>4 抽象建模能力</h2><p>有些面试官喜欢从日常生活中抽取提炼出问题，考查应聘者是否能简历数学模型并解决问题。</p><p>建模的第一步是<strong>选择合理的数据结构来表述问题</strong>。我们在根据问题的特点，综合考虑性能、编程难度等因素之后，选择最合适的数据结构来表达问题，也就是建立模型。</p><p>建模的第二步是<strong>分析模型中的内在规律，并用编程语言表述这种规律</strong>。</p><h2 id="面试题60-63"><a href="#面试题60-63" class="headerlink" title="面试题60-63"></a>面试题60-63</h2><blockquote><p>面试题60：n个骰子的点数。</p></blockquote><p>把<code>n</code>个骰子扔在地上，所有骰子朝上一面的点数之和为<code>s</code>。输入<code>n</code>，打印出现<code>s</code>的所有可能的值出现的概率。</p><p>最简单的方法递归地遍历骰子的所有值情况，然后记录和<code>s</code>的出现次数，时间复杂度<code>O(6^n)</code>，当<code>n</code>很大时难以接受。</p><p>其实可以简化这个问题，例如设<code>f(n,s)</code>为n个骰子时和<code>s</code>的出现次数，则有<code>f(n,s)=f(n-1,s-1)+f(n-1,s-2)+f(n-1,s-3)+f(n-1,s-4)+f(n-1,s-5)+f(n-1,s-6)</code>，写出这样的递归式，我们就可以想到通过迭代来代替递归的方式计算结果，设初值<code>f(1,k)=1, 1&lt;=k&lt;=6</code>，每次迭代，向后计算即可，时间复杂度<code>O(n^2)</code>。</p><p>完整实现代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print_probability</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n &lt; <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> size = <span class="number">6</span> * n + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span>* prob1 = <span class="keyword">new</span> <span class="keyword">int</span>[size];</span><br><span class="line">    <span class="keyword">int</span>* prob2 = <span class="keyword">new</span> <span class="keyword">int</span>[size];</span><br><span class="line">    <span class="built_in">std</span>::fill(prob1, prob1 + size, <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">std</span>::fill(prob2, prob2 + size, <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">std</span>::fill(prob1 + <span class="number">1</span>, prob1 + <span class="number">7</span>, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; size; j++) &#123;</span><br><span class="line">            prob2[j] = <span class="number">0</span>; <span class="comment">// 别忘了数值重置</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">1</span>; k &lt;= <span class="number">6</span> &amp;&amp; j-k&gt;=<span class="number">0</span>; k++) &#123;</span><br><span class="line">                prob2[j] += prob1[j-k];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 交换数组</span></span><br><span class="line">        <span class="keyword">int</span>* temp = prob1;</span><br><span class="line">        prob1 = prob2;</span><br><span class="line">        prob2 = temp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">double</span> total = (<span class="keyword">double</span>)<span class="built_in">std</span>::<span class="built_in">pow</span>(<span class="number">6</span>, n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = n; i &lt; size; i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d: %d\n&quot;</span>, i, prob1[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">delete</span>[] prob1;</span><br><span class="line">    <span class="keyword">delete</span>[] prob2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    print_probability(<span class="number">11</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>相比于书上的代码，这一版本更加简洁。</p><hr><blockquote><p>面试题61：扑克牌中的顺子。</p></blockquote><p>从扑克牌中随机抽5张牌，判断是不是一个顺子，即这5张牌是不是连续的。<code>2~10</code>为数字，<code>A</code>为<code>1</code>、<code>J</code>为<code>11</code>、<code>Q</code>为<code>12</code>、<code>K</code>为<code>13</code>，而<strong>大、小王可以看成任意数字</strong>。</p><p>思路比较基础，就是先把手里的数组排序（大小王当作0），统计0的个数，统计排序相邻数字之间的空缺总数，如果综述小于等于0的个数，则数组连续，否则不连续。如果数组中非0数字重复出现，则该数字不是连续的。</p><p>完整实现代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">is_straight</span><span class="params">(<span class="keyword">int</span>* numbers, <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(numbers == <span class="literal">nullptr</span> || len &lt; <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">std</span>::sort(numbers, numbers+len);</span><br><span class="line">    <span class="keyword">int</span> zeros = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> gaps = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(numbers[i] == <span class="number">0</span>) &#123;</span><br><span class="line">            zeros++;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(i &gt; <span class="number">0</span> &amp;&amp; numbers[i] == numbers[i<span class="number">-1</span>]) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(i &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            gaps += numbers[i] - numbers[i<span class="number">-1</span>] - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(gaps &lt;= zeros) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> nums[] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line">    <span class="keyword">if</span>(is_straight(nums, <span class="keyword">sizeof</span>(nums)/<span class="keyword">sizeof</span>(<span class="keyword">int</span>))) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Is straight.&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Is not straight.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果觉得代码中排序的部分<code>O(nlogn)</code>不够快，因为这里出现的数字只有<code>0~13</code>，所以还可以使用哈希表实现<code>O(n)</code>的排序。</p><hr><blockquote><p>面试题62：圆圈中最后剩下的数字。</p></blockquote><p><code>0,1,...,n-1</code>这<code>n</code>个数字排成一个圆圈，从数字<code>0</code>开始，每次从这个圆圈里删除第<code>m</code>个数字。求出这个圆圈里剩下的最后一个数字。</p><div align="center"><p><img src="/images/s2o-c6-f3.jpg"></p></div><p>例如上图的圆圈，从数字<code>0</code>开始，每次删除第<code>3</code>个数字，则删除的前4个数字是<code>2、0、4、1</code>，最后剩下的数字是<code>3</code>。</p><p>本题就是有名的约瑟夫(Josephuse)环问题。一种方法是用环形链表模拟圆圈的经典解法，时间复杂度<code>O(nm)</code>，另一种方法是分析被删除数字的规律，直接计算出圆圈中最后剩下的数字，时间复杂度<code>O(n)</code>。</p><p>链表模拟法就不再赘述了，主要讲一下第二个的规律分析法。</p><p>定义一个关于n和m的函数<code>f(n,m)</code>，表示每次在<code>n</code>个数字<code>0,1,...,n-1</code>中删除第<code>m</code>个数字最后剩下的数字。</p><p>在这n个数字中，第一个被删除的是<code>(m-1)%n</code>，简单起见，记为<code>k</code>，删除k之后剩下的n-1个数字为<code>0,1,...,k-1,k+1,...,n-1</code>，并且在下一次删除从数字<code>k+1</code>开始计数。相当于在剩下的序列中，<code>k+1</code>排在最前面，从而形成<code>k+1,...,n-1,0,1,...,k-1</code>。这个序列最后剩下的数字应该也是关于<code>n</code>和<code>m</code>的函数。</p><p>由于第二个序列和前面最初的序列不一样，因此函数不同于前面的函数，记为<code>f&#39;(n-1,m)</code>，所以有<code>f(n,m)=f&#39;(n-1,m)</code>。</p><p>接下来我们把，剩下的这<code>n-1</code>个数字的序列<code>k+1,...,n-1,0,1,...,k-1</code>进行映射，结果形成一个<code>0~n-2</code>的序列。</p><div align="center"><p><img src="/images/s2o-c6-f4.jpg"></p></div><p>把映射定义为<code>p</code>，则有<code>p(x)=(x-k-1)%n</code>，映射的逆映射是<code>p&#39;(x)=(x+k+1)%n</code>。</p><p>由于映射之后的序列和最初的序列具有相同的形式，即都是从0开始的连续序列，因此仍然可以用函数<code>f</code>来表示，记为<code>f(n-1,m)</code>。根据我们之前的推导，映射之前的序列剩下的数字是<code>f&#39;(n-1,m)=p&#39;(f(n-1,m))=(f(n-1,m)+k+1)%n</code>，把<code>k=(m-1)%n</code>代入，可以得到<code>f(n,m)=f&#39;(n-1,m)=[f(n-1,m)+m]%n</code>。</p><p>通过分析后，我们找到了一个递归公式，要得到这n个数的序列中最后剩下的数字，只需要得到n-1个数字的序列中最后剩下的数字，并以此类推。</p><p>当n=1时，序列中只有一个数字<code>0</code>，那么很显然最后剩下的数字就是<code>0</code>，这种递归可以写为：</p><div align="center"><p><img src="/images/s2o-c6-f5.jpg"></p></div><p>公式无论是用递归还是循环，都很容易实现。</p><p>完整实现代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">last_remaining</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> n, <span class="keyword">unsigned</span> <span class="keyword">int</span> m)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n &lt; <span class="number">1</span> || m &lt; <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> last = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        last = (last + m) % i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> last;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, last_remaining(<span class="number">5</span>, <span class="number">3</span>));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度<code>O(n)</code>，空间复杂度<code>O(1)</code>。</p><hr><blockquote><p>面试题63：股票的最大利润。</p></blockquote><p>假设把某股票的价格按照时间先后顺序存储在数组中，请问买卖该股票一次，可能获得的<strong>最大利润</strong>是多少？例如一支股票在某些时间节点的价格为<code>&#123;9,11,8,5,7,12,16,14&#125;</code>。如果我们能在价格<code>5</code>时买入，并在价格<code>16</code>时卖出，则收获最大利润<code>11</code>。</p><p>暴力遍历法时间复杂度<code>O(n^2)</code>，但是只要在从前向后计算的时候，保存前面序列中的最小值，就可以计算出当前值和前面序列的最小值的差值，最后获得最大差值就是最大利润。</p><p>完整实现代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;limits.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">max_profit</span><span class="params">(<span class="keyword">int</span>* numbers, <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(numbers == <span class="literal">nullptr</span> || len &lt; <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> min = numbers[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">int</span> max_profits = INT_MIN;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; len; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(numbers[i] - min &gt; max_profits) &#123;</span><br><span class="line">            max_profits = numbers[i] - min;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(min &gt; numbers[i]) &#123;</span><br><span class="line">            min = numbers[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> max_profits;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> numbers[] = &#123;<span class="number">9</span>,<span class="number">11</span>,<span class="number">8</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">12</span>,<span class="number">16</span>,<span class="number">14</span>&#125;;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;max profit is %d&quot;</span>, max_profit(numbers, <span class="keyword">sizeof</span>(numbers)/<span class="keyword">sizeof</span>(<span class="keyword">int</span>)));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>只需要扫描数组一次，该算法的时间复杂度<code>O(n)</code>。</p><h2 id="5-发散思维能力"><a href="#5-发散思维能力" class="headerlink" title="5 发散思维能力"></a>5 发散思维能力</h2><p>发散思维的特点是思维活动的多向性和变通性，也就是思考问题时，注重运动多思路、多方案、多途径来解决问题。对于同一个问题，我们可以从不同的方向、侧面和层次，采用探索、转移、迁移、组合和分解等方法，提出多种创新的解法。</p><h2 id="面试题64-66"><a href="#面试题64-66" class="headerlink" title="面试题64-66"></a>面试题64-66</h2><blockquote><p>面试题64：求1+2+…+n。</p></blockquote><p>求<code>1+2+...+n</code>，要求不能使用乘除法、for、while、if、else、switch、case等关键字及条件判断语句(A?B:C)。</p><p>循环和递归实现在本题中就没办法使用了，可以尝试从一些语言特性的方面来解决。</p><p><strong>解法一</strong>：利用构造函数求解。</p><p>循环只是让相同的代码重复执行n次而已，完全可以不用for和while来达到这个效果。比如定义一个类型，接着创建n个该类型的实例，那么这个类型的构造函数将确定会被调用n次，可以将与累加相关的代码放到构造函数里。</p><p>完整实现代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Temp</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Temp() &#123;</span><br><span class="line">        ++N;</span><br><span class="line">        Sum+=N;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">reset</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        N = <span class="number">0</span>;</span><br><span class="line">        Sum = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">get_sum</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Sum;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> N;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> Sum;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> Temp::N = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> Temp::Sum = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">sum_solution1</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    Temp::reset();</span><br><span class="line"></span><br><span class="line">    Temp* a = <span class="keyword">new</span> Temp[n]; <span class="comment">// 靠内部的循环来作弊，绝了</span></span><br><span class="line">    <span class="keyword">delete</span>[] a;</span><br><span class="line">    a = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> Temp::get_sum();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, sum_solution1(<span class="number">10</span>));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>解法二</strong>：利用虚函数求解。</p><p>同样可以围绕递归来做，既然不能在一个函数中判断是不是应该终止递归，那么不妨定义两个函数，一个充当递归函数，另一个函数处理终止递归地情况，需要做的就是在两个函数里二选一，从二选一我们很自然地想到布尔变量，比如值为<code>true</code>时，调用第一个函数，值为<code>false</code>时，调用第二个函数。</p><p>完整实现代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>;</span></span><br><span class="line">A* Array[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span>:</span> <span class="keyword">public</span> A &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 使用状态来选择函数，实现if else</span></span><br><span class="line">        <span class="keyword">return</span> Array[(<span class="keyword">bool</span>)n]-&gt;sum(n<span class="number">-1</span>)+n;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sum_solution2</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    A a;</span><br><span class="line">    B b;</span><br><span class="line">    Array[<span class="number">0</span>] = &amp;a;</span><br><span class="line">    Array[<span class="number">1</span>] = &amp;b;</span><br><span class="line">    <span class="keyword">int</span> value = Array[<span class="number">1</span>]-&gt;sum(n);</span><br><span class="line">    <span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, sum_solution2(<span class="number">10</span>));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用虚函数来实现函数的选择，当n不为0时，调用函数<code>B::sum</code>，当<code>n</code>等于<code>0</code>时，调用函数<code>A::sum</code>。</p><p><strong>解法三</strong>：利用函数指针求解。</p><p>纯C语言的变成环境中，我们不能使用虚函数，此时可以用函数指针来模拟，这样代码可能还更加直观一点。</p><p>完整实现代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="title">int</span> <span class="params">(*fun)</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">terminator</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">sum_solution3</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> fun f[<span class="number">2</span>] = &#123;terminator, sum_solution3&#125;;</span><br><span class="line">    <span class="keyword">return</span> n + f[(<span class="keyword">bool</span>)n](n<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, sum_solution3(<span class="number">10</span>));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>解法四</strong>：利用模板类求解。</p><p>还可以让编译器帮助完成类似于递归地计算。</p><p>完整能够代码实现：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">unsigned</span> <span class="keyword">int</span> n&gt; <span class="class"><span class="keyword">struct</span> <span class="title">sum_solution4</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">enum</span> <span class="title">value</span> &#123;</span> N = sum_solution4&lt;n<span class="number">-1</span>&gt;::N + n &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;&gt; <span class="class"><span class="keyword">struct</span> <span class="title">sum_solution4</span>&lt;</span><span class="number">1</span>&gt; &#123;</span><br><span class="line">    <span class="class"><span class="keyword">enum</span> <span class="title">Value</span> &#123;</span>N = <span class="number">1</span>&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, sum_solution4&lt;<span class="number">10</span>&gt;::N);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当编译器看到<code>sum_solution4&lt;10&gt;</code>，就会为模板类<code>sum_solution4</code>以参数<code>10</code>生成该类型的代码，并且以<code>10</code>为参数的类型需要得到以<code>9</code>为参数的类型，这个过程会一直递归到参数为<code>1</code>的类型（已经显式定义，编译器无须生成）。</p><p>由于这个过程是在编译过程中完成的，因此要求输入的n必须是在编译期间就能确定的常量，不能动态输入。而且编译器对递归编译代码的递归深度是有限制的，要求n不能太大。</p><hr><blockquote><p>面试题65：不用加减乘除做加法。</p></blockquote><p>写一个函数，求两个整数之和，要求在函数体内不得使用<code>+</code>、<code>-</code>、<code>×</code>、<code>÷</code>四则运算符号。</p><p>不能用四则运算的话，就只能考虑用位运算（与、或、非、异或）的方式来实现加法了。</p><p>例如<code>5+17=22</code>，<code>5</code>的二进制是<code>101</code>，<code>17</code>的二进制是<code>10001</code>，我们试着把计算分成三步：</p><ul><li>第一步，各位相加，不计进位，得到的结果是<code>10100</code>（1+1溢出后就是0）；</li><li>第二步，记下进位，在这个例子中只在最后一位相加时产生一个进位，结果是二进制的<code>10</code>；</li><li>第三步，把前两步的结果相加，得到结果<code>10110</code>，转换成十进制就是<code>22</code>。</li></ul><p>现在把二进制的加法用位运算来代替：</p><ul><li>第一步，非进位加法，其实和异或运算相同，例如<code>101^10001=10100</code>；</li><li>第二步，只有<code>1</code>加<code>1</code>时，会向前产生一个进位<code>1</code>，此时我们可以想象成两个数先做位与运算，然后再向左移动一位，例如<code>101&amp;10001 &lt;&lt; 1 = 10</code>；</li><li>第三步，把前面两步结果相加，又变成一个新的问题，递归调用前两步，直到不会再产生进位为止。</li></ul><p>完整实现代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">same_sign</span><span class="params">(<span class="keyword">int</span> num1, <span class="keyword">int</span> num2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (num1 &gt;&gt; <span class="number">31</span>) == (num2 &gt;&gt; <span class="number">31</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bit_add</span><span class="params">(<span class="keyword">int</span> num1, <span class="keyword">int</span> num2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sum, carry;</span><br><span class="line">    <span class="keyword">int</span> tnum1 = num1, tnum2 = num2;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        sum = tnum1^tnum2;</span><br><span class="line">        carry = (tnum1 &amp; tnum2) &lt;&lt; <span class="number">1</span>;</span><br><span class="line">        tnum1 = sum;</span><br><span class="line">        tnum2 = carry;</span><br><span class="line">    &#125; <span class="keyword">while</span>(tnum2 != <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(same_sign(num1, num2) &amp;&amp; !same_sign(num1, sum)) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Error: add overflow\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, bit_add(<span class="number">200</span>, <span class="number">20</span>));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在书上的代码基础上，加入对溢出的异常判断，其中对于溢出判定方法是，只有当两个数同号时才会在加法中溢出，并且最后结果和原来的两个数异号时，就代表发生了溢出，此时应该抛出异常。</p><p>PS：不使用新的变量，交换两个变量的值（适用于数值类）。比如有<code>a</code>、<code>b</code>，我们希望交换它们的值。有两种不同的方法：</p><div align="center"><p><img src="/images/s2o-c6-f6.jpg"></p></div><hr><blockquote><p>面试题66：构建乘积数组。</p></blockquote><p>给定一个数组<code>A[0,1,...,n-1]</code>，请构建一个数组<code>B[0,1,...,n-1]</code>，其中B中的元素<code>B[i]=A[0]*A[1]*...*A[i-1]*A[i+1]*...*A[n-1]</code>。不能使用除法。</p><p>因为不能使用除法，所以只能另辟蹊径，如果用暴力求解法，时间复杂度是<code>O(n)</code>。</p><p>如果单独地求解<code>A[0]*A[1]*...*A[i-1]</code>，我们是可以迭代地在<code>O(n)</code>时间里求解出所有的前序乘积的，同理所有的<code>A[i-1]*A[i+1]*...*A[n-1]</code>，我们也可以逆序地迭代<code>O(n)</code>的时间中求解，最后对于每一个<code>B[i]</code>找到对应的前序序列和逆序序列就可以用乘法得到最后的结果了。</p><p>PS：不知道这道题要不要考虑什么乘积大数溢出的问题，根据面试的具体情况来分析吧，这种题再加上大数就稍微有点复杂了。</p><p>完整实现代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">multi_array</span><span class="params">(<span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt;&amp; array1, <span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt;&amp; array2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len1 = array1.size();</span><br><span class="line">    <span class="keyword">int</span> len2 = array2.size();</span><br><span class="line">    <span class="keyword">if</span>(len1 != len2 || len2 &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 先计算正序序列值，暂存在array2中</span></span><br><span class="line">    <span class="keyword">double</span> temp = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len1; i++) &#123;</span><br><span class="line">        array2[i] = temp;</span><br><span class="line">        temp *= array1[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 计算逆序序列值，乘出最后结果</span></span><br><span class="line">    temp = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = len2 - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        array2[i] *= temp;</span><br><span class="line">        temp *= array1[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt; <span class="title">array1</span><span class="params">(&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;)</span></span>;</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt; <span class="title">array2</span><span class="params">(<span class="number">5</span>)</span></span>;</span><br><span class="line">    multi_array(array1, array2);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; array2.size(); i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%e &quot;</span>, array2[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种思路的时间复杂度是<code>O(n)</code>。</p><h2 id="6-总结"><a href="#6-总结" class="headerlink" title="6 总结"></a>6 总结</h2><p>面试是我们展示自己综合素质的时候，除了扎实的编程能力，我们还需要表现自己的沟通能力和学习能力，以及知识迁移能力、抽象建模能力和发散思维能力等方面的综合实力。</p><div align="center"><p><img src="/images/s2o-c6-f7.jpg"></p></div>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;沟通和学习能力是面试中关键的考查点。&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="剑指Offer" scheme="https://yumi-cn.github.io/categories/%E5%89%91%E6%8C%87Offer/"/>
    
    
    <category term="笔记" scheme="https://yumi-cn.github.io/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>《剑指Offer》第5章笔记 优化效率</title>
    <link href="https://yumi-cn.github.io/2021/01/11/s2o-c5-optimize/"/>
    <id>https://yumi-cn.github.io/2021/01/11/s2o-c5-optimize/</id>
    <published>2021-01-11T14:04:48.000Z</published>
    <updated>2021-01-14T10:23:20.987Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>时间与空间，是算法永恒的话题。</p></blockquote><a id="more"></a><h2 id="1-面试官谈效率"><a href="#1-面试官谈效率" class="headerlink" title="1 面试官谈效率"></a>1 面试官谈效率</h2><p>大佬们说的名言名句。</p><p>咕咕待更。</p><h2 id="2-时间效率"><a href="#2-时间效率" class="headerlink" title="2 时间效率"></a>2 时间效率</h2><p>面试官除了考查应聘者的编程能力，还关注应聘者有没有不断优化效率、追求完美的态度和能力。</p><p>首先，我们的编程习惯对代码的时间效率有很大影响。比如C/C++程序员要养成采用<strong>引用（或指针）传递复杂类型参数</strong>的习惯。如果采用值传递的方式，则从形参到实参会产生一次复制操作，这样的复制大部分时候是多余的，应该尽量避免。再比如，C#中做多次字符串的拼接操作，尽量不要用多次<code>String</code>的<code>+</code>运算符来拼接字符串，因为这样会产生很多<code>String</code>的临时实例，造成时间和空间的浪费，更好的办法是用<code>StringBuilder</code>的<code>Append</code>方法来完成字符串的拼接。如果我们平时不太注意这些影响代码效率的细节，没有养成好的编码习惯，写出的代码可能会让面试官大失所望。</p><p>其次，即使同一个算法用<strong>循环和递归两种思路实现</strong>的<strong>时间效率可能会大不一样</strong>。递归的本质是把一个大的复杂问题分解成两个或者多个小的简单问题。如果小问题有相互重叠的部分，那么直接用递归实现虽然代码显得很简洁，但时间效率可能会非常差，对于这种题目，可以用递归地思路来分析，写代码的时候可以基于循环实现，并且用数组来保存中间结果，绝大部分动态规划算法的分析和代码实现都是分这两个步骤完成的。</p><p>再次，代码的<strong>时间效率</strong>还能体现应聘者<strong>对数据结构和算法功底的掌握程度</strong>。同样是查找，如果是顺序查找则需要<code>O(n)</code>的时间；如果输入的是排序的数组则只需要<code>O(logn)</code>的时间；如果事先已经构造好了哈希表，那么查找在<code>O(1)</code>时间内就能完成。</p><p>最后，应聘者在面试的时候要展示<strong>敏捷的思维能力</strong>和<strong>追求完美的激情</strong>，这些对最终的面试结果也有很重要的影响。</p><h2 id="面试题-39-48"><a href="#面试题-39-48" class="headerlink" title="面试题 39-48"></a>面试题 39-48</h2><blockquote><p>面试题39：数组中出现次数超过一半的数字。</p></blockquote><p>数组中有一个数字出现的次数超过数组长度的一半，请找出这个数字。例如，输入一个长度为<code>9</code>的数组<code>&#123;1,2,3,2,2,2,5,4,2&#125;</code>。由于数字<code>2</code>在数组中出现了<code>5</code>次，超过数组长度的一半，因此输出<code>2</code>。</p><p><strong>解法一</strong>：基于Partition函数的时间复杂度为<code>O(n)</code>的算法。</p><p>数组中有一个数字出现的次数超过了数组长度的一半，如果这个数组排序，那么<strong>排序之后位于数组中间</strong>的数字，一定就是那个<strong>出现次数超过数组长度一半的数字</strong>。这个数字就是统计学上的中位数，即长度为<code>n</code>的数组中第<code>n/2</code>大的数字。我们有成熟的时间复杂度为<code>O(n)</code>的算法得到数组中任意第<code>k</code>大的数字。</p><p>这种算法受快速排序算法的启发。在随机快速排序算法中，先在数组中随机选择一个数字，然后调整数组中数字的顺序，使得比选中的数字小的数字都排在它的左边，比选中的数字大的数字都排在它的右边。如果这个<strong>选中的数字</strong>下标刚好是<code>n/2</code>，则这个数字就是数组的中位数；如果下标大于<code>n/2</code>，那么中位数应该在它的左边，接着在它的左边找；如果下标小于<code>n/2</code>，中位数在它的右边，接着在它的右边找。这是一个典型的递归过程。</p><p>完整实现代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">partition</span><span class="params">(<span class="keyword">int</span>* numbers, <span class="keyword">int</span> len, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(start == end) &#123;</span><br><span class="line">        <span class="keyword">return</span> start;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> anchor = numbers[end];</span><br><span class="line">    <span class="keyword">int</span> left = start;</span><br><span class="line">    <span class="keyword">int</span> right = end - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(left &lt; right) &#123;</span><br><span class="line">        <span class="keyword">while</span>(numbers[left] &lt; anchor &amp;&amp; left &lt; right) &#123;</span><br><span class="line">            left++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(numbers[right] &gt;= anchor &amp;&amp; left &lt; right) &#123;</span><br><span class="line">            right--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(left != right) &#123;</span><br><span class="line">            <span class="keyword">int</span> temp = numbers[left];</span><br><span class="line">            numbers[left] = numbers[right];</span><br><span class="line">            numbers[right] = temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(left != end - <span class="number">1</span> || numbers[left] &gt; anchor) &#123;</span><br><span class="line">        <span class="keyword">int</span> temp = numbers[left];</span><br><span class="line">        numbers[left] = numbers[end];</span><br><span class="line">        numbers[end] = temp;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        left = end;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> left;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> g_input_invalid = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check_array</span><span class="params">(<span class="keyword">int</span>* numbers, <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">    g_input_invalid = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span>(numbers == <span class="literal">nullptr</span> || len &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        g_input_invalid = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> g_input_invalid;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check_more_than_half</span><span class="params">(<span class="keyword">int</span>* numbers, <span class="keyword">int</span> len, <span class="keyword">int</span> number)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> times = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(numbers[i] == number) &#123;</span><br><span class="line">            times++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">bool</span> is_more_than_half = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">if</span>(times * <span class="number">2</span> &lt;= len) &#123;</span><br><span class="line">        g_input_invalid = <span class="literal">true</span>;</span><br><span class="line">        is_more_than_half = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> is_more_than_half;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">more_than_half_num</span><span class="params">(<span class="keyword">int</span>* numbers, <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(check_array(numbers, len)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> middle = len &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> start = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> end = len - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> index = partition(numbers, len, start, end);</span><br><span class="line">    <span class="keyword">while</span>(index != middle) &#123;</span><br><span class="line">        <span class="keyword">if</span>(index &gt; middle) &#123;</span><br><span class="line">            end = index - <span class="number">1</span>;</span><br><span class="line">            index = partition(numbers, len, start, end);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            start = index + <span class="number">1</span>;</span><br><span class="line">            index = partition(numbers, len, start, end);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> result = numbers[middle];</span><br><span class="line">    <span class="keyword">if</span>(!check_more_than_half(numbers, len, result)) &#123;</span><br><span class="line">        result = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> numbers[] = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">2</span> &#125;;</span><br><span class="line">    <span class="keyword">int</span> result = more_than_half_num(numbers, <span class="number">9</span>);</span><br><span class="line">    <span class="keyword">if</span>(g_input_invalid) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Invalid input.\n&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Result: %d\n&quot;</span>, result);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在面试的时候，除了完成基本功能，还要考虑一些无效的输入。如果函数的输入参数是一个指针（数组在参数传递的时候退化为指针），就要考虑这个指针可能为<code>nullptr</code>。代码中的<code>check_array</code>用来判断输入的数组是不是无效的。<code>check_more_than_half</code>用来检验输入的数组中，是不是这个数字出现次数大于长度一半，用全局变量<code>g_input_invalid</code>来表示输入无效的情况。</p><p><strong>解法二</strong>：根据数组特点找出时间复杂度为<code>O(n)</code>的算法。</p><p>从另一个角度来解决这个问题。数组中有一个数字出现的次数超过数组长度的一半，也就是说<strong>它出现的次数比其他所有数字出现的和还要多</strong>。因此，考虑在遍历数组的时候保存<strong>两个值</strong>，一个是<strong>数组中的一个数字</strong>，另一个是<strong>次数</strong>。当遍历到下一个数字时，如果下一个数字和之前保存的数字相同，则<strong>次数加1</strong>；如果下一个数字和之前保存的不同，则<strong>次数减1</strong>；如果<strong>次数为0</strong>，则<strong>保存下一个数字</strong>，并把<strong>次数设1</strong>。由于要找的数字出现的次数比其他所有出现的次数之和还要多，那么要找的数字肯定是<strong>最后一次把次数设为1对应的数字</strong>。</p><p>完整实现代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> g_input_invalid = <span class="literal">false</span>;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check_array</span><span class="params">(<span class="keyword">int</span>* numbers, <span class="keyword">int</span> len)</span> </span>&#123; ... &#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check_more_than_half</span><span class="params">(<span class="keyword">int</span>* numbers, <span class="keyword">int</span> len, <span class="keyword">int</span> number)</span> </span>&#123; ... &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">more_than_half_num</span><span class="params">(<span class="keyword">int</span>* numbers, <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(check_array(numbers, len)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> result = numbers[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">int</span> times = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(times == <span class="number">0</span>) &#123;</span><br><span class="line">            result = numbers[i];</span><br><span class="line">            times = <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(numbers[i] == result) &#123;</span><br><span class="line">            times++;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            times--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(!check_more_than_half(numbers, len, result)) &#123;</span><br><span class="line">        result = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> numbers[] = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">2</span> &#125;;</span><br><span class="line">    <span class="keyword">int</span> result = more_than_half_num(numbers, <span class="number">9</span>);</span><br><span class="line">    <span class="keyword">if</span>(g_input_invalid) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Invalid input.\n&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Result: %d\n&quot;</span>, result);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>两种解法算法的时间复杂度都是<code>O(n)</code>，在第一种解法中，需要交换数组中数字的顺序，这就会修改输入的数组，而在面试的时候需要尝试和面试官讨论，明确需求，如果说不能修改输入的数组，就只能采用第二种解法了。</p><hr><blockquote><p>面试题40：最小的K个数。</p></blockquote><p>输入<code>n</code>个整数，找出其中最小的<code>k</code>个数，例如，输入<code>4,5,1,6,2,7,3,8</code>这<code>8</code>个数字，则最小的<code>4</code>个数字是<code>1,2,3,4</code>。</p><p>最简单直观的解法就是进行<code>k</code>次数组遍历，每一次找出一个相对最小值，时间复杂度<code>O(nk)</code>，代码比较简单就不再写了，主要讲两种优化的思路。</p><p><strong>解法一</strong>：时间复杂度为<code>O(n)</code>的算法，只有当我们<strong>可以修改输入的数组时</strong>可用。</p><p>同样可以基于<code>partition</code>函数来解决这个问题。如果基于数组的第<code>k</code>个数字来调整，使得比第<code>k</code>个数字小的所有数字都位于数组的左边，比第<code>k</code>个数大的所有数字都位于数组的右边。这样，位于数组中左边的<code>k</code>个数字就是最小的<code>k</code>个数字（<code>k</code>个数字不一定是排序的）。</p><p>完整实现代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">partition</span><span class="params">(<span class="keyword">int</span>* numbers, <span class="keyword">int</span> len, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123; ... &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">find_k_min</span><span class="params">(<span class="keyword">int</span>* input, <span class="keyword">int</span> n, <span class="keyword">int</span>* output, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(input == <span class="literal">nullptr</span> || output == <span class="literal">nullptr</span> || k &gt; n || n &lt;= <span class="number">0</span> || k &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> start = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> end = n - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> index = partition(input, n, start, end);</span><br><span class="line">    <span class="keyword">while</span>(index != k - <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span>(index &gt; k - <span class="number">1</span>) &#123;</span><br><span class="line">            end = index - <span class="number">1</span>;</span><br><span class="line">            index = partition(input, n, start, end);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            start = index + <span class="number">1</span>;</span><br><span class="line">            index = partition(input, n, start, end);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; i++) &#123;</span><br><span class="line">        output[i] = input[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> input[] = &#123; <span class="number">4</span>,<span class="number">5</span>,<span class="number">1</span>,<span class="number">6</span>,<span class="number">2</span>,<span class="number">7</span>,<span class="number">3</span>,<span class="number">8</span> &#125;;</span><br><span class="line">    <span class="keyword">int</span> n = <span class="number">8</span>;</span><br><span class="line">    <span class="keyword">int</span> k = <span class="number">4</span>;</span><br><span class="line">    <span class="keyword">int</span>* output = <span class="keyword">new</span> <span class="keyword">int</span>[k];</span><br><span class="line">    find_k_min(input, n, output, k);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, output[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果面试官要求不能修改输入的数组，那么就只能另辟蹊径。</p><p><strong>解法二</strong>：时间复杂度为<code>O(nlogk)</code>的算法，特别适合处理海量数据。</p><p>先创建一个大小为<code>k</code>的数据容器来存储最小的<code>k</code>个数字，接下来每次从输入的<code>n</code>个整数中读入一个数。如果容器中少于<code>k</code>个，则直接把这次读入的整数放入容器中；如果容器已经有<code>k</code>个了，此时<strong>比较读入的数字和容器中最大的数字</strong>，如果读入的更小，就插入容器，删除掉最大的。</p><p>如果用一棵二叉树（堆）来实现容器，那么就能在<code>O(logk)</code>时间内完成一个序列的最大值构建（<code>O(1)</code>的时间得到最大值，<code>O(logk)</code>时间完成删除和插入操作），对于<code>n</code>个输入数字，总的时间效率是<code>O(nlogk)</code>。</p><p>从头实现一个最大堆需要一定的代码，面试的几十分钟内很难完成，我们可以借助STL提供的一些数据结构，例如<code>set</code>或者<code>multiset</code>（区别是后者可以重复），如果面试官不反对使用STL，就可以直接拿来用，根据这道题的需求，使用<code>multiset</code>更加合适一点。</p><p>完整实现代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// std::greater 代表递减排序 最大的在begin</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">std</span>::<span class="built_in">multiset</span>&lt;<span class="keyword">int</span>, <span class="built_in">std</span>::greater&lt;<span class="keyword">int</span>&gt;&gt; int_set;</span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">std</span>::<span class="built_in">multiset</span>&lt;<span class="keyword">int</span>, <span class="built_in">std</span>::greater&lt;<span class="keyword">int</span>&gt;&gt;::iterator int_set_iter;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">find_k_min</span><span class="params">(<span class="keyword">int</span>* input, <span class="keyword">int</span> n, <span class="keyword">int</span>* output, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(input == <span class="literal">nullptr</span> || output == <span class="literal">nullptr</span> || k &gt; n || n &lt;= <span class="number">0</span> || k &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    int_set <span class="built_in">set</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">set</span>.size() &lt; k) &#123;</span><br><span class="line">            <span class="built_in">set</span>.insert(input[i]);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            int_set_iter iter = <span class="built_in">set</span>.begin();</span><br><span class="line">            <span class="keyword">if</span>(*iter &gt; input[i]) &#123;</span><br><span class="line">                <span class="built_in">set</span>.erase(iter);</span><br><span class="line">                <span class="built_in">set</span>.insert(input[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    int_set_iter iter = <span class="built_in">set</span>.begin();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; i++) &#123;</span><br><span class="line">        output[i] = *iter;</span><br><span class="line">        iter++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> input[] = &#123; <span class="number">4</span>,<span class="number">5</span>,<span class="number">1</span>,<span class="number">6</span>,<span class="number">2</span>,<span class="number">7</span>,<span class="number">3</span>,<span class="number">8</span> &#125;;</span><br><span class="line">    <span class="keyword">int</span> n = <span class="number">8</span>;</span><br><span class="line">    <span class="keyword">int</span> k = <span class="number">4</span>;</span><br><span class="line">    <span class="keyword">int</span>* output = <span class="keyword">new</span> <span class="keyword">int</span>[k];</span><br><span class="line">    find_k_min(input, n, output, k);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, output[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>第一种基于函数<code>partition</code>的第一种解法平均时间复杂度是<code>O(n)</code>，比第二种解法要快，但同时也有限制，比如会修改输入的数组（开<code>O(n)</code>空间虽然可以解决，但是有额外的空间代价）。</p><p>第二种基于最大堆容器的解法虽然慢，但一是没有修改输入的数据，二是算法适合海量数据的处理，因为第二种方法不用一次性将全部数据都读入到内存中，而第一种方法只有全部读入才能计算。</p><hr><!-- BGM《magnolia》keshi --><blockquote><p>面试题41：数据流中的中位数。</p></blockquote><p>如何得到一个数据流的中位数？如果从数据流读出的<strong>数据是奇数个</strong>，那么中位数就是所有值排序之后位于中间的数值；如果从数据流中读取<strong>偶数个数值</strong>，那么中位数是排序之后两个数的平均值。</p><p>数据是从一个数据流中读出来的，<strong>因而数据的数目随着时间的变化而增加</strong>，如果用一个数据容器来保存从流中读出来的数据，<strong>则当有新的数据从流中读出来，这些数据就插入数据容器</strong>（所以中位数是一个不断在变化的值，和容器的状态相关）。</p><p>那么可以考虑用几种不同的数据结构来作为容器：</p><ul><li><strong>数组</strong>：没有排序，可以使用<code>partition</code>找出数组的中位数，输入复杂度<code>O(1)</code>，找数中位数<code>O(n)</code>；</li><li><strong>排序数组</strong>：<code>O(logn)</code>时间搜索，但需要<code>O(n)</code>时间来插入，得到中位数的时间是<code>O(1)</code>；</li><li><strong>排序链表</strong>：<code>O(n)</code>时间插入，定义两个指针来指向链表中间的节点（不断调整的开销<code>O(1)</code>），所以找出中位数只需要<code>O(1)</code>；</li><li><strong>AVL树</strong>：<code>O(logn)</code>时间插入一个新节点，用<code>O(1)</code>时间得到所有节点的中位数，虽然AVL效率很高，但是大部分编程语言的函数库都没有实现这个数据结构，自己在短时间内实现也很麻烦；</li><li><strong>最大堆+最小堆</strong>：以把中位数定义为将数组分为两个部分，前一部分小于中位数，后一部分大于中位数，所以其实我们不需要前后部分一定要完整地排序，我们只需要得到前一部分的最大值和后一部分的最小值，所以可以<strong>用最大堆来组织前一部分，用最小堆组织后一部分</strong>，让两部分的大小接近相等，插入时间<code>O(logn)</code>，得到中位数的时间<code>O(1)</code>。</li></ul><div align="center"><p><img src="/images/s2o-c5-f1.jpg"><br><img src="/images/s2o-c5-f2.jpg"></p></div><p>基于STL中的函数<code>push_heap</code>、<code>pop_heap</code>及<code>vector</code>实现堆。比较仿函数<code>less</code>和<code>greater</code>分别用来实现最大堆和最小堆。</p><p>完整实现代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt; // push_heap/pop_heap/less/greater</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;exception&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="class"><span class="keyword">class</span> <span class="title">DynamicArray</span> &#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(T num)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(((min.size() + max.size()) &amp; <span class="number">1</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// 已经有偶数个，但有可能是0</span></span><br><span class="line">                <span class="keyword">if</span>(max.size() &gt; <span class="number">0</span> &amp;&amp; num &lt; max[<span class="number">0</span>]) &#123;</span><br><span class="line">                    <span class="comment">// 如果这个数比最大堆的堆顶元素小，要先放进最大堆</span></span><br><span class="line">                    max.push_back(num);</span><br><span class="line">                    <span class="comment">// 构建堆</span></span><br><span class="line">                    <span class="built_in">std</span>::push_heap(max.begin(), max.end(), <span class="built_in">std</span>::less&lt;T&gt;());</span><br><span class="line">                    <span class="comment">// 拿出堆顶元素</span></span><br><span class="line">                    num = max[<span class="number">0</span>];</span><br><span class="line">                    <span class="comment">// pop_head，将堆顶元素放在后面</span></span><br><span class="line">                    <span class="built_in">std</span>::pop_heap(max.begin(), max.end(), <span class="built_in">std</span>::less&lt;T&gt;());</span><br><span class="line">                    <span class="comment">// 元素出堆</span></span><br><span class="line">                    max.pop_back();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 元素进最小堆</span></span><br><span class="line">                min.push_back(num);</span><br><span class="line">                <span class="built_in">std</span>::push_heap(min.begin(), min.end(), <span class="built_in">std</span>::greater&lt;T&gt;());</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 已经有奇数个</span></span><br><span class="line">                <span class="keyword">if</span>(min.size() &gt; <span class="number">0</span> &amp;&amp; min[<span class="number">0</span>] &lt; num) &#123;</span><br><span class="line">                    <span class="comment">// 如果这个数比最小堆的堆顶元素大，要先放进最小堆</span></span><br><span class="line">                    min.push_back(num);</span><br><span class="line">                    <span class="comment">// 构建堆</span></span><br><span class="line">                    <span class="built_in">std</span>::push_heap(min.begin(), min.end(), <span class="built_in">std</span>::greater&lt;T&gt;());</span><br><span class="line">                    <span class="comment">// 拿出堆顶元素</span></span><br><span class="line">                    num = min[<span class="number">0</span>];</span><br><span class="line">                    <span class="comment">// 堆顶元素放在后面</span></span><br><span class="line">                    <span class="built_in">std</span>::pop_heap(min.begin(), min.end(), <span class="built_in">std</span>::greater&lt;T&gt;());</span><br><span class="line">                    <span class="comment">// 元素出堆</span></span><br><span class="line">                    min.pop_back();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 元素进最大堆</span></span><br><span class="line">                max.push_back(num);</span><br><span class="line">                <span class="built_in">std</span>::push_heap(max.begin(), max.end(), <span class="built_in">std</span>::less&lt;T&gt;());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function">T <span class="title">get_median</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">int</span> size = min.size() + max.size();</span><br><span class="line">            <span class="keyword">if</span>(size == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// throw error</span></span><br><span class="line">                <span class="function"><span class="built_in">std</span>::logic_error <span class="title">ex</span><span class="params">(<span class="string">&quot;Empty!&quot;</span>)</span></span>;</span><br><span class="line">                <span class="keyword">throw</span> <span class="built_in">std</span>::exception(ex);</span><br><span class="line">            &#125;</span><br><span class="line">            T median = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span>((size &amp; <span class="number">1</span>) == <span class="number">1</span>) &#123;</span><br><span class="line">                median = min[<span class="number">0</span>]; <span class="comment">// 偶数的时候进最小堆，所以奇数时最小堆会多一个</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                median = (min[<span class="number">0</span>] + max[<span class="number">0</span>]) / <span class="number">2</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> median;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;T&gt; min;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;T&gt; max;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">stream_median</span><span class="params">(<span class="keyword">int</span>* stream, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(stream == <span class="literal">nullptr</span> || n &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    DynamicArray&lt;<span class="keyword">int</span>&gt; darray; <span class="comment">// 注意模板类的声明使用方法</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        darray.insert(stream[i]);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Read index=%d, median=%d\n&quot;</span>, i, darray.get_median());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> stream[] = &#123; <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>&#125;;</span><br><span class="line">    stream_median(stream, <span class="number">20</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中使用到了代码里不常用的模板类，如果面试题有说明具体的数据类型，也可以直接用那个数据类型，而不是使用模板类。</p><p>其中使用到的几个和堆相关的函数进行一下说明，以后可能会用到：</p><ul><li><code>make_heap(begin, end, comp)</code>：虽然在这里没有用到，但还是说明一下，将一个数组(<code>vector</code>)的指定部分(<code>[begin,end)</code>)进行堆排序，堆顶元素放在第一个位置，默认使用的<code>comp</code>是<code>less&lt;T&gt;</code>，即最大元素放在第一个位置（最大堆），<code>greater&lt;T&gt;</code>为最小元素放在第一个位置（最小堆）；</li><li><code>push_heap(begin, end, comp)</code>：一般在调用前，把一个新元素放在数组的尾部(<code>vec.push_back(elm)</code>)，然后再调用函数对插入尾部的元素做堆排序；</li><li><code>pop_heap(begin, end, comp)</code>：将堆顶元素移动到数组尾部，同时将剩下的元素重新构造成堆结构；</li><li><code>sort_heap(begin, end, comp)</code>：将一个堆做排序，最终成为一个有序的序列，前提条件是输入的数组范围本身是一个对应<code>comp</code>的堆，如果<code>comp</code>是<code>less&lt;T&gt;</code>，最大堆最终序列是一个递增序列（大的在后面），如果是<code>greater&lt;T&gt;</code>，最小堆最终序列是一个递减序列（小的在后面）；</li></ul><hr><blockquote><p>面试题42：连续子数组的最大和。</p></blockquote><p>输入一个整型数组，数组里有正数也有负数。数组中的一个或连续多个整数组成一个子数组。求所有子数组的和的最大值（就是和最大的那个子数组的和值是多少），要求时间复杂度<code>O(n)</code>；例如，输入的数组为<code>&#123;1,-2,3,10,-4,7,2,-5&#125;</code>，和最大的子数组为<code>&#123;3,10,-4,7,2&#125;</code>，因此输出为该子数组的和<code>18</code>。</p><p>最简单直观的暴力遍历法就不说了（时间<code>O(n^2)</code>），只说优化的解决方案。</p><p><strong>解法一</strong>：举例分析数组的规律。</p><p>从头开始往后加可以分析其中的规律，例如从某一步从<code>i</code>开始向后累加和，到<code>j</code>之前如果和已经为负数了，那么对于<code>j</code>而言，如果再加上前面这前<code>j-i</code>个位置的数字肯定不会比<code>j</code>自身要大，所以要计算从<code>j</code>开始的可能最大子数组和，就不用再加上前<code>j-i</code>位置的数字，重新从<code>j</code>开始求子数组和；同时求和的过程中，不断的更新记录的最大和。</p><div align="center"><p><img src="/images/s2o-c5-f3.jpg" alt="计算数组{1,-2,3,10,-4,7,2,-5}中最大子数组和的过程"></p></div><p>完整实现代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;limits.h&gt; // INT_MIN INT_MAX</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> g_invalid_input = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check_input</span><span class="params">(<span class="keyword">int</span>* data, <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">    g_invalid_input = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span>(data == <span class="literal">nullptr</span> || len &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        g_invalid_input = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find_max_sub_sum</span><span class="params">(<span class="keyword">int</span>* data, <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!check_input(data, len)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> max_sum = INT_MIN;</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(sum &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            sum = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        sum += data[i];</span><br><span class="line">        <span class="keyword">if</span>(max_sum &lt; sum) &#123;</span><br><span class="line">            max_sum = sum;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> max_sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> data[] = &#123;<span class="number">1</span>, <span class="number">-2</span>, <span class="number">3</span>, <span class="number">10</span>, <span class="number">-4</span>, <span class="number">7</span>, <span class="number">2</span>, <span class="number">-5</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> result = find_max_sub_sum(data, <span class="number">8</span>);</span><br><span class="line">    <span class="keyword">if</span>(g_invalid_input) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Invalid input.\n&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Max sum: %d\n&quot;</span>, result); <span class="comment">// 18</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>解法二</strong>：动态规划法。</p><p>如果用函数<code>f(i)</code>表示以第<code>i</code>个数字结尾的子数组（即必须包含这个尾元素）的最大和，那么我们需要求出<code>max&#123;f(i)&#125;, 0&lt;=i&lt;=n</code>，可以用如下递归公式来求<code>f(i)</code>：</p><div align="center"><p><img src="/images/s2o-c5-f4.jpg"></p></div><p>其实公式的意义和解法一的思路是相同的，不过表达形式不同，代码就不再写一遍了。</p><hr><blockquote><p>面试题43：1~n整数中1出现的次数。</p></blockquote><p>输入一个整数<code>n</code>，求<code>1~n</code>这<code>n</code>个整数的十进制表示中<code>1</code>出现的次数，例如，输入<code>12</code>，<code>1~12</code>这些整数中包含<code>1</code>的数字有<code>1、10、11</code>和<code>12</code>，<code>1</code>一共出现了<code>5</code>次。</p><p>简单地方法就不再写了，主要写一下书上的优化方法（其实还蛮不好理解的），直接看书上举的例子吧。</p><ul><li>例如<code>1~21345</code>，首先拆成<code>1~1345</code>和<code>1346~21345</code>，前者可以递归地调用<code>1~n</code>；</li><li><code>1346~21345</code>必然会包含<code>10000~19999</code>（因为<code>21345</code>的顶位<code>2</code>大于<code>1</code>），所以顶位上出现的1的个数有<code>10^4</code>个；如果定位小于<code>1</code>，即只包括<code>1346~11345</code>或者说<code>10000~11345</code>这部分，顶位的1个数就只有<code>1346+1</code>个；</li><li><code>1346~21345</code>数完顶位后，开始计数其他位的1个数，此时分为两组<code>1346~11345</code>,<code>11346~21345</code>，这样分的目的是，<code>1346~11345</code>的后4位<code>x1346~x1345</code>整好覆盖了4位数的所有情况<code>0~9999</code>，所以只需要其中一位固定1，其他位任选<code>0~9</code>，就可以得到该位上的1个数，所以对于一组<code>1346~11345</code>有<code>4*10^3</code>个，<code>11346~21345</code>同理<code>4*10^3</code>个，所以一共<code>2*4*10^3</code>个；</li><li>最后将递归求解的<code>1~1345</code>计数，和<code>1346~21345</code>顶位计数和其他位技术相加，就得到最后的结果。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pow_base_10</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> result = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">unsigned</span> <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        result *= <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">count_1</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* str_n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!str_n || *str_n &lt; <span class="string">&#x27;0&#x27;</span> || *str_n &gt; <span class="string">&#x27;9&#x27;</span> || *str_n == <span class="string">&#x27;\0&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> first = *str_n - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> len = (<span class="keyword">unsigned</span> <span class="keyword">int</span>)<span class="built_in">strlen</span>(str_n);</span><br><span class="line">    <span class="keyword">if</span>(len == <span class="number">1</span> &amp;&amp; first == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(len == <span class="number">1</span> &amp;&amp; first &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 假设str_n是 21345</span></span><br><span class="line">    <span class="comment">// num_first_digit 是数字10000~19999的第一位中的数目</span></span><br><span class="line">    <span class="keyword">int</span> num_first_digit = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(first &gt; <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">// 无论first有多大，只要大于1</span></span><br><span class="line">        <span class="comment">// 就包含10000~19999这些数（目前的例子下）</span></span><br><span class="line">        <span class="comment">// 所以目前的顶位出现的1的数量有 10^(len-1)个</span></span><br><span class="line">        num_first_digit = pow_base_10(len - <span class="number">1</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(first == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">// 如果fisrt位1，就是10000~11345这种情况</span></span><br><span class="line">        <span class="comment">// 这个时候就有1345+1个1出现在顶位上</span></span><br><span class="line">        num_first_digit = atoi(str_n + <span class="number">1</span>) + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 1346~21345除了在顶位之外的数位上1的情况</span></span><br><span class="line">    <span class="comment">// 最高位是2，所以分成两段 1346~11345 11346~21345</span></span><br><span class="line">    <span class="comment">// 每一段剩下的4位数字中，选择其中一位是1，其余三位可以在0~9数字中选择</span></span><br><span class="line">    <span class="comment">// 根据排列组合有 2 * 4 * 10^3</span></span><br><span class="line">    <span class="keyword">int</span> num_other_digit = first * (len - <span class="number">1</span>) * pow_base_10(len - <span class="number">2</span>);</span><br><span class="line">    <span class="comment">// 1~1345的1的数目</span></span><br><span class="line">    <span class="keyword">int</span> num_rec = count_1(str_n + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> num_first_digit + num_other_digit + num_rec;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">count_1_from_1_to_n</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n &lt; <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">char</span> str_n[<span class="number">50</span>];</span><br><span class="line">    <span class="built_in">sprintf</span>(str_n, <span class="string">&quot;%d&quot;</span>, n);</span><br><span class="line">    <span class="keyword">return</span> count_1(str_n);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;1~%d have %d &#x27;1&#x27;\n&quot;</span>, <span class="number">12</span>, count_1_from_1_to_n(<span class="number">12</span>));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;1~%d have %d &#x27;1&#x27;\n&quot;</span>, <span class="number">21345</span>, count_1_from_1_to_n(<span class="number">21345</span>));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最基础的思路需要<code>O(nlogn)</code>的时间，优化后的思路只需要<code>O(logn)</code>，所以要快得多。</p><hr><blockquote><p>面试题44：数字序列中某一位的数字。</p></blockquote><p>数字以<code>0123456789101112131415...</code>的格式，序列化到一个字符序列中。在这个序列中，第5位(从0开始计数)是5，第13位是1，第19位是4，等等。写一个函数，求任意第<code>n</code>位对应的数字。</p><p>直接的方法就是从0开始逐一地枚举每个数组，每枚举一个数字时，求该数字是几位数，并把位数累加，如果位数只和小于或等于输入的n，则继续枚举下一个数字，当累加位数大于n时，第n位数字一定在这个数字里，我们再从该数字中找出对应的一位。</p><p>这样的方法还不够优化，其实是可以有规律地一段段跳过的，例如寻找第<code>1001</code>位：</p><ul><li><code>0~9</code>一共10个字符，<code>1001</code>&gt;<code>10</code>，在后面的字符中寻找第<code>991</code>位；</li><li><code>10~99</code>一共180(90*2)个字符，<code>991</code>&gt;<code>180</code>，在后面的字符中寻找第<code>881</code>位；</li><li><code>100~999</code>一共2700(900*3)个字符，<code>881</code>&lt;<code>2700</code>，所以第<code>n</code>位一定是<code>100~999</code>中间的某个数，由于<code>811=270*3+1</code>，意味着第<code>881</code>位是从<code>100</code>开始的第<code>270</code>个数字(<code>370</code>)的中间1位，即<code>7</code>。</li></ul><p>完整代码实现：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt; // std::pow</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 得到为m位数字总共有多少个</span></span><br><span class="line"><span class="comment">// 例如m=2，返回(10~99)一共90个</span></span><br><span class="line"><span class="comment">// m=3，返回(100~999)一共900个</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">count_of_integers</span><span class="params">(<span class="keyword">int</span> digits)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(digits == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> count = (<span class="keyword">int</span>) <span class="built_in">std</span>::<span class="built_in">pow</span>(<span class="number">10</span>, digits - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">9</span> * count;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 得到在m位数字中，第一个数字</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">begin_num</span><span class="params">(<span class="keyword">int</span> digits)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(digits == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">int</span>) <span class="built_in">std</span>::<span class="built_in">pow</span>(<span class="number">10</span>, digits - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 得到在m位数字中，第n位到是什么</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">digit_at_n</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> digits)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 例如370 = 100 + 881 / 3</span></span><br><span class="line">    <span class="keyword">int</span> number = begin_num(digits) + n / digits;</span><br><span class="line">    <span class="comment">// 例如1 = 3 - 881 % 3</span></span><br><span class="line">    <span class="comment">// from right 是为了之后求数的时候直接从底位开始</span></span><br><span class="line">    <span class="keyword">int</span> n_from_right = digits - n % digits;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n_from_right; i++) &#123;</span><br><span class="line">        number /= <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> number % <span class="number">10</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">digit_at_n</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> digits = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> numbers = count_of_integers(digits);</span><br><span class="line">        <span class="keyword">if</span>(n &lt; numbers * digits) &#123;</span><br><span class="line">            <span class="keyword">return</span> digit_at_n(n, digits);</span><br><span class="line">        &#125;</span><br><span class="line">        n -= digits * numbers;</span><br><span class="line">        digits++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, digit_at_n(<span class="number">0</span>));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, digit_at_n(<span class="number">1000</span>));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, digit_at_n(<span class="number">1001</span>));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, digit_at_n(<span class="number">1002</span>));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><blockquote><p>面试题45：把数组排成最小的数。</p></blockquote><p>输入一个<strong>正整数数组</strong>，把数组里<strong>所有数字</strong>拼接起来<strong>排成一个数</strong>，打印能拼接出的所有数字中<strong>最小的一个</strong>。例如，输入<code>&#123;3,32,321&#125;</code>，则打印出这3个数字能排成的最小数字<code>321323</code><br>。</p><p>基础的思路是全排列，然后找出最小的，时间开销一般是<code>O(n!)</code>，优化的思路也不会很复杂，比如就单看两个数<code>nn</code>和<code>mm</code>，他们两个如何拼接可以最小，也就是比较<code>nnmm</code>和<code>mmnn</code>，那么当整个数组都是前一个数在前面的情况下可以让两个数的结果最小，顺序拼接的结果自然也是最小的（即不会出现比这个结果还小的结果），所以最后问题变成利用这种规则去对数组进行排序。</p><p>完整实现代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt; // sort</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt; // strcpy strcmp strcat</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> g_invalid_input = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check_data</span><span class="params">(<span class="keyword">int</span>* data, <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">    g_invalid_input = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span>(data == <span class="literal">nullptr</span> || len &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        g_invalid_input = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 校验是否都是正整数</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(data[i] &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            g_invalid_input = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAX_INT_LEN = <span class="number">10</span>;</span><br><span class="line"><span class="comment">// 申请两个全局字符数组，避免排序函数中反复申请，浪费时间</span></span><br><span class="line"><span class="keyword">char</span>* g_str_comb1 = <span class="keyword">new</span> <span class="keyword">char</span>[MAX_INT_LEN * <span class="number">2</span> + <span class="number">1</span>];</span><br><span class="line"><span class="keyword">char</span>* g_str_comb2 = <span class="keyword">new</span> <span class="keyword">char</span>[MAX_INT_LEN * <span class="number">2</span> + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">compare</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* num1, <span class="keyword">const</span> <span class="keyword">char</span>* num2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">strcpy</span>(g_str_comb1, num1);</span><br><span class="line">    <span class="built_in">strcat</span>(g_str_comb1, num2);</span><br><span class="line">    <span class="built_in">strcpy</span>(g_str_comb2, num2);</span><br><span class="line">    <span class="built_in">strcat</span>(g_str_comb2, num1);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">strcmp</span>(g_str_comb1, g_str_comb2) == <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">min_concat</span><span class="params">(<span class="keyword">int</span>* data, <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!check_data(data, len)) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 其实还要考虑两个int相连有可能会超过int表示范围</span></span><br><span class="line">    <span class="comment">// 所以转用字符串可能更合适，同时也不会修改原数据的顺序</span></span><br><span class="line">    <span class="keyword">char</span>** str_data = <span class="keyword">new</span> <span class="keyword">char</span>*[len];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">        str_data[i] = <span class="keyword">new</span> <span class="keyword">char</span>[MAX_INT_LEN + <span class="number">1</span>];</span><br><span class="line">        <span class="built_in">sprintf</span>(str_data[i], <span class="string">&quot;%d&quot;</span>, data[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">std</span>::sort(str_data, str_data + len, compare);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>, str_data[i]);</span><br><span class="line">        <span class="keyword">delete</span>[] str_data[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">delete</span>[] str_data;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> data[] = &#123;<span class="number">3</span>, <span class="number">32</span>, <span class="number">321</span>, <span class="number">8</span>, <span class="number">44</span>, <span class="number">1</span>, <span class="number">143</span>&#125;;</span><br><span class="line">    min_concat(data, <span class="number">7</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码中需要注意的一个地方是，如果直接用数字排序的方式，可能会在比较<code>nnmm</code>和<code>mmnn</code>时，这种拼接结果超出<code>int</code>的表示范围，而导致错误结果，所以可能出现大数的情况，要注意用字符串来替代处理。另外书上的代码在校验输入的时候，漏掉了对数组的是否是正整数的判断，上面代码也补上了，并且书上代码使用的排序方法是<code>qsort</code>，个人建议使用<code>sort</code>，一般情况下更加效率和便利。</p><p>书上有细致的讲，如何去证明这样的方法的正确性（比较规则的三个角度，自反性(<code>aa = aa</code>)、对称性(<code>a&lt;b =&gt; ab&lt;ba, ba&gt;ab, =&gt; b&gt;a</code>)以及传递性(<code>a&lt;b,b&lt;c =&gt; ab&lt;ba, bc&lt;cb =&gt; ac&lt;ca</code>)，和反证法，假设结果不是最小的，存在一个更小的，然后去推出假设不成立），尤其是当面试官问到的时候，也要能够说出缘由来，这里就不再复述了。</p><hr><blockquote><p>面试题46：把数字翻译成字符串。</p></blockquote><p>给定一个数字，按照如下规则把它翻译成字符串：<code>0</code>翻译成<code>a</code>，<code>1</code>翻译成<code>b</code>，…，<code>11</code>翻译成<code>l</code>，…，<code>25</code>翻译成<code>z</code>。一个数字可能有多个翻译。例如<code>12258</code>有5种不同的翻译，分别是<code>bccfi</code>、<code>bwf1</code>、<code>bczi</code>、<code>mcfi</code>和<code>mzi</code>。实现一个函数，用来计算一个数字有多少种不同的翻译方法。</p><p>直观的递归方法是，<code>12258</code>可以拆解为求解<code>2258</code>和<code>258</code>两个子问题，其中有可分支的条件是<code>c1==1 || (c1==2 &amp;&amp; c2 &lt;= 5)</code>，否则只能单线往下求解。</p><p>单纯递归完整代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAX_INT_LEN = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">kinds_of_encode</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* str_num)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(*str_num == <span class="string">&#x27;\0&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">char</span> c1 = *str_num, c2 = *(str_num + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span>(c1 == <span class="string">&#x27;1&#x27;</span> || (c1 == <span class="string">&#x27;2&#x27;</span> &amp;&amp; c2 &lt;= <span class="string">&#x27;5&#x27;</span>)) &#123;</span><br><span class="line">        <span class="keyword">return</span> kinds_of_encode(str_num + <span class="number">1</span>) + kinds_of_encode(str_num + <span class="number">2</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> kinds_of_encode(str_num + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">kinds_of_encode</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(num &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 用字符数组来处理更加方便一点</span></span><br><span class="line">    <span class="keyword">char</span>* str_num = <span class="keyword">new</span> <span class="keyword">char</span>[MAX_INT_LEN + <span class="number">1</span>];</span><br><span class="line">    <span class="built_in">sprintf</span>(str_num, <span class="string">&quot;%d&quot;</span>, num);</span><br><span class="line">    <span class="keyword">int</span> result = kinds_of_encode(str_num);</span><br><span class="line">    <span class="keyword">delete</span>[] str_num;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, kinds_of_encode(<span class="number">12258</span>)); <span class="comment">// 5</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>尽管看起来很简洁，但是这并不是最优的代码，例如<code>2258</code>和<code>258</code>两个子问题，<code>2258</code>会继续分支出<code>258</code>和<code>58</code>，在这一步<code>258</code>子问题被反复求解了，导致了计算的浪费。递归是从最大的问题开始自上而下的解决，其实我们也可以从最小的子问题开始自下而上的解决，来消除重复子问题。</p><p>也就是说，<strong>从数字的末尾开始，从右到左翻译</strong>，并计算不同翻译的数目。</p><p>完整实现代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">kinds_of_encode</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(num &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 从右向左翻译，避免重复子问题</span></span><br><span class="line">    <span class="keyword">char</span>* str_num = <span class="keyword">new</span> <span class="keyword">char</span>[MAX_INT_LEN + <span class="number">1</span>];</span><br><span class="line">    <span class="built_in">sprintf</span>(str_num, <span class="string">&quot;%d&quot;</span>, num);</span><br><span class="line">    <span class="keyword">int</span> len = <span class="built_in">strlen</span>(str_num);</span><br><span class="line">    <span class="keyword">int</span>* results = <span class="keyword">new</span> <span class="keyword">int</span>[len];</span><br><span class="line">    results[len - <span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">char</span> c1, c2;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = len - <span class="number">2</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        c1 = *(str_num + i);</span><br><span class="line">        c2 = *(str_num + i + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span>(c1 == <span class="string">&#x27;1&#x27;</span> || (c1 == <span class="string">&#x27;2&#x27;</span> &amp;&amp; c2 &lt;= <span class="string">&#x27;5&#x27;</span>)) &#123;</span><br><span class="line">            results[i] = results[i + <span class="number">1</span>] + results[i + <span class="number">2</span>];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            results[i] = results[i + <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> result = results[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">delete</span>[] str_num;</span><br><span class="line">    <span class="keyword">delete</span>[] results;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, kinds_of_encode(<span class="number">12258</span>)); <span class="comment">// 5</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><blockquote><p>面试题47：礼物的最大价值。</p></blockquote><p>在一个<code>m x n</code>的棋盘的每一格都放有一个礼物，每个礼物都有一定的价值（价值大于0）。可以从棋盘的左上角开始拿格子里的礼物，并每次向右或向下移动一格，直到到达棋盘的右下角。给定一个棋盘以及礼物价值，请问最多能拿到多少价值的礼物？</p><p>例如，下面的棋盘中，如果沿着带下划线的数字线路（1、12、5、7、7、16、5），那么我们能拿到最大价值为53的礼物。</p><div align="center"><p><img src="/images/s2o-c5-f5.jpg"></p></div><p>定义<code>f(i,j)</code>为到达坐标<code>(i,j)</code>的格子时，能拿到的礼物总和的最大值，我们有两种途径来到达坐标为<code>(i,j)</code>的格子，通过格子<code>(i-1,j)</code>左侧或者<code>(i,j-1)</code>上侧，所以<code>f(i,j)=max(f(i-1,j), f(i,j-1)) + gift[i,j]</code>，<code>gift[i,j]</code>表示坐标<code>(i,j)</code>的格子里礼物的价值。</p><p>典型的动态规划问题，定义一个辅助二维数组，数组中<code>(i,j)</code>表示到达该格子时，能拿到的礼物价值总和的最大值。</p><p>完整实现代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">max_gift_value</span><span class="params">(<span class="keyword">int</span>** values, <span class="keyword">int</span> rows, <span class="keyword">int</span> cols)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(values == <span class="literal">nullptr</span> || *values == <span class="literal">nullptr</span> || rows &lt;= <span class="number">0</span> || cols &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span>** max_values = <span class="keyword">new</span> <span class="keyword">int</span>*[rows];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; rows; i++) &#123;</span><br><span class="line">        max_values[i] = <span class="keyword">new</span> <span class="keyword">int</span>[cols];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; rows; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; cols; j++) &#123;</span><br><span class="line">            <span class="keyword">int</span> left = <span class="number">0</span>, up = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span>(i &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                up = max_values[i - <span class="number">1</span>][j];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(j &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                left = max_values[i][j - <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">int</span> value = *((<span class="keyword">int</span> *)values + cols * i + j);</span><br><span class="line">            max_values[i][j] = <span class="built_in">std</span>::max(left, up) + value;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> max_value = max_values[rows<span class="number">-1</span>][cols<span class="number">-1</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; rows; i++) &#123;</span><br><span class="line">        <span class="keyword">delete</span>[] max_values[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">delete</span>[] max_values;</span><br><span class="line">    <span class="keyword">return</span> max_value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> rows = <span class="number">4</span>, cols = <span class="number">4</span>;</span><br><span class="line">    <span class="keyword">int</span> values[<span class="number">4</span>][<span class="number">4</span>] = &#123;</span><br><span class="line">        &#123;<span class="number">1</span>, <span class="number">10</span>, <span class="number">3</span>, <span class="number">8</span>&#125;,</span><br><span class="line">        &#123;<span class="number">12</span>, <span class="number">2</span>, <span class="number">9</span>, <span class="number">6</span>&#125;,</span><br><span class="line">        &#123;<span class="number">5</span>, <span class="number">7</span>, <span class="number">4</span>, <span class="number">11</span>&#125;,</span><br><span class="line">        &#123;<span class="number">3</span>, <span class="number">7</span>, <span class="number">16</span>, <span class="number">5</span>&#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Max gift value: %d&quot;</span>, max_gift_value((<span class="keyword">int</span>**)values, rows, cols));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>考虑进一步的优化（主要是空间上），前面我们提到，到达坐标为<code>(i,j)</code>的格子时，最大价值依赖于<code>(i,j-1)</code>左侧和<code>(i-1,j)</code>上侧两个格子，因为此第<code>i-2</code>行及更上面的所有格子礼物的最大价值实际没有保存的必要。我们可以用一个一维数组来替代前面代码中的二维数组<code>max_values</code>，一维数组的长度为<code>cols</code>。</p><p>优化之后的代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">max_gift_value</span><span class="params">(<span class="keyword">int</span>** values, <span class="keyword">int</span> rows, <span class="keyword">int</span> cols)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(values == <span class="literal">nullptr</span> || *values == <span class="literal">nullptr</span> || rows &lt;= <span class="number">0</span> || cols &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span>* max_values = <span class="keyword">new</span> <span class="keyword">int</span>[rows]; <span class="comment">// 修改为一维数组</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; rows; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; cols; j++) &#123;</span><br><span class="line">            <span class="keyword">int</span> left = <span class="number">0</span>, up = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span>(i &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                up = max_values[j]; <span class="comment">// 此时j位置保存的为上一行的数据</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(j &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                left = max_values[j - <span class="number">1</span>]; <span class="comment">// 此时j-1位置已经是该行的数据</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">int</span> value = *((<span class="keyword">int</span> *)values + cols * i + j);</span><br><span class="line">            max_values[j] = <span class="built_in">std</span>::max(left, up) + value; <span class="comment">// 更新j为该行的数据</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> max_value = max_values[cols<span class="number">-1</span>];</span><br><span class="line">    <span class="keyword">delete</span>[] max_values;</span><br><span class="line">    <span class="keyword">return</span> max_value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><blockquote><p>面试题48：最长不含重复字符的子字符串。</p></blockquote><p>请从字符串中找出一个<strong>最长的不包含重复字符</strong>的子字符串，计算该最长子字符串的长度。假设字符串中只包含<code>a~z</code>。例如<code>arabcacfr</code>中，最长的不包含重复字符的子字符串是<code>acfr</code>，长度是<code>4</code>(还有子串<code>rabc</code>)。</p><p>这道题其实和之前的最大子数组和（面试题42）的思路有异曲同工之妙，同样有两种方法，一种是通过规律观察，另一种就是书上讲的动态规划法。首先讲一下这类“连续子串的最大/小”问题的一种规律解法，申明两个指针从头开始，头指针指向子串的头部，尾指针指向子串的尾部，尾指针每一步都向后移动一尾，同时根据移动后尾指针访问的状况（以及结合之前的值）来判断如何移动头指针。在本题目中，约束条件是不包含重复字符，也就是说当尾指针访问到一个重复字符时，就要调整头指针移向下一个不会让子串出现重复字符的位置（也就是跳到下一个满足约束的子串），记录过程中子串的最大长度，最后返回最大长度，时间复杂度<code>O(n)</code>。</p><p>完整实现代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">longest_substr_no_dup</span><span class="params">(<span class="keyword">char</span>* str)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(str == <span class="literal">nullptr</span> || <span class="built_in">strlen</span>(str) == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">map</span>&lt;<span class="keyword">char</span>, <span class="keyword">bool</span>&gt; char_map;</span><br><span class="line">    <span class="comment">// 初始化map</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; i++) &#123;</span><br><span class="line">        char_map[<span class="string">&#x27;a&#x27;</span>+i] = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">char</span>* start = str;</span><br><span class="line">    <span class="keyword">char</span>* end = str;</span><br><span class="line">    <span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> max_len = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">strlen</span>(str); i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(!char_map[*end]) &#123;</span><br><span class="line">            <span class="comment">// 没有遇到重复字符，子串长度+1</span></span><br><span class="line">            len++;</span><br><span class="line">            max_len = (max_len &lt; len) ? len : max_len;</span><br><span class="line">            char_map[*end] = <span class="literal">true</span>;</span><br><span class="line">            end++;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 直到start遇到该重复字符为止</span></span><br><span class="line">            <span class="keyword">while</span>(*start != *end) &#123;</span><br><span class="line">                char_map[*start] = <span class="literal">false</span>;</span><br><span class="line">                start++;</span><br><span class="line">                len--;</span><br><span class="line">            &#125;</span><br><span class="line">            start++;</span><br><span class="line">            char_map[*end] = <span class="literal">true</span>;</span><br><span class="line">            end++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> max_len;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span>* str = <span class="string">&quot;arabcacfr&quot;</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s longest substr no dup: %d&quot;</span>, str, longest_substr_no_dup(str));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码中使用到了<code>std::map&lt;char, bool&gt;</code>来记录当前子串的字符出现情况，也可以自行建立一个<code>bool</code>数组实现记录。</p><p>然后再看一下书上的动态规划思路（其实和面试题42的动态规划解法也类似），定义<code>f(i)</code>表示以第<code>i</code>个字符结尾的不包含重复字符的子串的最长长度。如果是从左到右的计算顺序，当我们计算<code>f(i)</code>的时候<code>f(i-1)</code>已经被计算出了。</p><ul><li>如果第<code>i</code>个字符没有出现过，那么<code>f(i)=f(i-1)+1</code>；</li><li>如果第<code>i</code>个字符之前已经出现过了，要先计算第<code>i</code>个字符和它上次出现在字符串中位置的距离，记为d，接着要分两种情况：<ul><li>如果<code>d &lt;= f(i-1)</code>，此时第i个字符上次出现在<code>f(i-1)</code>对应的最长子字符串之中，因此<code>f(i)=d</code>；</li><li>如果<code>d &gt; f(i-1)</code>，此时第i个字符上次出现在<code>f(i-1)</code>对应的最长子字符串之前，因此仍然有<code>f(i)=f(i-1)+1</code>。</li></ul></li></ul><p>完整实现代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">longest_substr_no_dup</span><span class="params">(<span class="keyword">char</span>* str)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(str == <span class="literal">nullptr</span> || <span class="built_in">strlen</span>(str) == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> max_len = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> str_len = <span class="built_in">strlen</span>(str);</span><br><span class="line">    <span class="keyword">int</span>* position = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">26</span>]; <span class="comment">// 存储每个字符上次出现的下标</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; i++) &#123;</span><br><span class="line">        position[i] = <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; str_len; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> prev_index = position[*(str+i) - <span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">        <span class="keyword">if</span>(prev_index &lt; <span class="number">0</span> || i - prev_index &gt; len) &#123;</span><br><span class="line">            len++;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>(len &gt; max_len) &#123;</span><br><span class="line">                max_len = len;</span><br><span class="line">            &#125;</span><br><span class="line">            len = i - prev_index;</span><br><span class="line">        &#125;</span><br><span class="line">        position[*(str+i) - <span class="string">&#x27;a&#x27;</span>] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(len &gt; max_len) &#123;</span><br><span class="line">        max_len = len;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">delete</span> position;</span><br><span class="line">    <span class="keyword">return</span> max_len;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-时间与空间的平衡"><a href="#3-时间与空间的平衡" class="headerlink" title="3 时间与空间的平衡"></a>3 时间与空间的平衡</h2><p>由于内存的容量增加迅速，在软件开发的过程中我们允许以牺牲一定的空间为代价来优化时间性能，以尽可能地缩短软件的响应时间。这就是我们通常所说的“以空间换时间”。</p><p>在面试的时候，如果我们分配少量的辅助空间来保存计算的中间结果以提高时间效率，则通常是可以被接受的。</p><p>但“空间换时间”并不一定都是可行的，面试的时候要具体问题具体分析，也就是对时间和空间的平衡考量。</p><h2 id="面试题-49-52"><a href="#面试题-49-52" class="headerlink" title="面试题 49-52"></a>面试题 49-52</h2><blockquote><p>面试题49：丑数。</p></blockquote><p>把只包含因子<code>2、3</code>和<code>5</code>的数称作丑数(Ugly Number）。求按从小到大的顺序的第1500个丑数。例如<code>6、8</code>都是丑数，但<code>14</code>不是。习惯上把<code>1</code>当作第1个丑数。</p><p>判断一个数是不是丑数的方法，就是依次除以因数<code>2、3、5</code>，每一个因数都是无法再除了再除下一个因数，如果三个因数都除尽了，剩下的为1，则为丑数，否则不是丑数，简单实现的判别函数：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">is_ugly</span><span class="params">(<span class="keyword">int</span> number)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(number % <span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line">        number /= <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(number % <span class="number">3</span> == <span class="number">0</span>) &#123;</span><br><span class="line">        number /= <span class="number">3</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(number % <span class="number">5</span> == <span class="number">0</span>) &#123;</span><br><span class="line">        number /= <span class="number">5</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (number == <span class="number">1</span>) ? <span class="literal">true</span> : <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>每个数依次的判别是不是丑数肯定是不够高效的。</p><p><strong>优化思路</strong>：创建数组保存已找到的丑数，用空间换时间的解法。</p><p>根据丑数的定义，丑数应该是另一个丑数乘以2、3或者5的结果（1除外），因此，我们可以创建一个数组，里面数字是排好序的丑数，每个丑数都是前面的丑数乘以2、3或者5得到的。</p><p>这种思路的关键在于怎么确保数组里面的丑数排好序。假设数组已有若干个排好序的丑数，把最大的丑数记为M，分析如何生成下一个丑数。下一个丑数肯定是前面某一个丑数乘以2、3或者5得到的，并且我们仅仅需要第一个大于M的丑数，也不用去乘以前方的所有丑数，其中一定有一个丑数满足一个条件，他是从小到大的第一个乘以2会大于M的丑数，记为<code>T_2</code>，类似的有<code>T_3</code>、<code>T_5</code>，每一次我们只需要在<code>T_2 * 2</code>和<code>T_3 * 3</code>和<code>T_5 * 5</code>中找到较小的一个即可（并且要更新所有<code>T</code>）。</p><p>完整实现代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">min</span><span class="params">(<span class="keyword">int</span> num1, <span class="keyword">int</span> num2, <span class="keyword">int</span> num3)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> min = (num1 &lt; num2) ? num1 : num2;</span><br><span class="line">    min = (min &lt; num3) ? min : num3;</span><br><span class="line">    <span class="keyword">return</span> min;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ugly_num_at_n</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> *ugly_nums = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">    ugly_nums[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> next_ugly_index = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span>* pt2 = ugly_nums;</span><br><span class="line">    <span class="keyword">int</span>* pt3 = ugly_nums;</span><br><span class="line">    <span class="keyword">int</span>* pt5 = ugly_nums;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(next_ugly_index &lt; n) &#123;</span><br><span class="line">        <span class="keyword">int</span> min_num = min(*pt2 * <span class="number">2</span>, *pt3 * <span class="number">3</span>, *pt5 * <span class="number">5</span>);</span><br><span class="line">        ugly_nums[next_ugly_index] = min_num;</span><br><span class="line">        <span class="keyword">while</span>(*pt2 * <span class="number">2</span> &lt;= min_num) &#123;</span><br><span class="line">            pt2++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(*pt3 * <span class="number">3</span> &lt;= min_num) &#123;</span><br><span class="line">            pt3++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(*pt5 * <span class="number">5</span> &lt;= min_num) &#123;</span><br><span class="line">            pt5++;</span><br><span class="line">        &#125;</span><br><span class="line">        next_ugly_index++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> ugly = ugly_nums[n - <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">delete</span>[] ugly_nums;</span><br><span class="line">    <span class="keyword">return</span> ugly;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Ugly Num at %d is %d\n&quot;</span>, <span class="number">1500</span>, ugly_num_at_n(<span class="number">1500</span>)); <span class="comment">// 859963392</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Ugly Num at %d is %d\n&quot;</span>, <span class="number">5</span>, ugly_num_at_n(<span class="number">5</span>)); <span class="comment">// 5</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Ugly Num at %d is %d\n&quot;</span>, <span class="number">1</span>, ugly_num_at_n(<span class="number">1</span>)); <span class="comment">// 1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><blockquote><p>面试题50：第一次只出现一次的字符。</p></blockquote><p>题目一：字符串中第一个只出现一次的字符。</p><p>在字符串中找出第一个只出现一次的字符。如输入<code>abaccdeff</code>，则输出<code>b</code>。</p><p>直接的思路是每次都比较一个字符是否在其后面出现，这种思路的时间复杂度是<code>O(n^2)</code>，效率不够高，可以考虑用空间换时间。如果我们可以统计每个字符出现的次数，可能就会变得简单的多，一般也用哈希表来解决这种问题。</p><p>哈希表是一种比较复杂的数据结构，C++标准模板库中的<code>map</code>和<code>unordered_map</code>实现了哈希表的功能，可以直接用。由于本题的特殊性，我们其实只需要一个非常简单的哈希表就能满足要求，因此我们可以考虑实现一个简单的哈希表。字符(char)是一个长度为8(bit)的数据类型，因此总共有256种可能性。我们创建一个长度为256的数组，每个字母根据其ASCII码值作为数组的下标对应数组的一个数组，而数组中存储的是每个字符出现的次数。这样我们就创建了一个大小为256、以字符ASCII码为键值的哈希表。</p><p>第一次扫描时，更新一个字符的出现次数需要时间<code>O(1)</code>，总共<code>O(n)</code>；第二次扫描时，寻找第一个出现次数为<code>1</code>的字符，时间也是<code>O(n)</code>。同时我们需要一个辅助数组，大小是<code>1KB</code>，由于数组大小是一个常数，因此认为这种算法的空间复杂度是<code>O(1)</code>。</p><p>完整实现代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">char</span> <span class="title">first_unique_char</span><span class="params">(<span class="keyword">char</span>* str)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(str == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> TABLE_SIZE = <span class="number">256</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> hash_table[TABLE_SIZE];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">unsigned</span> <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; TABLE_SIZE; i++) &#123;</span><br><span class="line">        hash_table[i] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">char</span>* pchar = str;</span><br><span class="line">    <span class="keyword">while</span>(*pchar != <span class="string">&#x27;\0&#x27;</span>) &#123;</span><br><span class="line">        hash_table[*pchar]++;</span><br><span class="line">        pchar++;</span><br><span class="line">    &#125;</span><br><span class="line">    pchar = str;</span><br><span class="line">    <span class="keyword">while</span>(*pchar != <span class="string">&#x27;\0&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span>(hash_table[*pchar] == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> *pchar;</span><br><span class="line">        &#125;</span><br><span class="line">        pchar++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span>* str = <span class="string">&quot;abaccdeff&quot;</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;First unique char of %s is %c&quot;</span>, str, first_unique_char(str));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>题目二：字符流中第一个只出现一次的字符。</p><p>实现一个函数，用来找出字符流中第一个只出现一次的字符。例如，字符流只读出<code>go</code>时，第一个只出现一次的字符是<code>g</code>；当读出<code>google</code>时，第一个只出现一次的字符时<code>l</code>。</p><p>可以定义一个数据容器来<strong>保存字符在字符流中的位置</strong>。当一个字符第一次从字符流读出来时，把位置保存在数据容器中。当字符再次从字符流中读取时，这时把它在容器中保存的值更新为一个特殊值（如负数）。而在查找第一个只出现一次的字符时，只需要遍历容器，找到最小的位置即可。</p><p>完整实现代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;limits.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CharStatistics</span> &#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        CharStatistics(): index(<span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">256</span>; i++) &#123;</span><br><span class="line">                occurrence[i] = <span class="number">-1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">char</span> ch)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(occurrence[ch] == <span class="number">-1</span>) &#123;</span><br><span class="line">                occurrence[ch] = index;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span>(occurrence[ch] &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                occurrence[ch] = <span class="number">-2</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            index++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">char</span> <span class="title">first_unique_char</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">char</span> ch = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">            <span class="keyword">int</span> min_index = INT_MAX;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">256</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span>(occurrence[i] &gt;= <span class="number">0</span> &amp;&amp; occurrence[i] &lt; min_index) &#123;</span><br><span class="line">                    ch = (<span class="keyword">char</span>)i;</span><br><span class="line">                    min_index = occurrence[i];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> ch;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="comment">// occurrence[i] : A char with ASCII value i;</span></span><br><span class="line">        <span class="comment">// occurrence[i] = -1 : not found yet</span></span><br><span class="line">        <span class="comment">// occurrence[i] = -2 : have been found for mutlple times</span></span><br><span class="line">        <span class="comment">// occurrence[i] &gt;= 0 : have been found only once</span></span><br><span class="line">        <span class="keyword">int</span> occurrence[<span class="number">256</span>];</span><br><span class="line">        <span class="keyword">int</span> index;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    CharStatistics char_statistics;</span><br><span class="line">    <span class="keyword">char</span>* stream = <span class="string">&quot;google&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">6</span>; i++) &#123;</span><br><span class="line">        char_statistics.insert(stream[i]);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;After insert %c, first unique char is %c\n&quot;</span>, stream[i],</span><br><span class="line">            char_statistics.first_unique_char());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><blockquote><p>面试题51：数组中的逆序对。</p></blockquote><p>在数组中的两个数字，如果前面一个数字大于后面的数字，则这两个数字组成一个逆序对。输入一个数组，求出这个数组中的逆序对的总数。例如，数组<code>&#123;7,5,6,4&#125;</code>中，一共有5个逆序对，分别是<code>(7,5)</code>、<code>(7,6)</code>、<code>(7,4)</code>、<code>(5,4)</code>和<code>(6,4)</code>。</p><div align="center"><p><img src="/images/s2o-c5-f6.jpg" alt="统计逆序对的过程"></p></div><div align="center"><p><img src="/images/s2o-c5-f7.jpg" alt="(d)中合并两个子数组并统计逆序对的过程"></p></div><ul><li>(a) P1指向的数字大于P2指向的数字（先比较最大的），表示数组中存在逆序对，把逆序对数目加2（后一个子数组的长度），并把7复制到辅助数组，向前移动P1和P3；</li><li>(b) P1指向的数字小于P2指向的数字，没有逆序对。把P2指向的数字复制到辅助数组，并向前移动P2和P3；</li><li>(c) P1指向的数字大于P2指向的数字，存在逆序对，把逆序对数目加1（后一个子数组的剩余长度），把5复制到辅助数组，想前移动P1和P3；</li><li>(…) 直到只剩一个元素，复制到辅助数组，结束合并，开始下一次相邻数组的合并。</li></ul><p>过程有点类似与归并排序，不过为了统计逆序对，从尾部开始合并。</p><p>完整实现代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">inverse_pair_core</span><span class="params">(<span class="keyword">int</span>* data, <span class="keyword">int</span>* copy, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(start == end) &#123;</span><br><span class="line">        copy[start] == data[start];</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> len = (end - start) / <span class="number">2</span>;</span><br><span class="line">    <span class="comment">// 注意这里交换了copy和data的位置，实现了交替使用</span></span><br><span class="line">    <span class="comment">// 一次合并排序的结果保存在data中</span></span><br><span class="line">    <span class="keyword">int</span> left = inverse_pair_core(copy, data, start, start + len);</span><br><span class="line">    <span class="keyword">int</span> right = inverse_pair_core(copy, data, start + len + <span class="number">1</span>, end);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> i = start + len;</span><br><span class="line">    <span class="keyword">int</span> j = end;</span><br><span class="line">    <span class="keyword">int</span> index_copy = end;</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(i &gt;= start &amp;&amp; j &gt;= start + len + <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span>(data[i] &gt; data[j]) &#123;</span><br><span class="line">            <span class="comment">// 前面的大于后面的</span></span><br><span class="line">            copy[index_copy--] = data[i--];</span><br><span class="line">            count += j - start - len;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 前面的小于后面的</span></span><br><span class="line">            copy[index_copy--] = data[j--];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 拷贝剩余的</span></span><br><span class="line">    <span class="keyword">while</span>(i &gt;= start) &#123;</span><br><span class="line">        copy[index_copy--] = data[i--];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(j &gt;= start + len + <span class="number">1</span>) &#123;</span><br><span class="line">        copy[index_copy--] = data[j--];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> left + right + count;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">inverse_pair</span><span class="params">(<span class="keyword">int</span>* data, <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(data == <span class="literal">nullptr</span> || len &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span>* copy = <span class="keyword">new</span> <span class="keyword">int</span>[len];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">        copy[i] = data[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> count = inverse_pair_core(data, copy, <span class="number">0</span>, len - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">delete</span>[] copy;</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> data[] = &#123;<span class="number">7</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">4</span>&#125;;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Data have %d inverse pair.\n&quot;</span>, inverse_pair(data, <span class="number">4</span>));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>归并排序的时间复杂度是<code>O(nlogn)</code>，比直观方法的<code>O(n^2)</code>要快，但同时归并需要一个长度为<code>n</code>的辅助数组，所以用了<code>O(n)</code>的空间来换时间效率的提升。</p><hr><blockquote><p>面试题52：两个链表的第一个公共节点。</p></blockquote><p>输入两个链表，找出他们的第一个公共节点。链表节点定义如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> key;</span><br><span class="line">    node* pnext;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其实有之前题目的铺垫，这里蛮容易想到根据两个链不同长度来调整起始指针的位置，调整起始后的两个指针，同步移动，当相遇时就是两个链表的公共节点，时间复杂度<code>O(m+n)</code>，<code>m</code>和<code>n</code>是两个链表的长度。</p><p>完整实现代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> key;</span><br><span class="line">    node* pnext;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">node* <span class="title">init_node</span><span class="params">(<span class="keyword">int</span> key)</span> </span>&#123; ... &#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init_list</span><span class="params">(node** pphead1, node** pphead2)</span> </span>&#123; ... &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">get_list_len</span><span class="params">(node* phead)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line">    node* pnode = phead;</span><br><span class="line">    <span class="keyword">while</span>(pnode != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        len++;</span><br><span class="line">        pnode = pnode-&gt;pnext;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> len;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">node* <span class="title">find_first_common_node</span><span class="params">(node* phead1, node* phead2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> len1 = get_list_len(phead1);</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> len2 = get_list_len(phead2);</span><br><span class="line">    <span class="keyword">if</span>(len1 == <span class="number">0</span> || len2 == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> len_diff = len1 - len2;</span><br><span class="line">    node* plong_list = phead1;</span><br><span class="line">    node* pshort_list = phead2;</span><br><span class="line">    <span class="keyword">if</span>(len2 &gt; len1) &#123;</span><br><span class="line">        len_diff = len2 - len1;</span><br><span class="line">        plong_list = phead2;</span><br><span class="line">        pshort_list = phead1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len_diff; i++) &#123;</span><br><span class="line">        plong_list = plong_list-&gt;pnext;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(plong_list != <span class="literal">nullptr</span> &amp;&amp; pshort_list != <span class="literal">nullptr</span></span><br><span class="line">          &amp;&amp; plong_list != pshort_list) &#123;</span><br><span class="line">        plong_list = plong_list-&gt;pnext;</span><br><span class="line">        pshort_list = pshort_list-&gt;pnext;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> plong_list;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    node* phead1;</span><br><span class="line">    node* phead2;</span><br><span class="line">    init_list(&amp;phead1, &amp;phead2);</span><br><span class="line">    node* first_common_node = find_first_common_node(phead1, phead2);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;First common node is %d\n&quot;</span>, first_common_node-&gt;key);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>书上还提到了一种方法，非常的巧妙，尤其是在这种需要在单向链表反向查找时，可以使用一个栈来实现逆向查询，例如在本题中，如果我们可以从两个链表的尾节点开始逆向查找，那么最后一个相同的节点，也就是第一个公共节点，可以使用两个栈来实现这个过程，时间开销<code>O(m+n)</code>，空间开销<code>O(m+n)</code>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">node* <span class="title">find_first_common_node</span><span class="params">(node* phead1, node* phead2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(phead1 == <span class="literal">nullptr</span> || phead2 == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;node*&gt; stk1, stk2;</span><br><span class="line">    <span class="keyword">while</span>(phead1 != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        stk1.push_back(phead1);</span><br><span class="line">        phead1 = phead1-&gt;pnext;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(phead2 != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        stk2.push_back(phead2);</span><br><span class="line">        phead2 = phead2-&gt;pnext;</span><br><span class="line">    &#125;</span><br><span class="line">    node* common_node = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">while</span>(!stk1.empty() &amp;&amp; !stk2.empty()) &#123;</span><br><span class="line">        <span class="keyword">if</span>(stk1[stk1.size() - <span class="number">1</span>] == stk2[stk2.size() - <span class="number">1</span>]) &#123;</span><br><span class="line">            common_node = stk1[stk1.size() - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        stk1.pop_back();</span><br><span class="line">        stk2.pop_back();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> common_node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>后一种方法虽然多了一个<code>O(m+n)</code>的空间开销，但是在一些单纯链表方法不能方便解决的时候，也不妨是一种构思的思路。</p><h2 id="4-总结"><a href="#4-总结" class="headerlink" title="4 总结"></a>4 总结</h2><p>编程面试时，面试官通常对时间复杂度和空间复杂度都会有要求，并且一般情况下面试官更加关注时间复杂度。</p><p>降低时间复杂度的第一种方法是<strong>改用更加高效的算法</strong>；第二种方法是<strong>用空间换时间</strong>。</p><p>以空间换时间并不一定都是可行的方案，还要注意辅助空间的大小，消耗空间过大也是得不偿失的。</p>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;时间与空间，是算法永恒的话题。&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="剑指Offer" scheme="https://yumi-cn.github.io/categories/%E5%89%91%E6%8C%87Offer/"/>
    
    
    <category term="笔记" scheme="https://yumi-cn.github.io/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>《剑指Offer》第4章笔记 解题的思路 P3</title>
    <link href="https://yumi-cn.github.io/2021/01/03/s2o-c4-part3/"/>
    <id>https://yumi-cn.github.io/2021/01/03/s2o-c4-part3/</id>
    <published>2021-01-03T07:45:17.000Z</published>
    <updated>2021-01-03T07:46:30.991Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>遇到复杂的问题，可以尝试将大问题分解为若干小问题。</p></blockquote><a id="more"></a><h2 id="1、2-章节"><a href="#1、2-章节" class="headerlink" title="1、2 章节"></a>1、2 章节</h2><p>包含面试题27-29。</p><p>请到《第4章笔记 解题的思路 P1》阅读这部分内容。</p><h2 id="3-章节"><a href="#3-章节" class="headerlink" title="3 章节"></a>3 章节</h2><p>包含面试题30-34。</p><p>请到《第4章笔记 高质量代码 P2》阅读这部分内容。</p><h2 id="4-分解让复杂问题简单化"><a href="#4-分解让复杂问题简单化" class="headerlink" title="4 分解让复杂问题简单化"></a>4 分解让复杂问题简单化</h2><p>在面试中，当我们遇到复杂的大问题的时候，如果能够先把大问题分解成若干个简单地小问题，然后再逐个解决这些小问题，则可能也会容易很多。</p><p>在计算机领域有一类算法叫分治法，即“分而治之”，把分解后的小问题各个解决，然后把小问题的解决方案结合起来解决大问题。</p><h2 id="面试题35-38"><a href="#面试题35-38" class="headerlink" title="面试题35-38"></a>面试题35-38</h2><blockquote><p>面试题35：复杂链表的复制。</p></blockquote><p>实现函数<code>ComplexListNode* clone(ComplexListNode* phead)</code>，复制一个复杂链表。在复杂链表中，每个节点除了有一个<code>pnext</code>指针指向下一个节点，还有一个<code>psibling</code>指针指向链表中的任意节点或者<code>nullptr</code>。节点定义如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ComplexListNode</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> value;</span><br><span class="line">    ComplexListNode* pnext;</span><br><span class="line">    ComplexListNode* psibling;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><div align="center"><p><img src="/images/s2o-c4-part3-f1.jpg" alt="一个含有5个节点的复杂链表"></p></div><ol><li>直观地思路是先复制整个链表，然后使用一个辅助存储空间来存储节点间的映射关系，例如用一个哈希表来存储<code>&lt;节点、克隆节点&gt;</code>的映射关系，这样在建立<code>psibling</code>关系时十分有用，时间开销也可以做到<code>O(n)</code>；</li><li>进一步地，可以不用借助辅助的空间来存储节点对应关系，例如<strong>直接先将克隆节点挂靠在原节点后面</strong>，用这种方式来替代哈希表，同时也可以方便地建立<code>psibling</code>关系，这种方法对应的缺陷是过程中会对原数据结构进行修改，如果外部程序允许，则可以这样操作（在一些并行程序中可能会出现问题）。</li></ol><div align="center"><p><img src="/images/s2o-c4-part3-f2.jpg"></p></div><p>完整实现代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ComplexListNode</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> value;</span><br><span class="line">    ComplexListNode* pnext;</span><br><span class="line">    ComplexListNode* psibling;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">ComplexListNode* <span class="title">init_node</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123; ... &#125;</span><br><span class="line"><span class="function">ComplexListNode* <span class="title">init_list</span><span class="params">()</span> </span>&#123; ... &#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ComplexListNode* <span class="title">clone</span><span class="params">(ComplexListNode* phead)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(phead == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ComplexListNode* pnode = phead;</span><br><span class="line">    <span class="comment">// 克隆节点</span></span><br><span class="line">    <span class="keyword">while</span>(pnode != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        ComplexListNode* pclone = init_node(pnode-&gt;value);</span><br><span class="line">        pclone-&gt;pnext = pnode-&gt;pnext;</span><br><span class="line">        pnode-&gt;pnext = pclone;</span><br><span class="line">        pnode = pclone-&gt;pnext;</span><br><span class="line">    &#125;</span><br><span class="line">    pnode = phead;</span><br><span class="line">    <span class="comment">// 建立克隆节点的sibling关系</span></span><br><span class="line">    <span class="keyword">while</span>(pnode != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span>(pnode-&gt;psibling != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            ComplexListNode* psibling = pnode-&gt;psibling;</span><br><span class="line">            ComplexListNode* pclone = pnode-&gt;pnext;</span><br><span class="line">            pclone-&gt;psibling = psibling-&gt;pnext;</span><br><span class="line">        &#125;</span><br><span class="line">        pnode = pnode-&gt;pnext-&gt;pnext;</span><br><span class="line">    &#125;</span><br><span class="line">    ComplexListNode* pclone_head = <span class="literal">nullptr</span>;</span><br><span class="line">    ComplexListNode* ptemp = <span class="literal">nullptr</span>;</span><br><span class="line">    pnode = phead;</span><br><span class="line">    <span class="comment">// 从链表中分离出克隆节点</span></span><br><span class="line">    <span class="keyword">while</span>(pnode != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span>(pclone_head == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            pclone_head = pnode-&gt;pnext;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            ptemp-&gt;pnext = pnode-&gt;pnext;</span><br><span class="line">        &#125;</span><br><span class="line">        ptemp = pnode-&gt;pnext;</span><br><span class="line">        pnode-&gt;pnext = ptemp-&gt;pnext;</span><br><span class="line">        ptemp-&gt;pnext = <span class="literal">nullptr</span>;</span><br><span class="line">        pnode = pnode-&gt;pnext;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> pclone_head;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(ComplexListNode* phead)</span> </span>&#123;</span><br><span class="line">    ComplexListNode* pnode = phead;</span><br><span class="line">    <span class="keyword">while</span>(pnode != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, pnode-&gt;value);</span><br><span class="line">        <span class="keyword">if</span>(pnode-&gt;psibling != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;-&gt;%d&quot;</span>, pnode-&gt;psibling-&gt;value);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">        pnode = pnode-&gt;pnext;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ComplexListNode* phead = init_list();</span><br><span class="line">    ComplexListNode* pclone = clone(phead);</span><br><span class="line">    print(phead);</span><br><span class="line">    print(pclone);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><blockquote><p>面试题36：二叉搜索树与双向链表。</p></blockquote><p>输入一棵二叉搜索树，将该<strong>二叉搜索树</strong>转换成一个<strong>排序的双向链表</strong>。要求不能创建任何新的节点，只能调整树中节点指针的指向。比如，输入图4.15中左边的二叉搜索树，则输出转换之后的排序双向链表。二叉树节点定义如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span></span><br><span class="line">  <span class="keyword">int</span> value;</span><br><span class="line">  node* pleft;</span><br><span class="line">  node* pright;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><div align="center"><p><img src="/images/s2o-c4-part3-f3.jpg"></p></div><p>稍微观察就可以发现，对于单个的一个节点（子树），转换为双向链表时，<strong>只需要将其左子树的最大节点和其右子树的最小节点传分别链接到两个对应指针上</strong>，递归地处理其左子树和右子树，就可以得到最终的结果。</p><p>完整实现代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> value;</span><br><span class="line">    node* pleft;</span><br><span class="line">    node* pright;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">node* <span class="title">init_node</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123; ... &#125;</span><br><span class="line"><span class="function">node* <span class="title">init_tree</span><span class="params">()</span> </span>&#123; ... &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">tree_to_list_core</span><span class="params">(node* proot, node** max, node** min)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(proot == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    node *lmax, *lmin, *rmax, *rmin;</span><br><span class="line">    lmax = lmin = rmax = rmin = <span class="literal">nullptr</span>;</span><br><span class="line">    tree_to_list_core(proot-&gt;pleft, &amp;lmax, &amp;lmin);</span><br><span class="line">    tree_to_list_core(proot-&gt;pright, &amp;rmax, &amp;rmin);</span><br><span class="line">    *max = rmax?rmax:proot; <span class="comment">// 确定头节点(最小节点)</span></span><br><span class="line">    *min = lmin?lmin:proot; <span class="comment">// 确定尾节点(最大节点)</span></span><br><span class="line">    <span class="keyword">if</span>(lmax != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        lmax-&gt;pright = proot;</span><br><span class="line">    &#125;</span><br><span class="line">    proot-&gt;pleft = lmax;</span><br><span class="line">    <span class="keyword">if</span>(rmin != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        rmin-&gt;pleft = proot;</span><br><span class="line">    &#125;</span><br><span class="line">    proot-&gt;pright = rmin;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">tree_to_list</span><span class="params">(node* proot, node** max, node** min)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(proot == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    tree_to_list_core(proot, max, min);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dual_print</span><span class="params">(node* phead, node* ptail)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 顺序打印</span></span><br><span class="line">    node* pnode = phead;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Min -&gt; Max: &quot;</span>);</span><br><span class="line">    <span class="keyword">while</span>(pnode != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, pnode-&gt;value);</span><br><span class="line">        pnode = pnode-&gt;pright;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    <span class="comment">// 逆序打印</span></span><br><span class="line">    pnode = ptail;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Max -&gt; Min: &quot;</span>);</span><br><span class="line">    <span class="keyword">while</span>(pnode != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, pnode-&gt;value);</span><br><span class="line">        pnode = pnode-&gt;pleft;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    node* proot = init_tree();</span><br><span class="line">    node *phead, *ptail;</span><br><span class="line">    phead = ptail = <span class="literal">nullptr</span>;</span><br><span class="line">    tree_to_list(proot, &amp;ptail, &amp;phead);</span><br><span class="line">    dual_print(phead, ptail);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>书上使用的方法是，<strong>在中序遍历的同时</strong>，在函数参数中加上一个已构建链表的尾节点，逐步地向尾部挂链节点，这样的方法个人逻辑上理解起来有点绕，所以我自己写的时候，对函数的定义是要同时确定<strong>重构建链表的头节点和尾节点</strong>，这样逻辑构建上感觉会更加清晰一点，并且最后可以直接返回双向链表的头节点和尾节点，无需再去重新遍历寻找，核心算法的时间效率上和书上代码并没有太大区别。</p><hr><blockquote><p>面试题37：序列化二叉树。</p></blockquote><p>请实现两个函数，分别用来序列化和反序列化二叉树。</p><p>PS：序列化(Serialization)指的是将对象的状态信息转换为可以存储或传输的形式的过程，反序列化则是通过序列化信息来重建对应状态的对象。</p><p>之前的面试题7“重建二叉树”，我们知道可以从前序遍历和中序遍历构造出一棵（也是唯一的）二叉树。受启发，可能可以尝试把一棵二叉树序列化成一个前序和一个中序，然后反序列通过两个序列重构出原二叉树。</p><p>但这样的思路有两个问题：</p><ol><li>这种方法要求二叉树不能有数值重复的节点（如果有重复的节点，在确定根节点时会出现歧义）；</li><li>只有两个序列中<strong>所有数据都读出来后</strong>才能开始反序列化，如果两个遍历数据只能从一个流中读取，那么可能要等待较长时间。</li></ol><p>实际上，如果二叉树的序列化是从根节点开始的，那么相应的反序列化在根节点的数值读出来的时候就可以开始了。因此，可以根据<strong>前序遍历的顺序来序列化二叉树</strong>，在二叉树碰到<code>nullptr</code>时，转化为一个特殊的字符(比如<code>$</code>)，另外节点的数值要用一个特殊字符(比如<code>,</code>)隔开。</p><p>完整代码实现：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> value;</span><br><span class="line">    node* pleft;</span><br><span class="line">    node* pright;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">node* <span class="title">init_node</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123; ... &#125;</span><br><span class="line"><span class="function">node* <span class="title">init_tree</span><span class="params">()</span> </span>&#123; ... &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">serialize</span><span class="params">(node* proot, <span class="keyword">char</span>*&amp; stream)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(proot == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        *stream = <span class="string">&#x27;$&#x27;</span>;</span><br><span class="line">        *(stream + <span class="number">1</span>) = <span class="string">&#x27;,&#x27;</span>;</span><br><span class="line">        *(stream + <span class="number">2</span>) = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">        stream += <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    *stream = <span class="string">&#x27;0&#x27;</span> + proot-&gt;value;</span><br><span class="line">    *(stream + <span class="number">1</span>) = <span class="string">&#x27;,&#x27;</span>;</span><br><span class="line">    *(stream + <span class="number">2</span>) = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">    stream += <span class="number">2</span>;</span><br><span class="line">    serialize(proot-&gt;pleft, stream);</span><br><span class="line">    serialize(proot-&gt;pright, stream);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">read_stream</span><span class="params">(<span class="keyword">char</span>*&amp; stream, <span class="keyword">int</span>* number)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(*stream &lt;= <span class="string">&#x27;9&#x27;</span> &amp;&amp; *stream &gt;= <span class="string">&#x27;0&#x27;</span>) &#123;</span><br><span class="line">        *number = *stream - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        stream += <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        stream += <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">deserialize</span><span class="params">(node** proot, <span class="keyword">char</span>*&amp; stream)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> number;</span><br><span class="line">    <span class="keyword">if</span>(read_stream(stream, &amp;number)) &#123;</span><br><span class="line">        *proot = init_node(number);</span><br><span class="line">        deserialize(&amp;((*proot)-&gt;pleft), stream);</span><br><span class="line">        deserialize(&amp;((*proot)-&gt;pright), stream);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">preorder_traversal</span><span class="params">(node* proot)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(proot == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, proot-&gt;value);</span><br><span class="line">    preorder_traversal(proot-&gt;pleft);</span><br><span class="line">    preorder_traversal(proot-&gt;pright);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    node* proot = init_tree();</span><br><span class="line">    <span class="keyword">char</span>* stream = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">100</span>];</span><br><span class="line">    <span class="keyword">char</span>* pchar = stream;</span><br><span class="line">    serialize(proot, pchar);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, stream);</span><br><span class="line">    node* new_proot = <span class="literal">nullptr</span>;</span><br><span class="line">    pchar = stream;</span><br><span class="line">    deserialize(&amp;proot, pchar);</span><br><span class="line">    preorder_traversal(proot);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里利用了先序遍历的节点顺序特性，使用中序或者后序就无法实现这样的效果，算是一种特殊的技巧吧，用<code>$</code>替代空指针<code>nullptr</code>，在先序遍历的同时确定之后重建的顺序。序列化中一些需要注意的细节，比如使用的替代字符<code>$</code>是否在节点<code>value</code>范围中，要使用间隔符<code>,</code>将值隔开，避免节点值产生混淆错误。</p><hr><blockquote><p>面试题38：字符串的排列。</p></blockquote><p>输入一个字符串，打印出该字符串中字符的所有排列。例如，输入字符串<code>abc</code>，则打印由字符<code>a</code>、<code>b</code>、<code>c</code>所能排列出的所有字符串<code>abc</code>、<code>acb</code>、<code>bac</code>、<code>bca</code>、<code>cab</code>和<code>cba</code>。</p><p>基础思路是使用递归来完成，例如确定一个字符后，只需要知道剩下字符串的全排列即可，在第<code>i</code>层递归时，从还未选择的字符中确定一个字符在输出的第<code>i</code>个位置，遍历所有可能性，也就是全排列的实现方式。</p><p>完整实现代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">permutation</span><span class="params">(<span class="keyword">char</span>* <span class="built_in">string</span>, <span class="keyword">bool</span>* choose, <span class="keyword">int</span> len, <span class="keyword">char</span>* output, <span class="keyword">int</span> olen)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(olen == len) &#123;</span><br><span class="line">        *(output + olen) = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, output);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(!choose[i]) &#123;</span><br><span class="line">            *(output + olen) = <span class="built_in">string</span>[i];</span><br><span class="line">            choose[i] = <span class="literal">true</span>;</span><br><span class="line">            permutation(<span class="built_in">string</span>, choose, len, output, olen + <span class="number">1</span>);</span><br><span class="line">            choose[i] = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">permutation</span><span class="params">(<span class="keyword">char</span>* <span class="built_in">string</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">string</span> == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> len = <span class="built_in">strlen</span>(<span class="built_in">string</span>);</span><br><span class="line">    <span class="keyword">char</span>* output = <span class="keyword">new</span> <span class="keyword">char</span>[len + <span class="number">1</span>];</span><br><span class="line">    output[<span class="number">0</span>] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">    <span class="keyword">bool</span>* choose = <span class="keyword">new</span> <span class="keyword">bool</span>[len];</span><br><span class="line">    <span class="built_in">memset</span>(choose, <span class="number">0</span>, <span class="keyword">sizeof</span>(choose));</span><br><span class="line">    permutation(<span class="built_in">string</span>, choose, len, output, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span>* <span class="built_in">string</span> = <span class="string">&quot;abc&quot;</span>;</span><br><span class="line">    permutation(<span class="built_in">string</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>书上的代码是通过交换原字符串中各字符的位置来实现的，自己写代码时为了确保字符串本身不被修改，所以使用了一个<code>bool* choose</code>数组来记录被选中的字符位置，以及<code>char* output</code>来记录字符的顺序（用以最后的输出）。</p><h2 id="5-总结"><a href="#5-总结" class="headerlink" title="5 总结"></a>5 总结</h2><div align="center"><p><img src="/images/s2o-c4-part3-f4.jpg" alt="解决复杂问题的3种方法：画图、举例和分解"></p></div><p>图形使抽象的问题形象化。</p><p>举例使抽象的问题具体化。</p><p>分解使复杂的问题易解化。</p>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;遇到复杂的问题，可以尝试将大问题分解为若干小问题。&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="剑指Offer" scheme="https://yumi-cn.github.io/categories/%E5%89%91%E6%8C%87Offer/"/>
    
    
    <category term="笔记" scheme="https://yumi-cn.github.io/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>《剑指Offer》第4章笔记 解题的思路 P2</title>
    <link href="https://yumi-cn.github.io/2021/01/02/s2o-c4-part2/"/>
    <id>https://yumi-cn.github.io/2021/01/02/s2o-c4-part2/</id>
    <published>2021-01-02T08:43:28.000Z</published>
    <updated>2021-01-02T08:43:43.370Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>一眼看不出问题的隐藏规律时，说不定能通过举例来发现。</p></blockquote><a id="more"></a><h2 id="1、2-章节"><a href="#1、2-章节" class="headerlink" title="1、2 章节"></a>1、2 章节</h2><p>包含面试题27-29。</p><p>请到《第4章笔记 解题的思路 P1》阅读这部分内容。</p><h2 id="3-举例让抽象问题具体化"><a href="#3-举例让抽象问题具体化" class="headerlink" title="3 举例让抽象问题具体化"></a>3 举例让抽象问题具体化</h2><p>和上一节画图的方法一样，我们也可以借助举例模拟的方法来思考分析复杂的问题。当一眼看不出问题中隐藏的规律时，可以试着用一两个具体的例子模拟操作的过程，说不定能通过具体的例子找到抽象的规律。</p><p>具体的例子也可以帮助我们向面试官解释算法思路，也能帮助我们确保代码的质量，举出来的例子可以当作测试用例检验代码的正确性。</p><h2 id="面试题-30-34"><a href="#面试题-30-34" class="headerlink" title="面试题 30-34"></a>面试题 30-34</h2><blockquote><p>面试题30：包含min函数的栈。</p></blockquote><p>定义栈的数据结构，在该类型中实现一个能够得到栈的最小元素的min函数，在该栈中，调用<code>min</code>、<code>push</code>、<code>pop</code>的时间复杂度都是<code>O(1)</code>。</p><p>这道题容易曲解成是对这一组元素的排序，就容易陷入到一个思维陷阱，开始怀疑是怎么在<code>O(n)</code>时间内做到对这些元素的排序的（常用的排序也需要<code>O(nlogn)</code>的时间），其实多举几个例子可以发现，这个过程并不完全等价于是对一组元素的排序，栈的<code>min</code>值是有条件性的，取决于栈中到底有什么样的元素，以及<strong>这些元素的入栈顺序</strong>，所以用一个相同长度的栈，来存储一个元素入栈后，栈的<code>min</code>值是多少，就可以同步地在<code>O(1)</code>时间里实现<code>min</code>的获取。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> max_len = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">MinStack</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> <span class="built_in">stack</span>[max_len];</span><br><span class="line">    <span class="keyword">int</span> min_stack[max_len];</span><br><span class="line">    <span class="keyword">int</span> anchor = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> elem)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(anchor &lt; max_len - <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="built_in">stack</span>[anchor + <span class="number">1</span>] = elem;</span><br><span class="line">            <span class="keyword">if</span>(anchor == <span class="number">-1</span> || min_stack[anchor] &gt; elem) &#123;</span><br><span class="line">                min_stack[anchor + <span class="number">1</span>] = elem;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                min_stack[anchor + <span class="number">1</span>] = min_stack[anchor];</span><br><span class="line">            &#125;</span><br><span class="line">            anchor++;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// throw error</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> pop() &#123;</span><br><span class="line">        <span class="keyword">if</span>(anchor &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            anchor--;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">stack</span>[anchor + <span class="number">1</span>];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// throw error</span></span><br><span class="line">            <span class="keyword">return</span> - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">min</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(anchor &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> min_stack[anchor];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// throw error</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    MinStack min_stack;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">        min_stack.push(<span class="number">4</span> - i);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;After push %d, min=%d\n&quot;</span>, <span class="number">4</span> - i, min_stack.min());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// After push 4, min=4</span></span><br><span class="line">    <span class="comment">// After push 3, min=3</span></span><br><span class="line">    <span class="comment">// After push 2, min=2</span></span><br><span class="line">    <span class="comment">// After push 1, min=1</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> pop = min_stack.pop();</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;After pop %d, min=%d\n&quot;</span>, pop, min_stack.min());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// After pop 1, min=2</span></span><br><span class="line">    <span class="comment">// After pop 2, min=3</span></span><br><span class="line">    <span class="comment">// After pop 3, min=4</span></span><br><span class="line">    <span class="comment">// After pop 4, min=-1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><blockquote><p>面试题31：栈的压入、弹出序列。</p></blockquote><p>输入两个整数序列，第一个序列表示栈的压入顺序，请判断第二个序列是否为该栈的弹出顺序。假设压入栈的所有数字均不相等，例如<code>&#123;1,2,3,4,5&#125;</code>是某栈的压栈序列，序列<code>&#123;4,5,3,2,1&#125;</code>是该栈的对应一个弹出序列，但<code>&#123;4,3,5,1,2&#125;</code>就不可能是该压栈的弹出序列。</p><p>PS：题目其实说的蛮含糊的，只要理解一个关键点就好了，它指的是执行一系列压栈和弹出操作，并不是先只压栈然后再只弹出，所以一个入栈顺序为<code>&#123;1,2,3,4,5&#125;</code>，出栈顺序也可能是<code>&#123;1,2,3,4,5&#125;</code>（进一个就出一个）。</p><p>比较直观的方法就是用一个栈来模拟整个流程，看这个流程是否能匹配上压栈和弹出的顺序。</p><p>每次压栈结束后，就检查剩余的出栈顺序，如果下一个出栈的元素就栈顶的元素就出栈，并且循环检查，直到无法再出栈。如果入栈都结束后，出栈顺序或者栈内不为空，则表示出栈顺序有错误。</p><p>完整实现代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">is_pop_order</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span>* ppush, <span class="keyword">const</span> <span class="keyword">int</span>* ppop, <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">bool</span> possible = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span>(ppush != <span class="literal">nullptr</span> &amp;&amp; ppop != <span class="literal">nullptr</span> &amp;&amp; len &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">int</span>* pnext_push = ppush;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">int</span>* pnext_pop = ppop;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; <span class="built_in">stack</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(pnext_pop - ppop &lt; len) &#123;</span><br><span class="line">            <span class="keyword">while</span>(<span class="built_in">stack</span>.empty() || <span class="built_in">stack</span>.top() != *pnext_pop) &#123;</span><br><span class="line">                <span class="comment">// 元素压栈</span></span><br><span class="line">                <span class="keyword">if</span>(pnext_push - ppush == len) &#123;</span><br><span class="line">                    <span class="keyword">break</span>; <span class="comment">// 元素全部已入栈</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="built_in">stack</span>.push(*pnext_push);</span><br><span class="line">                pnext_push++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span>(!<span class="built_in">stack</span>.empty() &amp;&amp; <span class="built_in">stack</span>.top() == *pnext_pop) &#123;</span><br><span class="line">                <span class="comment">// 元素出栈</span></span><br><span class="line">                <span class="built_in">stack</span>.pop();</span><br><span class="line">                pnext_pop++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(pnext_push - ppush == len &amp;&amp; pnext_pop - ppop != len) &#123;</span><br><span class="line">                <span class="comment">// 入栈已空，但出栈还未空，不是正确的出栈顺序</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">stack</span>.empty() &amp;&amp; pnext_pop - ppop == len) &#123;</span><br><span class="line">            possible = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> possible;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span>* ppush, <span class="keyword">const</span> <span class="keyword">int</span>* ppop, <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, is_pop_order(ppush, ppop, len)?<span class="string">&quot;yes&quot;</span>:<span class="string">&quot;no&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> push_order[<span class="number">5</span>] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> pop_order1[<span class="number">5</span>] = &#123;<span class="number">4</span>,<span class="number">5</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> pop_order2[<span class="number">5</span>] = &#123;<span class="number">4</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">1</span>,<span class="number">2</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> pop_order3[<span class="number">5</span>] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> pop_order4[<span class="number">5</span>] = &#123;<span class="number">5</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>&#125;;</span><br><span class="line">    test(push_order, pop_order1, <span class="number">5</span>); <span class="comment">// yes</span></span><br><span class="line">    test(push_order, pop_order2, <span class="number">5</span>); <span class="comment">// no</span></span><br><span class="line">    test(push_order, pop_order3, <span class="number">5</span>); <span class="comment">// yes</span></span><br><span class="line">    test(push_order, pop_order4, <span class="number">5</span>); <span class="comment">// yes</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><blockquote><p>面试题32：从上到下打印二叉树。</p></blockquote><p><strong>题目一</strong>：不分行从上到下打印，同一层按照从左到右的顺序打印，节点定义：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> value;</span><br><span class="line">    node* pleft;</span><br><span class="line">    node* pright;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>思路就是之前有提到过的层序遍历了，使用队列的数据结构来辅助遍历。</p><div align="center"><p><img src="/images/s2o-c4-part2-f1.jpg" alt="打印顺序：8,6,10,5,7,9,11"></p></div><p>完整实现代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> value;</span><br><span class="line">    node* pleft;</span><br><span class="line">    node* pright;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">node* <span class="title">init_node</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123; ... &#125;</span><br><span class="line"><span class="function">node* <span class="title">init_tree</span><span class="params">()</span> </span>&#123; ... &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">level_order_traversal</span><span class="params">(node* proot)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(proot == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">queue</span>&lt;node*&gt; q;</span><br><span class="line">    q.push(proot);</span><br><span class="line">    node* pnode;</span><br><span class="line">    <span class="keyword">while</span>(!q.empty()) &#123;</span><br><span class="line">        pnode = q.front();</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, pnode-&gt;value);</span><br><span class="line">        <span class="keyword">if</span>(pnode-&gt;pleft != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            q.push(pnode-&gt;pleft);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(pnode-&gt;pright != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            q.push(pnode-&gt;pright);</span><br><span class="line">        &#125;</span><br><span class="line">        q.pop();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    node* proot = init_tree();</span><br><span class="line">    level_order_traversal(proot);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>PS：书上代码用的队列是<code>deque</code>双端队列，不是很明白作者的用意，这里我就直接用普通队列<code>queue</code>了。</p><p><strong>题目二</strong>：分行从上到下打印二叉树，每一层打印到一行，例如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">8</span></span><br><span class="line"><span class="number">6</span> <span class="number">10</span></span><br><span class="line"><span class="number">5</span> <span class="number">7</span> <span class="number">9</span> <span class="number">11</span></span><br></pre></td></tr></table></figure><p>队列除了保存节点顺序，还要保存一个层数，在题目一代码基础上进行稍微的修改。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;utility&gt; // use std::pair</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;tuple&gt; // use std::tie</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> value;</span><br><span class="line">    node* pleft;</span><br><span class="line">    node* pright;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">node* <span class="title">init_node</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123; ... &#125;</span><br><span class="line"><span class="function">node* <span class="title">init_tree</span><span class="params">()</span> </span>&#123; ... &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">level_order_traversal</span><span class="params">(node* proot)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(proot == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">queue</span>&lt;<span class="built_in">std</span>::<span class="built_in">pair</span>&lt;node*, <span class="keyword">int</span>&gt;&gt; q;</span><br><span class="line">    q.push(<span class="built_in">std</span>::<span class="built_in">make_pair</span>(proot, <span class="number">1</span>));</span><br><span class="line">    node* pnode;</span><br><span class="line">    <span class="keyword">int</span> level;</span><br><span class="line">    <span class="keyword">int</span> last_level = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(!q.empty()) &#123;</span><br><span class="line">        <span class="built_in">std</span>::tie(pnode, level) = q.front();</span><br><span class="line">        <span class="keyword">if</span>(level &gt; last_level) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">            last_level = level;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\t&quot;</span>, pnode-&gt;value);</span><br><span class="line">        <span class="keyword">if</span>(pnode-&gt;pleft != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            q.push(<span class="built_in">std</span>::<span class="built_in">make_pair</span>(pnode-&gt;pleft, level + <span class="number">1</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(pnode-&gt;pright != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            q.push(<span class="built_in">std</span>::<span class="built_in">make_pair</span>(pnode-&gt;pright, level + <span class="number">1</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        q.pop();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    node* proot = init_tree();</span><br><span class="line">    level_order_traversal(proot);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>书上代码把逻辑拆分的有点复杂，不够简洁，所以就用自己的方式来写了，在队列的节点中嵌入了节点的层数，用一个变量<code>last_level</code>来保存上一次打印节点的层数，如果发现已经到了下一层，就先输出一个换行，逻辑上更加简洁。</p><p><strong>题目三</strong>：之字形打印二叉树，第一行按照从左到右顺序，第二行按照从右到左顺序，第三行从左到右，依次类推。</p><p>可以简单地理解为，奇数行照常顺序打印，而偶数行需要逆向打印，所以可以简单地给偶数行添加一个栈结构，先全部压栈，再出栈打印，其他流程照旧，即可实现题目的要求，在题目二的代码基础上稍加修改即可。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;utility&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;tuple&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> value;</span><br><span class="line">    node* pleft;</span><br><span class="line">    node* pright;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">node* <span class="title">init_node</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123; ... &#125;</span><br><span class="line"><span class="function">node* <span class="title">init_tree</span><span class="params">()</span> </span>&#123; ... &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">level_order_traversal_zigzag</span><span class="params">(node* proot)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(proot == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">queue</span>&lt;<span class="built_in">std</span>::<span class="built_in">pair</span>&lt;node*, <span class="keyword">int</span>&gt;&gt; q;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; print_stack;</span><br><span class="line">    q.push(<span class="built_in">std</span>::<span class="built_in">make_pair</span>(proot, <span class="number">1</span>));</span><br><span class="line">    node* pnode;</span><br><span class="line">    <span class="keyword">int</span> level;</span><br><span class="line">    <span class="keyword">int</span> last_level = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(!q.empty()) &#123;</span><br><span class="line">        <span class="built_in">std</span>::tie(pnode, level) = q.front();</span><br><span class="line">        <span class="keyword">if</span>(level &gt; last_level) &#123;</span><br><span class="line">            <span class="keyword">if</span>(level &amp; <span class="number">0x1</span> == <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">while</span>(!print_stack.empty()) &#123;</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;%d\t&quot;</span>, print_stack.top());</span><br><span class="line">                    print_stack.pop();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">            last_level = level;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(level &amp; <span class="number">0x1</span> == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="comment">// 奇数行直接输出</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d\t&quot;</span>, pnode-&gt;value);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 偶数行先压栈</span></span><br><span class="line">            print_stack.push(pnode-&gt;value);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(pnode-&gt;pleft != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            q.push(<span class="built_in">std</span>::<span class="built_in">make_pair</span>(pnode-&gt;pleft, level + <span class="number">1</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(pnode-&gt;pright != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            q.push(<span class="built_in">std</span>::<span class="built_in">make_pair</span>(pnode-&gt;pright, level + <span class="number">1</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        q.pop();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 最后一层是偶数层时， 需要继续清空输出</span></span><br><span class="line">    <span class="keyword">while</span>(!print_stack.empty()) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\t&quot;</span>, print_stack.top());</span><br><span class="line">        print_stack.pop();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    node* proot = init_tree();</span><br><span class="line">    level_order_traversal_zigzag(proot);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>书上的代码逻辑稍微复杂一点，要用两个栈来完成两层的循环之字输出，理解起来稍微比较难，所以我就只是简单地在题目二的基础上进行修改了，逻辑上理解起来更加方便。</p><hr><blockquote><p>面试题33：二叉搜索树的后序遍历序列。</p></blockquote><p>输入一个整数数组，判断该数组是不是<strong>某二叉搜索树的后序遍历结果</strong>。如果是则返回<code>true</code>，否则返回<code>false</code>。假设输入的数组的任意两个数字互不相同，如，<code>&#123;5,7,6,9,11,10,8&#125;</code>，则返回<code>true</code>，因为整数序列是下图的二叉搜索树的后序遍历结果，如果输入<code>&#123;7,4,6,5&#125;</code>，则返回<code>false</code>，无法找到这样的二叉搜索树。</p><div align="center"><p><img src="/images/s2o-c4-part2-f2.jpg"></p></div><p><strong>后序遍历的特点在于最后访问根节点</strong>，所以对于一个树（或子树）的后续遍历序列，根节点都是最后一个数，另外，<strong>对于二叉搜索树的一个节点，其左子树的节点都小于该节点，右子树的节点都大于该节点</strong>，在遍历序列上体现就是前一部分大于节点值，后一部分小于节点值。所以解题的思路就是递归地去分解后续遍历序列，不断的去验证各个节点子树对应的后续遍历是否满足二叉搜索树的特性即可。</p><p>完整实现代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">is_post_order</span><span class="params">(<span class="keyword">int</span> sequence[], <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(sequence == <span class="literal">nullptr</span> || start &gt; end) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(start == end) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> pstart, pend;</span><br><span class="line">    <span class="keyword">for</span>(pstart = start; pstart &lt; end; pstart++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(sequence[pstart] &gt; sequence[end]) &#123;</span><br><span class="line">            pstart--;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(pend = end - <span class="number">1</span>; pend &gt;= start; pend--) &#123;</span><br><span class="line">        <span class="keyword">if</span>(sequence[pend] &lt; sequence[end]) &#123;</span><br><span class="line">            pend++;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(pstart == pend) &#123;</span><br><span class="line">        <span class="comment">// 全偏树，此时所有节点都大于或小于子树根节点</span></span><br><span class="line">        <span class="keyword">return</span> is_post_order(sequence, start, end<span class="number">-1</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(pstart + <span class="number">1</span> == pend) &#123;</span><br><span class="line">        <span class="comment">// 左子树都小于节点，右子树都大于节点</span></span><br><span class="line">        <span class="keyword">bool</span> bleft = is_post_order(sequence, start, pstart);</span><br><span class="line">        <span class="keyword">bool</span> bright = is_post_order(sequence, pend, end<span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">return</span> bleft &amp;&amp; bright;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 不满足要求</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">(<span class="keyword">int</span> sequence[], <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, is_post_order(sequence, start, end)?<span class="string">&quot;yes&quot;</span>:<span class="string">&quot;no&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sequence1[] = &#123; <span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">9</span>,<span class="number">11</span>,<span class="number">10</span>,<span class="number">8</span> &#125;;</span><br><span class="line">    <span class="keyword">int</span> sequence2[] = &#123; <span class="number">7</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">5</span> &#125;;</span><br><span class="line">    test(sequence1, <span class="number">0</span>, <span class="number">6</span>); <span class="comment">// yes</span></span><br><span class="line">    test(sequence2, <span class="number">0</span>, <span class="number">3</span>); <span class="comment">// no</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>比较细致地考虑的话，要记得把全偏树的情况考虑到，此时根节点前面的所有节点都属于一个子树，而不是还是分左子树和右子树。</p><hr><blockquote><p>面试题34：二叉树中和为某一值的路径。</p></blockquote><p>输入<strong>一棵二叉树和一个整数</strong>，打印出二叉树中<strong>节点值的和</strong>为输入整数的所有路径。从树的根节点开始往下一直到叶节点所经过的节点形成一条路径。二叉树节点的定义如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> value;</span><br><span class="line">    node* pleft;</span><br><span class="line">    node* pright;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><div align="center"><p><img src="/images/s2o-c4-part2-f3.jpg" alt="和为22的路径有两条，10、5、7和10、12"></p></div><p>直观的方法应该就是递归地往下遍历所有情况，到叶节点的时候计算路径上的节点和，如果和等于输入的整数，则输出路径。</p><p>完整实现代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> value;</span><br><span class="line">    node* pleft;</span><br><span class="line">    node* pright;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">node* <span class="title">init_node</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123; ... &#125;</span><br><span class="line"><span class="function">node* <span class="title">init_tree</span><span class="params">()</span> </span>&#123; ... &#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;node*&gt; path; <span class="comment">// 存储路径</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">find_path</span><span class="params">(node* pnode, <span class="keyword">int</span> sum, <span class="keyword">int</span> expect_sum)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(pnode == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(pnode-&gt;pleft == <span class="literal">nullptr</span> &amp;&amp; pnode-&gt;pright == <span class="literal">nullptr</span></span><br><span class="line">        &amp;&amp; sum + pnode-&gt;value == expect_sum) &#123;</span><br><span class="line">        <span class="comment">// 满足要求，输出节点</span></span><br><span class="line">        path.push_back(pnode);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; path.size(); i++) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, path[i]-&gt;value);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">        path.pop_back();</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    path.push_back(pnode);</span><br><span class="line">    <span class="keyword">if</span>(pnode-&gt;pleft != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        find_path(pnode-&gt;pleft, sum + pnode-&gt;value, expect_sum);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(pnode-&gt;pright != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        find_path(pnode-&gt;pright, sum + pnode-&gt;value, expect_sum);</span><br><span class="line">    &#125;</span><br><span class="line">    path.pop_back();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    node* tree = init_tree();</span><br><span class="line">    find_path(tree, <span class="number">0</span>, <span class="number">22</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这道题可能会联想到提前剪枝的优化，例如当还没有到叶节点时，发现和已经大于了期望值的和，此时提前停止往下查询的操作叫做剪枝，但需要注意的是本题目中并没有限定节点的值<code>value</code>一定是正数(类型也是<code>int</code>而非<code>unsigned int</code>)，可以出现途中和大于期望值和，所以本题不能用这样的剪枝优化方法。</p><h2 id="4-分解让复杂问题简单化"><a href="#4-分解让复杂问题简单化" class="headerlink" title="4 分解让复杂问题简单化"></a>4 分解让复杂问题简单化</h2><p>包含面试题35-38。</p><p>请到《第4章笔记 高质量代码 P3》阅读这部分内容。</p>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;一眼看不出问题的隐藏规律时，说不定能通过举例来发现。&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="剑指Offer" scheme="https://yumi-cn.github.io/categories/%E5%89%91%E6%8C%87Offer/"/>
    
    
    <category term="笔记" scheme="https://yumi-cn.github.io/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>《剑指Offer》第4章笔记 解题的思路 P1</title>
    <link href="https://yumi-cn.github.io/2021/01/01/s2o-c4-part1/"/>
    <id>https://yumi-cn.github.io/2021/01/01/s2o-c4-part1/</id>
    <published>2021-01-01T08:55:16.000Z</published>
    <updated>2021-01-01T08:57:59.123Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>写代码之前理思路，举例子和画图都是很好的办法。</p></blockquote><a id="more"></a><h2 id="1-面试官谈面试思路"><a href="#1-面试官谈面试思路" class="headerlink" title="1 面试官谈面试思路"></a>1 面试官谈面试思路</h2><p>一些大佬说的话。</p><p>咕咕待更。</p><h2 id="2-画图让抽象问题形象化"><a href="#2-画图让抽象问题形象化" class="headerlink" title="2 画图让抽象问题形象化"></a>2 画图让抽象问题形象化</h2><p>画图是在面试过程中应聘者用来帮助自己分析、推理的常用手段。很多面试题很抽象，不容易找到解决办法。这时不妨画出一些与题目相关的图形，借以辅助自己观察和思考。图形能使抽象的问题具体化、形象化，说不定通过几幅图形就能找到规律，从而找到问题的解决方案。</p><p>有不少与数据结构相关的问题，比如二叉树、二维数组、链表等问题，都可以采用画图的方法来分析。</p><p>面试的时候，需要向面试官解释自己的思路，对于复杂的问题，应聘者光用言语未必能够说清楚，这个时候也可以画出几幅图形，一边看着图形一边讲解。</p><h2 id="面试题27-29"><a href="#面试题27-29" class="headerlink" title="面试题27-29"></a>面试题27-29</h2><blockquote><p>面试题27：二叉树的镜像。</p></blockquote><p>完成一个函数，输入一棵二叉树，函数输出它的镜像。二叉树节点定义：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> value;</span><br><span class="line">    node* pleft;</span><br><span class="line">    node* pright;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><div align="center"><p><img src="/images/s2o-c4-part1-f1.jpg"></p></div><p>画出一个镜像的二叉树后，观察可以发现只要简单地从上到下地交换每个节点的左右节点即可。</p><p>完整实现代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> value;</span><br><span class="line">    node* pleft;</span><br><span class="line">    node* pright;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">node* <span class="title">init_node</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123; ... &#125;</span><br><span class="line"><span class="function">node* <span class="title">init_tree</span><span class="params">()</span> </span>&#123; ... &#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">in_order_print</span><span class="params">(node* pnode)</span> </span>&#123; ... &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mirror_recursively</span><span class="params">(node* pnode)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(pnode == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    node* temp = pnode-&gt;pleft;</span><br><span class="line">    pnode-&gt;pleft = pnode-&gt;pright;</span><br><span class="line">    pnode-&gt;pright = temp;</span><br><span class="line">    mirror_recursively(pnode-&gt;pleft);</span><br><span class="line">    mirror_recursively(pnode-&gt;pright);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    node* tree = init_tree();</span><br><span class="line">    in_order_print(tree);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    mirror_recursively(tree);</span><br><span class="line"></span><br><span class="line">    in_order_print(tree);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果不使用递归，而是使用循环实现的话，可以考虑用一个队列来实现点的从上到下遍历的模拟，每访问一个节点，交换完毕后，将左右子节点加入到队列中，每次从队列中取出一个节点进行交换子节点操作，直到所有节点被处理完毕。</p><hr><blockquote><p>面试题28：对称的二叉树。</p></blockquote><p>请实现一个函数，用来判断一棵二叉树是不是对称的。如果一棵二叉树和它的镜像一样，那么它是对称的。</p><div align="center"><p><img src="/images/s2o-c4-part1-f2.jpg" alt="3棵二叉树，只有第一棵是对称的"></p></div><p>完整实现代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> value;</span><br><span class="line">    node* pleft;</span><br><span class="line">    node* pright;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">node* <span class="title">init_node</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123; ... &#125;</span><br><span class="line"><span class="function">node* <span class="title">init_tree</span><span class="params">()</span> </span>&#123; ... &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">is_symmetrical</span><span class="params">(node* pnode1, node* pnode2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(pnode1 == <span class="literal">nullptr</span> &amp;&amp; pnode2 == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(pnode1 == <span class="literal">nullptr</span> || pnode2 == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(pnode1-&gt;value == pnode2-&gt;value) &#123;</span><br><span class="line">        <span class="keyword">bool</span> lr_result = is_symmetrical(pnode1-&gt;pleft, pnode2-&gt;pright);</span><br><span class="line">        <span class="keyword">bool</span> rl_result = is_symmetrical(pnode1-&gt;pright, pnode2-&gt;pleft);</span><br><span class="line">        <span class="keyword">return</span> lr_result &amp;&amp; rl_result;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">is_symmetrical</span><span class="params">(node* proot)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(proot == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> is_symmetrical(proot-&gt;pleft, proot-&gt;pright);</span><br><span class="line">    <span class="comment">// 或者可以写为 虽然会多一倍计算过程 但代码精简到一行，有点抽象</span></span><br><span class="line">    <span class="comment">// return is_symmetrical(proot, proot);</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    node* tree = init_tree();</span><br><span class="line">    <span class="keyword">if</span>(is_symmetrical(tree)) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Tree is symmetrical.\n&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Tree is not symmetrical.\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><blockquote><p>面试题29：顺时针打印矩阵。</p></blockquote><p>输入一个矩阵，按照从外向里以顺时针的顺序依次打印出每一个数字。例如，如果输入如下矩阵，则依次打印数字1、2、3、4、8、12、16、15、15、13、9、5、6、7、11、10。</p><div align="center"><p><img src="/images/s2o-c4-part1-f3.jpg"></p></div><p>完整实现代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print_matrix_clockwise</span><span class="params">(<span class="keyword">int</span>** matrix, <span class="keyword">int</span> rows, <span class="keyword">int</span> cols)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(matrix == <span class="literal">nullptr</span> || rows &lt;= <span class="number">0</span> || cols &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> up = <span class="number">0</span>, bottom = rows<span class="number">-1</span>, left = <span class="number">0</span>, right = cols<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">int</span> i, j;</span><br><span class="line">    <span class="keyword">while</span>(up &lt; bottom &amp;&amp; left &lt; right) &#123;</span><br><span class="line">        <span class="comment">// 从左到右打印</span></span><br><span class="line">        i = up;</span><br><span class="line">        <span class="keyword">for</span>(j = left; j &lt;= right; j++) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, matrix[i][j]);</span><br><span class="line">        &#125;</span><br><span class="line">        up++;</span><br><span class="line">        <span class="comment">// 从上到下打印</span></span><br><span class="line">        j = right;</span><br><span class="line">        <span class="keyword">for</span>(i = up; i &lt;= bottom; i++) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, matrix[i][j]);</span><br><span class="line">        &#125;</span><br><span class="line">        right--;</span><br><span class="line">        <span class="comment">// 从右到左打印</span></span><br><span class="line">        i = bottom;</span><br><span class="line">        <span class="keyword">for</span>(j = right; j &gt;= left; j--) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, matrix[i][j]);</span><br><span class="line">        &#125;</span><br><span class="line">        bottom--;</span><br><span class="line">        <span class="comment">// 从下到上打印</span></span><br><span class="line">        j = left;</span><br><span class="line">        <span class="keyword">for</span>(i = bottom; i &gt;= up; i--) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, matrix[i][j]);</span><br><span class="line">        &#125;</span><br><span class="line">        left++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 当列数或行数是奇数时</span></span><br><span class="line">    <span class="comment">// 会出现多余一列或者一行的情况</span></span><br><span class="line">    <span class="keyword">if</span>(rows &amp; <span class="number">0x1</span> == <span class="number">1</span> || cols &amp; <span class="number">0x1</span> == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">// 最后一列</span></span><br><span class="line">        <span class="keyword">if</span>(up &lt; bottom) &#123;</span><br><span class="line">            j = left;</span><br><span class="line">            <span class="keyword">for</span>(i = up; i &lt;= bottom; i++) &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, matrix[i][j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 最后一行</span></span><br><span class="line">        <span class="keyword">if</span>(left &lt; right) &#123;</span><br><span class="line">            i = up;</span><br><span class="line">            <span class="keyword">for</span>(j = left; j &lt;= right; j++) &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, matrix[i][j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> rows = <span class="number">4</span>, cols = <span class="number">4</span>;</span><br><span class="line">    <span class="keyword">int</span>** matrix = <span class="keyword">new</span> <span class="keyword">int</span>*[rows];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; rows; i++) &#123;</span><br><span class="line">        matrix[i] = <span class="keyword">new</span> <span class="keyword">int</span>[cols];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; cols; j++) &#123;</span><br><span class="line">            matrix[i][j] = i * <span class="number">4</span> + j + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    print_matrix_clockwise((<span class="keyword">int</span>**)matrix, rows, cols);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在实现完整代码的时候，其中需要注意的一个问题是，二维数组的传参问题，如果想像题目一样传指针的方式传参，就需要在主函数使用动态数组的申请方式，用普通的声明方式<code>int matrix[][]</code>再强转<code>(int**)matrix</code>虽说可以传入到函数中，但访问数组会发生错误（原因暂时没有去细究了，应该和内存段的访问相关）。</p><h2 id="3-举例让抽象问题具体化"><a href="#3-举例让抽象问题具体化" class="headerlink" title="3 举例让抽象问题具体化"></a>3 举例让抽象问题具体化</h2><p>包含面试题30-34。</p><p>请到《第4章笔记 高质量代码 P2》阅读这部分内容。</p><h2 id="4-分解让复杂问题简单化"><a href="#4-分解让复杂问题简单化" class="headerlink" title="4 分解让复杂问题简单化"></a>4 分解让复杂问题简单化</h2><p>包含面试题35-38。</p><p>请到《第4章笔记 高质量代码 P3》阅读这部分内容。</p>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;写代码之前理思路，举例子和画图都是很好的办法。&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="剑指Offer" scheme="https://yumi-cn.github.io/categories/%E5%89%91%E6%8C%87Offer/"/>
    
    
    <category term="笔记" scheme="https://yumi-cn.github.io/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>《剑指Offer》第3章笔记 高质量代码 P2</title>
    <link href="https://yumi-cn.github.io/2021/01/01/s2o-c3-part2/"/>
    <id>https://yumi-cn.github.io/2021/01/01/s2o-c3-part2/</id>
    <published>2021-01-01T04:26:35.000Z</published>
    <updated>2021-01-01T04:22:23.734Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>鲁棒是英文Robust的音译，有时也翻译成健壮性。</p></blockquote><a id="more"></a><div align="center"><p><img src="/images/s2o-c3-part2-f4.jpg"></p></div><h2 id="1、2、3-章节"><a href="#1、2、3-章节" class="headerlink" title="1、2、3 章节"></a>1、2、3 章节</h2><p>请到《第3章笔记 高质量代码 P1》阅读这部分内容。</p><h2 id="4-代码的鲁棒性"><a href="#4-代码的鲁棒性" class="headerlink" title="4 代码的鲁棒性"></a>4 代码的鲁棒性</h2><p>提高代码的鲁棒性的有效途径是进行防御性编程。防御性编程是一种编程习惯，是指预见在什么地方可能会出现问题，并为这些可能出现的问题制定处理方式。</p><p>在面试时，最简单也是最实用的防御性变成就是在函数入口添加代码以验证用户输入是否符合要求。通常面试要求的是写一两个函数，我们需要格外关注这些函数的输入参数。当然并不是所有与鲁棒性相关的问题都是检查输入的参数这么简单，有时候要关注稍微隐含一点的逻辑中，可能会发生的潜在问题。</p><h2 id="面试题22-26"><a href="#面试题22-26" class="headerlink" title="面试题22-26"></a>面试题22-26</h2><blockquote><p>面试题22：链表中倒数第K个节点</p></blockquote><p>输入一个链表，输出该链表中倒数第k个节点。这里的k从1开始计数，即链表的尾节点是倒数第1个节点。如，一个链表有6个节点，从头节点开始，他们的值依次是1、2、3、4、5、6，这个链表的倒数第3个节点是值为4的节点。链表节点定义如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> value;</span><br><span class="line">    node* pnext;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这里面需要考虑到的一个问题是，虽然输入的数据是<code>k</code>是正常的整数，但还要考虑链表中是否有大于等于<code>k</code>个的节点。思路就是简单的用两个间隔距离为<code>k-1</code>的指针来解决。</p><p>完整代码实现：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> value;</span><br><span class="line">    node* pnext;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">node* <span class="title">init_node</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123; ... &#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert_node</span><span class="params">(node** phead, node* pnode)</span> </span>&#123; ... &#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(node** phead)</span> </span>&#123; ... &#125;</span><br><span class="line"></span><br><span class="line"><span class="function">node* <span class="title">find_k_to_tail</span><span class="params">(node** phead, <span class="keyword">unsigned</span> <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(phead == <span class="literal">nullptr</span> || *phead == <span class="literal">nullptr</span> || k == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    node* left = *phead;</span><br><span class="line">    node* right = *phead;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k<span class="number">-1</span> &amp;&amp; right != <span class="literal">nullptr</span>; i++) &#123;</span><br><span class="line">        right = right-&gt;pnext;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(right == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(right-&gt;pnext != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        right = right-&gt;pnext;</span><br><span class="line">        left = left-&gt;pnext;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> left;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    node** phead = <span class="keyword">new</span> node*;</span><br><span class="line">    *phead = <span class="literal">nullptr</span>;</span><br><span class="line">    node** node_list = <span class="keyword">new</span> node*[<span class="number">10</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">        node* new_node = init_node(i);</span><br><span class="line">        node_list[i] = new_node;</span><br><span class="line">        insert_node(phead, new_node);</span><br><span class="line">    &#125;</span><br><span class="line">    print(phead); <span class="comment">// 0 1 2 3 4 5 6 7 8 9</span></span><br><span class="line">    node* first_node = find_k_to_tail(phead, <span class="number">10</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;first node: %d\n&quot;</span>, first_node-&gt;value);</span><br><span class="line">    <span class="comment">// first node: 0</span></span><br><span class="line">    node* last_second_node = find_k_to_tail(phead, <span class="number">2</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;last second node: %d\n&quot;</span>, last_second_node-&gt;value);</span><br><span class="line">    <span class="comment">// last second node: 8</span></span><br><span class="line">    node* last_node = find_k_to_tail(phead, <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;last node: %d\n&quot;</span>, last_node-&gt;value);</span><br><span class="line">    <span class="comment">// last node: 9</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><blockquote><p>面试题23：链表中环的入口节点</p></blockquote><p>如果一个链表包含环，如何找出环的入口节点？例如，在如下图所示的链表中，环的入口节点是节点3。</p><div align="center"><p><img src="/images/s2o-c3-part2-f1.jpg"></p></div><ol><li>如何确定链表有环？两个指针，一个1次1步，一个1次2步，如果1次2步的指针“追上了”1次1步的指针，则代表有环，如果指针遇到<code>nullptr</code>则无环；</li><li>如果有环，如何确定环的入口在哪？假设我们知道环里面节点的个数为<code>4</code>，则可以用两个指针，第一个指针先走4步（到达图中第5个节点），第二指针从1开始，同时开始移动，当两个指针相遇时（图中会相遇在第3个节点），即是环的入口节点；</li><li>问题从“<strong>判断环的入口在哪</strong>”转换成了“<strong>如何判断一个环里有多少个节点？</strong>”；判断环里有多少个节点可以用第一步中的结果，固定一个指针，移动一个指针，当两个指针又相遇时，则可以计数出环中的节点个数。</li></ol><p>完整代码实现：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> value;</span><br><span class="line">    node* pnext;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">node* <span class="title">init_node</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123; ... &#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert_node</span><span class="params">(node** phead, node* pnode)</span> </span>&#123; ... &#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(node** phead)</span> </span>&#123; ... &#125;</span><br><span class="line"></span><br><span class="line"><span class="function">node* <span class="title">meeting_node</span><span class="params">(node** phead)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(phead == <span class="literal">nullptr</span> || *phead == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    node* pslow = (*phead)-&gt;pnext;</span><br><span class="line">    node* pfast = pslow-&gt;pnext;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(pfast != <span class="literal">nullptr</span> &amp;&amp; pfast != pslow) &#123;</span><br><span class="line">        pslow = pslow-&gt;pnext;</span><br><span class="line">        pfast = pfast-&gt;pnext;</span><br><span class="line">        <span class="keyword">if</span>(pfast != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            pfast = pfast-&gt;pnext;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(pfast == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> pfast;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">node* <span class="title">find_loop_entry</span><span class="params">(node** phead)</span> </span>&#123;</span><br><span class="line">    node* mnode = meeting_node(phead);</span><br><span class="line">    <span class="keyword">if</span>(mnode == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="comment">// 无环或输入数据错误</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 得到环中的节点数目</span></span><br><span class="line">    <span class="keyword">int</span> nodes_in_loop = <span class="number">1</span>;</span><br><span class="line">    node* pnode1 = mnode;</span><br><span class="line">    <span class="keyword">while</span>(pnode1-&gt;pnext != mnode) &#123;</span><br><span class="line">        pnode1 = pnode1-&gt;pnext;</span><br><span class="line">        nodes_in_loop++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 移动pnode1，次数为欢中节点数目</span></span><br><span class="line">    pnode1 = *phead;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nodes_in_loop; i++) &#123;</span><br><span class="line">        pnode1 = pnode1-&gt;pnext;</span><br><span class="line">    &#125;</span><br><span class="line">    node* pnode2 = *phead;</span><br><span class="line">    <span class="comment">// 再同时移动pnode1和pnode2</span></span><br><span class="line">    <span class="keyword">while</span>(pnode1 != pnode2) &#123;</span><br><span class="line">        pnode1 = pnode1-&gt;pnext;</span><br><span class="line">        pnode2 = pnode2-&gt;pnext;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> pnode1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    node** phead = <span class="keyword">new</span> node*;</span><br><span class="line">    *phead = <span class="literal">nullptr</span>;</span><br><span class="line">    node** node_list = <span class="keyword">new</span> node*[<span class="number">6</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">6</span>; i++) &#123;</span><br><span class="line">        node* new_node = init_node(i+<span class="number">1</span>);</span><br><span class="line">        node_list[i] = new_node;</span><br><span class="line">        insert_node(phead, new_node);</span><br><span class="line">    &#125;</span><br><span class="line">    print(phead);</span><br><span class="line">    <span class="comment">// 1 2 3 4 5 6</span></span><br><span class="line">    <span class="keyword">if</span>(find_loop_entry(phead) == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;No loop yet.\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 尾节点指向第3个节点</span></span><br><span class="line">    node_list[<span class="number">5</span>]-&gt;pnext = node_list[<span class="number">2</span>];</span><br><span class="line">    node* loop_entry = find_loop_entry(phead);</span><br><span class="line">    <span class="keyword">if</span>(loop_entry == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;No loop, Error.\n&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Loop entry at %d.\n&quot;</span>, loop_entry-&gt;value);</span><br><span class="line">        <span class="comment">// Loop entry at 3.</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><blockquote><p>面试题24：反转链表</p></blockquote><p>定义一个函数，输入一个链表的头节点，反转该链表并输出反转后链表的头节点，链表节点定义如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> value;</span><br><span class="line">    node* pnext;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>思路就是新建一个头结点，在遍历链表的时候，不断的把节点插入到新链表的头节点，最后完成倒序。</p><p>完整实现代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> value;</span><br><span class="line">    node* pnext;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">node* <span class="title">init_node</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123; ... &#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert_node</span><span class="params">(node** phead, node* pnode)</span> </span>&#123; ... &#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(node** phead)</span> </span>&#123; ... &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">reverse</span><span class="params">(node** phead)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(phead == <span class="literal">nullptr</span> || *phead == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    node** new_phead = <span class="keyword">new</span> node*;</span><br><span class="line">    *new_phead = <span class="literal">nullptr</span>;</span><br><span class="line">    node* pnode = *phead;</span><br><span class="line">    <span class="keyword">while</span>(pnode != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        *phead = pnode-&gt;pnext;</span><br><span class="line">        <span class="keyword">if</span>(*new_phead == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            pnode-&gt;pnext = <span class="literal">nullptr</span>;</span><br><span class="line">            *new_phead = pnode;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            pnode-&gt;pnext = *new_phead;</span><br><span class="line">            *new_phead = pnode;</span><br><span class="line">        &#125;</span><br><span class="line">        pnode = *phead;</span><br><span class="line">    &#125;</span><br><span class="line">    *phead = *new_phead;</span><br><span class="line">    *new_phead = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">delete</span> new_phead;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    node** phead = <span class="keyword">new</span> node*;</span><br><span class="line">    *phead = <span class="literal">nullptr</span>;</span><br><span class="line">    node** node_list = <span class="keyword">new</span> node*[<span class="number">10</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">        node* new_node = init_node(i+<span class="number">1</span>);</span><br><span class="line">        node_list[i] = new_node;</span><br><span class="line">        insert_node(phead, new_node);</span><br><span class="line">    &#125;</span><br><span class="line">    print(phead);</span><br><span class="line">    <span class="comment">// 1 2 3 4 5 6 7 8 9 10</span></span><br><span class="line">    reverse(phead);</span><br><span class="line">    print(phead);</span><br><span class="line">    <span class="comment">// 10 9 8 7 6 5 4 3 2 1</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><blockquote><p>面试题25：合并两个排序的链表。</p></blockquote><p>输入两个递增排序的链表，合并这两个链表并使新链表中的节点仍然是递增排序的。</p><div align="center"><p><img src="/images/s2o-c3-part2-f2.jpg"></p></div><p>思路也没有很复杂，就是不断比较头结点大小，然后插入新链表的尾部，不过要注意一些实现细节，例如其中一个链表提前为空后的插入方法、算法结束判断、输入的各种可能性。</p><p>完整实现代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> value;</span><br><span class="line">    node* pnext;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">node* <span class="title">init_node</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123; ... &#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert_node</span><span class="params">(node** phead, node* pnode)</span> </span>&#123; ... &#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(node** phead)</span> </span>&#123; ... &#125;</span><br><span class="line"></span><br><span class="line"><span class="function">node** <span class="title">order_merge</span><span class="params">(node** phead1, node** phead2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(phead1 == <span class="literal">nullptr</span> || *phead1 == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> phead2;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(phead2 == <span class="literal">nullptr</span> || *phead2 == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> phead1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    node** phead;</span><br><span class="line">    *phead = <span class="literal">nullptr</span>;</span><br><span class="line">    node* pnode = <span class="literal">nullptr</span>;</span><br><span class="line">    node* temp = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(*phead1 != <span class="literal">nullptr</span> &amp;&amp; *phead2 != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span>((*phead1)-&gt;value &lt;= (*phead2)-&gt;value) &#123;</span><br><span class="line">            temp = *phead1;</span><br><span class="line">            *phead1 = temp-&gt;pnext;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            temp = *phead2;</span><br><span class="line">            *phead2 = temp-&gt;pnext;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(*phead == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            *phead = temp;</span><br><span class="line">            pnode = *phead;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            pnode-&gt;pnext = temp;</span><br><span class="line">            pnode = temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(*phead1 != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        pnode-&gt;pnext = *phead1;</span><br><span class="line">        pnode = pnode-&gt;pnext;</span><br><span class="line">        *phead1 = (*phead1)-&gt;pnext;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(*phead2 != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        pnode-&gt;pnext = *phead2;</span><br><span class="line">        pnode = pnode-&gt;pnext;</span><br><span class="line">        *phead2 = (*phead2)-&gt;pnext;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    pnode-&gt;pnext = <span class="literal">nullptr</span>;</span><br><span class="line">    pnode = <span class="literal">nullptr</span>;</span><br><span class="line">    temp = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">delete</span> pnode;</span><br><span class="line">    <span class="keyword">delete</span> temp;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> phead;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    node** phead1 = <span class="keyword">new</span> node*;</span><br><span class="line">    node** phead2 = <span class="keyword">new</span> node*;</span><br><span class="line">    *phead1 = <span class="literal">nullptr</span>;</span><br><span class="line">    *phead2 = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">        node* new_node1 = init_node(i * <span class="number">2</span>);</span><br><span class="line">        node* new_node2 = init_node(i * <span class="number">2</span> + <span class="number">1</span>);</span><br><span class="line">        insert_node(phead1, new_node1);</span><br><span class="line">        insert_node(phead2, new_node2);</span><br><span class="line">    &#125;</span><br><span class="line">    print(phead1); <span class="comment">// 0 2 4 6</span></span><br><span class="line">    print(phead2); <span class="comment">// 1 3 5 7</span></span><br><span class="line">    node** phead3 = order_merge(phead1, phead2);</span><br><span class="line">    print(phead3); <span class="comment">// 0 1 2 3 4 5 6 7</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>书上写的是递归版本，但是这里考虑到时间效率优化（其实是没想到），就写成循环实现了，会稍微长一点点。</p><hr><blockquote><p>面试题26：树的子结构</p></blockquote><p>输入两颗二叉树<code>A</code>和<code>B</code>，判断<code>B</code>是不是<code>A</code>的子结构。二叉树节点定义：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span></span><br><span class="line">    <span class="keyword">double</span> value;</span><br><span class="line">    node* pleft;</span><br><span class="line">    node* pright;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>关于<strong>子结构</strong>的定义，如下图中的两棵二叉树，A中有一部分子树的结构和B是一样的，所以B是A的子结构。</p><div align="center"><p><img src="/images/s2o-c3-part2-f3.jpg" alt="左A，右B"></p></div><ol><li>第一步在树A中查找与根节点的值一样的节点，实际上是树的遍历；</li><li>判断树A中以R为根节点的子树是不是和树B具有相同的结构。</li></ol><p>完整实现代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span></span><br><span class="line">    <span class="keyword">double</span> value;</span><br><span class="line">    node* pleft;</span><br><span class="line">    node* pright;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">node* <span class="title">init_node</span><span class="params">(<span class="keyword">double</span> value)</span> </span>&#123; ... &#125;</span><br><span class="line"><span class="function">node* <span class="title">init_a_tree</span><span class="params">()</span> </span>&#123; ... &#125;</span><br><span class="line"><span class="function">node* <span class="title">init_b_tree</span><span class="params">()</span> </span>&#123; ... &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> eps = <span class="number">1e-7</span>;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">equal</span><span class="params">(<span class="keyword">double</span> d1, <span class="keyword">double</span> d2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>((d1 - d2) &gt; -eps &amp;&amp; (d1 - d2) &lt; eps) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">does_tree1_have_tree2</span><span class="params">(node* proot1, node* proot2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(proot2 == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(proot1 == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(!equal(proot1-&gt;value, proot2-&gt;value)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 检查左子树</span></span><br><span class="line">    <span class="keyword">bool</span> left_result = does_tree1_have_tree2(proot1-&gt;pleft, proot2-&gt;pleft);</span><br><span class="line">    <span class="comment">// 检查右子树</span></span><br><span class="line">    <span class="keyword">bool</span> right_result = does_tree1_have_tree2(proot1-&gt;pright, proot2-&gt;pright);</span><br><span class="line">    <span class="keyword">return</span> left_result &amp;&amp; right_result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">is_sub_tree</span><span class="params">(node* proot1, node* proot2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">bool</span> result = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(proot1 != <span class="literal">nullptr</span> &amp;&amp; proot2 != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span>(equal(proot1-&gt;value, proot2-&gt;value)) &#123;</span><br><span class="line">            <span class="comment">// 检查根节点是否为B树子结构</span></span><br><span class="line">            result = does_tree1_have_tree2(proot1, proot2);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(!result) &#123;</span><br><span class="line">            <span class="comment">// 检查左子树是否为B树子结构</span></span><br><span class="line">            result = is_sub_tree(proot1-&gt;pleft, proot2);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(!result) &#123;</span><br><span class="line">            <span class="comment">// 检查右子树是否为B树子结构</span></span><br><span class="line">            result = is_sub_tree(proot1-&gt;pright, proot2);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    node* tree_a = init_a_tree();</span><br><span class="line">    node* tree_b = init_b_tree();</span><br><span class="line">    <span class="keyword">if</span>(is_sub_tree(tree_a, tree_b)) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Tree A has Tree B.\n&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Tree A does not have Tree B.\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>需要注意地方有两个，一个是在使用指针前一定要先对其进行判断，另一个是注意题目给的<code>value</code>类型是<code>double</code>，在判断相等时不能只是简单地使用<code>==</code>，要使用精度阈值的判断方法<code>fabs(n1 - n2) &lt; eps</code>。</p>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;鲁棒是英文Robust的音译，有时也翻译成健壮性。&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="剑指Offer" scheme="https://yumi-cn.github.io/categories/%E5%89%91%E6%8C%87Offer/"/>
    
    
    <category term="笔记" scheme="https://yumi-cn.github.io/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>《剑指Offer》第3章笔记 高质量代码 P1</title>
    <link href="https://yumi-cn.github.io/2020/12/30/s2o-c3-part1/"/>
    <id>https://yumi-cn.github.io/2020/12/30/s2o-c3-part1/</id>
    <published>2020-12-30T11:05:35.000Z</published>
    <updated>2020-12-30T11:14:58.937Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>除了程序代码的正确性，经常我们还要关注它的鲁棒性。</p></blockquote><a id="more"></a><h2 id="1-面试官谈代码质量"><a href="#1-面试官谈代码质量" class="headerlink" title="1 面试官谈代码质量"></a>1 面试官谈代码质量</h2><blockquote><p>“一般会考查应聘人员对代码的容错处理能力，对一些特别的输入会询问应聘人员是否考虑、如何处理。不能容忍代码只是针对一种假想的‘正常值’进行处理，不考虑异常状况，也不考虑资源的回收等问题。”</p><p>—— 殷焰（支付宝，高级安全测试工程师）</p></blockquote><blockquote><p>“如果是因为粗心犯错，则可以原谅，因为毕竟面试的时候会紧张；不能容忍的是，该掌握的知识点却没有掌握，而且提醒了还不知道。”</p><p>—— 马凌洲（Autodesk，软件开发经理）</p></blockquote><blockquote><p>“最不能容忍功能错误，忽略边界情况。”</p><p>—— 尹彦（英特尔，软件工程师）</p></blockquote><blockquote><p>“如果一个程序员连变量、函数命名都毫无章法，解决一个具体问题都找不到一个最合适的数据结构，那么这会让面试官对他的印象大打折扣，因为这只能说明他程序写得太少，不够熟悉。”</p><p>—— 吴斌（英伟达，图形设计师）</p></blockquote><blockquote><p>“我会从程序的正确性和鲁棒性两方面检验代码的质量。会关注对输入参数的检查、处理错误和异常的方式、命名方式等。对于没有工作经验的学生，程序正确性之外的错误基本都能容忍，但经过提示后希望能够很快解决。对于有工作经验的人，不能容忍考虑不周到，有明显的鲁棒性错误。”</p><p>—— 田超（微软，SDE ||）</p></blockquote><hr><h2 id="2-代码的规范性"><a href="#2-代码的规范性" class="headerlink" title="2 代码的规范性"></a>2 代码的规范性</h2><p>面试官会根据应聘者写出的代码来决定是否录用他，如果应聘者代码写的不够规范，影响面试官阅读代码的兴致，那么面试官就会默默地减去几分。<strong>书写、布局和命名</strong>都决定着代码的规范性。</p><div align="center"><p><img src="/images/s2o-c3-part1-f1.jpg" alt="影响代码规范性的因素"></p></div><p>首先，<strong>清晰的规范的代码书写</strong>。写的慢一点也可以，把字母、数字、符号写清楚。</p><p>其次，<strong>清晰的规范的代码布局</strong>。缩进、对齐的一些布局格式要注意统一。</p><p>最后，<strong>合理的规范的代码命名</strong>。建议在写代码时，用完整的英文单词组合命名变量和函数。比如函数传入一个二叉树的根节点作为参数，则可以把该参数命名为<code>BinaryTreeNode* pRoot</code>，不用觉得这样多写字母会麻烦，如果一眼能看出变量、函数的用途，应聘者就能避免搞混淆而犯一些低级错误（除了循环量<code>i,j,k</code>这种，其他都要注意），同时合理的命名也能让面试官一眼读懂代码的意图。</p><hr><h2 id="3-代码的完整性"><a href="#3-代码的完整性" class="headerlink" title="3 代码的完整性"></a>3 代码的完整性</h2><p>面试官会通过检查代码是否完整来考查应聘者的思维是否全面，一般会检查代码是否完成了基本功能、输入边界值是否能得到正确地输出、是否对各种不合规范的非法输入做出了合理的错误处理。</p><h3 id="3-1-3个方面确保完整性"><a href="#3-1-3个方面确保完整性" class="headerlink" title="3.1 3个方面确保完整性"></a>3.1 3个方面确保完整性</h3><p>咕咕待更。</p><h3 id="3-2-3种错误处理的方法"><a href="#3-2-3种错误处理的方法" class="headerlink" title="3.2 3种错误处理的方法"></a>3.2 3种错误处理的方法</h3><p>咕咕待更。</p><h3 id="3-3-面试题-16-21"><a href="#3-3-面试题-16-21" class="headerlink" title="3.3 面试题 16-21"></a>3.3 面试题 16-21</h3><blockquote><p>面试题16：数值的整数次方。</p></blockquote><p>实现函数<code>double Power(double base, int exponent)</code>，求<code>base</code>的<code>exponent</code>次方，不得使用库函数，不需要考虑大数问题（只考虑结果在double的表达范围）。</p><p>完整实现代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> g_invalid_input = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">double</span> eps = <span class="number">1e-8</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">equal</span><span class="params">(<span class="keyword">double</span> lhs, <span class="keyword">double</span> rhs)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">double</span> big = (lhs &gt; rhs)?lhs:rhs;</span><br><span class="line">    <span class="keyword">double</span> small = (big != lhs)?lhs:rhs;</span><br><span class="line">    <span class="keyword">return</span> (big - small) &lt;= eps;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">power_with_unsigned_exp</span><span class="params">(<span class="keyword">double</span> base, <span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="built_in">exp</span>)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// exp只为正数，内部只关心几次方的计算</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">exp</span> == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">exp</span> == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> base;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 考虑用递归数学公式来加速幂计算</span></span><br><span class="line">        <span class="comment">// exp &gt;&gt; 1，int右移1位，等价于除以2向下取整，优化计算速度</span></span><br><span class="line">        <span class="keyword">double</span> result = power_with_unsigned_exp(base, <span class="built_in">exp</span> &gt;&gt; <span class="number">1</span>);</span><br><span class="line">        result *= result;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">exp</span> &amp; <span class="number">0x1</span> == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="comment">// 判断是否为奇数，这种方式比 % 2 == 0，速度更快</span></span><br><span class="line">            result *= base;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">power</span><span class="params">(<span class="keyword">double</span> base, <span class="keyword">int</span> <span class="built_in">exp</span>)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 考虑exp 为正、为负、为0的情况</span></span><br><span class="line"></span><br><span class="line">    g_invalid_input = <span class="literal">false</span>; <span class="comment">// 初始化全局变量</span></span><br><span class="line">    <span class="keyword">if</span>(equal(base, <span class="number">0.0</span>) &amp;&amp; <span class="built_in">exp</span> &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        g_invalid_input = <span class="literal">true</span>; <span class="comment">// 也可以考虑其他错误处理方式</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0.0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> abs_exp = (<span class="keyword">unsigned</span> <span class="keyword">int</span>)((<span class="built_in">exp</span> &lt; <span class="number">0</span>)?-<span class="built_in">exp</span>:<span class="built_in">exp</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">double</span> result = power_with_unsigned_exp(base, abs_exp);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (<span class="built_in">exp</span> &lt; <span class="number">0</span>)?(<span class="number">1.0</span> / result):(result);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; power(<span class="number">2</span>, <span class="number">4</span>) &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 16</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; power(<span class="number">10</span>, <span class="number">5</span>) &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 100000</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; power(<span class="number">13</span>, <span class="number">-2</span>) &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 0.00591716</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; power(<span class="number">0</span>, <span class="number">0</span>) &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 1</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><blockquote><p>面试题17：打印从1到最大的n位数。</p></blockquote><p>输入数字<code>n</code>，按顺序打印出<code>1</code>到最大的<code>n</code>位十进制数。比如输入3，从1、2、3一直打印到最大的3位数999。</p><p>用字符串模拟大数加法进位的方式：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">char</span>* number)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 对于前面的空0，不再打印</span></span><br><span class="line">    <span class="keyword">int</span> len = <span class="built_in">strlen</span>(number);</span><br><span class="line">    <span class="keyword">bool</span> begin = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(!begin &amp;&amp; number[i] == <span class="string">&#x27;0&#x27;</span>) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(!begin &amp;&amp; number[i] != <span class="string">&#x27;0&#x27;</span>) &#123;</span><br><span class="line">            begin = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>, number[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">increment</span><span class="params">(<span class="keyword">char</span>* number)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">bool</span> is_overflow = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">int</span> carry = <span class="number">0</span>; <span class="comment">// 进位量</span></span><br><span class="line">    <span class="keyword">int</span> len = <span class="built_in">strlen</span>(number);</span><br><span class="line">    <span class="comment">// 模拟加法进位</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = len - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="keyword">int</span> sum = number[i] - <span class="string">&#x27;0&#x27;</span> + carry;</span><br><span class="line">        <span class="keyword">if</span>(i == len - <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="comment">// 末位加1 increment</span></span><br><span class="line">            sum++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(sum &gt;= <span class="number">10</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span>(i == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// 已经在最高位，进位就溢出了</span></span><br><span class="line">                is_overflow = <span class="literal">true</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                carry = <span class="number">1</span>;</span><br><span class="line">                sum -= <span class="number">10</span>;</span><br><span class="line">                number[i] = <span class="string">&#x27;0&#x27;</span> + sum;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            number[i] = <span class="string">&#x27;0&#x27;</span> + sum;</span><br><span class="line">            carry = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> is_overflow;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print_1_to_n_max</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span>* number = <span class="keyword">new</span> <span class="keyword">char</span>[n + <span class="number">1</span>]; <span class="comment">// 多一位给结尾符 \0</span></span><br><span class="line">    <span class="built_in">memset</span>(number, <span class="string">&#x27;0&#x27;</span>, n);</span><br><span class="line">    number[n] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(!increment(number)) &#123;</span><br><span class="line">        print(number);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">delete</span>[] number;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    print_1_to_n_max(<span class="number">3</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>还可以考虑用全排列的方式，就不用再考虑进位的问题，代码就简洁了很多：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">char</span>* number)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 对于前面的空0，不再打印</span></span><br><span class="line">    <span class="keyword">int</span> len = <span class="built_in">strlen</span>(number);</span><br><span class="line">    <span class="keyword">bool</span> begin = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(!begin &amp;&amp; number[i] == <span class="string">&#x27;0&#x27;</span>) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(!begin &amp;&amp; number[i] != <span class="string">&#x27;0&#x27;</span>) &#123;</span><br><span class="line">            begin = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>, number[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(begin == <span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>); <span class="comment">// 修正部分，不打印全0的情况</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print_1_to_n_max_rec</span><span class="params">(<span class="keyword">char</span>* number, <span class="keyword">int</span> len, <span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(index == len) &#123;</span><br><span class="line">        print(number);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">        number[index] = i + <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        print_1_to_n_max_rec(number, len, index + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print_1_to_n_max_permutation</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">char</span>* number = <span class="keyword">new</span> <span class="keyword">char</span>[n + <span class="number">1</span>];</span><br><span class="line">    <span class="built_in">memset</span>(number, <span class="string">&#x27;0&#x27;</span>, n);</span><br><span class="line">    number[n] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line"></span><br><span class="line">    print_1_to_n_max_rec(number, n, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">delete</span>[] number;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    print_1_to_n_max_permutation(<span class="number">3</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不过全排列的方法有一个容易忽略的漏洞，就算按照书上的代码运行，会出现一个多余的打印情况<code>print(&quot;000&quot;)</code>，这是因为这是全排列的起点，而想修改全排列的起点为<code>001</code>还稍微有点麻烦，这个时候你会发现其实<code>print</code>并不会把<code>000</code>打印出来，但是会多打印一个<code>\n</code>换行，所以只要简单修改一下<code>print</code>，让其只在非<code>000</code>的情况下才换行，这样看起来我们的输出起点就是<code>1</code>了。</p><hr><blockquote><p>面试题18：删除链表的节点。</p></blockquote><p><strong>题目一</strong>：在O(1)的时间内删除链表节点。</p><p>给定单向链表的头指针和一个节点指针，定义一个函数在<code>O(1)</code>时间内删除该节点。链表节点与函数的定义如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> value;</span><br><span class="line">    node* pnext;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">delete_node</span><span class="params">(node** phead, node* pdelete)</span></span>;</span><br></pre></td></tr></table></figure><p>完整实现代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> value;</span><br><span class="line">    node* pnext;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">node* <span class="title">init_node</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">    node* pnode = <span class="keyword">new</span> node;</span><br><span class="line">    pnode-&gt;value = value;</span><br><span class="line">    pnode-&gt;pnext = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">return</span> pnode;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert_node</span><span class="params">(node** phead, node* pnode)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(*phead == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        *phead = pnode;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    node* temp = *phead;</span><br><span class="line">    <span class="keyword">while</span>(temp-&gt;pnext != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        temp = temp-&gt;pnext;</span><br><span class="line">    &#125;</span><br><span class="line">    temp-&gt;pnext = pnode;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">delete_node</span><span class="params">(node** phead, node* pdelete)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!phead || !pdelete) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(pdelete-&gt;pnext != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="comment">// 删除非尾节点，拷贝节点</span></span><br><span class="line">        node* pnext = pdelete-&gt;pnext;</span><br><span class="line">        pdelete-&gt;value = pnext-&gt;value;</span><br><span class="line">        pdelete-&gt;pnext = pnext-&gt;pnext;</span><br><span class="line">        <span class="comment">// 删除节点</span></span><br><span class="line">        <span class="keyword">delete</span> pnext;</span><br><span class="line">        pnext = <span class="literal">nullptr</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(*phead == pdelete) &#123;</span><br><span class="line">        <span class="comment">// 删除尾节点，并且链表只有一个节点</span></span><br><span class="line">        <span class="keyword">delete</span> pdelete;</span><br><span class="line">        pdelete = <span class="literal">nullptr</span>;</span><br><span class="line">        *phead = <span class="literal">nullptr</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 删除尾节点，只能从头找起</span></span><br><span class="line">        node* pnode = *phead;</span><br><span class="line">        <span class="keyword">while</span>(pnode-&gt;pnext != pdelete) &#123;</span><br><span class="line">            pnode = pnode-&gt;pnext;</span><br><span class="line">        &#125;</span><br><span class="line">        pnode-&gt;pnext = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">delete</span> pdelete;</span><br><span class="line">        pdelete = <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(node** phead)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(*phead == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    node* pnode = *phead;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, pnode-&gt;value);</span><br><span class="line">    <span class="keyword">while</span>(pnode-&gt;pnext != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        pnode = pnode-&gt;pnext;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, pnode-&gt;value);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    node** phead = <span class="keyword">new</span> node*;</span><br><span class="line">    *phead = <span class="literal">nullptr</span>;</span><br><span class="line">    node** node_list = <span class="keyword">new</span> node*[<span class="number">10</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">        node* new_node = init_node(i);</span><br><span class="line">        node_list[i] = new_node;</span><br><span class="line">        insert_node(phead, new_node);</span><br><span class="line">    &#125;</span><br><span class="line">    print(phead); <span class="comment">// 0 1 2 3 4 5 6 7 8 9</span></span><br><span class="line">    <span class="comment">// 删除头节点</span></span><br><span class="line">    delete_node(phead, node_list[<span class="number">0</span>]);</span><br><span class="line">    <span class="comment">// 删除尾节点</span></span><br><span class="line">    delete_node(phead, node_list[<span class="number">9</span>]);</span><br><span class="line">    <span class="comment">// 删除中间节点</span></span><br><span class="line">    delete_node(phead, node_list[<span class="number">5</span>]);</span><br><span class="line">    print(phead); <span class="comment">// 1 2 3 4 6 7 8</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码有三个需要讨论的地方：</p><ol><li><strong>关于时间复杂度</strong>，如果是尾节点，则需要<code>O(n)</code>时间，如果是非尾节点，则需要<code>O(1)</code>时间，平均情况下<code>[(n-1)*O(1) + O(n)]/n = O(1)</code>，这也是书上说明的情况，<strong>但如果你真的要较真</strong>，你说：“我就是尾节点也想做到<code>O(1)</code>时间，可不可以？” 我说当然可以，再细想一下尾节点需要<code>O(n)</code>的原因，因为我们没有办法知道它的前一个节点是什么，那整个链表里面有没有什么地方是可以让我们保留一个额外的指针的地方呢？当然有，那就是尾节点没有利用起来的<code>pnext</code>，如果你将尾节点的<code>pnext</code>指向它的前一个节点，那自然删除也只需要<code>O(1)</code>时间了，当然这会影响到一些其他过程，例如判断达到尾节点的方式就和以往的<code>pnode-&gt;pnext == nullptr</code>不同了，但方法终归是可行的，尤其是如果面试官再进一步问是否还可以更优化时；</li><li><strong>上述代码仍然不是完美代码</strong>，主要是指的完整性上，因为它基于一个假设：<strong>要删除的节点的确在链表中</strong>，需要<code>O(n)</code>的时间才能判断链表中是否包含某一个节点（不借助其他数据结构情况下），受到题目的<code>O(1)</code>时间限制，所以这部分就没有再考虑了，可以和面试官进行说明；</li><li>代码中用来<strong>删除节点的部分</strong>，用了一个保存节点的<code>node_list</code>数组，但这个数组中的节点情况并不会一直地和链表的节点情况保持一致，因为方法中涉及到了节点的拷贝，取决于删除的情况，数组<code>i</code>位置保存节点的<code>value</code>很有可能并不是<code>i</code>，也有可能链表中<code>i</code>值的节点还在，而<code>node_list</code>中<code>i</code>位置的指针已经被设置为<code>nullptr</code>。</li></ol><p><strong>题目二</strong>：删除链表中重复的节点。</p><p>在一个<strong>排序的链表</strong>中，如何删除重复的节点？</p><p>PS：这道题在书上的图3.4应该是打印出错了，初始链表的几个节点都没有打全，总之就是链表中重复的节只保留一个。另外，注意题目中的<strong>已排序</strong>条件。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> value;</span><br><span class="line">    node* pnext;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">delete_duplication</span><span class="params">(node** phead)</span></span>;</span><br></pre></td></tr></table></figure><p>完整实现代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> value;</span><br><span class="line">    node* pnext;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">node* <span class="title">init_node</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123; ... &#125;; <span class="comment">// 和上面代码的相同</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert_node</span><span class="params">(node** phead, node* pnode)</span> </span>&#123; ... &#125;; <span class="comment">// 和上面代码的相同</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(node** phead)</span> </span>&#123; ... &#125;; <span class="comment">// 和上面代码的相同</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">delete_duplication</span><span class="params">(node** phead)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(phead == <span class="literal">nullptr</span> || *phead == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    node* pprenode = <span class="literal">nullptr</span>;</span><br><span class="line">    node* pnode = *phead;</span><br><span class="line">    <span class="keyword">while</span>(pnode != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        node* pnext = pnode-&gt;pnext;</span><br><span class="line">        <span class="keyword">bool</span> need_delete = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(pnext != <span class="literal">nullptr</span> &amp;&amp; pnext-&gt;value == pnode-&gt;value) &#123;</span><br><span class="line">            need_delete = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        pprenode = pnode; <span class="comment">// 修改的代码</span></span><br><span class="line">        <span class="keyword">if</span>(!need_delete) &#123;</span><br><span class="line">            <span class="comment">// pprenode = pnode; // 原代码</span></span><br><span class="line">            pnode = pnode-&gt;pnext;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">int</span> value = pnode-&gt;value;</span><br><span class="line">            node* ptobedel = pnext; <span class="comment">// 修改的代码</span></span><br><span class="line">            <span class="comment">// node* ptobedel = pnode; // 原代码</span></span><br><span class="line">            <span class="keyword">while</span>(ptobedel != <span class="literal">nullptr</span> &amp;&amp; ptobedel-&gt;value == value) &#123;</span><br><span class="line">                pnext = ptobedel-&gt;pnext;</span><br><span class="line">                <span class="keyword">delete</span> ptobedel;</span><br><span class="line">                ptobedel = <span class="literal">nullptr</span>;</span><br><span class="line">                ptobedel = pnext;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(pprenode == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">                *phead = pnext;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                pprenode-&gt;pnext = pnext;</span><br><span class="line">            &#125;</span><br><span class="line">            pnode = pnext;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    node** phead = <span class="keyword">new</span> node*;</span><br><span class="line">    *phead = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">        node* new_node = init_node(i / <span class="number">2</span>);</span><br><span class="line">        insert_node(phead, new_node);</span><br><span class="line">    &#125;</span><br><span class="line">    print(phead); <span class="comment">// 0 0 1 1 2 2 3 3 4 4</span></span><br><span class="line">    delete_duplication(phead);</span><br><span class="line">    print(phead); <span class="comment">// 0 1 2 3 4</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>init_node</code>、<code>insert_node</code>以及<code>print</code>函数均和18题题目一的代码相同，不再赘述。</p><p>PS：需要说明的一点是，书上的<code>delete_duplication</code>代码和我这里所写的代码有细微差别，原因是<strong>对原题目的理解偏差问题</strong>，如果原题目所说的<strong>删除重复的节点</strong>不需要留下一个被重复的节点（即一个都不留），则看上面代码的原代码部分，如果是需要保留一个节点，就看修改后的部分。</p><hr><blockquote><p>面试题19：正则表达式匹配</p></blockquote><p>题目：请实现一个函数用来匹配包含 <code>.</code> 和 <code>*</code> 的正则表达式。模式中的字符 <code>.</code> 表示任意一个字符，而 <code>*</code> 表示它前面的字符可以出现任意次（含0次），匹配是指<strong>字符串的所有字符匹配整个模式</strong>，例如，字符串 <code>&quot;aaa&quot;</code> 与模式 <code>a.a</code> 和 <code>ab*ac*a</code> 匹配，但与 <code>aa.a</code> 和 <code>ab*a</code> 均不匹配。</p><p>遇到字符时，和模式串的对应字符进行比较：</p><ul><li>如果是<strong>普通字符</strong>，则直接比较匹配，后移指针；</li><li>如果是 <code>.</code>，匹配任意字符，后移指针；</li><li>如果发现字符的下一位是 <code>*</code>，就有两种情况了：<ul><li>如果是<strong>再匹配一次</strong>的情况，先检验是否匹配，如果匹配，则字符串指针后移，匹配串指针不后移；如果不匹配，则只能考虑将匹配串指针后移两位(跳过<code>*</code>)；</li><li>如果是<strong>不再匹配一次</strong>的情况，匹配串指针后移两位（跳过<code>*</code>）；</li><li>两种情况都要考虑到，所以需要用到递归来判断其中一个分支是否可行。</li></ul></li></ul><p>完整实现代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">match_core</span><span class="params">(<span class="keyword">char</span>* str, <span class="keyword">char</span>* pattern)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%c %c \n&quot;</span>, *str, *pattern);</span><br><span class="line">    <span class="keyword">if</span>(*str == <span class="string">&#x27;\0&#x27;</span> &amp;&amp; *pattern == <span class="string">&#x27;\0&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(*str != <span class="string">&#x27;\0&#x27;</span> &amp;&amp; *pattern == <span class="string">&#x27;\0&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(*(pattern + <span class="number">1</span>) == <span class="string">&#x27;*&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span>((*pattern == <span class="string">&#x27;.&#x27;</span> &amp;&amp; *str != <span class="string">&#x27;\0&#x27;</span>) || *str == *pattern) &#123;</span><br><span class="line">            <span class="keyword">return</span> match_core(str + <span class="number">1</span>, pattern) || match_core(str, pattern + <span class="number">2</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> match_core(str, pattern + <span class="number">2</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>((*pattern == <span class="string">&#x27;.&#x27;</span> &amp;&amp; *str != <span class="string">&#x27;\0&#x27;</span>) || *str == *pattern) &#123;</span><br><span class="line">        <span class="keyword">return</span> match_core(str + <span class="number">1</span>, pattern + <span class="number">1</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">match</span><span class="params">(<span class="keyword">char</span>* str, <span class="keyword">char</span>* pattern)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(str == <span class="literal">nullptr</span> || pattern == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> match_core(str, pattern);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> str[<span class="number">100</span>] = <span class="string">&quot;aaa&quot;</span>;</span><br><span class="line">    <span class="keyword">char</span> pattern[<span class="number">100</span>] = <span class="string">&quot;ab*ac*a&quot;</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Match? %s \n&quot;</span>, match(str, pattern) ? <span class="string">&quot;true&quot;</span> : <span class="string">&quot;false&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码中，需要注意的一个点是，对于匹配串的字符是<code>.</code>时，不能只是简单的只看匹配串，还要看<strong>被匹配串是否有字符可以匹配</strong>，所以不能只是简单地写为<code>if(*pattern == &#39;.&#39; || ...)</code>，应该写为<code>if((*pattern == &#39;.&#39; &amp;&amp; *str != &#39;\0&#39;) || ...)</code>，如果忽略这个细节，你不会在题目提供的几个输入输出上发现问题，但如果你多尝试其他的输入输出，尤其是当匹配串为<code>.*</code>(匹配任意字符)，你会发现结果是错误的。</p><hr><blockquote><p>面试题20：表示数值的字符串</p></blockquote><p>实现一个函数用来判断字符串是否表示数值（包括整数和小数），例如字符串<code>&quot;+100&quot;</code>、<code>&quot;5e2&quot;</code>、<code>&quot;-123&quot;</code>、<code>&quot;3.1416&quot;</code>及<code>&quot;-1E-16&quot;</code>都表示数值，但<code>&quot;12e&quot;</code>、<code>&quot;1a3.14&quot;</code>、<code>&quot;1.2.3&quot;</code>、<code>&quot;+-5&quot;</code>及<code>&quot;12e+5.4&quot;</code>都不是。</p><p>表示数值的字符串遵循模式 <code>A[.[B]][e|EC]</code> 或者 <code>.B[e|EC]</code>，其中A为数值的整数部分，B紧跟小数点为数值的小数部分，C紧跟着<code>e</code>或者<code>E</code>为数值的指数部分。A和C都是可能以<code>+</code>或者<code>-</code>开头的<code>0~9</code>的数位串，B也是<code>0~9</code>的数位串，但前面不能有正负号。</p><p>完整实现代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">scan_unsigned_inter</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>** str)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>* before = *str;</span><br><span class="line">    <span class="keyword">while</span>(**str != <span class="string">&#x27;\0&#x27;</span> &amp;&amp; **str &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; **str &lt;= <span class="string">&#x27;9&#x27;</span>) &#123;</span><br><span class="line">        (*str)++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> *str &gt; before;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">scan_integer</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>** str)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(**str == <span class="string">&#x27;+&#x27;</span> || **str == <span class="string">&#x27;-&#x27;</span>) &#123;</span><br><span class="line">        (*str)++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> scan_unsigned_inter(str);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">is_numberic</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* str)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(str == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// A[.[B]][e|EC] 或者 .B[e|EC]</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查A部分</span></span><br><span class="line">    <span class="keyword">bool</span> a_is_numeric = scan_integer(&amp;str);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">bool</span> b_is_numeric = <span class="literal">true</span>;</span><br><span class="line">    <span class="comment">// 如果碰到小数点，检查B部分</span></span><br><span class="line">    <span class="keyword">if</span>(*str == <span class="string">&#x27;.&#x27;</span>) &#123;</span><br><span class="line">        str++;</span><br><span class="line">        b_is_numeric = scan_unsigned_inter(&amp;str);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">bool</span> c_is_numeric = <span class="literal">true</span>;</span><br><span class="line">    <span class="comment">// 如果碰到e或E，检查C部分</span></span><br><span class="line">    <span class="keyword">if</span>(*str == <span class="string">&#x27;e&#x27;</span> || *str == <span class="string">&#x27;E&#x27;</span>) &#123;</span><br><span class="line">        str++;</span><br><span class="line">        c_is_numeric = scan_integer(&amp;str);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">bool</span> all_scan = (*str == <span class="string">&#x27;\0&#x27;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// (A || B) &amp;&amp; C &amp;&amp; End</span></span><br><span class="line">    <span class="keyword">return</span> (a_is_numeric || b_is_numeric) &amp;&amp; c_is_numeric &amp;&amp; all_scan;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print_is_numberic</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* str)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s %s\n&quot;</span>, str, is_numberic(str)?<span class="string">&quot;yes&quot;</span>:<span class="string">&quot;no&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    print_is_numberic(<span class="string">&quot;+100&quot;</span>); <span class="comment">// +100 yes</span></span><br><span class="line">    print_is_numberic(<span class="string">&quot;5e2&quot;</span>); <span class="comment">// 5e2 yes</span></span><br><span class="line">    print_is_numberic(<span class="string">&quot;-123&quot;</span>); <span class="comment">// -123 yes</span></span><br><span class="line">    print_is_numberic(<span class="string">&quot;3.1416&quot;</span>); <span class="comment">// 3.1416 yes</span></span><br><span class="line">    print_is_numberic(<span class="string">&quot;-1E-16&quot;</span>); <span class="comment">// -1E-16 yes</span></span><br><span class="line">    print_is_numberic(<span class="string">&quot;12e&quot;</span>); <span class="comment">// 12e no</span></span><br><span class="line">    print_is_numberic(<span class="string">&quot;1a3.14&quot;</span>); <span class="comment">// 1a3.14 no</span></span><br><span class="line">    print_is_numberic(<span class="string">&quot;1.2.3&quot;</span>); <span class="comment">// 1.2.3 no</span></span><br><span class="line">    print_is_numberic(<span class="string">&quot;+-5&quot;</span>); <span class="comment">// +-5 no</span></span><br><span class="line">    print_is_numberic(<span class="string">&quot;12e+5.4&quot;</span>); <span class="comment">// 12e+5.4 no</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码中需要注意的一个点是，书上原代码中是把各部分判断拆开计算逻辑合并的，但是我为了更加直观地写出其中逻辑思路，将各部分的判断都留到了最后，最后我们如果稍微一疏忽，容易就写成<code>A || B &amp;&amp; C &amp;&amp; End</code>，在C++中，<strong>逻辑运算符的结合反向是从左到右的</strong>，所以有可能你会把这种写法理解成<code>(A || B) &amp;&amp; C &amp;&amp; End</code>，<strong>但是</strong>，<strong>逻辑运算符之间的优先级顺序是</strong>，<code>! &gt; &amp;&amp; &gt; ||</code>，这会导致计算结果等价于<code>A || (B &amp;&amp; C &amp;&amp; End)</code>，即只要<code>A==true</code>就会判定为数字，这当然不正确的，所以要得到正确的结果，应该显式的写为<code>(A || B) &amp;&amp; C &amp;&amp; End</code>，避免计算错误。</p><hr><blockquote><p>面试题21：调整数组顺序使奇数位于偶数前面</p></blockquote><p>输入一个整数数组，实现一个函数来调整该数组中数字的顺序，使得<strong>所有奇数位于数组的前半部分</strong>，<strong>所有偶数位于数组的后半部分</strong>。</p><p>针对这道题的最优解法，在数组头尾设置两个指针，依次开始向中间扫描，如果左指针遇到偶数则停下，右指针遇到奇数则停下，然后交换两个指针指向的内容，直到两个指针相遇，算法停止，最后结果满足题目要求。</p><p>完整实现代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">reorder_odd_even</span><span class="params">(<span class="keyword">int</span>* <span class="built_in">array</span>, <span class="keyword">unsigned</span> <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">array</span> == <span class="literal">nullptr</span> || len == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span>* pleft = <span class="built_in">array</span>;</span><br><span class="line">    <span class="keyword">int</span>* pright = <span class="built_in">array</span> + len - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(pleft &lt; pright) &#123;</span><br><span class="line">        <span class="comment">// 左指针遇到偶数停</span></span><br><span class="line">        <span class="keyword">while</span>(pleft &lt; pright &amp;&amp; (*pleft &amp; <span class="number">0x1</span>) != <span class="number">0</span>) &#123;</span><br><span class="line">            pleft++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 右指针遇到奇数停</span></span><br><span class="line">        <span class="keyword">while</span>(pleft &lt; pright &amp;&amp; (*pright &amp; <span class="number">0x1</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">            pright--;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> temp = *pleft;</span><br><span class="line">        *pleft = *pright;</span><br><span class="line">        *pright = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> <span class="built_in">array</span>[<span class="number">10</span>] = &#123;<span class="number">0</span>, <span class="number">2</span>, <span class="number">9</span>, <span class="number">1</span>, <span class="number">6</span>, <span class="number">5</span>, <span class="number">8</span>, <span class="number">7</span>, <span class="number">3</span>, <span class="number">4</span>&#125;;</span><br><span class="line">    reorder_odd_even(<span class="built_in">array</span>, <span class="number">10</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, <span class="built_in">array</span>[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 3 7 9 1 5 6 8 2 0 4</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可扩展的解法，不固定其中的判别逻辑，可以将<strong>任意两类定义的数据</strong>进行这样的前后分离：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 这里用到的是一个函数指针，将一个函数传给另一个函数内部使用</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">reorder</span><span class="params">(<span class="keyword">int</span>* <span class="built_in">array</span>, <span class="keyword">unsigned</span> <span class="keyword">int</span> len, <span class="keyword">bool</span> (*func)(<span class="keyword">int</span>))</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">array</span> == <span class="literal">nullptr</span> || len == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span>* pleft = <span class="built_in">array</span>;</span><br><span class="line">    <span class="keyword">int</span>* pright = <span class="built_in">array</span> + len - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(pleft &lt; pright) &#123;</span><br><span class="line">        <span class="comment">// 左指针遇到偶数停</span></span><br><span class="line">        <span class="keyword">while</span>(pleft &lt; pright &amp;&amp; !func(*pleft)) &#123;</span><br><span class="line">            pleft++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 右指针遇到奇数停</span></span><br><span class="line">        <span class="keyword">while</span>(pleft &lt; pright &amp;&amp; func(*pright)) &#123;</span><br><span class="line">            pright--;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> temp = *pleft;</span><br><span class="line">        *pleft = *pright;</span><br><span class="line">        *pright = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">is_even</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (n &amp; <span class="number">0x1</span>) == <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">is_odd</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (n &amp; <span class="number">0x1</span>) != <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> <span class="built_in">array</span>[<span class="number">10</span>] = &#123;<span class="number">0</span>, <span class="number">2</span>, <span class="number">9</span>, <span class="number">1</span>, <span class="number">6</span>, <span class="number">5</span>, <span class="number">8</span>, <span class="number">7</span>, <span class="number">3</span>, <span class="number">4</span>&#125;;</span><br><span class="line">    reorder(<span class="built_in">array</span>, <span class="number">10</span>, is_even);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, <span class="built_in">array</span>[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 3 7 9 1 5 6 8 2 0 4</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    reorder(<span class="built_in">array</span>, <span class="number">10</span>, is_odd);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, <span class="built_in">array</span>[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 4 0 2 8 6 5 1 9 7 3</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="4-代码的鲁棒性"><a href="#4-代码的鲁棒性" class="headerlink" title="4 代码的鲁棒性"></a>4 代码的鲁棒性</h2><p>请到《第3章笔记 高质量代码 P2》阅读这部分内容。</p>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;除了程序代码的正确性，经常我们还要关注它的鲁棒性。&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="剑指Offer" scheme="https://yumi-cn.github.io/categories/%E5%89%91%E6%8C%87Offer/"/>
    
    
    <category term="笔记" scheme="https://yumi-cn.github.io/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>1月的计划</title>
    <link href="https://yumi-cn.github.io/2020/12/23/plan-2021-01/"/>
    <id>https://yumi-cn.github.io/2020/12/23/plan-2021-01/</id>
    <published>2020-12-23T10:10:23.000Z</published>
    <updated>2020-12-26T02:44:55.040Z</updated>
    
    <content type="html"><![CDATA[<p>距离2021的春招实习只有2个半月了，要开始争分夺秒了（唉，好想给女儿做二创啊）。</p><p>感觉前两个月因为各种各样的情况，看书写笔记的效率还是有点低（投入的时间确实也不够多），还有同时要看几本难啃的书确实不容易，之后要分清一下多个任务的主次了。</p><a id="more"></a><p>12月剩下时间的规划：</p><ul><li><strong>《剑指Offer》</strong>第3、4章，暂时不再写完整的博客了，只贴部分题目的完整实现代码；</li><li><strong>《3D游戏与计算机图形学中的数学方法》</strong>第4、5、6章，暂时不再写完整博客，会先简单写一些重要知识点摘录（自己打公式太费时间了）；</li><li><strong>《Real Time Rendering 4th》</strong>第2、3、4章，不再写完整博客，翻译还是有点费时费力，先看一遍过一下好了，主要作为3D数学方法那本书的知识补充。</li></ul><p>1月的规划：</p><ul><li><strong>《剑指Offer》</strong>第5、6章，不写完整博客，只贴部分题目的完整实现代码；</li><li><strong>《3D游戏与计算机图形学中的数学方法》</strong>第6-9章，暂时不再写完整博客，会先简单写一些重要知识点摘录；</li><li><strong>《Real Time Rendering 4th》</strong>第5-11章，只读，不写博客；</li><li><strong>《Effective C++》</strong>的55个条款，尽量都写写代码尝试实践，每一个其实都涉及到不少原本C++中的知识点，应该都要同步学习或者复习一下。</li></ul><p>其实就算是真的完成了这么多阅读的任务，还是有很多<strong>知识盲区</strong>，比如Unity3D、UE4、OpenGL、DirectX、RTX系列技术这种。</p><p>2月的初步规划（除掉过年，可能只有大半月的时间）：</p><ul><li><strong>面试笔试题</strong>，稍微刷一点面试常见的算法题(尤其是mid和hard难度的)，数量控制在100题以内吧，找到用C++解题的手感；</li><li><strong>引擎面试题</strong>，只能去收集各大厂引擎、渲染方面的面经贴，然后总结各种各样的点，有必要的话拓展去了解；</li><li><strong>OpenGL</strong>，估计至少要走一遍指南吧，代码都敲一敲；</li><li><strong>Unity3D入门和《Unity Shader 入门精要》</strong>，主要是了解Unity方面的相关知识；</li><li><strong>各大厂的简历投递</strong>，别忘了投简历了，注意提前收集他们的时间。</li></ul><p>3月的初步规划（基本上到了冲刺阶段了，剩下半个月时间）：</p><ul><li><strong>面试笔试题</strong>，每日做题的任务照常安排着走；</li><li><strong>引擎面试题</strong>，继续看收集的那些面试问题，顺带复习一下以前的笔记；</li><li><strong>《游戏引擎架构》</strong>，半个月简单刷一下这本书的大致内容，做到都有一定了解即可，当作知识广度阅读资料。</li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;距离2021的春招实习只有2个半月了，要开始争分夺秒了（唉，好想给女儿做二创啊）。&lt;/p&gt;
&lt;p&gt;感觉前两个月因为各种各样的情况，看书写笔记的效率还是有点低（投入的时间确实也不够多），还有同时要看几本难啃的书确实不容易，之后要分清一下多个任务的主次了。&lt;/p&gt;</summary>
    
    
    
    <category term="计划-Flags" scheme="https://yumi-cn.github.io/categories/%E8%AE%A1%E5%88%92-Flags/"/>
    
    
  </entry>
  
  <entry>
    <title>《剑指Offer》第2章笔记 算法和数据操作</title>
    <link href="https://yumi-cn.github.io/2020/12/20/s2o-c2-algorithm/"/>
    <id>https://yumi-cn.github.io/2020/12/20/s2o-c2-algorithm/</id>
    <published>2020-12-20T05:57:08.000Z</published>
    <updated>2020-12-20T05:57:53.072Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>考算法的面试题也备受面试官青睐（老折磨人了）。</p></blockquote><a id="more"></a><p>通常<strong>排序和查找</strong>是面试时考查算法的重点，准备的时候要重点掌握二分查找、归并排序和快速排序，要做到随时正确、完整地写出它们地代码。</p><p>二维数组上搜索路径的一些题目可以尝试用回溯法，通常回溯法适合用递归代码实现，如果面试官不允许递归实现，再尝试用栈来模拟递归过程。</p><p>如果是求解某个问题的最优解，并且问题可以分为子问题解决，就可以尝试用动态规划，如果在分解子问题中，满足一些特定条件就可以找到最优解，可以考虑用贪婪最优法。</p><hr><h2 id="1-递归和循环"><a href="#1-递归和循环" class="headerlink" title="1 递归和循环"></a>1 递归和循环</h2><ul><li>递归的代码通常比循环更加简洁，但代价是效率不够高，并且还有递归栈层数限制；</li><li>在一些题目中简单的递归会增加不必要的重复计算；</li><li>应用动态规划解决问题时，大部分都是递归方法分析问题，有些问题会出现子问题重复计算，到时候会讨论如何用循环替换递归实现；</li></ul><blockquote><p>面试题10：斐波那契数列</p></blockquote><p>题目一：求斐波那契数列的第n项，<code>f(0) = 0, f(1) = 1, f(n) = f(n-1) + f(n-2)</code>。</p><p>最简单的递归法就不在说明了，这里直接写一下不用重复计算的思路，当需要求解第n项时，需要求解前n-1项，通过观察可以发现从第2项开始计算，可以避免重复计算的问题。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> max_n = <span class="number">1000</span>;</span><br><span class="line"><span class="comment">// 如果不需要缓存，使用两个变量求解即可</span></span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> store[max_n];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">fibonacci</span><span class="params">(<span class="keyword">unsigned</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n &gt;= max_n) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>; <span class="comment">// Throw Error</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (store[n] != <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> store[n];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            store[i] = store[i<span class="number">-1</span>] + store[i<span class="number">-2</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> store[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::fill(&amp;store[<span class="number">0</span>], &amp;store[max_n], <span class="number">-1</span>);</span><br><span class="line">    store[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    store[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; fibonacci(<span class="number">50</span>) &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>书上还有一个<code>O(logn)</code>的算法，要使用到一个数学公式：</p><div>$$\left[\begin{matrix}f(n) & f(n-1) \\f(n-1) & f(n-2)\end{matrix}\right]=\left[\begin{matrix}1 & 1 \\1 & 0\end{matrix}\right]^{n-1}$$</div><p>公式可以用数学归纳法证明，问题就转换为如何求矩阵乘方，如果只是简单地从0开始循环，n次方需要n次元素，时间复杂度仍然是<code>O(n)</code>，并不比前面的方法快，但是其中的乘方有如下性质：</p><div>$$a^{n}=\left\{\begin{array}{rcl}a^{n/2} \cdot a^{n/2}, & & n\ is\ even \\a^{(n-1)/2} \cdot a^{(n-1)/2} \cdot a, & & n\ is\ odd\end{array}\right.$$</div><p>从公式可以看出，如果想求得n次方，就要先求得n/2次方，再把n/2次方的结果平方一下即可，时间复杂度为<code>O(logn)</code>。</p><p>不过算法仅做了解，很少会这么去写，实现起来也比较复杂。</p><p>还有不少面试题可以看成是斐波那契数列的应用：</p><p>题目二：青蛙跳台阶问题。</p><p>一只青蛙一次可以跳上1级台阶，也可以跳上2级台阶，求该青蛙跳上一个n级的台阶总共有多少种跳法。</p><p>将问题看作是求解函数f(n)，当青蛙第1次跳1级，则下一次求解f(n-1)，如果青蛙第1次跳2级，则下一次求解f(n-2)，所以其实本质还是斐波那契数列<code>f(n)=f(n-1)+f(n-2)</code>。</p><hr><h2 id="2-查询和排序"><a href="#2-查询和排序" class="headerlink" title="2 查询和排序"></a>2 查询和排序</h2><p>查询相对于排序较为简单，不外乎顺序查找、二分查找、哈希表查找和二叉排序树查找。<br>在面试的时候，不管是用循环还是递归，面试官都期待应聘者能够信手拈来写出<strong>完整正确地二分查找代码</strong>，否则可能连继续面试的兴趣都没有。</p><p>排序比查找要复杂一点，面试官会经常要求应聘者比较 插入排序、冒泡排序、归并排序、快速排序等不同算法的优劣。</p><p>实现快速排序算法的关键在于先在数组中选择一个数字，接下来把数组中的数字分为两部分，比选择的数字小的数字移到数组左边，比选择的数字大的数字移到数组的右边（递增排序）。</p><p>（然后就是一段基本上在哪本书上都能看到的快速排序代码）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">partition</span><span class="params">(<span class="keyword">int</span> data[], <span class="keyword">int</span> len, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(data == <span class="literal">nullptr</span> || len &lt;=<span class="number">0</span> || start &lt; <span class="number">0</span> || end &gt;= len) &#123;</span><br><span class="line">        <span class="function"><span class="built_in">std</span>::logic_error <span class="title">ex</span><span class="params">(<span class="string">&quot;Invalid Parameters&quot;</span>)</span></span>;</span><br><span class="line">        <span class="keyword">throw</span> <span class="built_in">std</span>::exception(ex);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> index = random_in_range(start, end);</span><br><span class="line">    swap(&amp;data[index], &amp;data[end]); <span class="comment">// end位置存储比较元素</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> small = start - <span class="number">1</span>; <span class="comment">// small用来指向存放小于比较元素的位置</span></span><br><span class="line">    <span class="keyword">for</span>(index = start; index &lt; end; index++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(data[index] &lt; data[end]) &#123;</span><br><span class="line">            <span class="comment">// 比比较元素小的就交换到small的地方</span></span><br><span class="line">            small++;</span><br><span class="line">            <span class="keyword">if</span>(small != index) &#123;</span><br><span class="line">                <span class="comment">// 如果位置相同就没必要再交换了</span></span><br><span class="line">                swap(&amp;data[index], &amp;data[small]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    small++;</span><br><span class="line">    swap(&amp;data[small], &amp;data[end]); <span class="comment">// 比较元素也放回对应位置</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> small; <span class="comment">// 返回比较元素的位置，划分左右两个子数组</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面是<code>partition</code>部分的代码，快速排序的其中一步，选择锚元素(比较元素)，将数组start-end区域的元素划分为两部分，一部分小于锚元素，另一部分大于锚元素。</p><p>完整的运行代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ctime&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;exception&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">random_in_range</span><span class="params">(<span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">    srand((<span class="keyword">unsigned</span>)time(<span class="literal">NULL</span>));</span><br><span class="line">    <span class="keyword">return</span> rand() % (end - start + <span class="number">1</span>) + start;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>* lhs, <span class="keyword">int</span>* rhs)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> temp = *lhs;</span><br><span class="line">    *lhs = *rhs;</span><br><span class="line">    *rhs = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">partition</span><span class="params">(<span class="keyword">int</span> data[], <span class="keyword">int</span> len, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(data == <span class="literal">nullptr</span> || len &lt;=<span class="number">0</span> || start &lt; <span class="number">0</span> || end &gt;= len) &#123;</span><br><span class="line">        <span class="function"><span class="built_in">std</span>::logic_error <span class="title">ex</span><span class="params">(<span class="string">&quot;Invalid Parameters&quot;</span>)</span></span>;</span><br><span class="line">        <span class="keyword">throw</span> <span class="built_in">std</span>::exception(ex);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> index = random_in_range(start, end);</span><br><span class="line">    swap(&amp;data[index], &amp;data[end]); <span class="comment">// end位置存储比较元素</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> small = start - <span class="number">1</span>; <span class="comment">// small用来指向存放小于比较元素的位置</span></span><br><span class="line">    <span class="keyword">for</span>(index = start; index &lt; end; index++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(data[index] &lt; data[end]) &#123;</span><br><span class="line">            <span class="comment">// 比比较元素小的就交换到small的地方</span></span><br><span class="line">            small++;</span><br><span class="line">            <span class="keyword">if</span>(small != index) &#123;</span><br><span class="line">                <span class="comment">// 如果位置相同就没必要再交换了</span></span><br><span class="line">                swap(&amp;data[index], &amp;data[small]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    small++;</span><br><span class="line">    swap(&amp;data[small], &amp;data[end]); <span class="comment">// 比较元素也放回对应位置</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> small; <span class="comment">// 返回比较元素的位置，划分左右两个子数组</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">quick_sort</span><span class="params">(<span class="keyword">int</span> data[], <span class="keyword">int</span> len, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(start == end) &#123;</span><br><span class="line">        <span class="keyword">return</span>; <span class="comment">// 单个元素，不用排序</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> index = partition(data, len, start, end);</span><br><span class="line">    <span class="keyword">if</span>(index &gt; start) &#123;</span><br><span class="line">        quick_sort(data, len, start, index<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(index &lt; end) &#123;</span><br><span class="line">        quick_sort(data, len, start+<span class="number">1</span>, end);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> data[] = &#123;<span class="number">9</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">7</span>, <span class="number">5</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">6</span>&#125;;</span><br><span class="line">    quick_sort(data, <span class="number">10</span>, <span class="number">0</span>, <span class="number">9</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, data[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>partition</code>函数除了可以用在快速排序中，还可以用来实现在长度n数组中查找第k大的数字，面试题39“数组中出现次数超过一半的数字”和面试题40“最小的k个数”都可以用这个函数来解决。</p><p>不同排序的适用场合也不尽相同，快速排序虽然总体的平均效率最好，但不是任何时候都是最优的算法（只是在平均效率上满足O(nlogn)，可以找出一些最坏的情况），所以在面试的时候，如果面试官要求实现一个排序算法，可以先问清楚这个排序<strong>应用的环境是什么</strong>、<strong>有哪些约束条件</strong>等等，得到足够多的信息之后再选择合适的排序算法。</p><blockquote><p>面试题11：旋转数组的最小数字</p></blockquote><p>把一个数组最开始的若干的元素搬到数组的末尾，称之为数组的旋转，输入一个递增排序的数组的一个旋转，输出旋转数组的最小元素。例如{3, 4, 5, 1, 2}是{1, 2, 3, 4, 5}的一个旋转，数组的最小值是1。</p><ul><li>思路1：简单遍历数组求最小值（无论正序还是逆序），时间开销都是O(n)，大概率不是一个最优解；</li><li>思路2：递增排序的一个区间满足性质, <strong>首元素一定小于尾元素</strong>，如果考虑到元素可以重复，即如果<strong>首元素大于等于尾元素</strong>，则该区间可能并不是<strong>非递减的</strong>。</li><li>思路3：思路2通过二分区间判断实现起来还是有一点复杂，还可以进一步地简化思路，每一次判断<code>mid</code>和<code>start</code>、<code>end</code>位置上元素大小关系，如果<code>mid&gt;=start</code>，证明<code>mid</code>位于前面的递增区间，下一步在<code>mid-end</code>中找最小元素；如果<code>mid&lt;=end</code>，证明<code>mid</code>位于后面的递增区间，下一步在<code>start-mid</code>中找最小元素。</li></ul><p>按照思路3，<code>start</code>总是指向前面递增数组的元素、<code>end</code>总是指向后面递增数组的元素，当<code>start</code>和<code>end</code>中间没有其他元素时，<code>end</code>就指向后面递增元素的第一个，也就是最小的数字，这也是循环结束的条件。</p><div align="center"><p><img src="/images/s2o-c2-ag-cv-11.1.jpg" alt="在数组{3,4,5,1,2}中查找最小值的过程"></p></div><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">min</span><span class="params">(<span class="keyword">int</span>* numbers, <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(numbers == <span class="literal">nullptr</span> || len &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="function"><span class="built_in">std</span>::logic_error <span class="title">ex</span><span class="params">(<span class="string">&quot;Invalid parameters&quot;</span>)</span></span>;</span><br><span class="line">        <span class="keyword">throw</span> <span class="built_in">std</span>::exception(ex);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> index1 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> index2 = len - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> index_mid = index1;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(numbers[index1] &gt;= numbers[index2]) &#123;</span><br><span class="line">        <span class="keyword">if</span>(index2 - index1 == <span class="number">1</span>) &#123;</span><br><span class="line">            index_mid = index2;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        index_mid = (index1 + index2) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(numbers[index_mid] &gt;= numbers[index1]) &#123;</span><br><span class="line">            <span class="comment">// mid在前面的递增数组中，min在后面</span></span><br><span class="line">            index1 = index_mid;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(numbers[index_mid] &lt;= numbers[index2]) &#123;</span><br><span class="line">            <span class="comment">// mid在后面的递增数组中，min在前面</span></span><br><span class="line">            index2 = index_mid;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> numbers[index_mid];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但上面的方法还有一些特殊情况没有考虑到：</p><ul><li>如果只搬动了0个元素到后面，即排序数组本身，上面的方法就不再适用了，但因为此时数组中一个数字就是最小的数字，可以直接返回；</li><li>如果<code>index1</code>和<code>index2</code>指向的元素相等，甚至他们都和<code>index_mid</code>指向的元素想等时，应该如何处理呢？这个时候无法简单地判断出<code>min</code>在前面还是后面（参考下面图），所以只能采取简单的遍历法（如果是递归函数实现的话可以都向下计算然后比对最小值）。</li></ul><div align="center"><p><img src="/images/s2o-c2-ag-cv-11.2.jpg" alt="数组{0,1,1,1,1}的两个旋转数组"></p></div><p>完整代码实现：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;exception&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">min_in_order</span><span class="params">(<span class="keyword">int</span>* numbers, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> min = numbers[start];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = start + <span class="number">1</span>; i &lt;= end; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(min &gt; numbers[i]) &#123;</span><br><span class="line">            min = numbers[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> min;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">min</span><span class="params">(<span class="keyword">int</span>* numbers, <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(numbers == <span class="literal">nullptr</span> || len &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="function"><span class="built_in">std</span>::logic_error <span class="title">ex</span><span class="params">(<span class="string">&quot;Invalid parameters&quot;</span>)</span></span>;</span><br><span class="line">        <span class="keyword">throw</span> <span class="built_in">std</span>::exception(ex);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> index1 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> index2 = len - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> index_mid = index1;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(numbers[index1] &gt;= numbers[index2]) &#123;</span><br><span class="line">        <span class="keyword">if</span>(index2 - index1 == <span class="number">1</span>) &#123;</span><br><span class="line">            index_mid = index2;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        index_mid = (index1 + index2) / <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(numbers[index1] == numbers[index2]</span><br><span class="line">            &amp;&amp; numbers[index_mid] == numbers[index1]) &#123;</span><br><span class="line">            <span class="comment">// index1 mid index2 均相等，顺序查找</span></span><br><span class="line">                <span class="keyword">return</span> min_in_order(numbers, index1, index2);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(numbers[index_mid] &gt;= numbers[index1]) &#123;</span><br><span class="line">            <span class="comment">// mid在前面的递增数组中，min在后面</span></span><br><span class="line">            index1 = index_mid;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(numbers[index_mid] &lt;= numbers[index2]) &#123;</span><br><span class="line">            <span class="comment">// mid在后面的递增数组中，min在前面</span></span><br><span class="line">            index2 = index_mid;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> numbers[index_mid];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> numbers[] = &#123;<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">1</span>, <span class="number">2</span>&#125;;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, min(numbers, <span class="number">5</span>)); <span class="comment">// 1</span></span><br><span class="line">    <span class="keyword">int</span> onumbers[] = &#123;<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>&#125;;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, min(onumbers, <span class="number">5</span>)); <span class="comment">// 0</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="3-回溯法"><a href="#3-回溯法" class="headerlink" title="3 回溯法"></a>3 回溯法</h2><p>回溯法可以看成蛮力法的升级，它从解决问题的每一步可能选项理选出一个可行的解决方法。<br>回溯法非常适合由多个步骤组成的问题，并且每个步骤都有多个选项。</p><p>用回溯法解决的问题的所有选项可以形象地用树状结构表示。在某一步有<code>n</code>个可能的选项，该步骤可以看成是树状结构中的一个节点，每个选项看成树中节点连接线。树的叶节点对应对应着终结状态，如果在叶节点的状态满足题目的约束条件，则找到了一个可行的解决方案。</p><p>如果叶节点的状态不满足约束，则只好回溯到它的上一个节点再尝试其他的选项，如果上一个节点所有可能的选项都已经试过，找下一种可能选项时，需要再次回溯到上一个节点（依次类推）。如果所有节点的所有选项都已经尝试过仍然不能达到满足约束条件的终结状态，则该问题无解。</p><p>以面试题12来说明回溯法的应用方法。</p><blockquote><p>面试题12：矩阵中的路径</p></blockquote><p>设计一个函数，用来判断一个矩阵中是否存在一条包含某字符串所有字符的路径。路径可以从矩阵中的任意一格开始，每一步可以在矩阵中向左、右、上、下移动一格。如果一条路径经过了矩阵的某一格，那么该路径不能再次进入该格子。</p><div align="center"><p><img src="/images/s2o-c2-ag-cv-12.1.jpg" alt="一个字符矩阵的例子"></p></div><p>用回溯法解决的典型题，首先在矩阵中任选一个格子作为路径的起点，然后尝试匹配字符串，如果位置字符匹配，则在临近格子中寻找下一步格子，重复上述过程，直到路径上所有字符都在矩阵中找到相应的位置。</p><p>由于回溯法的递归特性，路径可以被看成一个栈，当在矩阵中定位了路径中前n个字符位置之后，在与第n个字符对应的格子的周围都没有找到第n+1字符，这时候只好在路径上回到第n-1字符，重新定位第n个字符。</p><p>由于路径不能重复进入矩阵的格子，所以要定义和字符矩阵大小一样的布尔值矩阵，用来标识路径已经进入了哪些格子。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt; // include memset()</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">has_path_core</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* matrix, <span class="keyword">int</span> rows, <span class="keyword">int</span> cols, <span class="keyword">int</span> row,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">int</span> col, <span class="keyword">const</span> <span class="keyword">char</span>* str, <span class="keyword">int</span>&amp; path_len, <span class="keyword">bool</span>* visited)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(str[path_len] == <span class="string">&#x27;\0&#x27;</span>) &#123;</span><br><span class="line">        <span class="comment">// 前面的字符都找到相应位置了</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">bool</span> has_path = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span>(row &gt;= <span class="number">0</span> &amp;&amp; row &lt; rows &amp;&amp; col &gt;= <span class="number">0</span> &amp;&amp; col &lt; cols</span><br><span class="line">        &amp;&amp; matrix[row * cols + col] == str[path_len]</span><br><span class="line">        &amp;&amp; !visited[row * cols + col]) &#123;</span><br><span class="line">        path_len++;</span><br><span class="line">        visited[row*col + col] = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">        has_path = has_path_core(matrix, rows, cols, row, col<span class="number">-1</span>, str, path_len, visited)</span><br><span class="line">                || has_path_core(matrix, rows, cols, row<span class="number">-1</span>, col, str, path_len, visited)</span><br><span class="line">                || has_path_core(matrix, rows, cols, row, col+<span class="number">1</span>, str, path_len, visited)</span><br><span class="line">                || has_path_core(matrix, rows, cols, row+<span class="number">1</span>, col, str, path_len, visited);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(!has_path) &#123;</span><br><span class="line">            path_len--;</span><br><span class="line">            visited[row * cols + col] = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> has_path;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">has_path</span><span class="params">(<span class="keyword">char</span>* matrix, <span class="keyword">int</span> rows, <span class="keyword">int</span> cols, <span class="keyword">char</span>* str)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(matrix == <span class="literal">nullptr</span> || rows &lt; <span class="number">1</span> || cols &lt; <span class="number">1</span> || str == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">bool</span>* visited = <span class="keyword">new</span> <span class="keyword">bool</span>[rows * cols];</span><br><span class="line">    <span class="built_in">memset</span>(visited, <span class="number">0</span>, rows * cols);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> path_len = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> row = <span class="number">0</span>; row &lt; rows; row++) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> col = <span class="number">0</span>; col &lt; cols; col++) &#123;</span><br><span class="line">            <span class="comment">// 从点(row, col)出发去寻找path</span></span><br><span class="line">            <span class="keyword">if</span>(has_path_core(matrix, rows, cols, row, col, str, path_len, visited)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">delete</span>[] visited;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> matrix[<span class="number">12</span>] = &#123; <span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;t&#x27;</span>,<span class="string">&#x27;g&#x27;</span>, <span class="string">&#x27;c&#x27;</span>,<span class="string">&#x27;f&#x27;</span>,<span class="string">&#x27;c&#x27;</span>,<span class="string">&#x27;s&#x27;</span>, <span class="string">&#x27;j&#x27;</span>,<span class="string">&#x27;d&#x27;</span>,<span class="string">&#x27;e&#x27;</span>,<span class="string">&#x27;h&#x27;</span> &#125;;</span><br><span class="line">    <span class="keyword">char</span> str1[<span class="number">10</span>] = <span class="string">&quot;bfce&quot;</span>;</span><br><span class="line">    <span class="keyword">if</span>(has_path(matrix, <span class="number">3</span>, <span class="number">4</span>, str1)) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; str1 &lt;&lt; <span class="string">&quot; in matrxi.&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; str1 &lt;&lt; <span class="string">&quot; not in matrxi.&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// bfce in matrxi.</span></span><br><span class="line">    <span class="keyword">char</span> str2[<span class="number">10</span>] = <span class="string">&quot;abfb&quot;</span>;</span><br><span class="line">    <span class="keyword">if</span>(has_path(matrix, <span class="number">3</span>, <span class="number">4</span>, str2)) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; str2 &lt;&lt; <span class="string">&quot; in matrxi.&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; str2 &lt;&lt; <span class="string">&quot; not in matrxi.&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// abfb not in matrxi.</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>面试题13：机器人的运动范围</p></blockquote><p>地上有一个<code>m</code>行<code>n</code>列的方格。一个机器人从<code>(0,0)</code>的格子开始移动，它每次可以向左、右、上、下移动一格，但不能进入<strong>行坐标和列坐标的数位之和</strong>大于<code>k</code>的格子。例如，当<code>k</code>为<code>18</code>时，机器人能进入方法<code>(35, 37)</code>，因为<code>3+5+3+7=18</code>，但不能进入方格<code>(35, 38)</code>，因为<code>3+5+3+8=19</code>，请问该机器人能够到达多少格子？</p><p>机器人从<code>(0,0)</code>开始移动，准备进入<code>(i,j)</code>时，要检查坐标的数位来判断是否能够进入，如果能进入，再判断是否能进入4个相邻的格子（不包含已走格子）。</p><p>完整代码实现：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">get_digit_sum</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(num &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        sum += num % <span class="number">10</span>;</span><br><span class="line">        num /= <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span> threshold, <span class="keyword">int</span> rows, <span class="keyword">int</span> cols, <span class="keyword">int</span> row, <span class="keyword">int</span> col, <span class="keyword">bool</span>* visited)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(row &gt;= <span class="number">0</span> &amp;&amp; row &lt; rows &amp;&amp; col &gt;= <span class="number">0</span> &amp;&amp; col &lt; cols</span><br><span class="line">        &amp;&amp; get_digit_sum(row) + get_digit_sum(col) &lt;= threshold</span><br><span class="line">        &amp;&amp; !visited[row * cols + col]) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">moving_count_core</span><span class="params">(<span class="keyword">int</span> threshold, <span class="keyword">int</span> rows, <span class="keyword">int</span> cols, <span class="keyword">int</span> row, <span class="keyword">int</span> col, <span class="keyword">bool</span>* visited)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 检查当前是否可达</span></span><br><span class="line">    <span class="keyword">if</span>(check(threshold, rows, cols, row, col, visited)) &#123;</span><br><span class="line">        visited[row * cols + col] = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">        count = <span class="number">1</span></span><br><span class="line">            + moving_count_core(threshold, rows, cols, row - <span class="number">1</span>, col, visited)</span><br><span class="line">            + moving_count_core(threshold, rows, cols, row, col - <span class="number">1</span>, visited)</span><br><span class="line">            + moving_count_core(threshold, rows, cols, row + <span class="number">1</span>, col, visited)</span><br><span class="line">            + moving_count_core(threshold, rows, cols, row, col + <span class="number">1</span>, visited);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回计数</span></span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">moving_count</span><span class="params">(<span class="keyword">int</span> threshold, <span class="keyword">int</span> rows, <span class="keyword">int</span> cols)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(threshold &lt; <span class="number">0</span> || rows &lt;= <span class="number">0</span> || cols &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">bool</span> *visited = <span class="keyword">new</span> <span class="keyword">bool</span>[rows * cols];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; rows * cols; i++) &#123;</span><br><span class="line">        visited[i] = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从(0, 0)出发，计数count</span></span><br><span class="line">    <span class="keyword">int</span> count = moving_count_core(threshold, rows, cols, <span class="number">0</span>, <span class="number">0</span>, visited);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">delete</span>[] visited;</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; moving_count(<span class="number">-1</span>, <span class="number">1</span>, <span class="number">1</span>) &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 0</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; moving_count(<span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>) &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 1</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; moving_count(<span class="number">12</span>, <span class="number">40</span>, <span class="number">40</span>) &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 770</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; moving_count(<span class="number">18</span>, <span class="number">40</span>, <span class="number">40</span>) &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 1484</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="4-动态规划与贪婪算法"><a href="#4-动态规划与贪婪算法" class="headerlink" title="4 动态规划与贪婪算法"></a>4 动态规划与贪婪算法</h2><p>如果面试题是求一个问题的最优解(通常是<strong>求最大值或者最小值</strong>)，而且该问题能够被分解成若干个子问题，子问题之间还有重叠的更小子问题，就可以考虑用动态规划来解决这个问题。</p><p>在应用动态规划之前，要先分析<strong>是否能把大问题分解成小问题</strong>，分解后的<strong>每个小问题也存在最优解</strong>，如果把<strong>小问题的最优解组合起来能够得到整个问题的最优解</strong>，则可以应用动态规划来解决这个问题。</p><p>在一些题目情况中，相同子问题在分解大问题的过程中重复出现，为了避免重复求解相同子问题，可以用从下往上的顺序先计算小问题的最优解并存储下来，再以此为基础求取大问题的最优解。在应用动态规划解决问题的时候，我们总是从解决最小问题开始，并把已经解决的子问题的最优解存储下来（大部分题目一般用一维或者二维数组里），并把子问题的最优解组合起来逐步解决大的问题。</p><p>在应用动态规划时，每一步都面临若干个选择，在求解时只能把所有的可能尝试一遍，然后比较得出最优的选择。</p><p>贪婪算法和动态规划不一样，贪婪算法每一步都可以根据规则做出一个最优的选择，基于这个找到最优解，但贪婪算法需要证明每一步的选择是可以保证最后获得最优结果，有时候不要想当然的应用贪婪算法。</p><blockquote><p>面试题14：剪绳子</p></blockquote><p>给你一根长度为<code>n</code>的绳子，请把绳子剪成<code>m</code>段(<code>m</code>、<code>n</code>都是整数，<code>n&gt;1</code>并且<code>m&gt;1</code>)，每段绳子的长度记为<code>k[0],k[1],...,k[m]</code>，请问 <code>k[0] x k[1] x ... x k[m]</code>可能的最大乘积是多少？例如，当绳子的长度是8时，我们把它剪成长度分为2、3、3的三段，此时得到的最大乘积是18。</p><p>Tips：这道题里面的一个比较含糊不清的地方是对<code>m</code>的界定，有些题目中可能<code>m</code>也是一个输入量，指计算在这个<code>m</code>段限定条件下<code>n</code>长度绳子的最大结果值（基本上就是另一类题了），而在本书的这道题目中并没有将<code>m</code>看作一个单独的输入量，只是说明后续的计算流程用，在面试遇到这样的情况可以向面试官询问对<code>m</code>的作用界定。</p><ul><li>思路1：暴力遍历，第一步有<code>n-1</code>种剪法，第二步有<code>n-2</code>种剪法，…，剪到底的话需要剪<code>n</code>步（每一步可以剪多个绳子），所以可以简单估算时间复杂度<code>O(n^2)</code>；</li><li>思路2：动态规划；</li><li>思路3：尝试用贪婪算法来解决。</li></ul><p>先讲一下<strong>动态规划的解法</strong>。</p><p>首先定义函数<code>f(n)</code>为把长度为<code>n</code>的绳子剪成若干段后各段长度乘积的最大值。在剪第一刀时，有<code>n-1</code>中可能的选择，因此有<code>f(n)=max(f(i) x f(n-i))</code>，其中<code>0&lt;i&lt;n</code>。</p><p>这是一个从上至下的递归公式，递归会产生很多重复计算，所以一个更好的办法是按照从下而上的顺序计算，也就是说我们先得到<code>f(2)</code>、<code>f(3)</code>，再得到<code>f(4)</code>、<code>f(5)</code>，直到得到<code>f(n)</code>。比较容易得知<code>f(1)=0</code>、<code>f(2)=1</code>以及<code>f(3)=2</code>，之后就按照迭代公式计算，得到<code>f(n)</code>。</p><p>Tips：书上这个题目的解析里面，个人觉得有一点疏漏，<code>f(k-1)</code>的定义应该是在<strong>剪后的乘积最大</strong>和<strong>不剪的自身长度</strong>中的最大值，即<code>f(k-1)=max(&#123;f(i) x f(k-i), k=1,2,...,n-1&#125;), </code>，因为只有在计算<code>f(n)</code>的时候是必须要剪断的(因为<code>m&gt;1</code>)，而剩下的子段不是一定要剪断，所以<code>f(k-1), k=1,2,...,n-1</code>的计算方式不能完全照搬<code>f(n)</code>的公式，例如<code>f(1)</code>作为一个长度为<code>1</code>的子段，因为并不是一定要剪，所以其本身可以返回的最大长度是<code>1</code>，而不是<code>0</code>，否则对于一个长度为<code>n</code>的绳子，在剪为<code>1</code>长度和<code>n-1</code>长度的两个子段时，使用<code>f(1)=0</code>，就会导致计算的结果错误，因为在这个情况下是有最后的值的，而并不是<code>0*f(n-1)=0</code>，所以按照修正后的定义，当是子段的时候，<code>f(1)=1</code>，<code>f(2)=2</code>，<code>f(3)=3</code>，<code>f(4)=4</code>，<code>f(5)=6</code>，…，可以发现虽然在<code>k&gt;3</code>这部分定义修正没有意义，但对于<code>k&lt;=3</code>部分是有意义的。</p><p>完整实现代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">max_product_after_cutting_dyprog</span><span class="params">(<span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(len &lt; <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(len == <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(len == <span class="number">3</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 循环替代递归，减少重复子任务，动态规划法</span></span><br><span class="line">    <span class="keyword">int</span>* products = <span class="keyword">new</span> <span class="keyword">int</span>[len + <span class="number">1</span>];</span><br><span class="line">    products[<span class="number">0</span>] = <span class="number">0</span>; <span class="comment">// f(0)=0</span></span><br><span class="line">    products[<span class="number">1</span>] = <span class="number">1</span>; <span class="comment">// 修正定义的f(1)=1</span></span><br><span class="line">    products[<span class="number">2</span>] = <span class="number">2</span>; <span class="comment">// 修正定义的f(2)=2</span></span><br><span class="line">    products[<span class="number">3</span>] = <span class="number">3</span>; <span class="comment">// 修正定义的f(3)=3</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> max = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">4</span>; i &lt;= len; i++) &#123;</span><br><span class="line">        max = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= i/<span class="number">2</span>; j++) &#123;</span><br><span class="line">            <span class="keyword">int</span> product = products[j] * products[i - j];</span><br><span class="line">            <span class="keyword">if</span>(max &lt; product) &#123;</span><br><span class="line">                max = product;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// products[i] = max; // 书上该行的位置，个人觉得没必要</span></span><br><span class="line">        &#125;</span><br><span class="line">        products[i] = max; <span class="comment">// 个人意见的修正，虽然不影响结果</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    max = products[len];</span><br><span class="line">    <span class="keyword">delete</span>[] products;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> max;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 结果是36</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; max_product_after_cutting_dyprog(<span class="number">10</span>) &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Tips：上面的代码除了调整过一行的位置以外，基本上没有修改，可以看到代码中对<code>f(1)</code>、<code>f(2)</code>和<code>f(3)</code>的定义都是符合我之前说的修正后的定义，而不是作者说明的什么<code>f(1)=0</code>、<code>f(2)=1</code>以及<code>f(3)=2</code>，所以也侧面证明之前我对定义的修正是正确的。</p><p>接着看一下<strong>贪婪算法的解法</strong>。</p><p>如果按照如下的策略来剪绳子，则得到的各段绳子的长度乘积最大，当<code>n&gt;=5</code>时，尽可能多地剪长度为<code>3</code>的绳子；当剩下的绳子长度为<code>4</code>时，把绳子剪成两段长度为<code>2</code>的绳子。</p><p>完整实现代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">max_product_after_cutting_greedy</span><span class="params">(<span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(len &lt; <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(len == <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(len == <span class="number">3</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 尽可能剪为长度为3的绳子段</span></span><br><span class="line">    <span class="keyword">int</span> times_of_3 = len / <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 剩余长度为4时，不再减去3</span></span><br><span class="line">    <span class="keyword">if</span>(len - times_of_3 * <span class="number">3</span> == <span class="number">1</span>) &#123;</span><br><span class="line">        times_of_3 -= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 代表有多少个2段</span></span><br><span class="line">    <span class="keyword">int</span> times_of_2 = (len - times_of_3 * <span class="number">3</span>) / <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">int</span>)(<span class="built_in">pow</span>(<span class="number">3</span>, times_of_3) * <span class="built_in">pow</span>(<span class="number">2</span>, times_of_2));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 结果是36，和动态规划法相同</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; max_product_after_cutting_greedy(<span class="number">10</span>) &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>证明一些这种思路的正确性：</p><ul><li>首先，当<code>n&gt;=5</code>时，我们可以证明<code>2(n-2)&gt;n</code>并且<code>3(n-3)&gt;n</code>（剪出一长度2子段或剪出一长度<code>3</code>子段），也就是说，当绳子剩下的长度大于等于<code>5</code>时，就把它剪成<code>3</code>或者<code>2</code>的子段，另外，<code>n&gt;=5</code>时，<code>3(n-3)&gt;=2(n-2)</code>，因此我们应该尽可能地多剪长度为<code>3</code>的绳子段（<strong>其实书上的这部分证明还并不够严谨，可以自行去严谨地证明</strong>）。</li><li>那么当长度为4时，可以简单推出最大的情况就是<code>2*2</code>或者不剪的<code>4</code>。</li></ul><hr><h2 id="5-位运算"><a href="#5-位运算" class="headerlink" title="5 位运算"></a>5 位运算</h2><p>位运算是把<strong>数字用二进制表示</strong>之后，对每一位上<code>0</code>或者<code>1</code>的运算，二进制及其位运算是现代计算机学科的基石，很多底层的技术都离不开位运算（都是基石了咋离得开嘛），因为与位运算相关的题目也经常出现在面试中。</p><p>在微软产品Excel中，用A表示第1列，B表示第2列，…，Z表示第26列，AA表示第27列，AB表示第28列，…，以此类推，写出一个函数，输入用字母表示的列号，输出第几列，这就是一个典型的进制转换题目。</p><p>位运算总共只有5种运算：与 <code>&amp;</code>、或 <code>||</code>、异或 <code>^</code>、左移<code>&lt;&lt;</code>和右移<code>&gt;&gt;</code>。</p><p>与、或和异或运算规律可以用下表进行总结：</p><div align="center"><p><img src="/images/s2o-c2-ag-t-2.1.jpg"></p></div><p>左移运算法<code>m &lt;&lt; n</code>表示把<code>m</code>左移<code>n</code>位，在左移<code>n</code>位时，最左边的<code>n</code>位将被丢弃，同时在最右边补上<code>n</code>个<code>0</code>，比如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">00001010</span> &lt;&lt; <span class="number">2</span> = <span class="number">00101000</span></span><br><span class="line"><span class="number">10001010</span> &lt;&lt; <span class="number">3</span> = <span class="number">01010000</span></span><br></pre></td></tr></table></figure><p>右移运算符<code>m &gt;&gt; n</code>表示把<code>m</code>右移<code>n</code>位，在右移<code>n</code>位时，最右边的<code>n</code>位将被丢弃，但是在右移时处理最左边位的情形要稍微复杂一点：</p><ul><li>如果数字是一个无符号数值，则用0填补最左边的n位；</li><li>如果数字是一个有符号数值，则用数字的符号位填补最左边的n位；<ul><li>数字是正数，右移补0；</li><li>数字是负数，左移补1。</li></ul></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">00001010</span> &gt;&gt; <span class="number">2</span> = <span class="number">00000010</span></span><br><span class="line"><span class="number">10001010</span> &gt;&gt; <span class="number">3</span> = <span class="number">11110001</span></span><br></pre></td></tr></table></figure><p>面试题15“二进制中1的个数”就是直接考查位运算的例子，而面试56“数组中数字出现的次数”、面试题65“不用加减乘除做加法”等都是根据位运算的特点来解决问题。</p><blockquote><p>面试题15：二进制中1的个数</p></blockquote><p>实现一个函数，输入一个整数，输出该数二进制表示中1的个数，例如，把9表示成二进制是1001，有2个1，所以输出2。</p><ul><li><strong>可能会引起死循环</strong>的解法：判断整数二进制最右边是否为<code>1</code>，然后进行右移一位再进行判断，直到整个整数变为<code>0</code>为止，至于如何判断一个整数的最右边是不是<code>1</code>，只要把整数和<code>1</code>做位与(<code>&amp;</code>)运算看结果是不是<code>1</code>就只知道了，这个方法的问题在于对于负数的处理会导致死循环，如果是负数，则右移会在首位补<code>1</code>，数字永远不会变为<code>0</code>，最后变为<code>0xffffffff</code>导致死循环；</li><li><strong>常规解法</strong>：为了避免死循环，可以<strong>不右移</strong>输入的数字<code>n</code>，而转为<strong>左移</strong>用来校验的数字<code>1</code>，依次校验数字<code>n</code>的每一位是否为<code>1</code>；</li></ul><p>常规解法的代码实现：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">number_of_1</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> flag = <span class="number">1</span>; <span class="comment">// unsigned int 才能采集到符号位</span></span><br><span class="line">    <span class="comment">// 循环次数取决于操作系统中int的存储位数，一般是4字节，32位</span></span><br><span class="line">    <span class="keyword">while</span>(flag) &#123; <span class="comment">// 1从左边溢出后，flag会变成0</span></span><br><span class="line">        <span class="keyword">if</span>(num &amp; flag) &#123; <span class="comment">// 非0 即 该位有1</span></span><br><span class="line">            count++;</span><br><span class="line">        &#125;</span><br><span class="line">        flag = flag &lt;&lt; <span class="number">1</span>; <span class="comment">// 赋值更新</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; number_of_1(<span class="number">255</span>) &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 8</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; number_of_1(<span class="number">-1</span>) &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 32</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>令人惊喜的解法</strong>：先分析一下把一个数减去1的情况，如果一个整数不等于0，则二进制中<strong>至少有一位是1</strong>，假设这个数最右边为1，则减1导致最后一位为0，其余位保持不变；假设最后一位是0，如果最右边的1位于第m位，则减一时，第m位由1变0，m位之后的所有0都变成1，m之前的所有位保持不变。根据这两种情况，可以发现把一个整数减1，都是把最右边的1变成0，如果右边有0，则所有0变成1，如果把一个<strong>整数</strong>和<strong>它减去1的结果</strong>做<strong>位与运算</strong>，相当于把最右边的1变成0。以1100为例，减1结果是1011，1100和1011做位运算，结果是1000，即相比于1100把最右边的1变成0。所以最后的思路是，把一个整数减1，再和原整数做与运算，就把最右边1变为0，那么一个二进制中有多少1就可以进行多少次这样的操作。</li></ul><p>完整代码实现：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">number_of_1_sp</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(num) &#123;</span><br><span class="line">        count++;</span><br><span class="line">        num = (num - <span class="number">1</span>) &amp; num;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; number_of_1_sp(<span class="number">255</span>) &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 8</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; number_of_1_sp(<span class="number">-1</span>) &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 32</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;考算法的面试题也备受面试官青睐（老折磨人了）。&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="剑指Offer" scheme="https://yumi-cn.github.io/categories/%E5%89%91%E6%8C%87Offer/"/>
    
    
    <category term="笔记" scheme="https://yumi-cn.github.io/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>《3D图形的数学》第3章笔记 变换</title>
    <link href="https://yumi-cn.github.io/2020/12/12/3dmath-c3/"/>
    <id>https://yumi-cn.github.io/2020/12/12/3dmath-c3/</id>
    <published>2020-12-12T12:52:19.000Z</published>
    <updated>2020-12-12T15:18:18.379Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>3D游戏开发过程中，通常需要以某种方式对向量进行变换。</p></blockquote><a id="more"></a><p>通常用到的变换包括<strong>平移、缩放和旋转</strong>。</p><h2 id="1-通用变换"><a href="#1-通用变换" class="headerlink" title="1 通用变换"></a>1 通用变换</h2><p>通常把 \(n \times n\) 可逆矩阵M看成是一个从坐标系到另一个坐标系的变换矩阵。</p><p>M的列给出了坐标轴从原坐标系到新坐标系的映射；\(M^{-1}\)的列给出了坐标轴从新坐标系到原坐标系的映射。</p><p>PS：书上的上面两句话，可以尝试从M乘以一个坐标轴单位向量的结果角度来考量，也就理解M的列是如何对一个向量或者坐标的各个轴的处理的。</p><p>多个变换可以串联起来，也可以将多个变换矩阵的乘积用一个矩阵来表示，例如 \(G(MP)=(GM)P\)，其中G/M是变换矩阵，P是坐标或向量，先做M变换再做G变换的结果可以用一个(GM)矩阵来存储，这样可以对顶点做无数次的变换，不需要额外的存储空间和计算开销。</p><h3 id="1-1-正交矩阵"><a href="#1-1-正交矩阵" class="headerlink" title="1.1 正交矩阵"></a>1.1 正交矩阵</h3><p><strong>正交矩阵的转置等于其逆矩阵</strong>。</p><p><strong>【定义3.1】</strong> 一个n阶可逆方阵M，当且仅当 \(M^{-1}=M^{T}\)时，M为正交矩阵。</p><p><strong>【定理3.2】</strong> 如果向量组 \(V_{1}, V_{2}, \cdots, V_{n}\)构成的一个正交向量集合，则以 \(V_{j}, (1 \leq j \leq n)\)作为第j列的n阶方阵是正交矩阵。</p><p>正交矩阵还有另外一个性质，用于变换向量时，<strong>正交矩阵不改变向量的长度和角度</strong>（一般指的是两个同样变换的向量夹角）。</p><p><strong>【定理3.3】</strong> 如果n阶方阵M正交，则M具有保证长度和角度不变的特性。</p><p>Tips：证明可以先从不改变两个向量的内积入手，然后再说明对单个向量不改变长度，再推出不改变角度。</p><p>由于这样的特性，使用正交矩阵变换可以保持坐标系的整体结构，所以正交矩阵只能用于表示旋转和反射（在某一方向上将点镜像的运算）的组合。</p><h3 id="1-2-手向性"><a href="#1-2-手向性" class="headerlink" title="1.2 手向性"></a>1.2 手向性</h3><p>在三维空间中，由3D向量 \(V_{1}, V_{2}, V_{3}\) 构成的坐标系的基具有手向性。对于<strong>右手基</strong>，有 \((V_{1} \times V_{2}) \cdot V_{3} &gt; 0\)，即在右手坐标系中， \(V_{1}, V_{2}\)的叉积(右手法则下)的方向与 \(V_{3}\)的方向形成一个锐角，如果是一个<strong>正交规范的右手基</strong>，则有 \(V_{1} \times V_{2} = V_{3}\)；若\((V_{1} \times V_{2}) \cdot V_{3} &lt; 0\)，那么是<strong>左手基</strong>。</p><p>进行<strong>奇数次的反射操作</strong>，会改变手向性，<strong>偶数次的反射</strong>相当与一次旋转。通过考查变换矩阵的行列式可以判定矩阵是否存在反射，若<strong>行列式为负</strong>，则存在反射，用其对任意基的向量进行变换操作后，基的手向性发生改变。如果行列式是正的，则不改变手向性。</p><p>另外，正交矩阵的行列式值只可能是1或-1，如果为1，则矩阵只有旋转；如果为-1，则表示旋转操作后再进行一次反射。</p><hr><h2 id="2-缩放变换"><a href="#2-缩放变换" class="headerlink" title="2 缩放变换"></a>2 缩放变换</h2><p>用a作为系数缩放向量P，只需要计算 \(P^{‘}=aP\)，在三维空间中，运算也可以表示为和矩阵的乘积：</p><div>$$P^{'}=\left[\begin{matrix}a & 0 & 0 \\0 & a & 0 \\0 & 0 & a\end{matrix}\right]\left[\begin{matrix}P_{x} \\P_{y} \\P_{z}\end{matrix}\right]\tag{3.8}$$</div><p>这种缩放成为<strong>统一缩放</strong>（各个轴相同缩放系数），如果希望在x,y,z轴以不同的值缩放向量，可以改变对角线上的元素（不再是相同的一个a），这种缩放称为<strong>非统一缩放</strong>。</p><div>$$P^{'}=\left[\begin{matrix}a & 0 & 0 \\0 & b & 0 \\0 & 0 & c\end{matrix}\right]\left[\begin{matrix}P_{x} \\P_{y} \\P_{z}\end{matrix}\right]\tag{3.9}$$</div><p>如果想在<strong>3个任意轴上进行非统一缩放</strong>，就要用到稍微复杂的缩放过程。假设以a,b,c为系数，在U,V,W轴方向上进行缩放，就需要先从坐标系(U,V,W)变换到坐标系(i,j,k) （这一步乘以[U V W]的逆矩阵变换到UVW为ijk坐标轴的空间中），然后在(i,j,k)坐标系中计算缩放（乘以缩放矩阵），最后再还原到(U,V,W)坐标系（乘以[U V W]矩阵变换到原本的ijk坐标轴空间中）。</p><div>$$P^{'}=\left[\begin{matrix}U_{x} & V_{x} & W_{x} \\U_{y} & V_{y} & W_{y} \\U_{z} & V_{z} & W_{z}\end{matrix}\right]\left[\begin{matrix}a & 0 & 0 \\0 & b & 0 \\0 & 0 & c\end{matrix}\right]\left[\begin{matrix}U_{x} & V_{x} & W_{x} \\U_{y} & V_{y} & W_{y} \\U_{z} & V_{z} & W_{z}\end{matrix}\right]^{-1}\left[\begin{matrix}P_{x} \\P_{y} \\P_{z}\end{matrix}\right]\tag{3.10}$$</div><p>Tips：这一段其实说的有点绕，但其实理解第一步就可以理解后面了，关于为什么是乘以逆矩阵，是因为(U,V,W)中的目标 \(P^{uvw}\) 有以下的表示方法：</p><div>$$P^{uvw}_{x}\left[\begin{matrix}U_{x} \\U_{y} \\U_{z}\end{matrix}\right]+P^{uvw}_{y}\left[\begin{matrix}W_{x} \\W_{y} \\W_{z}\end{matrix}\right]+P^{uvw}_{z}\left[\begin{matrix}V_{x} \\V_{y} \\V_{z}\end{matrix}\right]\\ =\left[\begin{matrix}U_{x} & V_{x} & W_{x} \\U_{y} & V_{y} & W_{y} \\U_{z} & V_{z} & W_{z}\end{matrix}\right]\left[\begin{matrix}P^{uvw}_{x} \\P^{uvw}_{y} \\P^{uvw}_{z}\end{matrix}\right]=\left[\begin{matrix}P_{x} \\P_{y} \\P_{z}\end{matrix}\right]$$</div><p>所以要求得(U,V,W)坐标系下的坐标 \(P^{uvw}\) 就要用原坐标乘以矩阵[U V W]的逆矩阵：</p><div>$$\left[\begin{matrix}P^{uvw}_{x} \\P^{uvw}_{y} \\P^{uvw}_{z}\end{matrix}\right]=\left[\begin{matrix}U_{x} & V_{x} & W_{x} \\U_{y} & V_{y} & W_{y} \\U_{z} & V_{z} & W_{z}\end{matrix}\right]^{-1}\left[\begin{matrix}P_{x} \\P_{y} \\P_{z}\end{matrix}\right]$$</div><p>这也就解释了第一步为什么乘以的是逆矩阵，后面也就相同的方法来解释了。</p><hr><h2 id="3-旋转变换"><a href="#3-旋转变换" class="headerlink" title="3 旋转变换"></a>3 旋转变换</h2><p>得到将坐标系绕x,y或z轴旋转 \(\theta\)角的矩阵并不难，当A轴指向我们时，所看到的旋转时逆时针方向。</p><p>首先看一下二维空间旋转的通用公式，如图3.2所示，通过交换x和y坐标，并将新的x坐标取负，得到(-y,x)，就能够将位于xy平面线上的二维向量P进行90°的逆时针旋转。设旋转向量为Q，则有 \( Q=&lt;-P_{y}, P_{x}&gt;\)。向量P和Q组成了xy平面的一个正交基，因此xy平面的任意向量都可以用这两个向量的线性组合来表示。</p><div align="center"><p><img src="/images/3d-math-c3-3-1.jpg"></p></div><p>如图3.3所示，任意向量P以 \(\theta\)角旋转后所形成的二维向量 \(P^{‘}\)，都可以用分别平行于P和Q的分量来表示。</p><div>$$P^{'} = Pcos\theta + Qsin\theta \tag{3.11}$$</div><p>带入Q的坐标计算，可以有：</p><div>$$\begin{aligned}P^{'}_{x} &= P_{x}cos\theta - P_{y}sin\theta \\P^{'}_{y} &= P_{y}cos\theta + P_{x}sin\theta\end{aligned}\tag{3.12}$$</div><p>用矩阵改写则有：</p><div>$$P^{'} =\left[\begin{matrix}cos\theta & -sin\theta \\sin\theta & cos\theta\end{matrix}\right]P\tag{3.13}$$</div><p>将单位矩阵的第3行和第3列加入到等式3.13中的2D旋转矩阵，就可以扩展成3D空间中绕z轴的三维旋转，在旋转过程中z坐标保持不变，绕z轴旋转 \(\theta\) 角度的旋转矩阵 \(R_{z}(\theta)\)可以表示为：</p><div>$$R_{z}(\theta) =\left[\begin{matrix}cos\theta & -sin\theta & 0 \\sin\theta & cos\theta & 0 \\0 & 0 & 1\end{matrix}\right]\tag{3.14}$$</div><p>同样，可以分别得到绕x轴和绕y轴旋转\theta角度的旋转矩阵 \(R_{x}(\theta)\) 和 \(R_{y}(\theta)\)：</p><div>$$\begin{aligned}R_{x}(\theta) =\left[\begin{matrix}1 & 0 & 0 \\0 & cos\theta & -sin\theta \\0 & sin\theta & cos\theta\end{matrix}\right]\\R_{y}(\theta) =\left[\begin{matrix}cos\theta & 0 & sin\theta \\0 & 1 & 0 \\-sin\theta & 0 & cos\theta\end{matrix}\right]\end{aligned}\tag{3.15}$$</div><h3 id="3-1-绕任意轴旋转"><a href="#3-1-绕任意轴旋转" class="headerlink" title="3.1 绕任意轴旋转"></a>3.1 绕任意轴旋转</h3><p>如果如果希望将向量P绕一个<strong>任意轴旋转</strong> \(\theta\) 角，选定的任意轴以单位向量A表示，那么可以先将向量P分解为平行于A和垂直于A的分量。<br>如图3.4所示，由于平行分量在旋转过程中保持不变，所以只需要计算垂直于A的分量的旋转。</p><div align="center"><p><img src="/images/3d-math-c3-3-2.jpg"></p></div><p>A是一个单位向量，P在A上地投影为（公式1.18）：</p><div>$$proj_{A}P = \frac{P \cdot A}{A^{2}} A = (P \cdot A)A\tag{3.16}$$</div><p>P垂直于A的分量为（公式1.19）：</p><div>$$perp_{A} P = P - proj_{A} P = P - (P \cdot A)A\tag{3.17}$$</div><p>将垂直于A的分量进行旋转，再加上平行分量，就得到最终的旋转结果。</p><p>垂直分量的旋转实在垂直于A轴的平面内进行的，平面中可以用垂直分量和垂直分量旋转90°所形成的向量组成一组正交基，就可以表达该平面内的任意向量，垂直分量旋转90°的向量可以用 \(A \times P\) 得到。</p><p>用下面的公式表示 \(perp_{A}P\)旋转 \(\theta\)角，即：</p><div>$$[P - (P \cdot A)A]cos\theta + (A \times P)sin\theta\tag{3.18}$$</div><p>再加上平行分量 \(proj_{A}P\)，就可以得到P绕A轴旋转的公式：</p><div>$$P^{'} = [P - (P \cdot A)A]cos\theta + (A \times P)sin\theta + (P \cdot A)A \\= Pcos\theta + (A \times P)sin\theta + (P \cdot A)A(1 - cos\theta)\tag{3.19}$$</div><p>将其中的 \(A \times P\)和 \((P \cdot A)A\)替换为等价矩阵形式，就可以更加具体的表示出旋转矩阵 \(R_{A}(\theta)\)，公式过于繁杂就不再赘述。</p><h2 id="4-齐次坐标"><a href="#4-齐次坐标" class="headerlink" title="4 齐次坐标"></a>4 齐次坐标</h2><p>还有一个重要的变换是平移操作，在空间中平移坐标系，只需要简单地添加偏移向量，并不会影响坐标轴的方向和尺度，但这种矩阵无法用 \(3 \times 3\)的矩阵来直接表示，需要加一个平移分量：</p><div>$$P^{'} = MP + T \tag{3.22}$$</div><p>M为可逆变换矩阵，T是平移向量。</p><h3 id="4-1-四维变换"><a href="#4-1-四维变换" class="headerlink" title="4.1 四维变换"></a>4.1 四维变换</h3><p>可以用一种统一的数学形式来简洁而优雅地表示这些变换（包含平移操作），为了做到这一点，需要将向量从三维扩展到四维，使用 \(4 \times 4\)矩阵来表示变换操作，给3D点P增加一个坐标，并将这个扩展的第四坐标(称为w坐标)的值设为1。</p><p>构造一个  \(4 \times 4\)变换矩阵F，F对应于变换矩阵M和3D平移变换T：</p><div>$$F =\left[\begin{matrix}M & T \\0 & 1\end{matrix}\right]=\left[\begin{matrix}M_{11} & M_{12} & M_{13} & T_{x} \\M_{21} & M_{22} & M_{23} & T_{y} \\M_{31} & M_{32} & M_{33} & T_{z} \\0 & 0 & 0 & 1\end{matrix}\right]\tag{3.24}$$</div><p>这个矩阵乘以向量 \(P=&lt;P_{x}, P_{y}, P_{z}, 1&gt;\) 就等效于公式3.22，同时结果w坐标保持为1.</p><h3 id="4-2-点向量和方向向量"><a href="#4-2-点向量和方向向量" class="headerlink" title="4.2 点向量和方向向量"></a>4.2 点向量和方向向量</h3><p>Tips：书上把点坐标叫做点向量还是蛮奇怪的，就理解成点坐标就行了。</p><p>由于方向向量不会受平移变换的影响，所以在其扩展四维时，其w坐标设置为0（其实也可以从两个点坐标相减的角度理解，两个w相减就是0了），这个时候F矩阵中只有左上的 \(3 \times 3\) 部分可以影响方向向量。</p><h3 id="4-3-坐标的几何解释"><a href="#4-3-坐标的几何解释" class="headerlink" title="4.3 坐标的几何解释"></a>4.3 坐标的几何解释</h3><p>假设有一个四维点 \(P=&lt;x, y, z, w&gt;\)，其中坐标不为0，这里定义P在三维空间的映像，<br>如果用 \(\widetilde{P}\)表示P在 \(w=1\)的三维空间中的投影，\(\widetilde{P}\)可以用下面的公式来表示：</p><div>$$\widetilde{P} = <\frac{x}{w}, \frac{y}{w}, \frac{z}{w}>\tag{3.28}$$</div><div align="center"><p><img src="/images/3dmath-c3-3.6.jpg" alt="图3.6 四维点P在三维空间的投影"></p></div><p>如图3.6所示（图中省略z轴为了方便表示），三维点 \(\widetilde{P}\) 对应于连接点P与原点的直线和 \(w=1\)的平面的交点，从这一点可以知道，对四维向量P作任意系数乘积，其结果都对应于三维空间中一个相同的点，在第4章5节中详细讨论这种投影在三维图形中的重要性。</p><h2 id="5-法向量的变换"><a href="#5-法向量的变换" class="headerlink" title="5 法向量的变换"></a>5 法向量的变换</h2><p>一个多边形模型的顶点除了需要表示空间位置外，还要包含一些附加信息，这些信息用来表示<strong>该顶点是如何融合到周围的曲面中的</strong>。一般情况下，顶点可能有<strong>切线向量</strong>和<strong>法线向量</strong>与之关联。<strong>当变换一个模型时，不但要变换顶点，同时还要对与顶点有关的向量进行变换</strong>。</p><p>可通过求两个顶点之间的差来计算<strong>切线向量</strong>，所以经过<strong>变换的切线向量</strong>可以表示为<strong>两个变换点的差</strong>。如果使用一个矩阵来变换顶点位置，也可以用这个矩阵来变换顶点的切向量。图3.7所示所示为用一个<strong>非正交矩阵M变换法向量N</strong>时发生的情况，变换后的法向量最终不垂直于变换后的表面。</p><div align="center"><p><img src="/images/3dmath-c3-3.7.jpg" alt="图3.7 用非正交矩阵M变换法向量"></p></div><p>因为切线方向和法线方向是垂直的，所以同一顶点的切向量T和法向量N必须满足等式 \(N \cdot T = 0\)，并且必须保证变换后的切向量 \(T^{‘}\)和法向量 \(N^{‘}\)仍然满足等式，设变换矩阵为M，有 \(T^{‘}=MT\)，设变换N所需的矩阵为G，有：</p><div>$$N^{'} \cdot T^{'} = (GN) \cdot (MT) = 0\tag{3.29}$$</div><p>经过简单的运算，可以得到：</p><div>$$(GN) \cdot (MT) = (GN)^{T}(MT) = N^{T}G^{T}MT\tag{3.30}$$</div><p>由于 \(N^{T}T=0\)，如果 \(G^{T}M=I\)，则等式 \(N^{T}G^{T}MT\) 肯定成立。<br>因此可以得出 \(G=(M^{-1})^{T}\)。可以看出，用变换点的矩阵的逆转置矩阵，就能正确地变换法向量，<strong>必须通过这种方式变换的向量称为协变向量</strong>，用矩阵M以通常方式变换的向量（点或切向量）称为<strong>逆变向量</strong>。</p><p><strong>如果矩阵M是正交的</strong>，那么 \(M^{-1}=M^{T}\)，因此 \((M^{-1})^{T}=M\)，所以当M是正交矩阵时，<strong>法向量变换过程的求逆转置运算就可以避免</strong>，这一点适用于本章前面提到的当M等于旋转矩阵的情况。</p><h2 id="6-四元数"><a href="#6-四元数" class="headerlink" title="6 四元数"></a>6 四元数</h2><p>四元数是三维图像编程人员用来表示旋转的另一种数学形式。</p><p>在许多情况下，用四元数代替旋转矩阵会有很多的好处，因为四元数需要的存储空间更少，四元数之间的<strong>连接运算</strong>需要的算术运算更少，在产生平滑的三维动画时，用四元数更容易进行修改。</p><h3 id="6-1-四元数数学"><a href="#6-1-四元数数学" class="headerlink" title="6.1 四元数数学"></a>6.1 四元数数学</h3><p>四元数集合，被数学家们称为哈密顿四元数环(ring of Hamiltonian quaternions)，用H表示，可以理解为四维向量空间，空间中的元素q具有以下形式：</p><div>$$q = [w, x, y, z] = w + xi + yj + zk\tag{3.31}$$</div><p>四元数经常写为 \(q=s+v\)的形式，其中s表示数量部分，对应于q中的w分量，v表示向量部分，对应于q中的x,y,z分量。</p><p>四元数集合是复数集合的自然扩展，四元数的乘法服从分配率，并且虚部i,j,k之间的乘法服从下面的规则：</p><div>$$\begin{aligned}i^{2} &= j^{2} = k^{2} = -1 \\ij &= -ji = k \\jk &= -kj = i \\ki &= -ik = j\end{aligned}\tag{3.32}$$</div><p>四元数式的乘法是不可交换的，因此运算要注意顺序。</p><p>两个四元数 \(q_{1}=w_{1}+x_{1}i+y_{1}j+z_{1}k\) 和 \(q_{2}=w_{2}+x_{2}i+y_{2}j+z_{2}k\) 的乘积 \(q_{1}q_{2}\) 为：</p><div>$$q_{1}q_{2} = \\(w_{1}w_{2} - x_{1}x_{2} - y_{1}y_{2} - z_{1}z_{2}) + \\(w_{1}x_{2} + x_{1}w_{2} + y_{1}z_{2} - z_{1}y_{1})i + \\(w_{1}y_{2} - x_{1}z_{2} + y_{1}w_{2} + z_{1}x_{2})j + \\(w_{1}z_{2} + x_{1}y_{2} - y_{1}x_{2} + z_{1}w_{2})k\tag{3.33}$$</div><p>如果写成数量-向量形式，则 \(q_{1}=s_{1}+v_{1}\) 和 \(q_{2}=s_{2}+v_{2}\) 的乘积可以写成如下形式：</p><div>$$q_{1}q_{2} = s_{1}s_{2} - v_{1} \cdot v_{2} + s_{1}v_{2} + s_{2}v_{1} + v_{1} \times v_{2}\tag{3.34}$$</div><p>和复数一样，四元数有共轭。</p><p><strong>【定义3.4】</strong> 四元数 \(q=s+v\)的共轭，记为 \(\bar{q}\)，定义为 \(\bar{q}=s-v\)。</p><p>通过简单的运算，就可以发现q与其共轭 \(\bar{q}\)的乘积等于q自身的点积，也就是等于q模的平方。</p><div>$$q \bar{q} = \bar{q} q = q \cdot q = ||q||^{2} = q^{2}\tag{3.35}$$</div><p><strong>【定理3.5】</strong> 非零的四元数的逆，记为 \(q^{-1}\)，则有：</p><div>$$q^{-1} = \frac{\bar{q}}{q^{2}}\tag{3.36}$$</div><h3 id="6-2-四元数的旋转"><a href="#6-2-四元数的旋转" class="headerlink" title="6.2 四元数的旋转"></a>6.2 四元数的旋转</h3><p>三维空间的旋转可以理解为 \(R^{3}\) 到自身 的映射函数 \(\varphi\)。由于\(\varphi\)代表旋转，所以它必须包含长度、角度、旋转方向等信息。如果有：</p><div>$$||\varphi(P)||=||P||\tag{3.39}$$</div><p>则<strong>长度保持不变</strong>。</p><p>如果对任意两个点 \(P_{1}\) 和 \(P_{2}\)有：</p><div>$$\varphi(P_{1}) \cdot \varphi(P_{2}) = P_{1} \cdot P_{2}\tag{3.40}$$</div><p>则从原点到两个点 \(P_{1}\) 和 \(P_{2}\)的连线所形成的<strong>夹角保持不变</strong>。</p><p>最后，如果：</p><div>$$\varphi(P_{1}) \times \varphi(P_{2}) = \varphi(P_{1} \times P_{2})\tag{3.41}$$</div><p>则<strong>手向性也保持</strong>不变。</p><p>如果满足条件 \(\varphi(s+v)=s+\varphi(v)\)，则函数 \(\varphi\)可以扩展为H到自身的映射，这样就允许将公式(3.40)重写为：</p><div>$$\varphi(P_{1}) \cdot \varphi(P_{2}) = \varphi(P_{1} \cdot P_{2})\tag{3.42}$$</div><p>如果将 \(P_{1}\)和 \(P_{2}\)看成是数量部分为0的四元数，根据 \(P_{1}P_{2} = -P_{1} \cdot P_{2} + P_{1} \times P_{2}\)，就可以将等式(3.41)和(3.42)合并成一个等式，在该等式中可以<strong>保持角度不变和手向性不变</strong>，公式如下：</p><div>$$\varphi(P_{1})\varphi(P_{2}) = \varphi(P_{1}P_{2})\tag{3.43}$$</div><p>满足这种等式的函数 \(\varphi\) 称为是<strong>同态</strong>的。</p><p>这一类函数可以用下面的公式给出：</p><div>$$\varphi_{q}(P) = qPq^{-1}\tag{3.44}$$</div><p>其中q是一个非0的四元数，且满足等式(3.39)（长度不变）和(3.43)（角度不变、手向性不变），因此可以表示旋转的集合。</p><p>现在需要找到一个关于四元数q的公式，q对应于 \(\theta\)角绕A轴的旋转。<br>简单的计算表明 \(\varphi_{aq}=\varphi_{q}\) 适用于任何非零数量a，为了简单起见，只涉及单位四元数。设 \(q=s+v\) 是<strong>单位四元数</strong>，则 \(q^{-1}=s-v\)，对于给定的点P，有：</p><div>$$\begin{aligned}qPq^{-1} &= (s + v)P(s - v) \\&= (-v \cdot P + sP + v \times P)(s - v) \\&= -sv \cdot P + s^{2}P + sv \times P + (v \cdot P)v - sPv - (v \times P)v \\&= s^{2}P + 2sv \times P + (v \cdot P)v - v \times P \times v\end{aligned}\tag{3.47}$$</div><p>对叉积 \(v \times P \times v\) 使用定理1.9(6)，这个等式就变为：</p><div>$$\begin{aligned}v \times (P \times v) = v \times P \times v = v^{2}P - (v \cdot P) v \\qP^{-1}q = (s^{2}-v^{2})P + 2sv \times P + 2(v \cdot P)v\end{aligned}\tag{3.48}$$</div><p>设 \(v=tA\)，其中A为单位向量，则上式可改写为：</p><div>$$qP^{-1}q = (s^{2}-v^{2})P + 2stA \times P + 2t^{2}(A \cdot P)A\tag{3.49}$$</div><p>比较等式(3.19)给出的绕任意轴旋转的公式，可以推出下面的等式：</p><div>$$P^{'} = [P - (P \cdot A)A]cos\theta + (A \times P)sin\theta + (P \cdot A)A \\= Pcos\theta + (A \times P)sin\theta + (P \cdot A)A(1 - cos\theta)\tag{3.19}$$</div><div>$$\begin{aligned}s^{2} - t^{2} &= cos\theta \\2st &= sin\theta \\2t^{2} &= 1 - cos\theta\end{aligned}\tag{3.50}$$</div><p>由第三个等式可以得出：</p><div>$$t = \sqrt{\frac{1-cos\theta}{2}} = sin\frac{\theta}{2}\tag{3.51}$$</div><p>结合式(3.50)中第一和第三个等式，可以得出 \(s^{2}+t^{2}=1\)，因此可以肯定 \(s=cos\frac{\theta}{2}\)。</p><p>现在可以用下面的等式给出对应于 \(\theta\)角绕A轴旋转的单位四元数q为：</p><div>$$q = cos\frac{\theta}{2} + Asin\frac{\theta}{2}\tag{3.52}$$</div><p>这里应注意：四元数q的<strong>任意数量乘积</strong>(特别是-q)表示的是相同的旋转，这是因为之前说的\(\varphi_{aq}=\varphi_{q}\) 适用于任何非零数量a。</p><div>$$(aq)P(aq)^{-1} = aqP \frac{q^{-1}}{a} = qP^{-1}q\tag{3.53}$$</div><p>两个四元数的乘积也可以表示一个旋转，乘积 \(q_{1}q_{2}\) 表示<strong>先以</strong> \(q_{2}\)，<strong>后以</strong> \(q_{1}\)进行旋转：</p><div>$$q_{1}(q_{2}Pq_{2}^{-1})q_{1}^{-1} = (q_{1}q_{2})P(q_{1}q_{2})^{-1}\tag{3.54}$$</div><p>可以将任意多的四元数结合起来，形成表示一系列旋转的一个四元数，<br>将两个四元数相乘需要做16次乘法和加法运算，而两个 \(3 \times 3\) 矩阵相乘需要27次这样的操作，因此当对物体进行多次旋转时，应用四元数可以获得较高的计算效率。</p><p>经常需要将一个四元数变成等价的 \(3 \times 3\)旋转矩阵的形式。<br>利用等式(1.25)和(1.20)，可以确定对应于四元数 \(q = s + tA\)的矩阵公式。</p><div>$$P \times Q =\left[\begin{matrix}0 & -P_{z} & P_{y} \\P_{z} & 0 & -P_{x} \\-P_{y} & P_{x} & 0\end{matrix}\right]\left[\begin{matrix}Q_{x} \\Q_{y} \\Q_{z}\end{matrix}\right]\tag{1.25}$$</div><div>$$proj_{Q} P = \frac{1}{Q^{2}}\left[\begin{matrix}Q_{x}^{2} & Q_{x}Q_{y} & Q_{x}Q_{z} \\Q_{x}Q_{y} & Q_{y}^{2} & Q_{y}Q_{z} \\Q_{x}Q_{z} & Q_{y}Q_{z} & Q_{z}^{2}\end{matrix}\right]\left[\begin{matrix}P_{x} \\P_{y} \\P_{z}\end{matrix}\right]\tag{1.20}$$</div><p>然后将等式(3.49)改写成矩阵形式(和3.1节中用的技巧类似），由此可得：</p><div>$$qPq_{-1} =\left[\begin{matrix}s^{2}-t^{2} & 0 & 0 \\0 & s^{2}-t^{2} & 0 \\0 & 0 & s^{2}-t^{2}\end{matrix}\right]P + \\2st\left[\begin{matrix}0 & -A_{z} & A_{y} \\A_{z} & 0 & -A_{x} \\-A_{y} & A_{x} & 0\end{matrix}\right]P + \\2t^{2}\left[\begin{matrix}A_{x}^{2} & A_{x}A_{y} & A_{x}A_{z} \\A_{x}A_{y} & A_{y}^{2} & A_{y}A_{z} \\A_{x}A_{z} & A_{y}A_{z} & A_{z}^{2}\end{matrix}\right]P\tag{3.55}$$</div><p>将四元数p写成四维向量 \(q=&lt;w,x,y,z&gt;\)，那么 \(w=s, x=tA_{x}, y=tA_{y}, z=tA_{z}\)，因此A是单位向量，所以 \(x^{2}+y^{2}+z^{2} = t^{2}A^{2} = t^{2}\)，以 \(w,x,y,z\)为分量，则公式(3.55)可以改写为：</p><div>$$qPq_{-1} =\left[\begin{matrix}w^{2}-x^{2}-y^{2}-z^{2} & 0 & 0 \\0 & w^{2}-x^{2}-y^{2}-z^{2} & 0 \\0 & 0 & w^{2}-x^{2}-y^{2}-z^{2}\end{matrix}\right]P + \\2w\left[\begin{matrix}0 & -z & y \\z & 0 & -x \\-y & x & 0\end{matrix}\right]P + \\2\left[\begin{matrix}x^{2} & xy & xz \\xy & y^{2} & yz \\xz & yz & z^{2}\end{matrix}\right]P\tag{3.56}$$</div><p>因为q是单位四元数，满足 \(w^{2} + x^{2} + y^{2} + z^{2} = 1\)，所以有：</p><div>$$w^{2} - x^{2} - y^{2} - z^{2} = 1 - 2x^{2} - 2y^{2} - 2z^{2}\tag{3.57}$$</div><p>根据该等式，并结合前面的三个矩阵，可以得到用来计算矩阵 \(R_{q}\) 的公式，这里的 \(R_{q}\) 表示对应于四元数q的旋转矩阵，公式为：</p><div>$$R_{q} = \left[\begin{matrix}1-2y^{2}-2z^{2} & 2xy-2wz & 2xz+2wy \\2xy+2wz & 1-2x^{2}-2z^{2} & 2yz-2wx \\2xz-2wy & 2yz+2wx & 1-2x^{2}-2y^{2}\end{matrix}\right]\tag{3.58}$$</div><h3 id="6-3-球形线性插值"><a href="#6-3-球形线性插值" class="headerlink" title="6.3 球形线性插值"></a>6.3 球形线性插值</h3><p>因为四元数是用向量表示的，所以很适合于插值运算。<br>在产生一个物理动画的过程中，在产生位于两个预先计算的关键帧之间的中间过渡定位时，插值非常有用。</p><p>最简单的插值类型是<strong>线性插值</strong>，对于两个四元数 \(q_{1}\)和 \(q_{2}\)，线性插值后所得的四元数 \(q_{t}\)为：</p><div>$$q(t) = (1-t)q_{1} + tq_{2} \tag{3.59}$$</div><p>当t在0和1之间变化时，函数 \(q(t)\)在连接 \(q_{1}\)和 \(q_{2}\)的线段上平滑变化。</p><div align="center"><p><img src="/images/3d-math-c3-6-3.jpg" alt="四元数的线性插值"></p></div><p>如上图所示，\(q(t)\)并不保持 \(q_{1}\)和 \(q_{2}\)的单位长度，但可以使用下面的函数在任意点位置对 \(q(t)\)进行重新规格化：</p><div>$$q(t)=\frac{(1-t)q_{1} + tq_{2}}{||(1-t)q_{1} + tq_{2}||}\tag{3.60}$$</div><p>尽管线性插值是很有效的，但由等式(3.60)得出的函数 \(q(t)\)并没有以恒定的速率描绘 \(q_{1}\)和 \(q_{2}\)间的过渡弧线，这是线性插值的弊端。如下图所示，\(q_{1},q_{2}\)之间的角度变化速率在端点时相对较慢，在中间的地方最快。</p><div align="center"><p><img src="/images/3d-math-c3-6-4.jpg" alt="arccos(q(t)·q1)的曲线"></p></div><p>我们希望找到一个函数 \(q(t)\)，用它对四元数 \(q_{1}\)和 \(q_{2}\)进行插值时，<br>会保持其单位长度不变并且以恒定的速率扫过位于 \(q_{1}\)和 \(q_{2}\)之间的夹角。</p><p>如果 \(q_{1}\)和 \(q_{2}\)的夹角为 \(\theta\)，那么这个函数将会产生一个四元数，该四元数在 \(q(t)\)和 \(q_{1}\)之间形成一个夹角 \(\theta t\)，这里t在0在1之间取值。</p><p>如下图所示，四元数 \(q(t)\)位于连接 \(q_{1}\)和 \(q_{2}\)的弧上，与 \(q_{1}\)构成夹角 \(\theta t\)，与 \(q_{2}\)构成夹角 \(\theta(1-t)\)，可以将 \(q(t)\)写成：</p><div>$$q(t) = a(t)q_{1} + b(t)q_{2} \tag{3.61}$$</div><div align="center"><p><img src="/images/3d-math-c3-6-5.jpg" alt="图(a)和图(b) 用相似三角形得到分量长度"></p></div><p>如图(a)所示，可以构造相似三角形来确定长度 \(a(t)\)，\(q_{1}\)到以原点和 \(q_{2}\)为端点的线段的垂直距离为 \(||q_{1}||sin\theta\)，而 \(q(t)\)到该线段的垂直距离为 \(||q(t)||sin(\theta(1-t))\)，根据相似三角形，可以由：</p><p>Tips：书上说的这个相似三角形在图(a)中并不明显，是以角 \(\theta\)为共同角，将边 \(||q(t)||sin(\theta(1-t))\) 平移到左边，构成的一个小三角形。</p><div>$$\frac{a(t)}{||q(t)||sin(\theta(1-t))} =\frac{||q_{1}||}{||q||sin\theta}$$</div><p>所以有：</p><div>$$\frac{a(t)}{||q_{1}||} =\frac{||q(t)||sin(\theta(1-t))}{||q||sin\theta}\tag{3.62}$$</div><p>由于 \(||q_{1}||=1\)，\(||q(t)||=1\)，可以将上式简化为：</p><div>$$a(t) = \frac{sin(\theta(1-t))}{sin\theta}\tag{3.63}$$</div><p>图(b)表示了求长度 \(b(t)\)的相同过程，有结果：</p><div>$$b(t) = \frac{sin(\theta t)}{sin\theta}\tag{3.64}$$</div><p>可以将球型线性插值函数 \(q(t)\)定义如下：</p><div>$$q(t)= \frac{sin(\theta(1-t))}{sin\theta}q_{1} + \frac{sin(\theta t)}{sin\theta}q_{2}\tag{3.65}$$</div><p>这里的角 \(\theta\) 为：</p><div>$$\theta = arccos(q_{1} \cdot q_{2})\tag{3.66}$$</div><p>\(sin\theta\)计算：</p><div>$$sin\theta = \sqrt{1-(q_{1} \cdot q_{2})^{2}}\tag{3.67}$$</div><p>因为四元数 \(q\) 和\(-q\)表示<strong>相同的旋转</strong>，所以选择四元数 \(q_{1}\)和 \(q_{2}\)的正负号时一般要满足 \(q_{1} \cdot q_{2} \geq 0\)，这样可以保证以最短路径的方式进行插值。</p>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;3D游戏开发过程中，通常需要以某种方式对向量进行变换。&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="3D游戏与图形学的数学" scheme="https://yumi-cn.github.io/categories/3D%E6%B8%B8%E6%88%8F%E4%B8%8E%E5%9B%BE%E5%BD%A2%E5%AD%A6%E7%9A%84%E6%95%B0%E5%AD%A6/"/>
    
    
    <category term="笔记" scheme="https://yumi-cn.github.io/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>《实时渲染 4th》第1章笔记 导论</title>
    <link href="https://yumi-cn.github.io/2020/12/09/rtr-c1/"/>
    <id>https://yumi-cn.github.io/2020/12/09/rtr-c1/</id>
    <published>2020-12-09T11:12:14.000Z</published>
    <updated>2020-12-09T14:01:50.228Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>实时渲染一般指计算机里的快速图像生成。</p></blockquote><a id="more"></a><p>PS：原书《Real Time Rendering 4th》全英文，有些词翻译如果不够好还请见谅。</p><p>Tips：屏幕刷新率(refresh rate)和显示频率(display rate)在现在是有区别的；</p><blockquote><p>We will not be able to cover every topic in depth, so our goal is to present key concepts and terminology, explain the most robust and practical algorithms in the field, and provide pointers to the best places to go for more information.</p></blockquote><p>虽然这本书没有覆盖到实时渲染涉及到的每一个主题，但本书的目的是呈现关键概念和术语、解释最鲁邦和实用的算法、提供深入了解这些内容的方向指引。</p><h2 id="1-内容概览"><a href="#1-内容概览" class="headerlink" title="1 内容概览"></a>1 内容概览</h2><ul><li><strong>第2章 图形渲染管线</strong>：<code>The Graphics Rendering Pipeline</code>，实时渲染的核心是通过什么样的步骤来将场景传达到显示上；</li><li><strong>第3章 图形处理单元</strong>：<code>The Graphics Processing Unit</code>，现代GPU中一般通过一组计算单元(fixed-function and programmable units)来实现渲染管线；</li><li><strong>第4章 变换</strong>：<code>Transforms</code>，变换是操作物体位置、方向、大小以及形状、控制摄像机位置和视角的基本工具；</li><li><strong>第5章 着色基础</strong>：<code>Shading Basics</code>，着色一般指的是通过材质(Material)和光源(Light)来表现物体，还有一些相关的主题，例如抗锯齿（反走样 antialiasing）、透明处理以及Gamma矫正；</li><li><strong>第6章 纹理</strong>：<code>Texturing</code>，纹理贴图用于在物体表面呈现纹理；</li><li><strong>第7章 光影</strong>：<code>Shadows</code>，光影让场景更有真实情感，会介绍一些快速计算光影的流行算法；</li><li><strong>第8章 光和颜色</strong>：<code>Light and Color</code>，讲解计算机是如何如何量化光和颜色，以及把这些量化转换成显示量纲的方法；</li><li><strong>第9章 基于物理的着色</strong>：<code>Physically Based Shading</code>，基于物理的着色会更加接近真实；</li><li><strong>第10章 局部光照</strong>：<code>Local Illumination</code>，主要介绍一些渲染复杂光源的算法，例如光源本身具有物理形状；</li><li><strong>第11章 全局光照</strong>：<code>Global Illumination</code>，模拟光源和场景之间的交互的算法，进一步增加场景的真实度；</li><li><strong>第12章 图像效果</strong>：<code>Image-Space Effects</code>，GPU擅长快速处理图像，首先介绍图像滤波(image filtering)和重投影(reprojection)技术，然后介绍一些流行的后期效果，例如镜头光晕(lens flares)、动态模糊(motion blur)以及景深(depth of field)；</li><li><strong>第13章 几何之外</strong>：<code>Beyond Polygons</code>，三角形不一定总是最快或最真实地描述物体的方式，还有其他方式，例如图片(images)、点云(point clouds)、体素(voxels)等；</li><li><strong>第14章 体渲染和透光渲染</strong>：<code>Volumetric and Translucency Rendering</code>，介绍体积材质(volumetric material)（例如云、烟、雾）的表达方式以及和光的交互，大到气象效果，小到头发渲染；</li><li><strong>第15章 非真实渲染</strong>：<code>Non-Photorealistic Rendering</code>，主要介绍一些风格渲染，例如卡通渲染(cartoon shading)、水彩效果(watercolor<br>effects)；</li><li><strong>第16章 几何技术</strong>：<code>Polygonal Techniques</code>，几何体数据的来源各种各样，如果需要又快又好地渲染，就需要进行一定处理，涉及到几何数据表达和压缩方法；</li><li><strong>第17章 曲线和曲面</strong>：<code>Curves and Curved Surfaces</code>，复杂的表面表达提供的优势在于更好的在质量和速度中进行取舍，表达越简洁，曲面就越光滑；</li><li><strong>第18章 管线优化</strong>：<code>Pipeline Optimization</code>，寻找渲染瓶颈来优化速度，涉及到一些多线程技术；</li><li><strong>第19章 加速算法</strong>：<code>Acceleration Algorithms</code>，比快更快，Various<br>forms of culling and level of detail rendering are covered；</li><li><strong>第20章 高效着色</strong>：<code>Efficient Shading</code>，越多的光源，渲染就越慢，在渲染前无法知道是否需要渲染会造成资源浪费，使用一些方法可以解决这些问题；</li><li><strong>第21章 虚拟现实和增强现实</strong>：<code>Virtual and Augmented Reality</code>，这些领域有很多特定的技术难题，也有一些相应方法来高效快速的生成图像；</li><li><strong>第22章 相交检测</strong>：<code>Intersection Test Methods</code>，深入介绍一些几何相交检测的高效算法；</li><li><strong>第23章 图形硬件</strong>：<code>Graphics Hardware</code>，图形硬件的一些细节，例如色彩深度(color depth)、帧缓冲(framebuffers)和基础架构类型；</li><li><strong>第24章 面向未来</strong>：<code>The Future</code>，Take a guess (we do)。</li></ul><p>还有一些没有收录在实体书中，在<a href="http://www.realtimerendering.com/">realtimerendering.com</a>上更新的章节：</p><ul><li><strong>碰撞检测</strong>：<code>Collision Detection</code>，The 3rd edition’s chapter on this subject has been fully updated, but could not fit in the bounds of the physical book；</li><li><strong>实时光线追踪</strong>：<code>Real-Time Ray Tracing</code>，API support for this area was announced in March 2018, too late for inclusion in the book, so we wrote an additional chapter about the subject as a whole.</li><li><strong>附录</strong>：<code>Appendices</code>，The two appendices, Some Linear Algebra and Trigonometry, also had to be cut from the physical book.</li></ul><h2 id="2-标记和定义"><a href="#2-标记和定义" class="headerlink" title="2 标记和定义"></a>2 标记和定义</h2><h3 id="2-1-数学标记"><a href="#2-1-数学标记" class="headerlink" title="2.1 数学标记"></a>2.1 数学标记</h3><div align="center"><p><img src="/images/rtr-c1-t1.1.jpg" alt="表1.1 本书中的大部分标记"></p></div><p><strong>向量或者点</strong>通常用粗体小写字母表示，并且其内部组成一般写为：</p><div>$$\textbf{v} =\left(\begin{matrix}v_{x} \\v_{y} \\v_{z}\end{matrix}\right)$$</div><p>在图形学领域中一般用列向量的表达方式，有时候为了书面方便也会写成行向量。</p><p>书中使用到<strong>矩阵</strong>大多是 \(2 \times 2\)，\(3 \times 3\) 和\(4 \times 4\)，以\(3 \times 3\)矩阵为例，说明矩阵的表示方式：</p><div>$$\textbf{M} =\left(\begin{matrix}m_{00} & m_{01} & m_{02} \\m_{10} & m_{11} & m_{12} \\m_{20} & m_{21} & m_{22}\end{matrix}\right)\tag{1.1}$$</div><p>有时候为了表达需求，会只关注行向量或者列向量的内容，矩阵也可以写为：</p><div>$$\textbf{M} =\left(\begin{matrix}\textbf{m}_{,0} & \textbf{m}_{,1} & \textbf{m}_{,2}\end{matrix}\right)=\left(\begin{matrix}\textbf{m}_{0,}^{T} \\\textbf{m}_{1,}^{T} \\\textbf{m}_{2,}^{T}\end{matrix}\right)\tag{1.2}$$</div><p>其中 \(\textbf{m}_{,j}\) 代表第j列向量，\(\textbf{m}_{i,}\) 代表第i行向量。</p><p><strong>平面</strong>的数学表示是 \(\pi:\textbf{n}\cdot\textbf{x} + d = 0\)，其中 \(\textbf{n}\)是平面的法向量，\(d\)是标量，平面将空间分为两个子空间，正子空间是 \(\textbf{n}\cdot\textbf{x} + d &gt; 0\)，相应的负子空间是 \(\textbf{n}\cdot\textbf{x} + d &lt; 0\)</p><p>三角形通常用三个点来表示，例如有不共线的三点 \(\textbf{v}_{0}, \textbf{v}_{1}, \textbf{v}_{2}\)，构成的三角形是 \(\bigtriangleup\textbf{v}_{0}\textbf{v}_{1}\textbf{v}_{2}\)。</p><div align="center"><p><img src="/images/rtr-c1-t1.2.jpg" alt="表1.2 数学运算的标记"></p></div><p>大部分都应该是比较常见的，需要稍微特殊说明的几个：</p><ol start="4"><li>主要用于二维向量，求二维向量的垂直向量，例如有 \(\textbf{v}=(v_{x}, v_{y})\)，\(\textbf{v}^{\perp}=(-v_{y}, v_{x})\)；</li><li>将x映射为非负空间数，当其为负值时会变为0；</li><li>和8较为类似，映射到0-1空间中，大于1变为1，小于0变为0；</li><li><code>binomial coefficients</code>，二项式系数，\(\left(\begin{matrix}n \\ k\end{matrix}\right) = \frac{n!}{k!(n-k)!}\)。</li></ol><p>一般把 \(x=0, y=0, z=0\) 叫做 坐标平面(coordinate<br>planes)或者轴对齐平面(axis-aligned planes)，将轴 \(\textbf{e}_{x}=(1, 0, 0), \textbf{e}_{y}=(0, 1, 0), \textbf{e}_{z}=(0, 0, 1)\)叫做主轴(main axes)或者主方向(main directions)，也分别叫做x轴(x-axis)，y轴(y-axis)和z轴(z-axis)。</p><div align="center"><p><img src="/images/rtr-c1-t1.3.jpg" alt="表1.3 其他需要说明的数学函数"></p></div><p>C语言数学函数 <code>atan2(y,x)</code> 有时候被经常提及到，它是<code>arctan(x)</code>的一个拓展，主要区别在于 \(-\frac{\pi}{2} &lt; arctan(x) &lt; \frac{\pi}{2}\)，\(0 \lep atan2(y, x) &lt; 2\pi\)，一种常用操作是计算<code>arctan(y/x)</code>，但是当<code>x=0</code>时会出现除0问题（尽管可能本意是表达一个无穷大数，但C语言会报除0错误），而这时候使用<code>atan2(y,x)</code>可以避免这样的问题。</p><p><code>log(n)</code>函数一般指的是自然数<code>e</code>为底数，而不是以<code>10</code>为底数。</p><p>默认情况下均使用右手坐标系。</p><p>颜色一般用一个三元向量表示，<code>(red, green, blue)</code>，各项的值都在[0,1]。</p><h3 id="2-2-几何定义"><a href="#2-2-几何定义" class="headerlink" title="2.2 几何定义"></a>2.2 几何定义</h3><p>最原石的一些基础渲染元(basic rendering primitives, also called drawing primitives)，最常用的是点、线和三角形。</p><p>在本书中，一组几何体(a collection of geometric entities)通常叫做一个<strong>模型</strong>(model)或者<strong>对象</strong>(object)；<strong>场景</strong>(scene)指的是环境中一组需要渲染模型，场景一般也包括材质描述、光线以及视角定义。</p><p>也有些不是使用点、线和三角形这种基础渲染元表达的模型，例如点云、函数表达（贝塞尔曲线）。</p><h3 id="2-3-Shading和Shader？"><a href="#2-3-Shading和Shader？" class="headerlink" title="2.3 Shading和Shader？"></a>2.3 Shading和Shader？</h3><p>本书中的 <strong>Shading</strong> 和 <strong>Shader</strong> 是两个截然不同但是又有关联的概念：</p><ul><li>前者指的是计算机生成的视觉表达(computer-generated visual appearance)，例如shading model、shading equation以及toon shading这些概念原理；</li><li>后者指的是渲染系统中的一个可编程单元，例如vertex shader、shading language。</li></ul><p>尽管他们用词形式上有一些混淆，但是要通过语境上下文来判断其指的是哪个概念（在书本以外可能会单独开一页来讲一些概念的区分）。</p>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;实时渲染一般指计算机里的快速图像生成。&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="Real Time Rendering 4th" scheme="https://yumi-cn.github.io/categories/Real-Time-Rendering-4th/"/>
    
    
    <category term="笔记" scheme="https://yumi-cn.github.io/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>《剑指Offer》第2章笔记 树</title>
    <link href="https://yumi-cn.github.io/2020/12/07/s2o-c2-tree/"/>
    <id>https://yumi-cn.github.io/2020/12/07/s2o-c2-tree/</id>
    <published>2020-12-07T12:18:45.000Z</published>
    <updated>2020-12-07T12:17:45.992Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>树的操作会涉及大量指针，因此与树相关的面试题都不太容易。</p></blockquote><a id="more"></a><p>树的逻辑很简单：</p><ul><li>除根节点之外，每个节点只有一个父节点，根节点没有父节点；</li><li>除叶节点之外，每个节点都有一个或多个子节点，叶节点没有子节点；</li><li>父节点和子节点之间用指针链接。</li></ul><p>面试中大部分都是<strong>二叉树</strong>，在二叉树中每个节点最多只能有两个子节点。</p><p>二叉树中最重要的操作是如何遍历数结构，按照某种顺序访问树的所有节点，通常有几种遍历方式：</p><ul><li>前序：父-&gt;左子-&gt;右子；</li><li>中序：左子-&gt;父-&gt;右子；</li><li>后序：左子-&gt;右子-&gt;父；</li><li>层序：从根节点层到叶节点层，按层输出，每一层按照从左到右输出。</li></ul><p>二叉树中又有一些特例：</p><ul><li><strong>二叉搜索树</strong>：在二叉搜索树中，左子节点总是小于或等于父节点，右子节点总是大于或等于父节点，可以平均在<code>O(logn)</code>的时间内根据值在二叉树中查找节点；</li><li><strong>堆</strong>：堆分为最大堆和最小堆，在最大堆中，根节点的值最大，最小堆中的根节点值最小（其他节点按子树递推），有很多需要快速找到最大值或最小值的问题都可以用堆来解决；</li><li><strong>红黑树</strong>：把树中的节点定义为红、黑两种颜色，并通过规则确保<strong>从根节点到叶节点的最长路径</strong>的长度<strong>不超过</strong>最短路径的两倍；在C++的STL中，<code>set</code>、<code>multiset</code>、<code>map</code>、<code>multimap</code>等都是基于红黑树实现的。</li></ul><blockquote><p>面试题7：重建二叉树</p></blockquote><p>输入二叉树的前序和中序遍历结果，重建该二叉树，假设输入的前序中序结构中都不含有重复的数字。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 二叉树节点定义</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">  <span class="keyword">int</span> value;</span><br><span class="line">  Node* left;</span><br><span class="line">  Node* right;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><div align="center"><p><img src="/images/s2o-c2-tree-cv-7.jpg"></p></div><p>在前序遍历中，第一个数字总是树的根节点；但在中序遍历中，根节点的值在序列中间，左子树的值位于根节点左边，右子树的值位于根节点右边；所以<strong>对于一个子树</strong>，我们在<strong>前序中寻找其根节点</strong>（第一个出现的值），然后在<strong>中序中根据根节点的位置</strong>，把<strong>剩下的点</strong>分为<strong>左子树和右子树</strong>。</p><p>完整代码实现：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;exception&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> value;</span><br><span class="line">    Node* left;</span><br><span class="line">    Node* right;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Node* construct_core</span><br><span class="line">(</span><br><span class="line">    <span class="keyword">int</span>* po_start, <span class="keyword">int</span>* po_end,</span><br><span class="line">    <span class="keyword">int</span>* io_start, <span class="keyword">int</span>* io_end</span><br><span class="line">) &#123;</span><br><span class="line">    <span class="keyword">int</span> root_value = po_start[<span class="number">0</span>];</span><br><span class="line">    Node* root = <span class="keyword">new</span> Node();</span><br><span class="line">    root-&gt;value = root_value;</span><br><span class="line">    root-&gt;left = root-&gt;right = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">if</span>(po_start == po_end) &#123;</span><br><span class="line">        <span class="keyword">if</span>(io_start == io_end &amp;&amp; *po_start == *io_start) &#123;</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// Windows Ver Error</span></span><br><span class="line">            <span class="built_in">std</span>::logic_error ex(<span class="string">&quot;Invalid input&quot;</span>);</span><br><span class="line">            <span class="keyword">throw</span> <span class="built_in">std</span>::exception(ex);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span>* io_root = io_start;</span><br><span class="line">    <span class="keyword">while</span>(io_root &lt;= io_end &amp;&amp; *io_root != root_value) &#123;</span><br><span class="line">        io_root++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(io_root == io_end &amp;&amp; *io_root != root_value) &#123;</span><br><span class="line">        <span class="comment">// Windows Ver Error</span></span><br><span class="line">        <span class="function"><span class="built_in">std</span>::logic_error <span class="title">ex</span><span class="params">(<span class="string">&quot;Invalid input&quot;</span>)</span></span>;</span><br><span class="line">        <span class="keyword">throw</span> <span class="built_in">std</span>::exception(ex);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> left_len = io_root - io_start;</span><br><span class="line">    <span class="keyword">int</span>* left_po_end = po_start + left_len;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(left_len &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        root-&gt;left = construct_core(po_start+<span class="number">1</span>, left_po_end, io_start, io_root<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(left_len &lt; po_end - po_start) &#123;</span><br><span class="line">        root-&gt;right = construct_core(left_po_end + <span class="number">1</span>, po_end, io_root+<span class="number">1</span>, io_end);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Node* <span class="title">construct</span><span class="params">(<span class="keyword">int</span>* preodr, <span class="keyword">int</span>* inodr, <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(preodr == <span class="literal">nullptr</span> || inodr == <span class="literal">nullptr</span> || len &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> construct_core(preodr, preodr + len - <span class="number">1</span>,</span><br><span class="line">            inodr, inodr + len - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">post_order_print</span><span class="params">(Node* node)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(node != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        post_order_print(node-&gt;left);</span><br><span class="line">        post_order_print(node-&gt;right);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, node-&gt;value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> preodr[<span class="number">8</span>] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">7</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">8</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> inodr[<span class="number">8</span>] = &#123;<span class="number">4</span>, <span class="number">7</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">3</span>, <span class="number">8</span>, <span class="number">6</span>&#125;;</span><br><span class="line">    Node* root = construct(preodr, inodr, <span class="number">8</span>);</span><br><span class="line">    post_order_print(root); <span class="comment">// 7 4 2 5 8 6 3 1</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>面试题8：二叉树的下一个节点</p></blockquote><p>给定二叉树和其中的一个节点，如何<strong>找出中序遍历序列的下一个节点</strong>？树节点除了有左右子节点指针，还有一个指向父节点的指针。</p><p>这类题目一般从各类情况具体分析入手：</p><ul><li>如果<strong>节点有右子树</strong>，则下一个节点就是<strong>右子树中的最左子节点</strong>；</li><li>如果<strong>节点没有右子树</strong>：<ul><li>如果该节点是<strong>父节点的左子节点</strong>，<strong>父节点</strong>就是下一个节点；</li><li>并且该节点是<strong>父节点的右子节点</strong>，按照中序遍历的逻辑，需要继续往上寻找，<strong>直到找到某一个节点A，这个节点A是A父节点的左子节点</strong>，如果不存在这样的节点，那就代表原节点为最后一个遍历节点了，没有下一个节点。</li></ul></li></ul><p>面试中遇到这种题，大概率只需要编写指定功能的函数部分，不需要编写完整的代码，所以需要对面试官询问具体的输入输出情况。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> value;</span><br><span class="line">    Node* left;</span><br><span class="line">    Node* right;</span><br><span class="line">    Node* parent;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">Node* <span class="title">find_next</span><span class="params">(Node* node)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(node == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Node* next = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">if</span>(node-&gt;right != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="comment">// 右子树的最左子节点（不一定需要是叶节点）</span></span><br><span class="line">        Node* temp = node-&gt;right;</span><br><span class="line">        <span class="keyword">while</span>(temp-&gt;left != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            temp = temp-&gt;left;</span><br><span class="line">        &#125;</span><br><span class="line">        next = temp;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (node-&gt;parent != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="comment">// 寻找满足条件的祖先节点</span></span><br><span class="line">        <span class="comment">// 某个节点是其父节点的左子节点</span></span><br><span class="line">        Node* temp = node;</span><br><span class="line">        Node* parent = node-&gt;parent;</span><br><span class="line">        <span class="keyword">while</span>(parent != <span class="literal">nullptr</span> &amp;&amp; temp == parent-&gt;right) &#123;</span><br><span class="line">            temp = parent;</span><br><span class="line">            parent = parent-&gt;parent;</span><br><span class="line">        &#125;</span><br><span class="line">        next = parent;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;树的操作会涉及大量指针，因此与树相关的面试题都不太容易。&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="剑指Offer" scheme="https://yumi-cn.github.io/categories/%E5%89%91%E6%8C%87Offer/"/>
    
    
    <category term="笔记" scheme="https://yumi-cn.github.io/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>《剑指Offer》第2章笔记 栈和队列</title>
    <link href="https://yumi-cn.github.io/2020/12/07/s2o-c2-stk-queue/"/>
    <id>https://yumi-cn.github.io/2020/12/07/s2o-c2-stk-queue/</id>
    <published>2020-12-07T12:17:27.000Z</published>
    <updated>2020-12-07T14:14:52.856Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>栈：先进后出，队列：先进先出。</p></blockquote><a id="more"></a><p>栈是一个非常常见的数据结构，在计算机领域被广泛应用，比如操作系统会给每个线程创建一个栈用来存储函数调用时各个函数的参数、返回地址以及临时变量等。栈的特点是<strong>后进先出</strong>。</p><p>在栈中通常需要<code>O(n)</code>时间才能找到栈最大或者最小的元素，如果想<code>O(1)</code>时间内找到则需要做特殊的设计。</p><p>队列是另一种很重要的数据结构，队列的特点是<strong>先进先出</strong>。</p><blockquote><p>面试题9：用两个栈实现队列</p></blockquote><p>使用栈实现队列的两个函数<code>appendTail</code>和<code>deleteHead</code>，分别完成在队列尾部插入节点和在队列头部删除节点的功能。</p><p>一个典型的队列定义：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="class"><span class="keyword">class</span> <span class="title">CQueue</span> &#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        CQueue(<span class="keyword">void</span>);</span><br><span class="line">        ~CQueue(<span class="keyword">void</span>);</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">appendTail</span><span class="params">(<span class="keyword">const</span> T&amp; node)</span></span>;</span><br><span class="line">        <span class="function">T <span class="title">deleteHead</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="built_in">stack</span>&lt;T&gt; stack1;</span><br><span class="line">        <span class="built_in">stack</span>&lt;T&gt; stack2;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>至于这道题的解法，基于一个简单的原理，将一组数先进行依次进栈、再依次出栈入栈到另一个栈里，再全部进行出栈，就完成了一个简单的队列先进先出。但如果只是单纯的依赖这样的过程，无法极大程度地利用栈的空间（例如用于出栈<code>deleteHead</code>的栈满时，用于进栈<code>appendTail</code>其实还可以继续利用起来）。</p><p>定义stack1为入队栈，stack2为出队栈。</p><ul><li>入队操作：<ul><li>当stack1不满时，直接入栈；</li><li>当stack1满时：<ul><li>如果stack2为空，将stack1中的元素依次出栈入栈stack2；</li><li>如果stack2中有元素，则无法入队；</li></ul></li></ul></li><li>出队操作：<ul><li>当stack2中有元素是，直接出栈；</li><li>当stack2为空时：<ul><li>如果stack1不为空，将stack1所有元素依次出栈入栈stack2，再出栈栈顶元素；</li><li>如果stack1为空，则队列为空，无法出队；</li></ul></li></ul></li></ul><p>完整实现代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;exception&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="class"><span class="keyword">class</span> <span class="title">CQueue</span> &#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="comment">// CQueue(void);</span></span><br><span class="line">        <span class="comment">// ~CQueue(void);</span></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">appendTail</span><span class="params">(<span class="keyword">const</span> T&amp; node)</span></span>;</span><br><span class="line">        <span class="function">T <span class="title">deleteHead</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">stack</span>&lt;T&gt; stack1;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">stack</span>&lt;T&gt; stack2;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="keyword">void</span> CQueue&lt;T&gt;::appendTail(<span class="keyword">const</span> T&amp; element) &#123;</span><br><span class="line">    <span class="comment">// 不限制栈容量时，直接入栈</span></span><br><span class="line">    stack1.push(element);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; T CQueue&lt;T&gt;::deleteHead() &#123;</span><br><span class="line">    <span class="keyword">if</span>(stack2.size() &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">while</span>(stack1.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            T&amp; data = stack1.top(); <span class="comment">// Why use T&amp;</span></span><br><span class="line">            stack1.pop();</span><br><span class="line">            stack2.push(data);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(stack2.size() == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// Throw Empty Error</span></span><br><span class="line">        <span class="function"><span class="built_in">std</span>::logic_error <span class="title">ex</span><span class="params">(<span class="string">&quot;queue is empty&quot;</span>)</span></span>;</span><br><span class="line">        <span class="keyword">throw</span> <span class="built_in">std</span>::exception(ex);</span><br><span class="line">    &#125;</span><br><span class="line">    T head = stack2.top();</span><br><span class="line">    stack2.pop();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    CQueue&lt;<span class="keyword">int</span>&gt; cqueue;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">        cqueue.appendTail(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; cqueue.deleteHead() &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">5</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">        cqueue.appendTail(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">7</span>; i++) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; cqueue.deleteHead() &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>相关题目：用两个队列实现一个栈。</p><p>简单分析一下思路，模仿入栈操作时，只能用使用入队操作，当需要出栈时，元素在队列尾部，只能将前面所有元素进行出队才能获取到，而出队剩下的元素就继续进入到第二个队列中。</p>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;栈：先进后出，队列：先进先出。&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="剑指Offer" scheme="https://yumi-cn.github.io/categories/%E5%89%91%E6%8C%87Offer/"/>
    
    
    <category term="笔记" scheme="https://yumi-cn.github.io/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>《3D图形的数学》第2章笔记 矩阵</title>
    <link href="https://yumi-cn.github.io/2020/12/01/3dmath-c2/"/>
    <id>https://yumi-cn.github.io/2020/12/01/3dmath-c2/</id>
    <published>2020-12-01T09:19:10.000Z</published>
    <updated>2020-12-01T12:51:52.499Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>在三维变换中，矩阵运算是最常用的表达方式。</p></blockquote><a id="more"></a><h2 id="1-矩阵的性质"><a href="#1-矩阵的性质" class="headerlink" title="1 矩阵的性质"></a>1 矩阵的性质</h2><p>一个 \(n \times m\) 的矩阵M就是一个有n行和m列的数组，如果 \(n = m\) 则矩阵M是方阵，把矩阵M第j列的第i行元素（或者第i行第j列）记作 \(M_{ij}\)。</p><p><strong>矩阵M的转置</strong>，记作 \(\textbf{M}^{T}\)，是一个\(m \times n\)矩阵，其中 \(M_{ij}^{T} = M_{ji}\)。</p><p><strong>矩阵的数乘</strong>，或者叫标量乘积，和向量类似，是乘以矩阵的每个元素。</p><p><strong>矩阵的加法</strong>，两个相同大小的矩阵，对应行列的元素相加。</p><p><strong>矩阵的乘法</strong>，如果矩阵F的行数和矩阵G的列数相等，则矩阵F和G可以相乘，假设F是\(n \times m\)的矩阵，G是\(m \times p\)的矩阵，FG就是\(n \times p\)的矩阵，FG在(i, j)位置上的元素可以表示为：</p><div>$$(\textbf{F}\textbf{G})_{ij} = \sum_{k=1}^{m}F_{ik}G_{kj} = \textbf{F}_{i*} \cdot \textbf{G}_{*j} \tag{2.5}$$</div><p>其实也可以看作是矩阵F的第i行和矩阵G的第j列元素之间的点积。</p><p><strong>单位阵</strong>是\(n \times n\)的矩阵，记作\(\textbf{I}_{n}\)，对于\(n \times n\)的矩阵M，有 \( \textbf{M} \textbf{I}_{n}\) = \(\textbf{I}_{n} \textbf{M}\) = \(\textbf{M}\)。</p><div>$$\textbf{I}_{n} =\left[\begin{matrix}1 & 0 & \cdots & 0 \\0 & 1 & \cdots & 0 \\\vdots & \vdots & \ddots & \vdots \\0 & 0 & \cdots & 1\end{matrix}\right]\tag{2.6}$$</div><p>因为单位阵尺寸由情况而定，所以通常把下标n去掉，记作 \(\textbf{I}\)。</p><p><strong>【定理2.1】</strong> 矩阵有以下性质：</p><ul><li>矩阵加法满足交换律和结合律；</li><li>系数加法乘矩阵、系数乘矩阵加法，均满足分配率；</li></ul><p><strong>【定理2.2】</strong> 还具有以下性质：</p><ul><li>系数乘矩阵先后不影响结果；</li><li>矩阵连乘，先后不影响结果；</li><li>\((\textbf{F}\textbf{G})^{T}=\textbf{G}^{T}\textbf{F}^{T}\)。</li></ul><h2 id="2-线性方程组"><a href="#2-线性方程组" class="headerlink" title="2 线性方程组"></a>2 线性方程组</h2><p>矩阵提供了一种有效并且简便的线性方程组表示法，例如线性方程组：</p><div>$$\begin{aligned}3x + 2y - 3z &= 5 \\4x - 3y + 6z &= 1 \\x - z &= 3\end{aligned}\tag{2.10}$$</div><p>可以用以下矩阵形式表示：</p><div>$$\left[\begin{matrix}3 & 2 & -3 \\4 & -3 & 6 \\1 & 0 & -1\end{matrix}\right]\left[\begin{matrix}x \\y \\z\end{matrix}\right]= \left[\begin{matrix}5 \\1 \\3\end{matrix}\right]\tag{2.11}$$</div><p>在未知向量&lt;x,y,z&gt;前面的矩阵叫做<strong>系数矩阵</strong>，在等号右边的列向量叫做<strong>常数向量</strong>。常数向量不为0的线性方程组叫做<strong>非齐次方程组</strong>，常数向量为0叫做<strong>齐次方程组</strong>。</p><p>把系数矩阵和常数向量并置一起（称为增广矩阵），执行基本行变换，就可以得到线性方程组的解。</p><p><strong>【定义2.3】</strong> 所谓<strong>基本行变换</strong>就是对一个矩阵执行以下三种变换之一：</p><ul><li>两行相互交换；</li><li>一行和不为0的系数相乘；</li><li>一行与一个不为0的系数乘后加到另一行上。</li></ul><p>方程(2.11)为例，写出增广矩阵：</p><div>$$\left[\begin{array}{ccc|c}3 & 2 & -3 & 5 \\4 & -3 & 6 & 1 \\1 & 0 & -1 & 3\end{array}\right]\tag{2.12}$$</div><p>对线性方程组的增广矩阵进行的行变换不会影响线性方程组的解，只是使线性方程组更加容易计算（可以同步理解成，一般求方程组解的步骤，使用方程组互相带入化简，使得方程组最后较容易解出值）。</p><p><strong>当用行变换求解一个线性方程组时，目标是把系数矩阵变换为它的最简形式</strong>。</p><p><strong>【定义2.4】</strong> 当且仅当一个矩阵满足一下条件，称为最简形式：</p><ul><li>每一个非0行，最左边的非0元素，即前导元素，必须为1；</li><li>每一个非0行均在全0行前面，或者说，全0行在矩阵底部；</li><li>如果一行前导元素在第j列，则其他行第j列的元素均为0；</li><li>对任意两个非0行 \(i_{2}\) 和 \(i_{1}\)，如果满足\(i_{2} &gt; i_{1}\)，并且相应的前导元素分别位于\(j_{2}\)和\(j_{1}\)列，则必然存在\(j_{2} &gt; j_{1}\)。</li></ul><p>或者简单来说，对于最简形式的矩阵，前导元素是向下向右的趋势的，并且，包含前导元素的列只有一个1，其他元素都为0。</p><p>一个最简形式矩阵例子：</p><div>$$\left[\begin{matrix}1 & 0 & -3 & 0 \\0 & 1 & 2 & 0 \\0 & 0 & 0 & 1 \\0 & 0 & 0 & 0 \end{matrix}\right]\tag{2.14}$$</div><p><strong>【算法2.6】</strong> 把一个线性方程组的 \(n \times (n+1)\) 增广矩阵M变换为最简形式，以下每一步的M在逐渐更新，而不是保持原始状态：</p><ol><li>下标i=1；</li><li>下标j=1，从第1列到第n列开始循环；</li><li>找到一个满足行号 \(k \geq i\)，并且 \(\textbf{M}_{kj} \neq 0\) 的行，如果不存在，跳到步骤8；</li><li>如果 \(k \neq i\)，交换第k行和第i行；</li><li>使矩阵M的元素(i, j)变为1：将第i行乘以 \(1 / \textbf{M}_{ij}\)；</li><li>把第j列中除第i行之外的元素变为0：对于每一行r，\(1 \leq r \leq n\) 且 \(r \neq i\)，将第i行乘 \(-\textbf{M}_{rj}\)加到第r行上；</li><li>i加1；</li><li>如果\(j \leq n\)，j加1，跳到步骤3。</li></ol><p>简单来说，就是每次找到第j列上的前导元素在哪一行，然后把这一行放在对应的位置上，让前导元素变1，再清除第j列上的其它元素，直到再找不到有前导元素的行，算法停止。</p><p>对于化简到最简形式后，如何判断方程组解的情况，有以下规律：</p><ul><li>如果系数矩阵的最简形式是一个单位阵，<strong>方程组有唯一解</strong>；</li><li>如果有一行或多行全为0，方程组要么无解，要么有无穷多解；</li><li>如果某一行系数矩阵为0而常数向量不为0，<strong>则方程组无解</strong>。</li></ul><h2 id="3-逆矩阵"><a href="#3-逆矩阵" class="headerlink" title="3 逆矩阵"></a>3 逆矩阵</h2><p>对一个\(n \times n\)的矩阵M而言，如果存在一个矩阵\(M^{-1}\)，使得 \(\textbf{M}\textbf{M}^{-1}=\textbf{M}^{-1}\textbf{M}=\textbf{I}\)，则称矩阵M是可逆的，矩阵\(M^{-1}\)叫做M的逆矩阵。</p><p>并不是每个矩阵都可逆，没有逆矩阵的矩阵叫做奇异矩阵，例如任何一行或一列为0的矩阵就是奇异矩阵。</p><p><strong>【定理2.9】</strong> 有一行或一列全为0的矩阵是不可逆的。</p><p><strong>【定理2.10】</strong> 一个矩阵M是可逆的，当且仅当\(M^{T}\)是可逆的。</p><p><strong>证明：</strong></p><p>假设M是可逆的，则\(M^{-1}\)存在，所以有：</p><div>$$\textbf{M}^{T}(\textbf{M}^{-1})^{T} =(\textbf{M}^{-1}\textbf{M})^{T} = \textbf{I}^{T} = \textbf{I}\tag{2.29}$$</div><p>并且</p><div>$$(\textbf{M}^{-1})^{T}\textbf{M}^{T} =(\textbf{M}\textbf{M}^{-1})^{T} = \textbf{I}^{T} = \textbf{I}\tag{2.30}$$</div><p>因此，\((\textbf{M}^{-1})^{T}\)是 \(\textbf{M}^{T}\)的逆矩阵。</p><p>类似，如果假设\(\textbf{M}^{T}\)是可逆的，则\((\textbf{M}{T})^{-1}\)存在：</p><div>$$\textbf{M}[(\textbf{M}^{T})^{-1}]^{T} =[(\textbf{M}^{T})^{-1}\textbf{M}^{T})]^{T} =\textbf{I}^{T} = \textbf{I}\tag{2.31}$$</div><p>而且</p><div>$$[(\textbf{M}^{T})^{-1}]^{T}\textbf{M} =[(\textbf{M}^{T}(\textbf{M}^{T})^{-1})]^{T} =\textbf{I}^{T} = \textbf{I}\tag{2.32}$$</div><p>因此，\([(\textbf{M}^{T})^{-1}]^{T}\)是M的逆矩阵。</p><p><strong>【定理2.11】</strong> 如果F和G都是\(n \times n\)的可逆矩阵，那么FG也是可逆的，并且 \((\textbf{F}\textbf{G})^{-1}\) = \(\textbf{G}^{-1}\textbf{F}^{-1}\)。</p><p>求矩阵最简形式的方法（算法2.6）也可以用来计算矩阵逆矩阵，为了计算\(n \times n\)矩阵的逆矩阵，在矩阵的右边并接一个单位阵，以形成一个\(n \times 2n\)的矩阵。</p><div>$$\left[\begin{array}{cccc|cccc}M_{11} & M_{12} & \cdots & M_{1n} & 1 & 0 & \cdots & 0 \\M_{21} & M_{22} & \cdots & M_{2n} & 0 & 1 & \cdots & 0 \\\vdots & \vdots & \ddots & \vdots & \vdots & \vdots & \ddots & \vdots \\M_{n1} & M_{n2} & \cdots & M_{nn} & 0 & 0 & \cdots & 1\end{array}\right]\tag{2.34}$$</div><p>对整个矩阵执行基本行变换操作，直到其左边的\(n \times n\)矩阵变为单位阵，这时右边的\(n \times n\)部分就是M的逆矩阵，如果左边无法化为单位矩阵，则该矩阵不可逆。</p><p><strong>【定理2.14】</strong> 假设(n \times n\)矩阵 \(M^{‘}\)是(n \times n\)矩阵M进行基本变换后得到的矩阵，则有 \(M^{‘}=EM\)，其中E是对单位阵进行相同的基本变换的最终矩阵。</p><p>把<strong>单位阵</strong>经过<strong>行变换</strong>后得到的矩阵称为<strong>初等矩阵</strong>，如果为了把矩阵M变为单位阵而必须经过k次基本行变换，那么：</p><div>$$\textbf{I} = \textbf{E}_{k}\textbf{E}_{k-1} \cdots \textbf{E}_{1}\textbf{M}\tag{2.47}$$</div><p>其中矩阵 \(\textbf{E}_{1}, \textbf{E}_{2}, \cdots, \textbf{E}_{k}\)是单位阵对应的k次行变换的初等矩阵，也就是说，矩阵 \(\textbf{E}_{k}\textbf{E}_{k-1} \cdots \textbf{E}_{1}\)之间的积即为M的逆矩阵。</p><p><strong>【定理2.15】</strong> 当且仅当矩阵M的<strong>行是一个线性无关向量集</strong>时，(n \times n\)矩阵M是可逆的。</p><h2 id="4-行列式"><a href="#4-行列式" class="headerlink" title="4 行列式"></a>4 行列式</h2><p>方阵的行列式得到的是一个标量，矩阵M的行列式记作\(det \textbf{M}\)，行列式使用垂直线取代矩阵两侧的括号。</p><div>$$det \textbf{M} =\left|\begin{matrix}M_{11} & M_{12} & M_{13} \\M_{21} & M_{22} & M_{23} \\M_{31} & M_{32} & M_{33}\end{matrix}\right|\tag{2.50}$$</div><p>\(n \times n\)矩阵M的行列式的值由一个递推公式给出，用符号 \(M^{|i, j|}\)表示原始矩阵M中第i行和第j列删除后行程的 \((n-1) \times (n-1)\)矩阵，用这种方法，行列式值可用以下方法计算：</p><div>$$det \textbf{M} = \sum_{i=1}^{n}(-1)^{i+k}M_{ik} det \textbf{M}^{|i,k|}\tag{2.53}$$</div><div>$$det \textbf{M} = \sum_{i=1}^{n}(-1)^{k+j}M_{kj} det \textbf{M}^{|k,j|}\tag{2.54}$$</div><p>其中k是满足条件 \(1 \leq k \leq n\)的任意常数。</p><p>二阶矩阵的行列式公式：</p><div>$$\left|\begin{matrix}a & b \\c & d\end{matrix}\right|= ad - bc\tag{2.55}$$</div><p>三阶矩阵的行列式公式：</p><div>$$\begin{aligned}\left|\begin{matrix}a_{11} & a_{12} & a_{13} \\a_{21} & a_{22} & a_{23} \\a_{31} & a_{32} & a_{33}\end{matrix}\right|= a_{11}det\textbf{M}^{|1,1|} - a_{12}det\textbf{M}^{|1,2|} + a_{13}det\textbf{M}^{|1,3|} \\= a_{11}(a_{22}a_{33}-a_{23}a_{32}) -a_{12}(a_{21}a_{33}-a_{23}a_{31}) +a_{13}(a_{21}a_{32}-a_{22}a_{31})\end{aligned}\tag{2.56}$$</div><p><strong>【定理2.16】</strong> 执行基本变换对一个矩阵的行列式有以下性质：</p><ul><li>两行交换，行列式取反；</li><li>矩阵一行乘比例系数a则行列式变为原来的a倍；</li><li>把一行的若干倍加到另一行对行列式没有影响。</li></ul><p><strong>【推论2.17】</strong> 如果矩阵有相同行，则行列式为0。</p><p><strong>【定理2.18】</strong> \(n \times n\)矩阵M当且仅当 \(det \textbf{M} \neq 0\)时是可逆的。</p><p><strong>【定理2.19】</strong> 对任意两个 \(n \times n\)的矩阵F和G，有 \(det\textbf{F}\textbf{G}=det\textbf{F}det\textbf{G}\)。</p><p>Tips：初等矩阵乘积的行列式等于行列式的乘积。</p><p><strong>【定理2.20】</strong> 假设F是 \(n \times n\)矩阵，如果另一 \(n \times n\)矩阵G的元素为：</p><div>$$G_{ij} = (-1)^{i + j} \frac{det \textbf{F}^{|j, i|}}{det \textbf{F}}\tag{2.62}$$</div><p>那么 \(\textbf{G}=\textbf{F}^{-1}\)。</p><p>通过定理2.20可以推出图形学中经常用的几个逆矩阵计算公式主要是2阶和3阶的。</p><p>2阶方阵逆矩阵公式：</p><div>$$\textbf{A}^{-1} = \frac{1}{det \textbf{A}}\left[\begin{matrix}A_{22} & -A_{12}\\-A_{21} & A_{11}\end{matrix}\right]\tag{2.63}$$</div><p>3阶方阵逆矩阵公式：</p><div>$$\textbf{B}^{-1} = \frac{1}{det \textbf{B}}\left[\begin{matrix}B_{22}B_{33}-B_{23}B_{32} & B_{13}B_{32}-B_{12}B_{33} & B_{12}B_{23}-B_{13}B_{22} \\B_{23}B_{31}-B_{21}B_{33} & B_{11}B_{33}-B_{13}B_{31} & B_{13}B_{21}-B_{11}B_{23} \\B_{21}B_{32}-B_{22}B_{31} & B_{12}B_{31}-B_{11}B_{32} & B_{11}B_{22}-B_{12}B_{21}\end{matrix}\right]$$</div><h2 id="5-特征值与特征向量"><a href="#5-特征值与特征向量" class="headerlink" title="5 特征值与特征向量"></a>5 特征值与特征向量</h2><p>对于<strong>可逆方阵</strong>，<strong>必然</strong>存在一个<strong>向量</strong>，当该<strong>向量与可逆方阵相乘</strong>时，<strong>向量只会发生大小变换而方向不变</strong>，即，对于n阶方阵M，存在着非0的n维向量 \(\textbf{V}_{1}, \textbf{V}_{2}, \cdots, \textbf{V}_{n}\)满足：</p><div>$$\textbf{M}\textbf{V}_{i} = \lambda_{i}\textbf{V}_{i}\tag{2.65}$$</div><p>其中比例系数 \(\lambda_{i}\) 称为矩阵M的特征值，而向量 \(\textbf{V}_{i}\)是对应特征值的特征向量。</p><p>对式（2.65）进行变换可得到矩阵的特征值：</p><div>$$(\textbf{M}-\lambda_{i}\textbf{I})\textbf{V}_{i} = \textbf{0}\tag{2.66}$$</div><p>对于非0向量 \(\textbf{V}_{i}\)，如果上式成立，矩阵 \(\textbf{M}-\lambda_{i}\textbf{I}\)一定是奇异矩阵（不可逆），否则就可以对其求逆，得到:</p><div>$$\textbf{V}_{i} = (\textbf{M}-\lambda_{i}\textbf{I})^{-1}\textbf{0} = \textbf{0}\tag{2.67}$$</div><p>这个非0向量矛盾，所以矩阵 \(\textbf{M}-\lambda_{i}\textbf{I}\)的行列式为0，因此可以通过：</p><div>$$det(\textbf{M}-\lambda\textbf{I}) = 0\tag{2.68}$$</div><p>计算出矩阵的特征值解，由2.68式得出的关于 \(\lambda\)的n阶多项式叫做矩阵M的特征多项式，多项式的根就是矩阵M的特征值。</p><p>一旦矩阵的特征值求得，就可以代入式(2.66)，计算出相应的特征向量，因为矩阵 \(\textbf{M}-\lambda_{i}\textbf{I}\) 是奇异的，所以简化形式至少有一行全为0，所以有无穷多解（比如特征向量的系数倍数向量也是特征向量），因此特征向量可以表示成任意常数的形式，如果有必要也可以取特征向量的长度为1。</p><p>通常，<strong>如果矩阵特征值是复数，则相应的特征向量也含有复数元素</strong>；确保有实数特征值以及相应的实数特征向量的矩阵是<strong>对称矩阵</strong>。</p><p><strong>【定义2.23】</strong> 一个n阶方阵，当且仅当 对任意i和j均有 \(M_{ij}=M_{ji}\) 时是对称矩阵，也就是说如果矩阵元素关于主对角线对称，则该矩阵就成为<strong>对称矩阵</strong>。</p><p><strong>【定理2.24】</strong> 矩阵<strong>元素为实数</strong>的对称矩阵的特征值也是实数。</p><p><strong>【定理2.25】</strong> 对应于<strong>对称矩阵</strong>M的<strong>不同特征值的特征向量</strong>是<strong>正交</strong>的。</p><h2 id="6-对角化"><a href="#6-对角化" class="headerlink" title="6 对角化"></a>6 对角化</h2><p>对角矩阵（对称矩阵的特例），只在主对角线上有非0元素的矩阵。</p><p>给定方阵M，如果能找到一个矩阵A使得 \(\textbf{A}^{-1}\textbf{M}\textbf{A}\) 是对角矩阵，那么就说矩阵A将矩阵M对角化了。</p><p><strong>【定理2.26】</strong> 假设M是特征值为 \(\lambda_{1}, \lambda_{2}, \cdots, \lambda_{n}\)的n阶方阵，且与特征值对应的特征向量 \(\textbf{V}_{1}, \textbf{V}_{2}, \cdots, \textbf{V}_{n}\) 是一个<strong>线性无关集</strong>，则矩阵A：</p><div>$$A = [ \textbf{V}_{1} \textbf{V}_{2} \cdots \textbf{V}_{n} ]\tag{2.82}$$</div><p>可以将矩阵M对角化，而且 \(\textbf{A}^{-1}\textbf{M}\textbf{A}\) 的主对角元素是矩阵M的特征值，即：</p><div>$$\textbf{A}^{-1}\textbf{M}\textbf{A} =\left[\begin{matrix}\lambda_{1} & 0 & \cdots & 0 \\0 & \lambda_{2} & \cdots & 0\\\vdots & \vdots & \ddots & \vdots\\0 & 0 & \cdots & \lambda_{n}\end{matrix}\right]\tag{2.83}$$</div><p>相反，如果存在一个可逆矩阵A使得 \(\textbf{A}^{-1}\textbf{M}\textbf{A}\) 是一个对角阵，则矩阵A的列必然是矩阵M的特征向量，而 \(\textbf{A}^{-1}\textbf{M}\textbf{A}\) 的对角线元素则是矩阵M的特征值。</p>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;在三维变换中，矩阵运算是最常用的表达方式。&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="3D游戏与图形学的数学" scheme="https://yumi-cn.github.io/categories/3D%E6%B8%B8%E6%88%8F%E4%B8%8E%E5%9B%BE%E5%BD%A2%E5%AD%A6%E7%9A%84%E6%95%B0%E5%AD%A6/"/>
    
    
    <category term="笔记" scheme="https://yumi-cn.github.io/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>《剑指Offer》第2章笔记 链表</title>
    <link href="https://yumi-cn.github.io/2020/11/30/s2o-c2-linked/"/>
    <id>https://yumi-cn.github.io/2020/11/30/s2o-c2-linked/</id>
    <published>2020-11-30T11:09:59.000Z</published>
    <updated>2020-11-30T12:17:30.456Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>链表应该是面试时被提及最频繁的数据结构。</p></blockquote><a id="more"></a><p>链表的结构很简单，它由指针把若干个节点连接成链状结构，链表的创建、插入节点、删除节点等操作都只需要20行左右的代码就能实现，代码量比较适合面试（哈希表、有向图等复杂的一个操作可能就需要很多代码）。</p><p>链表是一种动态数据结构，创建链表时，无须知道链表长度，插入节点时，只需要为新节点分配内存，然后调整指针的指向来确保新节点被链接到链表中；内存分配不是在创建链表时一次性完成的，而是每添加一个节点分配一次内存。</p><p>典型的单向链表节点定义：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> value;</span><br><span class="line">    Node* next;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>往链表末尾添加一个节点：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add_to_tail</span><span class="params">(Node** phead, <span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 头结点是一个指针的指针</span></span><br><span class="line">    Node* pnew = <span class="keyword">new</span> Node();</span><br><span class="line">    pnew-&gt;value = value;</span><br><span class="line">    pnew-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">if</span>(*phead == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="comment">// 创建头节点</span></span><br><span class="line">        *phead = pnew;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 添加节点到尾部</span></span><br><span class="line">        Node* pnode = *phead;</span><br><span class="line">        <span class="keyword">while</span>(pnode-&gt;next != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            pnode = pnode-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        pnode-&gt;next = pnew;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>想要在链表中找到第i个节点，那我们只能从头结点开始遍历链表，时间效率为<code>O(n)</code>，而在数组中只需要<code>O(1)</code>的时间。</p><p>找到第一个含有某值节点并删除该节点的代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">remove_node</span><span class="params">(Node** phead, <span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(phead==<span class="literal">nullptr</span> || *phead==<span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Node* p_delete = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">if</span>((*phead)-&gt;value == value) &#123;</span><br><span class="line">        <span class="comment">// 头结点删除需要单独考虑操作</span></span><br><span class="line">        p_delete = *phead;</span><br><span class="line">        *phead = (*phead)-&gt;next;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        Node* pnode = *phead;</span><br><span class="line">        <span class="comment">// 寻找删除节点的前一个节点</span></span><br><span class="line">        <span class="keyword">while</span>(pnode-&gt;next != <span class="literal">nullptr</span></span><br><span class="line">            &amp;&amp; pnode-&gt;next-&gt;value != value) &#123;</span><br><span class="line">                pnode = pnode-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(pnode-&gt;next != <span class="literal">nullptr</span> &amp;&amp; pnode-&gt;next-&gt;value == value) &#123;</span><br><span class="line">            <span class="comment">// 调整删除节点前一个节点的链接</span></span><br><span class="line">            p_delete = pnode-&gt;next;</span><br><span class="line">            pnode-&gt;next = pnode-&gt;next-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(p_delete != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="keyword">delete</span> p_delete;</span><br><span class="line">        p_delete = <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一些特殊形式的链表也会被经常考到：</p><ul><li>环形链表：链表末尾节点指向头结点（面试题62）；</li><li>双向链表：节点还有一个指向前一个节点的指针（面试题36）；</li><li>复杂链表：节点还有拥有指向任意节点的指针（面试题35）。</li></ul><blockquote><p>面试题6：从尾到头打印链表</p></blockquote><p>输入一个链表的头节点，从尾到头反过来打印每个节点的值。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> value;</span><br><span class="line">    Node* next;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>Tips：如果打算修改输入数据，最好先问面试官是不是允许修改，这里假设面试官不能改变链表的结构。</p><p>这道题目需要先访问的节点后输出，可以想到使用栈这种数据结构，每次访问到节点，就压到栈中，输出的时候只需要循环出栈即可。</p><p>完整代码实现：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> value;</span><br><span class="line">    Node* next;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add_to_tail</span><span class="params">(Node** phead, <span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 头结点是一个指针的指针</span></span><br><span class="line">    Node* pnew = <span class="keyword">new</span> Node();</span><br><span class="line">    pnew-&gt;value = value;</span><br><span class="line">    pnew-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">if</span>(*phead == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="comment">// 创建头节点</span></span><br><span class="line">        *phead = pnew;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 添加节点到尾部</span></span><br><span class="line">        Node* pnode = *phead;</span><br><span class="line">        <span class="keyword">while</span>(pnode-&gt;next != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            pnode = pnode-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        pnode-&gt;next = pnew;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">reverse_print</span><span class="params">(Node** phead)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(phead==<span class="literal">nullptr</span> || *phead==<span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">stack</span>&lt;Node*&gt; pstack;</span><br><span class="line">    Node* pnode = *phead;</span><br><span class="line">    <span class="keyword">while</span>(pnode != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        pstack.push(pnode);</span><br><span class="line">        pnode = pnode-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(!pstack.empty()) &#123;</span><br><span class="line">        pnode = pstack.top();</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\t&quot;</span>, pnode-&gt;value);</span><br><span class="line">        pstack.pop();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> values[] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line">    Node** phead = <span class="keyword">new</span> Node*;</span><br><span class="line">    *phead = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">        add_to_tail(phead, values[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    reverse_print(phead);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>具体的实现中需要注意到的一个点是头节点的初始化，因为是指针的指针，所以需要先申请一个<strong>Node指针类型的指针</strong>，<code>new Node*</code>，然后再将头结点指向的节点设置为<code>nullptr</code>，这样才不会在访问时出错。</p><p>如果可以使用栈结构来实现，也可以考虑使用递归的方式实现，通过递归访问，只有在返回函数的时候再输出节点，就可以实现逆序输出。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 调用的时候要使用 *phead</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">reverse_print_rec</span><span class="params">(Node* node)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(node == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    reverse_print_rec(node-&gt;next);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\t&quot;</span>, node-&gt;value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>递归的代码相比于使用栈会简洁很多，但是使用递归是有代价的，函数递归使用的栈空间通常会有限制（比自己建立栈的空间要小），所以如果链表过于长可能会导致函数调用栈溢出。</p>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;链表应该是面试时被提及最频繁的数据结构。&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="剑指Offer" scheme="https://yumi-cn.github.io/categories/%E5%89%91%E6%8C%87Offer/"/>
    
    
    <category term="笔记" scheme="https://yumi-cn.github.io/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
</feed>
