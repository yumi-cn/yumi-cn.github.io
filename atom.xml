<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>画码余生</title>
  
  <subtitle>副标题</subtitle>
  <link href="https://yumi-cn.github.io/atom.xml" rel="self"/>
  
  <link href="https://yumi-cn.github.io/"/>
  <updated>2021-01-23T08:07:25.468Z</updated>
  <id>https://yumi-cn.github.io/</id>
  
  <author>
    <name>Yumiko</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>《剑指Offer》第6章笔记 各项能力</title>
    <link href="https://yumi-cn.github.io/2021/01/23/s2o-c6/"/>
    <id>https://yumi-cn.github.io/2021/01/23/s2o-c6/</id>
    <published>2021-01-23T08:04:48.000Z</published>
    <updated>2021-01-23T08:07:25.468Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>沟通和学习能力是面试中关键的考查点。</p></blockquote><a id="more"></a><h2 id="1-面试官谈能力"><a href="#1-面试官谈能力" class="headerlink" title="1 面试官谈能力"></a>1 面试官谈能力</h2><p>大佬们说的名言名句。</p><p>咕咕待更。</p><h2 id="2-沟通能力和学习能力"><a href="#2-沟通能力和学习能力" class="headerlink" title="2 沟通能力和学习能力"></a>2 沟通能力和学习能力</h2><ol><li>沟通能力</li></ol><p>随着软件、系统功能越来越复杂，开发团队的规模也随之扩张，开发者、测试者和项目经理之间的沟通交流也变得越来越重要。也正因如此，很多公司在面试的时候都会注意考查应聘者的沟通能力。这邀请应聘者无论是在<strong>介绍项目经验</strong>还是在<strong>介绍解题思路</strong>的时候，都需要<strong>逻辑清晰明了</strong>，<strong>语言详略得当</strong>，表述的时候<strong>重点突出、观点明确</strong>。</p><ol start="2"><li>学习能力</li></ol><p>计算机是一门更新速度很快的学科，每年都有新的技术不断涌现。因此，作为从业人员<strong>需要具备很强的学习能力</strong>，否则时间一长就会跟不上技术进步的步伐，也正是因为这个原因，IT公司在面试的时候，都会重视考查应聘者的学习能力。只有具备很强的学习能力及学习愿望的人，才能<strong>不断完善自己的知识结构，不断学习新的先进技术</strong>，让自己的职业生涯保持长久的生命力。</p><p>通常面试官有<strong>两种方法考查应聘者的学习能力</strong>。<strong>第一种方法</strong>是询问应聘者最近在<strong>看什么书或者在做什么项目、从中学到了哪些新技术</strong>。面试官可以用这个问题了解应聘者的学习愿望和学习能力。<strong>第二种方法是抛出一个新概念</strong>，接下来观察应聘者能不能在短时间内理解这个新概念并解决相关的问题。当面试官提出新概念时，他期待应聘者能够通过<strong>思考、提问、再思考的过程，理解它们并最终解决问题</strong>。</p><ol start="3"><li>善于学习、沟通的人也善于提问</li></ol><p>面试官提出一个新概念，应聘者没有听说过它，于是他在已有的理解基础上提出进一步地问题，在得到面试官答复之后，思考再提问，几个来回之后掌握了这个概念。这个过程就能体现应聘者的学习能力。建议应聘者在面试过程中遇到不明白的地方多提问，这样可以表现自己态度积极、求知欲望强烈（但是一些行业领域基础的东西不知道还是蛮尴尬的hhh）。</p><p>有些面试官故意一开始不把题目描述清楚，让题目存在一定的二义性，他期待应聘者可以一步步通过提问来弄明白题目的要求，这也是在考查应聘者的沟通能力（因为实际工作中也是这样的）。</p><h2 id="3-知识迁移能力"><a href="#3-知识迁移能力" class="headerlink" title="3 知识迁移能力"></a>3 知识迁移能力</h2><p>所谓学习能力，很重要的一点就是<strong>根据已经掌握的知识、技术，能够迅速学习、理解新的技术并运用到实际工作中去</strong>。大部分新的技术都不是凭空产生的，而是在已有技术的基础上发展起来的。这就要求我们能够把对已有技术的理解迁移到学习新技术的过程中去，也就是要具备很强的知识迁移能力。</p><p>面试官考查应聘者知识迁移能力的<strong>一种方法是把经典的问题稍作变换</strong>。这时候面试官期待应聘者能够找到和经典问题的联系，并从中受到启发，把解决经典问题的思路迁移过来解决新的问题。<strong>另一种方法是先问一个简单地问题</strong>，在应聘者答完简单地问题后，<strong>再追问一个相关的同时难度也更大的问题</strong>。这时候面试官希望应聘者能够总结前面解决简单问题的经验，把前面的思路、方法迁移过来。</p><p><strong>知识迁移能力的一种通俗的说法是“举一反三”的能力</strong>。<strong>面试题是刷不完的</strong>，不可能把所有的面试题都准备一遍，因此更重要的是每做一道面试题的时候，都要总结这道题的解法有什么特点，有哪些思路是可以应用到同类型的题目中去的。</p><h2 id="面试题53-59"><a href="#面试题53-59" class="headerlink" title="面试题53-59"></a>面试题53-59</h2><blockquote><p>面试题53：在排序数组中查找数字。</p></blockquote><p>题目一：数字在排序数组中出现的次数。</p><p>统计一个数字在排序数组中出现的次数，例如，输入排序数组<code>&#123;1,2,3,3,3,3,4,5&#125;</code>和3，由于3在这个数组中出现了4次，因此输出4。</p><p>最普通的遍历法时间复杂度<code>O(n)</code>，所以优化方法的时间复杂度肯定要优于<code>O(n)</code>。可以考虑用二分法方式寻找该数字的第一个位置和最后一个位置，然后就可以计算出出现次数了。在二分法时，首先找到有这个数的区间，当<code>mid</code>为寻找的目标数时，如果是寻找第一个位置，则看其左边是不是同样的数，如果是则在左侧继续寻找第一个位置，如果不是则<code>mid</code>就是第一个位置，寻找最后一个位置原理类似。</p><p>完整实现代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find_head</span><span class="params">(<span class="keyword">int</span>* data, <span class="keyword">int</span> start, <span class="keyword">int</span> end, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(start == end) &#123;</span><br><span class="line">        <span class="keyword">if</span>(data[start] == target) &#123;</span><br><span class="line">            <span class="keyword">return</span> start;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> mid = (start + end) / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span>(data[mid] == target) &#123;</span><br><span class="line">        <span class="keyword">if</span>(mid == <span class="number">0</span> || data[mid<span class="number">-1</span>] != target) &#123;</span><br><span class="line">            <span class="keyword">return</span> mid;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> find_head(data, start, mid<span class="number">-1</span>, target);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(data[mid] &lt; target) &#123;</span><br><span class="line">        <span class="keyword">return</span> find_head(data, mid+<span class="number">1</span>, end, target);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> find_head(data, start, mid<span class="number">-1</span>, target);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find_tail</span><span class="params">(<span class="keyword">int</span>* data, <span class="keyword">int</span> start, <span class="keyword">int</span> end, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(start == end) &#123;</span><br><span class="line">        <span class="keyword">if</span>(data[start] == target) &#123;</span><br><span class="line">            <span class="keyword">return</span> start;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> mid = (start + end) / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span>(data[mid] == target) &#123;</span><br><span class="line">        <span class="keyword">if</span>(mid == end || data[mid+<span class="number">1</span>] != target) &#123;</span><br><span class="line">            <span class="keyword">return</span> mid;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> find_tail(data, mid+<span class="number">1</span>, end, target);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(data[mid] &lt; target) &#123;</span><br><span class="line">        <span class="keyword">return</span> find_tail(data, mid+<span class="number">1</span>, end, target);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> find_tail(data, start, mid<span class="number">-1</span>, target);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">counts_in_order</span><span class="params">(<span class="keyword">int</span>* data, <span class="keyword">int</span> len, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(data == <span class="literal">nullptr</span> || len &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> head = find_head(data, <span class="number">0</span>, len<span class="number">-1</span>, target);</span><br><span class="line">    <span class="keyword">int</span> tail = find_tail(data, <span class="number">0</span>, len<span class="number">-1</span>, target);</span><br><span class="line">    <span class="keyword">if</span>(head == <span class="number">-1</span> || tail == <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> tail - head + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> data[] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Count:%d\n&quot;</span>, counts_in_order(data, <span class="number">8</span>, <span class="number">3</span>));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码中，<code>find_head</code>、<code>find_tail</code>都是二分查找算法在数组中查找数字，时间复杂度都是<code>O(logn)</code>，因此总的时间复杂度也是<code>O(logn)</code>。</p><p>题目二：<code>0~n-1</code>中缺失的数字。</p><p>一个长度<code>n-1</code>的递增排序数组中，所有数字都是唯一的，并且每个数字都在范围<code>0~n-1</code>中，在范围<code>0~n-1</code>内的n个数字中<strong>有且只有一个数字不在数组中</strong>，请找出这个数字。</p><p>最简单的方法是遍历数组求和，用<code>0~n-1</code>的总和<code>n(n-1)/2</code>相减就可以得到缺失的数字，但时间复杂度<code>O(n)</code>，可以观察<code>n-1</code>长度的数组，如果缺失了第<code>i</code>个数，由于排序的性质，对任意的<code>i&lt;j</code>第<code>j</code>个数会在<code>j-1</code>位置上，即不满足<code>j</code>在第<code>j</code>个位置上，所以问题转换为，找出第一个值和下标不相等的元素，利用二分法查找即可。</p><p>完整实现代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find_miss_num</span><span class="params">(<span class="keyword">int</span>* data, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(start == end) &#123;</span><br><span class="line">        <span class="keyword">if</span>(data[start] != start) &#123;</span><br><span class="line">            <span class="keyword">return</span> start;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> mid = (start + end) / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span>(data[mid] != mid) &#123;</span><br><span class="line">        <span class="keyword">if</span>(mid == start || data[mid<span class="number">-1</span>] == mid<span class="number">-1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> mid;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> find_miss_num(data, start, mid - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> find_miss_num(data, mid + <span class="number">1</span>, end);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find_miss_num</span><span class="params">(<span class="keyword">int</span>* data, <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(data == <span class="literal">nullptr</span> || len &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> find_miss_num(data, <span class="number">0</span>, len<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> data[] = &#123;<span class="number">0</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>&#125;;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Miss is %d\n&quot;</span>, find_miss_num(data, <span class="number">9</span>));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>题目三：数组中数值和下标相等的元素。</p><p>假设一个<strong>单调递增的数组</strong>里的每个元素都是整数并且<strong>唯一</strong>。请实现一个函数，找出数组中<strong>任意一个</strong>数值等于其下标的元素。例如，在数组<code>&#123;-3,-1,1,3,5&#125;</code>中，数字3和它的下标相等。</p><p>以<code>&#123;-3,-1,1,3,5&#125;</code>和<code>&#123;0,1,2,3,4&#125;</code>为例来分析，可以发现规律，<code>3</code>的左边都是<code>value &lt; index</code>，<code>3</code>的右边都是<code>value &gt; index</code>，根据这一点来判断二分查找的下一个位置。</p><p>完整实现代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find_index_eq_value</span><span class="params">(<span class="keyword">int</span>* data, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(start == end) &#123;</span><br><span class="line">        <span class="keyword">if</span>(data[start] == start) &#123;</span><br><span class="line">            <span class="keyword">return</span> start;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> mid = (start + end) / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span>(data[mid] == mid) &#123;</span><br><span class="line">        <span class="keyword">return</span> mid;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(data[mid] &lt; mid) &#123;</span><br><span class="line">        <span class="keyword">return</span> find_index_eq_value(data, mid + <span class="number">1</span>, end);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> find_index_eq_value(data, start, mid - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find_index_eq_value</span><span class="params">(<span class="keyword">int</span>* data, <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(data == <span class="literal">nullptr</span> || len &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> find_index_eq_value(data, <span class="number">0</span>, len<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> data[] = &#123;<span class="number">-3</span>, <span class="number">-1</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>&#125;;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Result: %d\n&quot;</span>, find_index_eq_value(data, <span class="number">5</span>));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><blockquote><p>面试题54：二叉搜索树的第K大节点。</p></blockquote><p>给定一棵二叉搜索树，请找出其中<strong>第K大的节点</strong>。例如在下图中的二叉搜索树，按节点数值大小顺序，第3大节点的值是4。</p><div align="center"><p><img src="/images/s2o-c6-f1.jpg"></p></div><p>书上的方法是直接简单的用二叉搜索树的性质，中序遍历即树中节点的递增排序，在中序遍历中找到第K大的节点。</p><p>完整实现代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> value;</span><br><span class="line">    node* pleft;</span><br><span class="line">    node* pright;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">node* <span class="title">init_node</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123; ... &#125;</span><br><span class="line"><span class="function">node* <span class="title">init_tree</span><span class="params">()</span> </span>&#123; ... &#125;</span><br><span class="line"></span><br><span class="line"><span class="function">node* <span class="title">find_kth_in_tree_core</span><span class="params">(node* proot, <span class="keyword">unsigned</span> <span class="keyword">int</span>&amp; k)</span> </span>&#123;</span><br><span class="line">    node* target = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="comment">// 中序遍历</span></span><br><span class="line">    <span class="keyword">if</span>(proot-&gt;pleft != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        target = find_kth_in_tree_core(proot-&gt;pleft, k);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(target == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="comment">// 没有在左子树中找到第k大</span></span><br><span class="line">        <span class="keyword">if</span>(k == <span class="number">1</span>) &#123;</span><br><span class="line">            target = proot;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 继续减少k</span></span><br><span class="line">        k--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(target == <span class="literal">nullptr</span> &amp;&amp; proot-&gt;pright != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        target = find_kth_in_tree_core(proot-&gt;pright, k);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> target;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">node* <span class="title">find_kth_in_tree</span><span class="params">(node* proot, <span class="keyword">unsigned</span> <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(proot == <span class="literal">nullptr</span> || k == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> find_kth_in_tree_core(proot, k);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    node* proot = init_tree();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%dth node is: %d&quot;</span>, <span class="number">3</span>, find_kth_in_tree(proot, <span class="number">3</span>)-&gt;value);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><blockquote><p>面试题55：二叉树的深度。</p></blockquote><p>题目一：二叉树的深度。</p><p>输入一棵二叉树的根节点，求该树的深度。从根节点到叶节点一次经过的节点（含根、叶节点）形成树的一条路径，<strong>最长路径的长度为树的深度</strong>。</p><p>节点定义如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> value;</span><br><span class="line">    node* pleft;</span><br><span class="line">    node* pright;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>思路比较简单，就是<strong>节点的深度等于左右子树的最大深度+1</strong>，递归地实现即可。</p><p>完整实现代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> value;</span><br><span class="line">    node* pleft;</span><br><span class="line">    node* pright;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">node* <span class="title">init_node</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123; ... &#125;</span><br><span class="line"><span class="function">node* <span class="title">init_tree</span><span class="params">()</span> </span>&#123; ... &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">tree_depth</span><span class="params">(node* proot)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(proot == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> left_depth = tree_depth(proot-&gt;pleft);</span><br><span class="line">    <span class="keyword">int</span> right_depth = tree_depth(proot-&gt;pright);</span><br><span class="line">    <span class="keyword">return</span> (left_depth &gt; right_depth) ? (left_depth + <span class="number">1</span>) : (right_depth + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    node* proot = init_tree();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Tree depth:%d\n&quot;</span>, tree_depth(proot));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>题目二：平衡二叉树。</p><p>输入一棵二叉树的根节点，<strong>判断该树是不是平衡二叉树</strong>。如果某二叉树中任意节点的左、右子树的深度相差不超过1，那么它就是一棵平衡二叉树。例如，下图就是一颗平衡二叉树。</p><div align="center"><p><img src="/images/s2o-c6-f2.jpg"></p></div><p>在题目一的基础上，在每个节点上一边判断是否平衡，同时一边返回他们的深度，如果是先检查深度，再去检查子树是否平衡，就会频繁多次的访问子节点，导致时间上的浪费。</p><p>完整实现代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> value;</span><br><span class="line">    node* pleft;</span><br><span class="line">    node* pright;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">node* <span class="title">init_node</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123; ... &#125;</span><br><span class="line"><span class="function">node* <span class="title">init_tree</span><span class="params">()</span> </span>&#123; ... &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">is_balanced</span><span class="params">(node* proot, <span class="keyword">int</span>* pdepth)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(proot == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        *pdepth = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> left, right;</span><br><span class="line">    <span class="keyword">if</span>(is_balanced(proot-&gt;pleft, &amp;left)</span><br><span class="line">       &amp;&amp; is_balanced(proot-&gt;pright, &amp;right)) &#123;</span><br><span class="line">        <span class="keyword">int</span> diff = left - right;</span><br><span class="line">        <span class="keyword">if</span>(diff &lt;= <span class="number">1</span> &amp;&amp; diff &gt;= <span class="number">-1</span>) &#123;</span><br><span class="line">            *pdepth = <span class="number">1</span> + (left &gt; right ? left : right);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">is_balanced</span><span class="params">(node* proot)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> depth = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> is_balanced(proot, &amp;depth);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    node* proot = init_tree();</span><br><span class="line">    <span class="keyword">if</span>(is_balanced(proot)) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Is Balanced.\n&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Is Not Balanced.\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><blockquote><p>面试题56：数组中数字出现的次数。</p></blockquote><p><strong>题目一</strong>：数组中只出现一次的两个数字。</p><p><strong>一个整型数组里除两个数字之外，其他数字都出现了两次</strong>。请写程序找出这<strong>两个只出现一次</strong>的数字。要求时间复杂度是<code>O(n)</code>，空间复杂度是<code>O(1)</code>。</p><p>这个题常规思路很难解决，需要使用到<strong>两个相同的数的异或为0</strong>这种知识点，首先把问题分解为<strong>在一个整数数组中，除了一个数字之外，其他都出现两次</strong>的一个子问题，对于这个子问题的求解方式是对所有数进行异或操作，最后结果数就是出现一次的数字（其中使用到了异或操作的交换律以及结合律，这里不再证明）。</p><p>再回到原始问题，看看有没有相同的思路。还是从头到尾异或每个数字，结果是两个只出现一次的数字的异或结果，因为其他数字都出现两次，在异或中全部抵消了。<strong>由于这两个数字不一样，所以异或的结果肯定不为0，至少有一位是1</strong>（这代表这两个数，一个在该位上为1，一个在该位上为0），我们在结果数字中找到第一个为1的位的位置，记为第n位。现在我们<strong>以第n位是不是1位标准把原数组中的数字分为两个子数组</strong>，第一个子数组中每个数字的第n位都是1，第二个子数组中每个数字的第n位都是0，这样两个不同的数字就分到了两个数组中，并且相同的数字一定会被分到一个数组中，也就<strong>拆分成了两个可以解决的子问题了</strong>。</p><p>完整实现代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 找到从右边数起的第一个1位（方便一点）</span></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">find_first_1_bit</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>((num &amp; <span class="number">1</span>) == <span class="number">0</span> &amp;&amp; index &lt; <span class="number">8</span> * <span class="keyword">sizeof</span>(<span class="keyword">int</span>)) &#123;</span><br><span class="line">        num = num &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        index++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> index;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">is_bit_1</span><span class="params">(<span class="keyword">int</span> num, <span class="keyword">unsigned</span> <span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    num = num &gt;&gt; index; <span class="comment">// 直接右移</span></span><br><span class="line">    <span class="keyword">return</span> (num &amp; <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> g_invalid_input = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">find_nums_appear_once</span><span class="params">(<span class="keyword">int</span> data[], <span class="keyword">int</span> len, <span class="keyword">int</span>* num1, <span class="keyword">int</span>* num2)</span> </span>&#123;</span><br><span class="line">    g_invalid_input = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span>(data == <span class="literal">nullptr</span> || len &lt; <span class="number">2</span> || len % <span class="number">2</span> != <span class="number">0</span>) &#123;</span><br><span class="line">        g_invalid_input = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> xor_result = <span class="number">0</span>; <span class="comment">// 异或初始值0</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">        xor_result ^= data[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> index_of_1 = find_first_1_bit(xor_result);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这里直接用一次O(n)来遍历，并不是显式地分为两个部分</span></span><br><span class="line">    <span class="comment">// 而是直接地根据位的情况来选择性异或，最后结果也一样</span></span><br><span class="line">    *num1 = *num2 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(is_bit_1(data[i], index_of_1)) &#123;</span><br><span class="line">            *num1 ^= data[i];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            *num2 ^= data[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> data[] = &#123;<span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">5</span>, <span class="number">3</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> num1 = <span class="number">0</span>, num2 = <span class="number">0</span>;</span><br><span class="line">    find_nums_appear_once(data, <span class="number">10</span>, &amp;num1, &amp;num2);</span><br><span class="line">    <span class="keyword">if</span>(g_invalid_input) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Error: Invalid Input.\n&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Num1: %d, Num2: %d\n&quot;</span>, num1, num2);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>题目二</strong>：数组中唯一只出现一次的数字。</p><p>在一个数组中<strong>除一个数字只出现一次之外</strong>，其他数字都<strong>出现了三次</strong>。请找出那个只出现一次的数字。</p><p><strong>如果一个数字出现三次，那么它的二进制表示的每一位（0或者1）也出现3次</strong>，如果把所有出现三次的数字的二进制表示的每一位分别都加起来，那么每一位的和都能被3整除。这样我们把数组中所有数字的二进制表示的每一位都加起来。如果某一位的和能被3整除，那么那个只出现一次的数字的二进制表示中对应的那一位就是0，否则是1。</p><p>完整实现代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> g_invalid_input = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find_num_appear_once</span><span class="params">(<span class="keyword">int</span> data[], <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">    g_invalid_input = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span>(data == <span class="literal">nullptr</span> || len &lt;= <span class="number">0</span> || len % <span class="number">3</span> != <span class="number">1</span>) &#123;</span><br><span class="line">        g_invalid_input = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 0 是最高位， 31 是最低位</span></span><br><span class="line">    <span class="comment">// 注意int的最高位是符号位，这里连同符号位一起处理了</span></span><br><span class="line">    <span class="keyword">int</span> bit_sum[<span class="number">32</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> bit_mask = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">31</span>; j &gt;= <span class="number">0</span>; j--) &#123;</span><br><span class="line">            <span class="keyword">int</span> bit = data[i] &amp; bit_mask;</span><br><span class="line">            <span class="keyword">if</span>(bit != <span class="number">0</span>) &#123;</span><br><span class="line">                bit_sum[j]++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 这里是基于bit_mask=1的左移</span></span><br><span class="line">            bit_mask = bit_mask &lt;&lt; <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这里使用的还原法是基于位移操作的</span></span><br><span class="line">    <span class="comment">// 要比使用2幂级更加高效，同时符号位处理也更加自然</span></span><br><span class="line">    <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">32</span>; ++i) &#123;</span><br><span class="line">        result = result &lt;&lt; <span class="number">1</span>; <span class="comment">// 先左移，空出最低位</span></span><br><span class="line">        result += bit_sum[i] % <span class="number">3</span>; <span class="comment">// 载入当前最低位</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> data[] = &#123;<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">-2</span>, <span class="number">-2</span>, <span class="number">-2</span>, <span class="number">-100</span>, <span class="number">4</span>, <span class="number">4</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">5</span>, <span class="number">5</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> result = find_num_appear_once(data, <span class="number">13</span>);</span><br><span class="line">    <span class="keyword">if</span>(g_invalid_input) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Error: Invalid Input.\n&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Result: %d\n&quot;</span>, result);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种方法同样只需要<code>O(n)</code>的时间以及<code>O(1)</code>的空间，相比于其他方法有更好的时间效率(例如用排序需要<code>O(logn)</code>)，同时也不会有多余的空间开销(例如用哈希表，需要额外的<code>O(n)</code>空间)。</p><hr><blockquote><p>面试题57：和为s的数字。</p></blockquote><p>题目一：和为s的两个数字。</p><p>输入一个<strong>递增排序</strong>的数组和一个数字<code>s</code>，在数组中<strong>查找两个数</strong>，使得它们的和正好是<code>s</code>。如果有<strong>多对数字的和</strong>等于<code>s</code>，则输出任意一对即可。</p><p>PS：在面试的时候，很重要的一点是应聘者要表现出很快的反应能力。只要想到一种方法，应聘者就可以马上告诉面试官（仅限于面谈形式的），即使这种方法不一定是最好的。</p><p>根据已排序数组的特性，当指定数组中的两个数字时：</p><ul><li>如果两个数字的和小于<code>s</code>，需要一个更大的数字，这个时候可以在较小数字的<strong>右侧**</strong>或者<strong>是较大数字的</strong>右侧**去寻找；</li><li>如果两个数字的和大于<code>s</code>，需要一个更小的数字，这个时候可以在较小数字的<strong>左侧**</strong>或者<strong>是较大数字的</strong>左侧**去寻找；</li><li>如果两个数字的和等于<code>s</code>，则找到两个满足要求的数字。</li></ul><p>仅仅分析到这里是还不够的，如果每个位置都要考虑两种情况，最后的复杂度会是<code>O(2^n)</code>，在这种去情况时，可以考虑固定一个方向寻找，并且要能够覆盖到所有情况，例如本题中，可以初始化一头一尾两个指针，如果和小于<code>s</code>，移动头指针向右，如果和大于<code>s</code>，移动头指针向左，<strong>这样可以遍历到所有情况</strong>。</p><p>PS：<strong>为什么说这样可以遍历到所有情况？</strong>对于每一个头指针指向的数字，你不能在当前尾指针的右侧找到一个更适合的数（都是大于s）；对于每一个尾指针指向的数字，你不能在当前头指针的左侧找到一个更适合的数（都是小于s），所以这样逐步缩小范围，同时也考虑到了所有情况。</p><p>完整实现代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> g_invalid_input = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find_nums_with_sum</span><span class="params">(<span class="keyword">int</span> data[], <span class="keyword">int</span> len, <span class="keyword">int</span> sum, <span class="keyword">int</span>* num1, <span class="keyword">int</span>* num2)</span> </span>&#123;</span><br><span class="line">    g_invalid_input = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">bool</span> found = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span>(data == <span class="literal">nullptr</span> || len &lt; <span class="number">2</span> || !num1 || !num2) &#123;</span><br><span class="line">        g_invalid_input = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> found;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> head = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> tail = len - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(head &lt; tail) &#123;</span><br><span class="line">        <span class="comment">// 使用了long long来存储</span></span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> cur_sum = data[head] + data[tail];</span><br><span class="line">        <span class="keyword">if</span>(cur_sum == sum) &#123;</span><br><span class="line">            *num1 = data[head];</span><br><span class="line">            *num2 = data[tail];</span><br><span class="line">            found = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(cur_sum &gt; sum) &#123;</span><br><span class="line">            tail--;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            head++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> found;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> data[] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">7</span>, <span class="number">11</span>, <span class="number">15</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> num1, num2;</span><br><span class="line">    <span class="keyword">if</span>(find_nums_with_sum(data, <span class="number">6</span>, <span class="number">15</span>, &amp;num1, &amp;num2)) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Found! Num1: %d, Num2: %d\n&quot;</span>, num1, num2);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(g_invalid_input) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Error: Invalid Input.\n&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Not Found!\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>题目二</strong>：和为s的连续正数序列。</p><p>输入一个正数<code>s</code>，打印出所有和为s的<strong>连续正数序列</strong>（至少含有两个数）。例如，输入15，由于<code>1+2+3+4+5=4+5+6+7=7+8=15</code>，所以打印出3个连续序列<code>1~5</code>、<code>4~6</code>、<code>7~8</code>。</p><p>和题目一思路类似。</p><p>完整实现代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">find_seqs_with_sum</span><span class="params">(<span class="keyword">int</span> sum)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(sum &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> head = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> tail = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">int</span> cur_sum = head + tail;</span><br><span class="line">    <span class="keyword">while</span>(!(head == tail - <span class="number">1</span> &amp;&amp; cur_sum &gt; sum)) &#123;</span><br><span class="line">        <span class="keyword">if</span>(cur_sum == sum) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d~%d\n&quot;</span>, head, tail);</span><br><span class="line">            cur_sum -= head;</span><br><span class="line">            head++;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(cur_sum &gt; sum) &#123;</span><br><span class="line">            cur_sum -= head;</span><br><span class="line">            head++;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            tail++;</span><br><span class="line">            cur_sum += tail;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    find_seqs_with_sum(<span class="number">15</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><blockquote><p>面试题58：翻转字符串。</p></blockquote><p><strong>题目一</strong>：翻转单词顺序。</p><p>输入一个英语句子，翻转句子中单词的顺序，但单词内字符的顺序不变。简单起见，标点符号和字幕一样处理。例如输入<code>I am a student.</code>，则输出<code>student. a am I</code>.</p><p>普通方法的思路也不是特别难，不过这里说一下书上的两次翻转字符串的解法：</p><ul><li>第一步<strong>翻转句子中所有的字符</strong>；</li><li>第二步<strong>翻转每个单词中的字符的顺序</strong>，就得到了最终结果。</li></ul><p>完整实现代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">reverse</span><span class="params">(<span class="keyword">char</span>* pstart, <span class="keyword">char</span>* pend)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(pstart == <span class="literal">nullptr</span> || pend == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(pstart &lt; pend) &#123;</span><br><span class="line">        <span class="keyword">char</span> temp = *pstart;</span><br><span class="line">        *pstart = *pend;</span><br><span class="line">        *pend = temp;</span><br><span class="line">        pstart++;</span><br><span class="line">        pend--;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">str_reverse</span><span class="params">(<span class="keyword">char</span>* str)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(str == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">char</span>* pstart = str;</span><br><span class="line">    <span class="keyword">char</span>* pend = str;</span><br><span class="line">    <span class="keyword">while</span>(*pend != <span class="string">&#x27;\0&#x27;</span>) &#123;</span><br><span class="line">        pend++;</span><br><span class="line">    &#125;</span><br><span class="line">    pend--;</span><br><span class="line"></span><br><span class="line">    reverse(pstart, pend);</span><br><span class="line"></span><br><span class="line">    pstart = pend = str;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(*pstart != <span class="string">&#x27;\0&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span>(*pstart == <span class="string">&#x27; &#x27;</span>) &#123;</span><br><span class="line">            pstart++;</span><br><span class="line">            pend++;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(*pend == <span class="string">&#x27; &#x27;</span> || *pend == <span class="string">&#x27;\0&#x27;</span>) &#123;</span><br><span class="line">            reverse(pstart, pend - <span class="number">1</span>);</span><br><span class="line">            pstart = pend;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            pend++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> str[] = <span class="string">&quot;  I am a student.  &quot;</span>;</span><br><span class="line">    str_reverse(str);</span><br><span class="line">    <span class="keyword">if</span>(str != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>, str);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>题目二</strong>：左旋转字符串。</p><p>字符串的左旋转操作是把字符串<strong>前面的若干个字符</strong>转移到<strong>字符串的尾部</strong>。比如输入字符串<code>abcdefg</code>和数字<code>2</code>，函数返回左旋两位得到的结果<code>cdefgab</code>。</p><p>题目一中的翻转字符串，如果在本例中，可以类比于将<code>ab cdefg</code>翻转为<code>cdefg ab</code>，所以可以使用和题目一类似的思路。</p><p>完整实现代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">reverse</span><span class="params">(<span class="keyword">char</span>* pstart, <span class="keyword">char</span>* pend)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(pstart == <span class="literal">nullptr</span> || pend == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(pstart &lt; pend) &#123;</span><br><span class="line">        <span class="keyword">char</span> temp = *pstart;</span><br><span class="line">        *pstart = *pend;</span><br><span class="line">        *pend = temp;</span><br><span class="line">        pstart++;</span><br><span class="line">        pend--;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">str_left_rotate</span><span class="params">(<span class="keyword">char</span>* str, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len = <span class="built_in">strlen</span>(str);</span><br><span class="line">    <span class="keyword">if</span>(str == <span class="literal">nullptr</span> || n &lt; <span class="number">0</span> || n &gt;= len || len == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 三次翻转即可</span></span><br><span class="line">    <span class="keyword">char</span>* pstart;</span><br><span class="line">    <span class="keyword">char</span>* pend;</span><br><span class="line">    pstart = str;</span><br><span class="line">    pend = str + n - <span class="number">1</span>;</span><br><span class="line">    reverse(pstart, pend);</span><br><span class="line">    pstart = str + n;</span><br><span class="line">    pend = str + len - <span class="number">1</span>;</span><br><span class="line">    reverse(pstart, pend);</span><br><span class="line">    pstart = str;</span><br><span class="line">    pend = str + len - <span class="number">1</span>;</span><br><span class="line">    reverse(pstart, pend);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> str[] = <span class="string">&quot;abcdefg&quot;</span>;</span><br><span class="line">    str_left_rotate(str, <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">if</span>(str != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>, str);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><blockquote><p>面试题59：队列的最大值。</p></blockquote><p><strong>题目一</strong>：滑动窗口的最大值。</p><p>给定一个数组和滑动窗口大小，请找出所有滑动窗口里的最大值。例如<code>&#123;2,3,4,2,6,2,5,1&#125;</code>以及滑动窗口大小<code>3</code>，那么一共存在6个滑动窗口，他们的最大值分别是<code>&#123;4,4,6,6,6,5&#125;</code>。</p><p><strong>使用一个双端队列来保存当前窗口最大值以及可能的次最大值们</strong>；如果新入窗口的元素大于队列的头元素（最大值），则清空队列，头部入队新元素；如果新入窗口的元素小于队列的头元素，则出尾部所有小于该新元素的数字，并在尾部入队新元素；同时在队列中只需要保存元素的<code>index</code>，用来同时获取数字以及判断当前其是否在窗口内，如果不在窗口内就要进行出队。</p><p>完整实现代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;deque&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">windows_max</span><span class="params">(<span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; num, <span class="keyword">unsigned</span> <span class="keyword">int</span> size)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; maxs;</span><br><span class="line">    <span class="keyword">if</span>(num.size() &lt; size &amp;&amp; size &gt;= <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> maxs;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt; index;</span><br><span class="line">    <span class="comment">// 初始化第一个窗口的状态</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">unsigned</span> <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">        <span class="keyword">while</span>(!index.empty() &amp;&amp; num[i] &gt;= num[index.back()]) &#123;</span><br><span class="line">            index.pop_back();</span><br><span class="line">        &#125;</span><br><span class="line">        index.push_back(i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 开始滑动窗口</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">unsigned</span> <span class="keyword">int</span> i = size; i &lt; num.size(); i++) &#123;</span><br><span class="line">        maxs.push_back(num[index.front()]);</span><br><span class="line">        <span class="comment">// 清除所有尾部小于新元素的</span></span><br><span class="line">        <span class="keyword">while</span>(!index.empty() &amp;&amp; num[i] &gt;= num[index.back()]) &#123;</span><br><span class="line">            index.pop_back();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 清除所有头部已经不在窗口的</span></span><br><span class="line">        <span class="keyword">if</span>(!index.empty() &amp;&amp; index.front() &lt;= (<span class="keyword">int</span>)(i - size)) &#123;</span><br><span class="line">            index.pop_front();</span><br><span class="line">        &#125;</span><br><span class="line">        index.push_back(i);</span><br><span class="line">    &#125;</span><br><span class="line">    maxs.push_back(num[index.front()]);</span><br><span class="line">    <span class="keyword">return</span> maxs;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">num</span><span class="params">(&#123;<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">2</span>,<span class="number">6</span>,<span class="number">2</span>,<span class="number">5</span>,<span class="number">1</span>&#125;)</span></span>;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; maxs = windows_max(num, <span class="number">3</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; maxs.size(); i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, maxs[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>题目二</strong>：队列的最大值。</p><p>定义一个队列，并实现函数<code>max</code>得到队列里的最大值，要求函数<code>max</code>、<code>push_back</code>和<code>pop_front</code>的时间复杂度都是<code>O(1)</code>。</p><p>思路和题目一类似，使用一个双端队列实现<code>max</code>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;deque&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="class"><span class="keyword">class</span> <span class="title">QueueWithMAx</span> &#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        QueueWithMAx(): cur_index(<span class="number">0</span>) &#123;&#125;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">push_back</span><span class="params">(T num)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">while</span>(!maxs.empty() &amp;&amp; num &gt;= maxs.back().num) &#123;</span><br><span class="line">                maxs.pop_back();</span><br><span class="line">            &#125;</span><br><span class="line">            InternalData idata = &#123; num, cur_index &#125;;</span><br><span class="line">            data.push_back(idata);</span><br><span class="line">            maxs.push_back(idata);</span><br><span class="line">            cur_index++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">pop_front</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(maxs.empty()) &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;Error: queue is empty\n&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(maxs.front().index == data.front().index) &#123;</span><br><span class="line">                <span class="comment">// 如果要出队最大元素，maxs也要出队</span></span><br><span class="line">                maxs.pop_front();</span><br><span class="line">            &#125;</span><br><span class="line">            data.pop_front();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">int</span> <span class="title">front</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(data.empty()) &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;Error: queue is empty\n&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> data.front().num;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function">T <span class="title">max</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(maxs.empty()) &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;Error: queue is empty\n&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> maxs.front().num;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">InternalData</span> &#123;</span></span><br><span class="line">            T num;</span><br><span class="line">            <span class="keyword">int</span> index;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="built_in">deque</span>&lt;InternalData&gt; data;</span><br><span class="line">        <span class="built_in">deque</span>&lt;InternalData&gt; maxs;</span><br><span class="line">        <span class="keyword">int</span> cur_index;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> num[] = &#123;<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">2</span>,<span class="number">6</span>,<span class="number">2</span>,<span class="number">5</span>,<span class="number">1</span>&#125;;</span><br><span class="line">    QueueWithMAx&lt;<span class="keyword">int</span>&gt; <span class="built_in">queue</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">8</span>; i++) &#123;</span><br><span class="line">        <span class="built_in">queue</span>.push_back(num[i]);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;After push %d, max is %d\n&quot;</span>, num[i], <span class="built_in">queue</span>.max());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">7</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> front = <span class="built_in">queue</span>.front();</span><br><span class="line">        <span class="built_in">queue</span>.pop_front();</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;After pop %d, max is %d\n&quot;</span>, front, <span class="built_in">queue</span>.max());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-抽象建模能力"><a href="#4-抽象建模能力" class="headerlink" title="4 抽象建模能力"></a>4 抽象建模能力</h2><p>有些面试官喜欢从日常生活中抽取提炼出问题，考查应聘者是否能简历数学模型并解决问题。</p><p>建模的第一步是<strong>选择合理的数据结构来表述问题</strong>。我们在根据问题的特点，综合考虑性能、编程难度等因素之后，选择最合适的数据结构来表达问题，也就是建立模型。</p><p>建模的第二步是<strong>分析模型中的内在规律，并用编程语言表述这种规律</strong>。</p><h2 id="面试题60-63"><a href="#面试题60-63" class="headerlink" title="面试题60-63"></a>面试题60-63</h2><blockquote><p>面试题60：n个骰子的点数。</p></blockquote><p>把<code>n</code>个骰子扔在地上，所有骰子朝上一面的点数之和为<code>s</code>。输入<code>n</code>，打印出现<code>s</code>的所有可能的值出现的概率。</p><p>最简单的方法递归地遍历骰子的所有值情况，然后记录和<code>s</code>的出现次数，时间复杂度<code>O(6^n)</code>，当<code>n</code>很大时难以接受。</p><p>其实可以简化这个问题，例如设<code>f(n,s)</code>为n个骰子时和<code>s</code>的出现次数，则有<code>f(n,s)=f(n-1,s-1)+f(n-1,s-2)+f(n-1,s-3)+f(n-1,s-4)+f(n-1,s-5)+f(n-1,s-6)</code>，写出这样的递归式，我们就可以想到通过迭代来代替递归的方式计算结果，设初值<code>f(1,k)=1, 1&lt;=k&lt;=6</code>，每次迭代，向后计算即可，时间复杂度<code>O(n^2)</code>。</p><p>完整实现代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print_probability</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n &lt; <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> size = <span class="number">6</span> * n + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span>* prob1 = <span class="keyword">new</span> <span class="keyword">int</span>[size];</span><br><span class="line">    <span class="keyword">int</span>* prob2 = <span class="keyword">new</span> <span class="keyword">int</span>[size];</span><br><span class="line">    <span class="built_in">std</span>::fill(prob1, prob1 + size, <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">std</span>::fill(prob2, prob2 + size, <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">std</span>::fill(prob1 + <span class="number">1</span>, prob1 + <span class="number">7</span>, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; size; j++) &#123;</span><br><span class="line">            prob2[j] = <span class="number">0</span>; <span class="comment">// 别忘了数值重置</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">1</span>; k &lt;= <span class="number">6</span> &amp;&amp; j-k&gt;=<span class="number">0</span>; k++) &#123;</span><br><span class="line">                prob2[j] += prob1[j-k];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 交换数组</span></span><br><span class="line">        <span class="keyword">int</span>* temp = prob1;</span><br><span class="line">        prob1 = prob2;</span><br><span class="line">        prob2 = temp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">double</span> total = (<span class="keyword">double</span>)<span class="built_in">std</span>::<span class="built_in">pow</span>(<span class="number">6</span>, n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = n; i &lt; size; i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d: %d\n&quot;</span>, i, prob1[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">delete</span>[] prob1;</span><br><span class="line">    <span class="keyword">delete</span>[] prob2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    print_probability(<span class="number">11</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>相比于书上的代码，这一版本更加简洁。</p><hr><blockquote><p>面试题61：扑克牌中的顺子。</p></blockquote><p>从扑克牌中随机抽5张牌，判断是不是一个顺子，即这5张牌是不是连续的。<code>2~10</code>为数字，<code>A</code>为<code>1</code>、<code>J</code>为<code>11</code>、<code>Q</code>为<code>12</code>、<code>K</code>为<code>13</code>，而<strong>大、小王可以看成任意数字</strong>。</p><p>思路比较基础，就是先把手里的数组排序（大小王当作0），统计0的个数，统计排序相邻数字之间的空缺总数，如果综述小于等于0的个数，则数组连续，否则不连续。如果数组中非0数字重复出现，则该数字不是连续的。</p><p>完整实现代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">is_straight</span><span class="params">(<span class="keyword">int</span>* numbers, <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(numbers == <span class="literal">nullptr</span> || len &lt; <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">std</span>::sort(numbers, numbers+len);</span><br><span class="line">    <span class="keyword">int</span> zeros = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> gaps = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(numbers[i] == <span class="number">0</span>) &#123;</span><br><span class="line">            zeros++;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(i &gt; <span class="number">0</span> &amp;&amp; numbers[i] == numbers[i<span class="number">-1</span>]) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(i &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            gaps += numbers[i] - numbers[i<span class="number">-1</span>] - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(gaps &lt;= zeros) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> nums[] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line">    <span class="keyword">if</span>(is_straight(nums, <span class="keyword">sizeof</span>(nums)/<span class="keyword">sizeof</span>(<span class="keyword">int</span>))) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Is straight.&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Is not straight.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果觉得代码中排序的部分<code>O(nlogn)</code>不够快，因为这里出现的数字只有<code>0~13</code>，所以还可以使用哈希表实现<code>O(n)</code>的排序。</p><hr><blockquote><p>面试题62：圆圈中最后剩下的数字。</p></blockquote><p><code>0,1,...,n-1</code>这<code>n</code>个数字排成一个圆圈，从数字<code>0</code>开始，每次从这个圆圈里删除第<code>m</code>个数字。求出这个圆圈里剩下的最后一个数字。</p><div align="center"><p><img src="/images/s2o-c6-f3.jpg"></p></div><p>例如上图的圆圈，从数字<code>0</code>开始，每次删除第<code>3</code>个数字，则删除的前4个数字是<code>2、0、4、1</code>，最后剩下的数字是<code>3</code>。</p><p>本题就是有名的约瑟夫(Josephuse)环问题。一种方法是用环形链表模拟圆圈的经典解法，时间复杂度<code>O(nm)</code>，另一种方法是分析被删除数字的规律，直接计算出圆圈中最后剩下的数字，时间复杂度<code>O(n)</code>。</p><p>链表模拟法就不再赘述了，主要讲一下第二个的规律分析法。</p><p>定义一个关于n和m的函数<code>f(n,m)</code>，表示每次在<code>n</code>个数字<code>0,1,...,n-1</code>中删除第<code>m</code>个数字最后剩下的数字。</p><p>在这n个数字中，第一个被删除的是<code>(m-1)%n</code>，简单起见，记为<code>k</code>，删除k之后剩下的n-1个数字为<code>0,1,...,k-1,k+1,...,n-1</code>，并且在下一次删除从数字<code>k+1</code>开始计数。相当于在剩下的序列中，<code>k+1</code>排在最前面，从而形成<code>k+1,...,n-1,0,1,...,k-1</code>。这个序列最后剩下的数字应该也是关于<code>n</code>和<code>m</code>的函数。</p><p>由于第二个序列和前面最初的序列不一样，因此函数不同于前面的函数，记为<code>f&#39;(n-1,m)</code>，所以有<code>f(n,m)=f&#39;(n-1,m)</code>。</p><p>接下来我们把，剩下的这<code>n-1</code>个数字的序列<code>k+1,...,n-1,0,1,...,k-1</code>进行映射，结果形成一个<code>0~n-2</code>的序列。</p><div align="center"><p><img src="/images/s2o-c6-f4.jpg"></p></div><p>把映射定义为<code>p</code>，则有<code>p(x)=(x-k-1)%n</code>，映射的逆映射是<code>p&#39;(x)=(x+k+1)%n</code>。</p><p>由于映射之后的序列和最初的序列具有相同的形式，即都是从0开始的连续序列，因此仍然可以用函数<code>f</code>来表示，记为<code>f(n-1,m)</code>。根据我们之前的推导，映射之前的序列剩下的数字是<code>f&#39;(n-1,m)=p&#39;(f(n-1,m))=(f(n-1,m)+k+1)%n</code>，把<code>k=(m-1)%n</code>代入，可以得到<code>f(n,m)=f&#39;(n-1,m)=[f(n-1,m)+m]%n</code>。</p><p>通过分析后，我们找到了一个递归公式，要得到这n个数的序列中最后剩下的数字，只需要得到n-1个数字的序列中最后剩下的数字，并以此类推。</p><p>当n=1时，序列中只有一个数字<code>0</code>，那么很显然最后剩下的数字就是<code>0</code>，这种递归可以写为：</p><div align="center"><p><img src="/images/s2o-c6-f5.jpg"></p></div><p>公式无论是用递归还是循环，都很容易实现。</p><p>完整实现代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">last_remaining</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> n, <span class="keyword">unsigned</span> <span class="keyword">int</span> m)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n &lt; <span class="number">1</span> || m &lt; <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> last = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        last = (last + m) % i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> last;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, last_remaining(<span class="number">5</span>, <span class="number">3</span>));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度<code>O(n)</code>，空间复杂度<code>O(1)</code>。</p><hr><blockquote><p>面试题63：股票的最大利润。</p></blockquote><p>假设把某股票的价格按照时间先后顺序存储在数组中，请问买卖该股票一次，可能获得的<strong>最大利润</strong>是多少？例如一支股票在某些时间节点的价格为<code>&#123;9,11,8,5,7,12,16,14&#125;</code>。如果我们能在价格<code>5</code>时买入，并在价格<code>16</code>时卖出，则收获最大利润<code>11</code>。</p><p>暴力遍历法时间复杂度<code>O(n^2)</code>，但是只要在从前向后计算的时候，保存前面序列中的最小值，就可以计算出当前值和前面序列的最小值的差值，最后获得最大差值就是最大利润。</p><p>完整实现代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;limits.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">max_profit</span><span class="params">(<span class="keyword">int</span>* numbers, <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(numbers == <span class="literal">nullptr</span> || len &lt; <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> min = numbers[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">int</span> max_profits = INT_MIN;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; len; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(numbers[i] - min &gt; max_profits) &#123;</span><br><span class="line">            max_profits = numbers[i] - min;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(min &gt; numbers[i]) &#123;</span><br><span class="line">            min = numbers[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> max_profits;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> numbers[] = &#123;<span class="number">9</span>,<span class="number">11</span>,<span class="number">8</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">12</span>,<span class="number">16</span>,<span class="number">14</span>&#125;;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;max profit is %d&quot;</span>, max_profit(numbers, <span class="keyword">sizeof</span>(numbers)/<span class="keyword">sizeof</span>(<span class="keyword">int</span>)));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>只需要扫描数组一次，该算法的时间复杂度<code>O(n)</code>。</p><h2 id="5-发散思维能力"><a href="#5-发散思维能力" class="headerlink" title="5 发散思维能力"></a>5 发散思维能力</h2><p>发散思维的特点是思维活动的多向性和变通性，也就是思考问题时，注重运动多思路、多方案、多途径来解决问题。对于同一个问题，我们可以从不同的方向、侧面和层次，采用探索、转移、迁移、组合和分解等方法，提出多种创新的解法。</p><h2 id="面试题64-66"><a href="#面试题64-66" class="headerlink" title="面试题64-66"></a>面试题64-66</h2><blockquote><p>面试题64：求1+2+…+n。</p></blockquote><p>求<code>1+2+...+n</code>，要求不能使用乘除法、for、while、if、else、switch、case等关键字及条件判断语句(A?B:C)。</p><p>循环和递归实现在本题中就没办法使用了，可以尝试从一些语言特性的方面来解决。</p><p><strong>解法一</strong>：利用构造函数求解。</p><p>循环只是让相同的代码重复执行n次而已，完全可以不用for和while来达到这个效果。比如定义一个类型，接着创建n个该类型的实例，那么这个类型的构造函数将确定会被调用n次，可以将与累加相关的代码放到构造函数里。</p><p>完整实现代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Temp</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Temp() &#123;</span><br><span class="line">        ++N;</span><br><span class="line">        Sum+=N;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">reset</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        N = <span class="number">0</span>;</span><br><span class="line">        Sum = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">get_sum</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Sum;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> N;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> Sum;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> Temp::N = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> Temp::Sum = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">sum_solution1</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    Temp::reset();</span><br><span class="line"></span><br><span class="line">    Temp* a = <span class="keyword">new</span> Temp[n]; <span class="comment">// 靠内部的循环来作弊，绝了</span></span><br><span class="line">    <span class="keyword">delete</span>[] a;</span><br><span class="line">    a = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> Temp::get_sum();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, sum_solution1(<span class="number">10</span>));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>解法二</strong>：利用虚函数求解。</p><p>同样可以围绕递归来做，既然不能在一个函数中判断是不是应该终止递归，那么不妨定义两个函数，一个充当递归函数，另一个函数处理终止递归地情况，需要做的就是在两个函数里二选一，从二选一我们很自然地想到布尔变量，比如值为<code>true</code>时，调用第一个函数，值为<code>false</code>时，调用第二个函数。</p><p>完整实现代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>;</span></span><br><span class="line">A* Array[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span>:</span> <span class="keyword">public</span> A &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 使用状态来选择函数，实现if else</span></span><br><span class="line">        <span class="keyword">return</span> Array[(<span class="keyword">bool</span>)n]-&gt;sum(n<span class="number">-1</span>)+n;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sum_solution2</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    A a;</span><br><span class="line">    B b;</span><br><span class="line">    Array[<span class="number">0</span>] = &amp;a;</span><br><span class="line">    Array[<span class="number">1</span>] = &amp;b;</span><br><span class="line">    <span class="keyword">int</span> value = Array[<span class="number">1</span>]-&gt;sum(n);</span><br><span class="line">    <span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, sum_solution2(<span class="number">10</span>));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用虚函数来实现函数的选择，当n不为0时，调用函数<code>B::sum</code>，当<code>n</code>等于<code>0</code>时，调用函数<code>A::sum</code>。</p><p><strong>解法三</strong>：利用函数指针求解。</p><p>纯C语言的变成环境中，我们不能使用虚函数，此时可以用函数指针来模拟，这样代码可能还更加直观一点。</p><p>完整实现代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="title">int</span> <span class="params">(*fun)</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">terminator</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">sum_solution3</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> fun f[<span class="number">2</span>] = &#123;terminator, sum_solution3&#125;;</span><br><span class="line">    <span class="keyword">return</span> n + f[(<span class="keyword">bool</span>)n](n<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, sum_solution3(<span class="number">10</span>));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>解法四</strong>：利用模板类求解。</p><p>还可以让编译器帮助完成类似于递归地计算。</p><p>完整能够代码实现：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">unsigned</span> <span class="keyword">int</span> n&gt; <span class="class"><span class="keyword">struct</span> <span class="title">sum_solution4</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">enum</span> <span class="title">value</span> &#123;</span> N = sum_solution4&lt;n<span class="number">-1</span>&gt;::N + n &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;&gt; <span class="class"><span class="keyword">struct</span> <span class="title">sum_solution4</span>&lt;</span><span class="number">1</span>&gt; &#123;</span><br><span class="line">    <span class="class"><span class="keyword">enum</span> <span class="title">Value</span> &#123;</span>N = <span class="number">1</span>&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, sum_solution4&lt;<span class="number">10</span>&gt;::N);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当编译器看到<code>sum_solution4&lt;10&gt;</code>，就会为模板类<code>sum_solution4</code>以参数<code>10</code>生成该类型的代码，并且以<code>10</code>为参数的类型需要得到以<code>9</code>为参数的类型，这个过程会一直递归到参数为<code>1</code>的类型（已经显式定义，编译器无须生成）。</p><p>由于这个过程是在编译过程中完成的，因此要求输入的n必须是在编译期间就能确定的常量，不能动态输入。而且编译器对递归编译代码的递归深度是有限制的，要求n不能太大。</p><hr><blockquote><p>面试题65：不用加减乘除做加法。</p></blockquote><p>写一个函数，求两个整数之和，要求在函数体内不得使用<code>+</code>、<code>-</code>、<code>×</code>、<code>÷</code>四则运算符号。</p><p>不能用四则运算的话，就只能考虑用位运算（与、或、非、异或）的方式来实现加法了。</p><p>例如<code>5+17=22</code>，<code>5</code>的二进制是<code>101</code>，<code>17</code>的二进制是<code>10001</code>，我们试着把计算分成三步：</p><ul><li>第一步，各位相加，不计进位，得到的结果是<code>10100</code>（1+1溢出后就是0）；</li><li>第二步，记下进位，在这个例子中只在最后一位相加时产生一个进位，结果是二进制的<code>10</code>；</li><li>第三步，把前两步的结果相加，得到结果<code>10110</code>，转换成十进制就是<code>22</code>。</li></ul><p>现在把二进制的加法用位运算来代替：</p><ul><li>第一步，非进位加法，其实和异或运算相同，例如<code>101^10001=10100</code>；</li><li>第二步，只有<code>1</code>加<code>1</code>时，会向前产生一个进位<code>1</code>，此时我们可以想象成两个数先做位与运算，然后再向左移动一位，例如<code>101&amp;10001 &lt;&lt; 1 = 10</code>；</li><li>第三步，把前面两步结果相加，又变成一个新的问题，递归调用前两步，直到不会再产生进位为止。</li></ul><p>完整实现代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">same_sign</span><span class="params">(<span class="keyword">int</span> num1, <span class="keyword">int</span> num2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (num1 &gt;&gt; <span class="number">31</span>) == (num2 &gt;&gt; <span class="number">31</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bit_add</span><span class="params">(<span class="keyword">int</span> num1, <span class="keyword">int</span> num2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sum, carry;</span><br><span class="line">    <span class="keyword">int</span> tnum1 = num1, tnum2 = num2;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        sum = tnum1^tnum2;</span><br><span class="line">        carry = (tnum1 &amp; tnum2) &lt;&lt; <span class="number">1</span>;</span><br><span class="line">        tnum1 = sum;</span><br><span class="line">        tnum2 = carry;</span><br><span class="line">    &#125; <span class="keyword">while</span>(tnum2 != <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(same_sign(num1, num2) &amp;&amp; !same_sign(num1, sum)) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Error: add overflow\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, bit_add(<span class="number">200</span>, <span class="number">20</span>));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在书上的代码基础上，加入对溢出的异常判断，其中对于溢出判定方法是，只有当两个数同号时才会在加法中溢出，并且最后结果和原来的两个数异号时，就代表发生了溢出，此时应该抛出异常。</p><p>PS：不使用新的变量，交换两个变量的值（适用于数值类）。比如有<code>a</code>、<code>b</code>，我们希望交换它们的值。有两种不同的方法：</p><div align="center"><p><img src="/images/s2o-c6-f6.jpg"></p></div><hr><blockquote><p>面试题66：构建乘积数组。</p></blockquote><p>给定一个数组<code>A[0,1,...,n-1]</code>，请构建一个数组<code>B[0,1,...,n-1]</code>，其中B中的元素<code>B[i]=A[0]*A[1]*...*A[i-1]*A[i+1]*...*A[n-1]</code>。不能使用除法。</p><p>因为不能使用除法，所以只能另辟蹊径，如果用暴力求解法，时间复杂度是<code>O(n)</code>。</p><p>如果单独地求解<code>A[0]*A[1]*...*A[i-1]</code>，我们是可以迭代地在<code>O(n)</code>时间里求解出所有的前序乘积的，同理所有的<code>A[i-1]*A[i+1]*...*A[n-1]</code>，我们也可以逆序地迭代<code>O(n)</code>的时间中求解，最后对于每一个<code>B[i]</code>找到对应的前序序列和逆序序列就可以用乘法得到最后的结果了。</p><p>PS：不知道这道题要不要考虑什么乘积大数溢出的问题，根据面试的具体情况来分析吧，这种题再加上大数就稍微有点复杂了。</p><p>完整实现代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">multi_array</span><span class="params">(<span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt;&amp; array1, <span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt;&amp; array2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len1 = array1.size();</span><br><span class="line">    <span class="keyword">int</span> len2 = array2.size();</span><br><span class="line">    <span class="keyword">if</span>(len1 != len2 || len2 &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 先计算正序序列值，暂存在array2中</span></span><br><span class="line">    <span class="keyword">double</span> temp = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len1; i++) &#123;</span><br><span class="line">        array2[i] = temp;</span><br><span class="line">        temp *= array1[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 计算逆序序列值，乘出最后结果</span></span><br><span class="line">    temp = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = len2 - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        array2[i] *= temp;</span><br><span class="line">        temp *= array1[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt; <span class="title">array1</span><span class="params">(&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;)</span></span>;</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt; <span class="title">array2</span><span class="params">(<span class="number">5</span>)</span></span>;</span><br><span class="line">    multi_array(array1, array2);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; array2.size(); i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%e &quot;</span>, array2[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种思路的时间复杂度是<code>O(n)</code>。</p><h2 id="6-总结"><a href="#6-总结" class="headerlink" title="6 总结"></a>6 总结</h2><p>面试是我们展示自己综合素质的时候，除了扎实的编程能力，我们还需要表现自己的沟通能力和学习能力，以及知识迁移能力、抽象建模能力和发散思维能力等方面的综合实力。</p><div align="center"><p><img src="/images/s2o-c6-f7.jpg"></p></div>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;沟通和学习能力是面试中关键的考查点。&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="剑指Offer" scheme="https://yumi-cn.github.io/categories/%E5%89%91%E6%8C%87Offer/"/>
    
    
    <category term="笔记" scheme="https://yumi-cn.github.io/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>《剑指Offer》第5章笔记 优化效率</title>
    <link href="https://yumi-cn.github.io/2021/01/11/s2o-c5-optimize/"/>
    <id>https://yumi-cn.github.io/2021/01/11/s2o-c5-optimize/</id>
    <published>2021-01-11T14:04:48.000Z</published>
    <updated>2021-01-14T10:23:20.987Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>时间与空间，是算法永恒的话题。</p></blockquote><a id="more"></a><h2 id="1-面试官谈效率"><a href="#1-面试官谈效率" class="headerlink" title="1 面试官谈效率"></a>1 面试官谈效率</h2><p>大佬们说的名言名句。</p><p>咕咕待更。</p><h2 id="2-时间效率"><a href="#2-时间效率" class="headerlink" title="2 时间效率"></a>2 时间效率</h2><p>面试官除了考查应聘者的编程能力，还关注应聘者有没有不断优化效率、追求完美的态度和能力。</p><p>首先，我们的编程习惯对代码的时间效率有很大影响。比如C/C++程序员要养成采用<strong>引用（或指针）传递复杂类型参数</strong>的习惯。如果采用值传递的方式，则从形参到实参会产生一次复制操作，这样的复制大部分时候是多余的，应该尽量避免。再比如，C#中做多次字符串的拼接操作，尽量不要用多次<code>String</code>的<code>+</code>运算符来拼接字符串，因为这样会产生很多<code>String</code>的临时实例，造成时间和空间的浪费，更好的办法是用<code>StringBuilder</code>的<code>Append</code>方法来完成字符串的拼接。如果我们平时不太注意这些影响代码效率的细节，没有养成好的编码习惯，写出的代码可能会让面试官大失所望。</p><p>其次，即使同一个算法用<strong>循环和递归两种思路实现</strong>的<strong>时间效率可能会大不一样</strong>。递归的本质是把一个大的复杂问题分解成两个或者多个小的简单问题。如果小问题有相互重叠的部分，那么直接用递归实现虽然代码显得很简洁，但时间效率可能会非常差，对于这种题目，可以用递归地思路来分析，写代码的时候可以基于循环实现，并且用数组来保存中间结果，绝大部分动态规划算法的分析和代码实现都是分这两个步骤完成的。</p><p>再次，代码的<strong>时间效率</strong>还能体现应聘者<strong>对数据结构和算法功底的掌握程度</strong>。同样是查找，如果是顺序查找则需要<code>O(n)</code>的时间；如果输入的是排序的数组则只需要<code>O(logn)</code>的时间；如果事先已经构造好了哈希表，那么查找在<code>O(1)</code>时间内就能完成。</p><p>最后，应聘者在面试的时候要展示<strong>敏捷的思维能力</strong>和<strong>追求完美的激情</strong>，这些对最终的面试结果也有很重要的影响。</p><h2 id="面试题-39-48"><a href="#面试题-39-48" class="headerlink" title="面试题 39-48"></a>面试题 39-48</h2><blockquote><p>面试题39：数组中出现次数超过一半的数字。</p></blockquote><p>数组中有一个数字出现的次数超过数组长度的一半，请找出这个数字。例如，输入一个长度为<code>9</code>的数组<code>&#123;1,2,3,2,2,2,5,4,2&#125;</code>。由于数字<code>2</code>在数组中出现了<code>5</code>次，超过数组长度的一半，因此输出<code>2</code>。</p><p><strong>解法一</strong>：基于Partition函数的时间复杂度为<code>O(n)</code>的算法。</p><p>数组中有一个数字出现的次数超过了数组长度的一半，如果这个数组排序，那么<strong>排序之后位于数组中间</strong>的数字，一定就是那个<strong>出现次数超过数组长度一半的数字</strong>。这个数字就是统计学上的中位数，即长度为<code>n</code>的数组中第<code>n/2</code>大的数字。我们有成熟的时间复杂度为<code>O(n)</code>的算法得到数组中任意第<code>k</code>大的数字。</p><p>这种算法受快速排序算法的启发。在随机快速排序算法中，先在数组中随机选择一个数字，然后调整数组中数字的顺序，使得比选中的数字小的数字都排在它的左边，比选中的数字大的数字都排在它的右边。如果这个<strong>选中的数字</strong>下标刚好是<code>n/2</code>，则这个数字就是数组的中位数；如果下标大于<code>n/2</code>，那么中位数应该在它的左边，接着在它的左边找；如果下标小于<code>n/2</code>，中位数在它的右边，接着在它的右边找。这是一个典型的递归过程。</p><p>完整实现代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">partition</span><span class="params">(<span class="keyword">int</span>* numbers, <span class="keyword">int</span> len, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(start == end) &#123;</span><br><span class="line">        <span class="keyword">return</span> start;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> anchor = numbers[end];</span><br><span class="line">    <span class="keyword">int</span> left = start;</span><br><span class="line">    <span class="keyword">int</span> right = end - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(left &lt; right) &#123;</span><br><span class="line">        <span class="keyword">while</span>(numbers[left] &lt; anchor &amp;&amp; left &lt; right) &#123;</span><br><span class="line">            left++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(numbers[right] &gt;= anchor &amp;&amp; left &lt; right) &#123;</span><br><span class="line">            right--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(left != right) &#123;</span><br><span class="line">            <span class="keyword">int</span> temp = numbers[left];</span><br><span class="line">            numbers[left] = numbers[right];</span><br><span class="line">            numbers[right] = temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(left != end - <span class="number">1</span> || numbers[left] &gt; anchor) &#123;</span><br><span class="line">        <span class="keyword">int</span> temp = numbers[left];</span><br><span class="line">        numbers[left] = numbers[end];</span><br><span class="line">        numbers[end] = temp;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        left = end;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> left;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> g_input_invalid = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check_array</span><span class="params">(<span class="keyword">int</span>* numbers, <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">    g_input_invalid = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span>(numbers == <span class="literal">nullptr</span> || len &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        g_input_invalid = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> g_input_invalid;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check_more_than_half</span><span class="params">(<span class="keyword">int</span>* numbers, <span class="keyword">int</span> len, <span class="keyword">int</span> number)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> times = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(numbers[i] == number) &#123;</span><br><span class="line">            times++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">bool</span> is_more_than_half = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">if</span>(times * <span class="number">2</span> &lt;= len) &#123;</span><br><span class="line">        g_input_invalid = <span class="literal">true</span>;</span><br><span class="line">        is_more_than_half = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> is_more_than_half;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">more_than_half_num</span><span class="params">(<span class="keyword">int</span>* numbers, <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(check_array(numbers, len)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> middle = len &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> start = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> end = len - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> index = partition(numbers, len, start, end);</span><br><span class="line">    <span class="keyword">while</span>(index != middle) &#123;</span><br><span class="line">        <span class="keyword">if</span>(index &gt; middle) &#123;</span><br><span class="line">            end = index - <span class="number">1</span>;</span><br><span class="line">            index = partition(numbers, len, start, end);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            start = index + <span class="number">1</span>;</span><br><span class="line">            index = partition(numbers, len, start, end);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> result = numbers[middle];</span><br><span class="line">    <span class="keyword">if</span>(!check_more_than_half(numbers, len, result)) &#123;</span><br><span class="line">        result = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> numbers[] = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">2</span> &#125;;</span><br><span class="line">    <span class="keyword">int</span> result = more_than_half_num(numbers, <span class="number">9</span>);</span><br><span class="line">    <span class="keyword">if</span>(g_input_invalid) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Invalid input.\n&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Result: %d\n&quot;</span>, result);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在面试的时候，除了完成基本功能，还要考虑一些无效的输入。如果函数的输入参数是一个指针（数组在参数传递的时候退化为指针），就要考虑这个指针可能为<code>nullptr</code>。代码中的<code>check_array</code>用来判断输入的数组是不是无效的。<code>check_more_than_half</code>用来检验输入的数组中，是不是这个数字出现次数大于长度一半，用全局变量<code>g_input_invalid</code>来表示输入无效的情况。</p><p><strong>解法二</strong>：根据数组特点找出时间复杂度为<code>O(n)</code>的算法。</p><p>从另一个角度来解决这个问题。数组中有一个数字出现的次数超过数组长度的一半，也就是说<strong>它出现的次数比其他所有数字出现的和还要多</strong>。因此，考虑在遍历数组的时候保存<strong>两个值</strong>，一个是<strong>数组中的一个数字</strong>，另一个是<strong>次数</strong>。当遍历到下一个数字时，如果下一个数字和之前保存的数字相同，则<strong>次数加1</strong>；如果下一个数字和之前保存的不同，则<strong>次数减1</strong>；如果<strong>次数为0</strong>，则<strong>保存下一个数字</strong>，并把<strong>次数设1</strong>。由于要找的数字出现的次数比其他所有出现的次数之和还要多，那么要找的数字肯定是<strong>最后一次把次数设为1对应的数字</strong>。</p><p>完整实现代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> g_input_invalid = <span class="literal">false</span>;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check_array</span><span class="params">(<span class="keyword">int</span>* numbers, <span class="keyword">int</span> len)</span> </span>&#123; ... &#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check_more_than_half</span><span class="params">(<span class="keyword">int</span>* numbers, <span class="keyword">int</span> len, <span class="keyword">int</span> number)</span> </span>&#123; ... &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">more_than_half_num</span><span class="params">(<span class="keyword">int</span>* numbers, <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(check_array(numbers, len)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> result = numbers[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">int</span> times = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(times == <span class="number">0</span>) &#123;</span><br><span class="line">            result = numbers[i];</span><br><span class="line">            times = <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(numbers[i] == result) &#123;</span><br><span class="line">            times++;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            times--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(!check_more_than_half(numbers, len, result)) &#123;</span><br><span class="line">        result = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> numbers[] = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">2</span> &#125;;</span><br><span class="line">    <span class="keyword">int</span> result = more_than_half_num(numbers, <span class="number">9</span>);</span><br><span class="line">    <span class="keyword">if</span>(g_input_invalid) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Invalid input.\n&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Result: %d\n&quot;</span>, result);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>两种解法算法的时间复杂度都是<code>O(n)</code>，在第一种解法中，需要交换数组中数字的顺序，这就会修改输入的数组，而在面试的时候需要尝试和面试官讨论，明确需求，如果说不能修改输入的数组，就只能采用第二种解法了。</p><hr><blockquote><p>面试题40：最小的K个数。</p></blockquote><p>输入<code>n</code>个整数，找出其中最小的<code>k</code>个数，例如，输入<code>4,5,1,6,2,7,3,8</code>这<code>8</code>个数字，则最小的<code>4</code>个数字是<code>1,2,3,4</code>。</p><p>最简单直观的解法就是进行<code>k</code>次数组遍历，每一次找出一个相对最小值，时间复杂度<code>O(nk)</code>，代码比较简单就不再写了，主要讲两种优化的思路。</p><p><strong>解法一</strong>：时间复杂度为<code>O(n)</code>的算法，只有当我们<strong>可以修改输入的数组时</strong>可用。</p><p>同样可以基于<code>partition</code>函数来解决这个问题。如果基于数组的第<code>k</code>个数字来调整，使得比第<code>k</code>个数字小的所有数字都位于数组的左边，比第<code>k</code>个数大的所有数字都位于数组的右边。这样，位于数组中左边的<code>k</code>个数字就是最小的<code>k</code>个数字（<code>k</code>个数字不一定是排序的）。</p><p>完整实现代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">partition</span><span class="params">(<span class="keyword">int</span>* numbers, <span class="keyword">int</span> len, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123; ... &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">find_k_min</span><span class="params">(<span class="keyword">int</span>* input, <span class="keyword">int</span> n, <span class="keyword">int</span>* output, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(input == <span class="literal">nullptr</span> || output == <span class="literal">nullptr</span> || k &gt; n || n &lt;= <span class="number">0</span> || k &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> start = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> end = n - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> index = partition(input, n, start, end);</span><br><span class="line">    <span class="keyword">while</span>(index != k - <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span>(index &gt; k - <span class="number">1</span>) &#123;</span><br><span class="line">            end = index - <span class="number">1</span>;</span><br><span class="line">            index = partition(input, n, start, end);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            start = index + <span class="number">1</span>;</span><br><span class="line">            index = partition(input, n, start, end);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; i++) &#123;</span><br><span class="line">        output[i] = input[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> input[] = &#123; <span class="number">4</span>,<span class="number">5</span>,<span class="number">1</span>,<span class="number">6</span>,<span class="number">2</span>,<span class="number">7</span>,<span class="number">3</span>,<span class="number">8</span> &#125;;</span><br><span class="line">    <span class="keyword">int</span> n = <span class="number">8</span>;</span><br><span class="line">    <span class="keyword">int</span> k = <span class="number">4</span>;</span><br><span class="line">    <span class="keyword">int</span>* output = <span class="keyword">new</span> <span class="keyword">int</span>[k];</span><br><span class="line">    find_k_min(input, n, output, k);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, output[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果面试官要求不能修改输入的数组，那么就只能另辟蹊径。</p><p><strong>解法二</strong>：时间复杂度为<code>O(nlogk)</code>的算法，特别适合处理海量数据。</p><p>先创建一个大小为<code>k</code>的数据容器来存储最小的<code>k</code>个数字，接下来每次从输入的<code>n</code>个整数中读入一个数。如果容器中少于<code>k</code>个，则直接把这次读入的整数放入容器中；如果容器已经有<code>k</code>个了，此时<strong>比较读入的数字和容器中最大的数字</strong>，如果读入的更小，就插入容器，删除掉最大的。</p><p>如果用一棵二叉树（堆）来实现容器，那么就能在<code>O(logk)</code>时间内完成一个序列的最大值构建（<code>O(1)</code>的时间得到最大值，<code>O(logk)</code>时间完成删除和插入操作），对于<code>n</code>个输入数字，总的时间效率是<code>O(nlogk)</code>。</p><p>从头实现一个最大堆需要一定的代码，面试的几十分钟内很难完成，我们可以借助STL提供的一些数据结构，例如<code>set</code>或者<code>multiset</code>（区别是后者可以重复），如果面试官不反对使用STL，就可以直接拿来用，根据这道题的需求，使用<code>multiset</code>更加合适一点。</p><p>完整实现代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// std::greater 代表递减排序 最大的在begin</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">std</span>::<span class="built_in">multiset</span>&lt;<span class="keyword">int</span>, <span class="built_in">std</span>::greater&lt;<span class="keyword">int</span>&gt;&gt; int_set;</span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">std</span>::<span class="built_in">multiset</span>&lt;<span class="keyword">int</span>, <span class="built_in">std</span>::greater&lt;<span class="keyword">int</span>&gt;&gt;::iterator int_set_iter;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">find_k_min</span><span class="params">(<span class="keyword">int</span>* input, <span class="keyword">int</span> n, <span class="keyword">int</span>* output, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(input == <span class="literal">nullptr</span> || output == <span class="literal">nullptr</span> || k &gt; n || n &lt;= <span class="number">0</span> || k &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    int_set <span class="built_in">set</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">set</span>.size() &lt; k) &#123;</span><br><span class="line">            <span class="built_in">set</span>.insert(input[i]);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            int_set_iter iter = <span class="built_in">set</span>.begin();</span><br><span class="line">            <span class="keyword">if</span>(*iter &gt; input[i]) &#123;</span><br><span class="line">                <span class="built_in">set</span>.erase(iter);</span><br><span class="line">                <span class="built_in">set</span>.insert(input[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    int_set_iter iter = <span class="built_in">set</span>.begin();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; i++) &#123;</span><br><span class="line">        output[i] = *iter;</span><br><span class="line">        iter++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> input[] = &#123; <span class="number">4</span>,<span class="number">5</span>,<span class="number">1</span>,<span class="number">6</span>,<span class="number">2</span>,<span class="number">7</span>,<span class="number">3</span>,<span class="number">8</span> &#125;;</span><br><span class="line">    <span class="keyword">int</span> n = <span class="number">8</span>;</span><br><span class="line">    <span class="keyword">int</span> k = <span class="number">4</span>;</span><br><span class="line">    <span class="keyword">int</span>* output = <span class="keyword">new</span> <span class="keyword">int</span>[k];</span><br><span class="line">    find_k_min(input, n, output, k);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, output[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>第一种基于函数<code>partition</code>的第一种解法平均时间复杂度是<code>O(n)</code>，比第二种解法要快，但同时也有限制，比如会修改输入的数组（开<code>O(n)</code>空间虽然可以解决，但是有额外的空间代价）。</p><p>第二种基于最大堆容器的解法虽然慢，但一是没有修改输入的数据，二是算法适合海量数据的处理，因为第二种方法不用一次性将全部数据都读入到内存中，而第一种方法只有全部读入才能计算。</p><hr><!-- BGM《magnolia》keshi --><blockquote><p>面试题41：数据流中的中位数。</p></blockquote><p>如何得到一个数据流的中位数？如果从数据流读出的<strong>数据是奇数个</strong>，那么中位数就是所有值排序之后位于中间的数值；如果从数据流中读取<strong>偶数个数值</strong>，那么中位数是排序之后两个数的平均值。</p><p>数据是从一个数据流中读出来的，<strong>因而数据的数目随着时间的变化而增加</strong>，如果用一个数据容器来保存从流中读出来的数据，<strong>则当有新的数据从流中读出来，这些数据就插入数据容器</strong>（所以中位数是一个不断在变化的值，和容器的状态相关）。</p><p>那么可以考虑用几种不同的数据结构来作为容器：</p><ul><li><strong>数组</strong>：没有排序，可以使用<code>partition</code>找出数组的中位数，输入复杂度<code>O(1)</code>，找数中位数<code>O(n)</code>；</li><li><strong>排序数组</strong>：<code>O(logn)</code>时间搜索，但需要<code>O(n)</code>时间来插入，得到中位数的时间是<code>O(1)</code>；</li><li><strong>排序链表</strong>：<code>O(n)</code>时间插入，定义两个指针来指向链表中间的节点（不断调整的开销<code>O(1)</code>），所以找出中位数只需要<code>O(1)</code>；</li><li><strong>AVL树</strong>：<code>O(logn)</code>时间插入一个新节点，用<code>O(1)</code>时间得到所有节点的中位数，虽然AVL效率很高，但是大部分编程语言的函数库都没有实现这个数据结构，自己在短时间内实现也很麻烦；</li><li><strong>最大堆+最小堆</strong>：以把中位数定义为将数组分为两个部分，前一部分小于中位数，后一部分大于中位数，所以其实我们不需要前后部分一定要完整地排序，我们只需要得到前一部分的最大值和后一部分的最小值，所以可以<strong>用最大堆来组织前一部分，用最小堆组织后一部分</strong>，让两部分的大小接近相等，插入时间<code>O(logn)</code>，得到中位数的时间<code>O(1)</code>。</li></ul><div align="center"><p><img src="/images/s2o-c5-f1.jpg"><br><img src="/images/s2o-c5-f2.jpg"></p></div><p>基于STL中的函数<code>push_heap</code>、<code>pop_heap</code>及<code>vector</code>实现堆。比较仿函数<code>less</code>和<code>greater</code>分别用来实现最大堆和最小堆。</p><p>完整实现代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt; // push_heap/pop_heap/less/greater</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;exception&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="class"><span class="keyword">class</span> <span class="title">DynamicArray</span> &#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(T num)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(((min.size() + max.size()) &amp; <span class="number">1</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// 已经有偶数个，但有可能是0</span></span><br><span class="line">                <span class="keyword">if</span>(max.size() &gt; <span class="number">0</span> &amp;&amp; num &lt; max[<span class="number">0</span>]) &#123;</span><br><span class="line">                    <span class="comment">// 如果这个数比最大堆的堆顶元素小，要先放进最大堆</span></span><br><span class="line">                    max.push_back(num);</span><br><span class="line">                    <span class="comment">// 构建堆</span></span><br><span class="line">                    <span class="built_in">std</span>::push_heap(max.begin(), max.end(), <span class="built_in">std</span>::less&lt;T&gt;());</span><br><span class="line">                    <span class="comment">// 拿出堆顶元素</span></span><br><span class="line">                    num = max[<span class="number">0</span>];</span><br><span class="line">                    <span class="comment">// pop_head，将堆顶元素放在后面</span></span><br><span class="line">                    <span class="built_in">std</span>::pop_heap(max.begin(), max.end(), <span class="built_in">std</span>::less&lt;T&gt;());</span><br><span class="line">                    <span class="comment">// 元素出堆</span></span><br><span class="line">                    max.pop_back();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 元素进最小堆</span></span><br><span class="line">                min.push_back(num);</span><br><span class="line">                <span class="built_in">std</span>::push_heap(min.begin(), min.end(), <span class="built_in">std</span>::greater&lt;T&gt;());</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 已经有奇数个</span></span><br><span class="line">                <span class="keyword">if</span>(min.size() &gt; <span class="number">0</span> &amp;&amp; min[<span class="number">0</span>] &lt; num) &#123;</span><br><span class="line">                    <span class="comment">// 如果这个数比最小堆的堆顶元素大，要先放进最小堆</span></span><br><span class="line">                    min.push_back(num);</span><br><span class="line">                    <span class="comment">// 构建堆</span></span><br><span class="line">                    <span class="built_in">std</span>::push_heap(min.begin(), min.end(), <span class="built_in">std</span>::greater&lt;T&gt;());</span><br><span class="line">                    <span class="comment">// 拿出堆顶元素</span></span><br><span class="line">                    num = min[<span class="number">0</span>];</span><br><span class="line">                    <span class="comment">// 堆顶元素放在后面</span></span><br><span class="line">                    <span class="built_in">std</span>::pop_heap(min.begin(), min.end(), <span class="built_in">std</span>::greater&lt;T&gt;());</span><br><span class="line">                    <span class="comment">// 元素出堆</span></span><br><span class="line">                    min.pop_back();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 元素进最大堆</span></span><br><span class="line">                max.push_back(num);</span><br><span class="line">                <span class="built_in">std</span>::push_heap(max.begin(), max.end(), <span class="built_in">std</span>::less&lt;T&gt;());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function">T <span class="title">get_median</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">int</span> size = min.size() + max.size();</span><br><span class="line">            <span class="keyword">if</span>(size == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// throw error</span></span><br><span class="line">                <span class="function"><span class="built_in">std</span>::logic_error <span class="title">ex</span><span class="params">(<span class="string">&quot;Empty!&quot;</span>)</span></span>;</span><br><span class="line">                <span class="keyword">throw</span> <span class="built_in">std</span>::exception(ex);</span><br><span class="line">            &#125;</span><br><span class="line">            T median = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span>((size &amp; <span class="number">1</span>) == <span class="number">1</span>) &#123;</span><br><span class="line">                median = min[<span class="number">0</span>]; <span class="comment">// 偶数的时候进最小堆，所以奇数时最小堆会多一个</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                median = (min[<span class="number">0</span>] + max[<span class="number">0</span>]) / <span class="number">2</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> median;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;T&gt; min;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;T&gt; max;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">stream_median</span><span class="params">(<span class="keyword">int</span>* stream, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(stream == <span class="literal">nullptr</span> || n &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    DynamicArray&lt;<span class="keyword">int</span>&gt; darray; <span class="comment">// 注意模板类的声明使用方法</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        darray.insert(stream[i]);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Read index=%d, median=%d\n&quot;</span>, i, darray.get_median());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> stream[] = &#123; <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>&#125;;</span><br><span class="line">    stream_median(stream, <span class="number">20</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中使用到了代码里不常用的模板类，如果面试题有说明具体的数据类型，也可以直接用那个数据类型，而不是使用模板类。</p><p>其中使用到的几个和堆相关的函数进行一下说明，以后可能会用到：</p><ul><li><code>make_heap(begin, end, comp)</code>：虽然在这里没有用到，但还是说明一下，将一个数组(<code>vector</code>)的指定部分(<code>[begin,end)</code>)进行堆排序，堆顶元素放在第一个位置，默认使用的<code>comp</code>是<code>less&lt;T&gt;</code>，即最大元素放在第一个位置（最大堆），<code>greater&lt;T&gt;</code>为最小元素放在第一个位置（最小堆）；</li><li><code>push_heap(begin, end, comp)</code>：一般在调用前，把一个新元素放在数组的尾部(<code>vec.push_back(elm)</code>)，然后再调用函数对插入尾部的元素做堆排序；</li><li><code>pop_heap(begin, end, comp)</code>：将堆顶元素移动到数组尾部，同时将剩下的元素重新构造成堆结构；</li><li><code>sort_heap(begin, end, comp)</code>：将一个堆做排序，最终成为一个有序的序列，前提条件是输入的数组范围本身是一个对应<code>comp</code>的堆，如果<code>comp</code>是<code>less&lt;T&gt;</code>，最大堆最终序列是一个递增序列（大的在后面），如果是<code>greater&lt;T&gt;</code>，最小堆最终序列是一个递减序列（小的在后面）；</li></ul><hr><blockquote><p>面试题42：连续子数组的最大和。</p></blockquote><p>输入一个整型数组，数组里有正数也有负数。数组中的一个或连续多个整数组成一个子数组。求所有子数组的和的最大值（就是和最大的那个子数组的和值是多少），要求时间复杂度<code>O(n)</code>；例如，输入的数组为<code>&#123;1,-2,3,10,-4,7,2,-5&#125;</code>，和最大的子数组为<code>&#123;3,10,-4,7,2&#125;</code>，因此输出为该子数组的和<code>18</code>。</p><p>最简单直观的暴力遍历法就不说了（时间<code>O(n^2)</code>），只说优化的解决方案。</p><p><strong>解法一</strong>：举例分析数组的规律。</p><p>从头开始往后加可以分析其中的规律，例如从某一步从<code>i</code>开始向后累加和，到<code>j</code>之前如果和已经为负数了，那么对于<code>j</code>而言，如果再加上前面这前<code>j-i</code>个位置的数字肯定不会比<code>j</code>自身要大，所以要计算从<code>j</code>开始的可能最大子数组和，就不用再加上前<code>j-i</code>位置的数字，重新从<code>j</code>开始求子数组和；同时求和的过程中，不断的更新记录的最大和。</p><div align="center"><p><img src="/images/s2o-c5-f3.jpg" alt="计算数组{1,-2,3,10,-4,7,2,-5}中最大子数组和的过程"></p></div><p>完整实现代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;limits.h&gt; // INT_MIN INT_MAX</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> g_invalid_input = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check_input</span><span class="params">(<span class="keyword">int</span>* data, <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">    g_invalid_input = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span>(data == <span class="literal">nullptr</span> || len &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        g_invalid_input = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find_max_sub_sum</span><span class="params">(<span class="keyword">int</span>* data, <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!check_input(data, len)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> max_sum = INT_MIN;</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(sum &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            sum = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        sum += data[i];</span><br><span class="line">        <span class="keyword">if</span>(max_sum &lt; sum) &#123;</span><br><span class="line">            max_sum = sum;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> max_sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> data[] = &#123;<span class="number">1</span>, <span class="number">-2</span>, <span class="number">3</span>, <span class="number">10</span>, <span class="number">-4</span>, <span class="number">7</span>, <span class="number">2</span>, <span class="number">-5</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> result = find_max_sub_sum(data, <span class="number">8</span>);</span><br><span class="line">    <span class="keyword">if</span>(g_invalid_input) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Invalid input.\n&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Max sum: %d\n&quot;</span>, result); <span class="comment">// 18</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>解法二</strong>：动态规划法。</p><p>如果用函数<code>f(i)</code>表示以第<code>i</code>个数字结尾的子数组（即必须包含这个尾元素）的最大和，那么我们需要求出<code>max&#123;f(i)&#125;, 0&lt;=i&lt;=n</code>，可以用如下递归公式来求<code>f(i)</code>：</p><div align="center"><p><img src="/images/s2o-c5-f4.jpg"></p></div><p>其实公式的意义和解法一的思路是相同的，不过表达形式不同，代码就不再写一遍了。</p><hr><blockquote><p>面试题43：1~n整数中1出现的次数。</p></blockquote><p>输入一个整数<code>n</code>，求<code>1~n</code>这<code>n</code>个整数的十进制表示中<code>1</code>出现的次数，例如，输入<code>12</code>，<code>1~12</code>这些整数中包含<code>1</code>的数字有<code>1、10、11</code>和<code>12</code>，<code>1</code>一共出现了<code>5</code>次。</p><p>简单地方法就不再写了，主要写一下书上的优化方法（其实还蛮不好理解的），直接看书上举的例子吧。</p><ul><li>例如<code>1~21345</code>，首先拆成<code>1~1345</code>和<code>1346~21345</code>，前者可以递归地调用<code>1~n</code>；</li><li><code>1346~21345</code>必然会包含<code>10000~19999</code>（因为<code>21345</code>的顶位<code>2</code>大于<code>1</code>），所以顶位上出现的1的个数有<code>10^4</code>个；如果定位小于<code>1</code>，即只包括<code>1346~11345</code>或者说<code>10000~11345</code>这部分，顶位的1个数就只有<code>1346+1</code>个；</li><li><code>1346~21345</code>数完顶位后，开始计数其他位的1个数，此时分为两组<code>1346~11345</code>,<code>11346~21345</code>，这样分的目的是，<code>1346~11345</code>的后4位<code>x1346~x1345</code>整好覆盖了4位数的所有情况<code>0~9999</code>，所以只需要其中一位固定1，其他位任选<code>0~9</code>，就可以得到该位上的1个数，所以对于一组<code>1346~11345</code>有<code>4*10^3</code>个，<code>11346~21345</code>同理<code>4*10^3</code>个，所以一共<code>2*4*10^3</code>个；</li><li>最后将递归求解的<code>1~1345</code>计数，和<code>1346~21345</code>顶位计数和其他位技术相加，就得到最后的结果。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pow_base_10</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> result = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">unsigned</span> <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        result *= <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">count_1</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* str_n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!str_n || *str_n &lt; <span class="string">&#x27;0&#x27;</span> || *str_n &gt; <span class="string">&#x27;9&#x27;</span> || *str_n == <span class="string">&#x27;\0&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> first = *str_n - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> len = (<span class="keyword">unsigned</span> <span class="keyword">int</span>)<span class="built_in">strlen</span>(str_n);</span><br><span class="line">    <span class="keyword">if</span>(len == <span class="number">1</span> &amp;&amp; first == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(len == <span class="number">1</span> &amp;&amp; first &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 假设str_n是 21345</span></span><br><span class="line">    <span class="comment">// num_first_digit 是数字10000~19999的第一位中的数目</span></span><br><span class="line">    <span class="keyword">int</span> num_first_digit = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(first &gt; <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">// 无论first有多大，只要大于1</span></span><br><span class="line">        <span class="comment">// 就包含10000~19999这些数（目前的例子下）</span></span><br><span class="line">        <span class="comment">// 所以目前的顶位出现的1的数量有 10^(len-1)个</span></span><br><span class="line">        num_first_digit = pow_base_10(len - <span class="number">1</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(first == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">// 如果fisrt位1，就是10000~11345这种情况</span></span><br><span class="line">        <span class="comment">// 这个时候就有1345+1个1出现在顶位上</span></span><br><span class="line">        num_first_digit = atoi(str_n + <span class="number">1</span>) + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 1346~21345除了在顶位之外的数位上1的情况</span></span><br><span class="line">    <span class="comment">// 最高位是2，所以分成两段 1346~11345 11346~21345</span></span><br><span class="line">    <span class="comment">// 每一段剩下的4位数字中，选择其中一位是1，其余三位可以在0~9数字中选择</span></span><br><span class="line">    <span class="comment">// 根据排列组合有 2 * 4 * 10^3</span></span><br><span class="line">    <span class="keyword">int</span> num_other_digit = first * (len - <span class="number">1</span>) * pow_base_10(len - <span class="number">2</span>);</span><br><span class="line">    <span class="comment">// 1~1345的1的数目</span></span><br><span class="line">    <span class="keyword">int</span> num_rec = count_1(str_n + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> num_first_digit + num_other_digit + num_rec;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">count_1_from_1_to_n</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n &lt; <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">char</span> str_n[<span class="number">50</span>];</span><br><span class="line">    <span class="built_in">sprintf</span>(str_n, <span class="string">&quot;%d&quot;</span>, n);</span><br><span class="line">    <span class="keyword">return</span> count_1(str_n);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;1~%d have %d &#x27;1&#x27;\n&quot;</span>, <span class="number">12</span>, count_1_from_1_to_n(<span class="number">12</span>));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;1~%d have %d &#x27;1&#x27;\n&quot;</span>, <span class="number">21345</span>, count_1_from_1_to_n(<span class="number">21345</span>));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最基础的思路需要<code>O(nlogn)</code>的时间，优化后的思路只需要<code>O(logn)</code>，所以要快得多。</p><hr><blockquote><p>面试题44：数字序列中某一位的数字。</p></blockquote><p>数字以<code>0123456789101112131415...</code>的格式，序列化到一个字符序列中。在这个序列中，第5位(从0开始计数)是5，第13位是1，第19位是4，等等。写一个函数，求任意第<code>n</code>位对应的数字。</p><p>直接的方法就是从0开始逐一地枚举每个数组，每枚举一个数字时，求该数字是几位数，并把位数累加，如果位数只和小于或等于输入的n，则继续枚举下一个数字，当累加位数大于n时，第n位数字一定在这个数字里，我们再从该数字中找出对应的一位。</p><p>这样的方法还不够优化，其实是可以有规律地一段段跳过的，例如寻找第<code>1001</code>位：</p><ul><li><code>0~9</code>一共10个字符，<code>1001</code>&gt;<code>10</code>，在后面的字符中寻找第<code>991</code>位；</li><li><code>10~99</code>一共180(90*2)个字符，<code>991</code>&gt;<code>180</code>，在后面的字符中寻找第<code>881</code>位；</li><li><code>100~999</code>一共2700(900*3)个字符，<code>881</code>&lt;<code>2700</code>，所以第<code>n</code>位一定是<code>100~999</code>中间的某个数，由于<code>811=270*3+1</code>，意味着第<code>881</code>位是从<code>100</code>开始的第<code>270</code>个数字(<code>370</code>)的中间1位，即<code>7</code>。</li></ul><p>完整代码实现：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt; // std::pow</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 得到为m位数字总共有多少个</span></span><br><span class="line"><span class="comment">// 例如m=2，返回(10~99)一共90个</span></span><br><span class="line"><span class="comment">// m=3，返回(100~999)一共900个</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">count_of_integers</span><span class="params">(<span class="keyword">int</span> digits)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(digits == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> count = (<span class="keyword">int</span>) <span class="built_in">std</span>::<span class="built_in">pow</span>(<span class="number">10</span>, digits - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">9</span> * count;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 得到在m位数字中，第一个数字</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">begin_num</span><span class="params">(<span class="keyword">int</span> digits)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(digits == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">int</span>) <span class="built_in">std</span>::<span class="built_in">pow</span>(<span class="number">10</span>, digits - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 得到在m位数字中，第n位到是什么</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">digit_at_n</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> digits)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 例如370 = 100 + 881 / 3</span></span><br><span class="line">    <span class="keyword">int</span> number = begin_num(digits) + n / digits;</span><br><span class="line">    <span class="comment">// 例如1 = 3 - 881 % 3</span></span><br><span class="line">    <span class="comment">// from right 是为了之后求数的时候直接从底位开始</span></span><br><span class="line">    <span class="keyword">int</span> n_from_right = digits - n % digits;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n_from_right; i++) &#123;</span><br><span class="line">        number /= <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> number % <span class="number">10</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">digit_at_n</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> digits = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> numbers = count_of_integers(digits);</span><br><span class="line">        <span class="keyword">if</span>(n &lt; numbers * digits) &#123;</span><br><span class="line">            <span class="keyword">return</span> digit_at_n(n, digits);</span><br><span class="line">        &#125;</span><br><span class="line">        n -= digits * numbers;</span><br><span class="line">        digits++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, digit_at_n(<span class="number">0</span>));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, digit_at_n(<span class="number">1000</span>));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, digit_at_n(<span class="number">1001</span>));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, digit_at_n(<span class="number">1002</span>));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><blockquote><p>面试题45：把数组排成最小的数。</p></blockquote><p>输入一个<strong>正整数数组</strong>，把数组里<strong>所有数字</strong>拼接起来<strong>排成一个数</strong>，打印能拼接出的所有数字中<strong>最小的一个</strong>。例如，输入<code>&#123;3,32,321&#125;</code>，则打印出这3个数字能排成的最小数字<code>321323</code><br>。</p><p>基础的思路是全排列，然后找出最小的，时间开销一般是<code>O(n!)</code>，优化的思路也不会很复杂，比如就单看两个数<code>nn</code>和<code>mm</code>，他们两个如何拼接可以最小，也就是比较<code>nnmm</code>和<code>mmnn</code>，那么当整个数组都是前一个数在前面的情况下可以让两个数的结果最小，顺序拼接的结果自然也是最小的（即不会出现比这个结果还小的结果），所以最后问题变成利用这种规则去对数组进行排序。</p><p>完整实现代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt; // sort</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt; // strcpy strcmp strcat</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> g_invalid_input = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check_data</span><span class="params">(<span class="keyword">int</span>* data, <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">    g_invalid_input = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span>(data == <span class="literal">nullptr</span> || len &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        g_invalid_input = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 校验是否都是正整数</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(data[i] &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            g_invalid_input = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAX_INT_LEN = <span class="number">10</span>;</span><br><span class="line"><span class="comment">// 申请两个全局字符数组，避免排序函数中反复申请，浪费时间</span></span><br><span class="line"><span class="keyword">char</span>* g_str_comb1 = <span class="keyword">new</span> <span class="keyword">char</span>[MAX_INT_LEN * <span class="number">2</span> + <span class="number">1</span>];</span><br><span class="line"><span class="keyword">char</span>* g_str_comb2 = <span class="keyword">new</span> <span class="keyword">char</span>[MAX_INT_LEN * <span class="number">2</span> + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">compare</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* num1, <span class="keyword">const</span> <span class="keyword">char</span>* num2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">strcpy</span>(g_str_comb1, num1);</span><br><span class="line">    <span class="built_in">strcat</span>(g_str_comb1, num2);</span><br><span class="line">    <span class="built_in">strcpy</span>(g_str_comb2, num2);</span><br><span class="line">    <span class="built_in">strcat</span>(g_str_comb2, num1);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">strcmp</span>(g_str_comb1, g_str_comb2) == <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">min_concat</span><span class="params">(<span class="keyword">int</span>* data, <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!check_data(data, len)) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 其实还要考虑两个int相连有可能会超过int表示范围</span></span><br><span class="line">    <span class="comment">// 所以转用字符串可能更合适，同时也不会修改原数据的顺序</span></span><br><span class="line">    <span class="keyword">char</span>** str_data = <span class="keyword">new</span> <span class="keyword">char</span>*[len];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">        str_data[i] = <span class="keyword">new</span> <span class="keyword">char</span>[MAX_INT_LEN + <span class="number">1</span>];</span><br><span class="line">        <span class="built_in">sprintf</span>(str_data[i], <span class="string">&quot;%d&quot;</span>, data[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">std</span>::sort(str_data, str_data + len, compare);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>, str_data[i]);</span><br><span class="line">        <span class="keyword">delete</span>[] str_data[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">delete</span>[] str_data;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> data[] = &#123;<span class="number">3</span>, <span class="number">32</span>, <span class="number">321</span>, <span class="number">8</span>, <span class="number">44</span>, <span class="number">1</span>, <span class="number">143</span>&#125;;</span><br><span class="line">    min_concat(data, <span class="number">7</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码中需要注意的一个地方是，如果直接用数字排序的方式，可能会在比较<code>nnmm</code>和<code>mmnn</code>时，这种拼接结果超出<code>int</code>的表示范围，而导致错误结果，所以可能出现大数的情况，要注意用字符串来替代处理。另外书上的代码在校验输入的时候，漏掉了对数组的是否是正整数的判断，上面代码也补上了，并且书上代码使用的排序方法是<code>qsort</code>，个人建议使用<code>sort</code>，一般情况下更加效率和便利。</p><p>书上有细致的讲，如何去证明这样的方法的正确性（比较规则的三个角度，自反性(<code>aa = aa</code>)、对称性(<code>a&lt;b =&gt; ab&lt;ba, ba&gt;ab, =&gt; b&gt;a</code>)以及传递性(<code>a&lt;b,b&lt;c =&gt; ab&lt;ba, bc&lt;cb =&gt; ac&lt;ca</code>)，和反证法，假设结果不是最小的，存在一个更小的，然后去推出假设不成立），尤其是当面试官问到的时候，也要能够说出缘由来，这里就不再复述了。</p><hr><blockquote><p>面试题46：把数字翻译成字符串。</p></blockquote><p>给定一个数字，按照如下规则把它翻译成字符串：<code>0</code>翻译成<code>a</code>，<code>1</code>翻译成<code>b</code>，…，<code>11</code>翻译成<code>l</code>，…，<code>25</code>翻译成<code>z</code>。一个数字可能有多个翻译。例如<code>12258</code>有5种不同的翻译，分别是<code>bccfi</code>、<code>bwf1</code>、<code>bczi</code>、<code>mcfi</code>和<code>mzi</code>。实现一个函数，用来计算一个数字有多少种不同的翻译方法。</p><p>直观的递归方法是，<code>12258</code>可以拆解为求解<code>2258</code>和<code>258</code>两个子问题，其中有可分支的条件是<code>c1==1 || (c1==2 &amp;&amp; c2 &lt;= 5)</code>，否则只能单线往下求解。</p><p>单纯递归完整代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAX_INT_LEN = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">kinds_of_encode</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* str_num)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(*str_num == <span class="string">&#x27;\0&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">char</span> c1 = *str_num, c2 = *(str_num + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span>(c1 == <span class="string">&#x27;1&#x27;</span> || (c1 == <span class="string">&#x27;2&#x27;</span> &amp;&amp; c2 &lt;= <span class="string">&#x27;5&#x27;</span>)) &#123;</span><br><span class="line">        <span class="keyword">return</span> kinds_of_encode(str_num + <span class="number">1</span>) + kinds_of_encode(str_num + <span class="number">2</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> kinds_of_encode(str_num + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">kinds_of_encode</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(num &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 用字符数组来处理更加方便一点</span></span><br><span class="line">    <span class="keyword">char</span>* str_num = <span class="keyword">new</span> <span class="keyword">char</span>[MAX_INT_LEN + <span class="number">1</span>];</span><br><span class="line">    <span class="built_in">sprintf</span>(str_num, <span class="string">&quot;%d&quot;</span>, num);</span><br><span class="line">    <span class="keyword">int</span> result = kinds_of_encode(str_num);</span><br><span class="line">    <span class="keyword">delete</span>[] str_num;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, kinds_of_encode(<span class="number">12258</span>)); <span class="comment">// 5</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>尽管看起来很简洁，但是这并不是最优的代码，例如<code>2258</code>和<code>258</code>两个子问题，<code>2258</code>会继续分支出<code>258</code>和<code>58</code>，在这一步<code>258</code>子问题被反复求解了，导致了计算的浪费。递归是从最大的问题开始自上而下的解决，其实我们也可以从最小的子问题开始自下而上的解决，来消除重复子问题。</p><p>也就是说，<strong>从数字的末尾开始，从右到左翻译</strong>，并计算不同翻译的数目。</p><p>完整实现代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">kinds_of_encode</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(num &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 从右向左翻译，避免重复子问题</span></span><br><span class="line">    <span class="keyword">char</span>* str_num = <span class="keyword">new</span> <span class="keyword">char</span>[MAX_INT_LEN + <span class="number">1</span>];</span><br><span class="line">    <span class="built_in">sprintf</span>(str_num, <span class="string">&quot;%d&quot;</span>, num);</span><br><span class="line">    <span class="keyword">int</span> len = <span class="built_in">strlen</span>(str_num);</span><br><span class="line">    <span class="keyword">int</span>* results = <span class="keyword">new</span> <span class="keyword">int</span>[len];</span><br><span class="line">    results[len - <span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">char</span> c1, c2;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = len - <span class="number">2</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        c1 = *(str_num + i);</span><br><span class="line">        c2 = *(str_num + i + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span>(c1 == <span class="string">&#x27;1&#x27;</span> || (c1 == <span class="string">&#x27;2&#x27;</span> &amp;&amp; c2 &lt;= <span class="string">&#x27;5&#x27;</span>)) &#123;</span><br><span class="line">            results[i] = results[i + <span class="number">1</span>] + results[i + <span class="number">2</span>];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            results[i] = results[i + <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> result = results[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">delete</span>[] str_num;</span><br><span class="line">    <span class="keyword">delete</span>[] results;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, kinds_of_encode(<span class="number">12258</span>)); <span class="comment">// 5</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><blockquote><p>面试题47：礼物的最大价值。</p></blockquote><p>在一个<code>m x n</code>的棋盘的每一格都放有一个礼物，每个礼物都有一定的价值（价值大于0）。可以从棋盘的左上角开始拿格子里的礼物，并每次向右或向下移动一格，直到到达棋盘的右下角。给定一个棋盘以及礼物价值，请问最多能拿到多少价值的礼物？</p><p>例如，下面的棋盘中，如果沿着带下划线的数字线路（1、12、5、7、7、16、5），那么我们能拿到最大价值为53的礼物。</p><div align="center"><p><img src="/images/s2o-c5-f5.jpg"></p></div><p>定义<code>f(i,j)</code>为到达坐标<code>(i,j)</code>的格子时，能拿到的礼物总和的最大值，我们有两种途径来到达坐标为<code>(i,j)</code>的格子，通过格子<code>(i-1,j)</code>左侧或者<code>(i,j-1)</code>上侧，所以<code>f(i,j)=max(f(i-1,j), f(i,j-1)) + gift[i,j]</code>，<code>gift[i,j]</code>表示坐标<code>(i,j)</code>的格子里礼物的价值。</p><p>典型的动态规划问题，定义一个辅助二维数组，数组中<code>(i,j)</code>表示到达该格子时，能拿到的礼物价值总和的最大值。</p><p>完整实现代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">max_gift_value</span><span class="params">(<span class="keyword">int</span>** values, <span class="keyword">int</span> rows, <span class="keyword">int</span> cols)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(values == <span class="literal">nullptr</span> || *values == <span class="literal">nullptr</span> || rows &lt;= <span class="number">0</span> || cols &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span>** max_values = <span class="keyword">new</span> <span class="keyword">int</span>*[rows];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; rows; i++) &#123;</span><br><span class="line">        max_values[i] = <span class="keyword">new</span> <span class="keyword">int</span>[cols];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; rows; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; cols; j++) &#123;</span><br><span class="line">            <span class="keyword">int</span> left = <span class="number">0</span>, up = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span>(i &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                up = max_values[i - <span class="number">1</span>][j];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(j &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                left = max_values[i][j - <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">int</span> value = *((<span class="keyword">int</span> *)values + cols * i + j);</span><br><span class="line">            max_values[i][j] = <span class="built_in">std</span>::max(left, up) + value;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> max_value = max_values[rows<span class="number">-1</span>][cols<span class="number">-1</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; rows; i++) &#123;</span><br><span class="line">        <span class="keyword">delete</span>[] max_values[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">delete</span>[] max_values;</span><br><span class="line">    <span class="keyword">return</span> max_value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> rows = <span class="number">4</span>, cols = <span class="number">4</span>;</span><br><span class="line">    <span class="keyword">int</span> values[<span class="number">4</span>][<span class="number">4</span>] = &#123;</span><br><span class="line">        &#123;<span class="number">1</span>, <span class="number">10</span>, <span class="number">3</span>, <span class="number">8</span>&#125;,</span><br><span class="line">        &#123;<span class="number">12</span>, <span class="number">2</span>, <span class="number">9</span>, <span class="number">6</span>&#125;,</span><br><span class="line">        &#123;<span class="number">5</span>, <span class="number">7</span>, <span class="number">4</span>, <span class="number">11</span>&#125;,</span><br><span class="line">        &#123;<span class="number">3</span>, <span class="number">7</span>, <span class="number">16</span>, <span class="number">5</span>&#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Max gift value: %d&quot;</span>, max_gift_value((<span class="keyword">int</span>**)values, rows, cols));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>考虑进一步的优化（主要是空间上），前面我们提到，到达坐标为<code>(i,j)</code>的格子时，最大价值依赖于<code>(i,j-1)</code>左侧和<code>(i-1,j)</code>上侧两个格子，因为此第<code>i-2</code>行及更上面的所有格子礼物的最大价值实际没有保存的必要。我们可以用一个一维数组来替代前面代码中的二维数组<code>max_values</code>，一维数组的长度为<code>cols</code>。</p><p>优化之后的代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">max_gift_value</span><span class="params">(<span class="keyword">int</span>** values, <span class="keyword">int</span> rows, <span class="keyword">int</span> cols)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(values == <span class="literal">nullptr</span> || *values == <span class="literal">nullptr</span> || rows &lt;= <span class="number">0</span> || cols &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span>* max_values = <span class="keyword">new</span> <span class="keyword">int</span>[rows]; <span class="comment">// 修改为一维数组</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; rows; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; cols; j++) &#123;</span><br><span class="line">            <span class="keyword">int</span> left = <span class="number">0</span>, up = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span>(i &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                up = max_values[j]; <span class="comment">// 此时j位置保存的为上一行的数据</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(j &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                left = max_values[j - <span class="number">1</span>]; <span class="comment">// 此时j-1位置已经是该行的数据</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">int</span> value = *((<span class="keyword">int</span> *)values + cols * i + j);</span><br><span class="line">            max_values[j] = <span class="built_in">std</span>::max(left, up) + value; <span class="comment">// 更新j为该行的数据</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> max_value = max_values[cols<span class="number">-1</span>];</span><br><span class="line">    <span class="keyword">delete</span>[] max_values;</span><br><span class="line">    <span class="keyword">return</span> max_value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><blockquote><p>面试题48：最长不含重复字符的子字符串。</p></blockquote><p>请从字符串中找出一个<strong>最长的不包含重复字符</strong>的子字符串，计算该最长子字符串的长度。假设字符串中只包含<code>a~z</code>。例如<code>arabcacfr</code>中，最长的不包含重复字符的子字符串是<code>acfr</code>，长度是<code>4</code>(还有子串<code>rabc</code>)。</p><p>这道题其实和之前的最大子数组和（面试题42）的思路有异曲同工之妙，同样有两种方法，一种是通过规律观察，另一种就是书上讲的动态规划法。首先讲一下这类“连续子串的最大/小”问题的一种规律解法，申明两个指针从头开始，头指针指向子串的头部，尾指针指向子串的尾部，尾指针每一步都向后移动一尾，同时根据移动后尾指针访问的状况（以及结合之前的值）来判断如何移动头指针。在本题目中，约束条件是不包含重复字符，也就是说当尾指针访问到一个重复字符时，就要调整头指针移向下一个不会让子串出现重复字符的位置（也就是跳到下一个满足约束的子串），记录过程中子串的最大长度，最后返回最大长度，时间复杂度<code>O(n)</code>。</p><p>完整实现代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">longest_substr_no_dup</span><span class="params">(<span class="keyword">char</span>* str)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(str == <span class="literal">nullptr</span> || <span class="built_in">strlen</span>(str) == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">map</span>&lt;<span class="keyword">char</span>, <span class="keyword">bool</span>&gt; char_map;</span><br><span class="line">    <span class="comment">// 初始化map</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; i++) &#123;</span><br><span class="line">        char_map[<span class="string">&#x27;a&#x27;</span>+i] = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">char</span>* start = str;</span><br><span class="line">    <span class="keyword">char</span>* end = str;</span><br><span class="line">    <span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> max_len = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">strlen</span>(str); i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(!char_map[*end]) &#123;</span><br><span class="line">            <span class="comment">// 没有遇到重复字符，子串长度+1</span></span><br><span class="line">            len++;</span><br><span class="line">            max_len = (max_len &lt; len) ? len : max_len;</span><br><span class="line">            char_map[*end] = <span class="literal">true</span>;</span><br><span class="line">            end++;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 直到start遇到该重复字符为止</span></span><br><span class="line">            <span class="keyword">while</span>(*start != *end) &#123;</span><br><span class="line">                char_map[*start] = <span class="literal">false</span>;</span><br><span class="line">                start++;</span><br><span class="line">                len--;</span><br><span class="line">            &#125;</span><br><span class="line">            start++;</span><br><span class="line">            char_map[*end] = <span class="literal">true</span>;</span><br><span class="line">            end++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> max_len;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span>* str = <span class="string">&quot;arabcacfr&quot;</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s longest substr no dup: %d&quot;</span>, str, longest_substr_no_dup(str));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码中使用到了<code>std::map&lt;char, bool&gt;</code>来记录当前子串的字符出现情况，也可以自行建立一个<code>bool</code>数组实现记录。</p><p>然后再看一下书上的动态规划思路（其实和面试题42的动态规划解法也类似），定义<code>f(i)</code>表示以第<code>i</code>个字符结尾的不包含重复字符的子串的最长长度。如果是从左到右的计算顺序，当我们计算<code>f(i)</code>的时候<code>f(i-1)</code>已经被计算出了。</p><ul><li>如果第<code>i</code>个字符没有出现过，那么<code>f(i)=f(i-1)+1</code>；</li><li>如果第<code>i</code>个字符之前已经出现过了，要先计算第<code>i</code>个字符和它上次出现在字符串中位置的距离，记为d，接着要分两种情况：<ul><li>如果<code>d &lt;= f(i-1)</code>，此时第i个字符上次出现在<code>f(i-1)</code>对应的最长子字符串之中，因此<code>f(i)=d</code>；</li><li>如果<code>d &gt; f(i-1)</code>，此时第i个字符上次出现在<code>f(i-1)</code>对应的最长子字符串之前，因此仍然有<code>f(i)=f(i-1)+1</code>。</li></ul></li></ul><p>完整实现代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">longest_substr_no_dup</span><span class="params">(<span class="keyword">char</span>* str)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(str == <span class="literal">nullptr</span> || <span class="built_in">strlen</span>(str) == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> max_len = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> str_len = <span class="built_in">strlen</span>(str);</span><br><span class="line">    <span class="keyword">int</span>* position = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">26</span>]; <span class="comment">// 存储每个字符上次出现的下标</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; i++) &#123;</span><br><span class="line">        position[i] = <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; str_len; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> prev_index = position[*(str+i) - <span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">        <span class="keyword">if</span>(prev_index &lt; <span class="number">0</span> || i - prev_index &gt; len) &#123;</span><br><span class="line">            len++;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>(len &gt; max_len) &#123;</span><br><span class="line">                max_len = len;</span><br><span class="line">            &#125;</span><br><span class="line">            len = i - prev_index;</span><br><span class="line">        &#125;</span><br><span class="line">        position[*(str+i) - <span class="string">&#x27;a&#x27;</span>] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(len &gt; max_len) &#123;</span><br><span class="line">        max_len = len;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">delete</span> position;</span><br><span class="line">    <span class="keyword">return</span> max_len;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-时间与空间的平衡"><a href="#3-时间与空间的平衡" class="headerlink" title="3 时间与空间的平衡"></a>3 时间与空间的平衡</h2><p>由于内存的容量增加迅速，在软件开发的过程中我们允许以牺牲一定的空间为代价来优化时间性能，以尽可能地缩短软件的响应时间。这就是我们通常所说的“以空间换时间”。</p><p>在面试的时候，如果我们分配少量的辅助空间来保存计算的中间结果以提高时间效率，则通常是可以被接受的。</p><p>但“空间换时间”并不一定都是可行的，面试的时候要具体问题具体分析，也就是对时间和空间的平衡考量。</p><h2 id="面试题-49-52"><a href="#面试题-49-52" class="headerlink" title="面试题 49-52"></a>面试题 49-52</h2><blockquote><p>面试题49：丑数。</p></blockquote><p>把只包含因子<code>2、3</code>和<code>5</code>的数称作丑数(Ugly Number）。求按从小到大的顺序的第1500个丑数。例如<code>6、8</code>都是丑数，但<code>14</code>不是。习惯上把<code>1</code>当作第1个丑数。</p><p>判断一个数是不是丑数的方法，就是依次除以因数<code>2、3、5</code>，每一个因数都是无法再除了再除下一个因数，如果三个因数都除尽了，剩下的为1，则为丑数，否则不是丑数，简单实现的判别函数：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">is_ugly</span><span class="params">(<span class="keyword">int</span> number)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(number % <span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line">        number /= <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(number % <span class="number">3</span> == <span class="number">0</span>) &#123;</span><br><span class="line">        number /= <span class="number">3</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(number % <span class="number">5</span> == <span class="number">0</span>) &#123;</span><br><span class="line">        number /= <span class="number">5</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (number == <span class="number">1</span>) ? <span class="literal">true</span> : <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>每个数依次的判别是不是丑数肯定是不够高效的。</p><p><strong>优化思路</strong>：创建数组保存已找到的丑数，用空间换时间的解法。</p><p>根据丑数的定义，丑数应该是另一个丑数乘以2、3或者5的结果（1除外），因此，我们可以创建一个数组，里面数字是排好序的丑数，每个丑数都是前面的丑数乘以2、3或者5得到的。</p><p>这种思路的关键在于怎么确保数组里面的丑数排好序。假设数组已有若干个排好序的丑数，把最大的丑数记为M，分析如何生成下一个丑数。下一个丑数肯定是前面某一个丑数乘以2、3或者5得到的，并且我们仅仅需要第一个大于M的丑数，也不用去乘以前方的所有丑数，其中一定有一个丑数满足一个条件，他是从小到大的第一个乘以2会大于M的丑数，记为<code>T_2</code>，类似的有<code>T_3</code>、<code>T_5</code>，每一次我们只需要在<code>T_2 * 2</code>和<code>T_3 * 3</code>和<code>T_5 * 5</code>中找到较小的一个即可（并且要更新所有<code>T</code>）。</p><p>完整实现代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">min</span><span class="params">(<span class="keyword">int</span> num1, <span class="keyword">int</span> num2, <span class="keyword">int</span> num3)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> min = (num1 &lt; num2) ? num1 : num2;</span><br><span class="line">    min = (min &lt; num3) ? min : num3;</span><br><span class="line">    <span class="keyword">return</span> min;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ugly_num_at_n</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> *ugly_nums = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">    ugly_nums[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> next_ugly_index = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span>* pt2 = ugly_nums;</span><br><span class="line">    <span class="keyword">int</span>* pt3 = ugly_nums;</span><br><span class="line">    <span class="keyword">int</span>* pt5 = ugly_nums;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(next_ugly_index &lt; n) &#123;</span><br><span class="line">        <span class="keyword">int</span> min_num = min(*pt2 * <span class="number">2</span>, *pt3 * <span class="number">3</span>, *pt5 * <span class="number">5</span>);</span><br><span class="line">        ugly_nums[next_ugly_index] = min_num;</span><br><span class="line">        <span class="keyword">while</span>(*pt2 * <span class="number">2</span> &lt;= min_num) &#123;</span><br><span class="line">            pt2++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(*pt3 * <span class="number">3</span> &lt;= min_num) &#123;</span><br><span class="line">            pt3++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(*pt5 * <span class="number">5</span> &lt;= min_num) &#123;</span><br><span class="line">            pt5++;</span><br><span class="line">        &#125;</span><br><span class="line">        next_ugly_index++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> ugly = ugly_nums[n - <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">delete</span>[] ugly_nums;</span><br><span class="line">    <span class="keyword">return</span> ugly;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Ugly Num at %d is %d\n&quot;</span>, <span class="number">1500</span>, ugly_num_at_n(<span class="number">1500</span>)); <span class="comment">// 859963392</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Ugly Num at %d is %d\n&quot;</span>, <span class="number">5</span>, ugly_num_at_n(<span class="number">5</span>)); <span class="comment">// 5</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Ugly Num at %d is %d\n&quot;</span>, <span class="number">1</span>, ugly_num_at_n(<span class="number">1</span>)); <span class="comment">// 1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><blockquote><p>面试题50：第一次只出现一次的字符。</p></blockquote><p>题目一：字符串中第一个只出现一次的字符。</p><p>在字符串中找出第一个只出现一次的字符。如输入<code>abaccdeff</code>，则输出<code>b</code>。</p><p>直接的思路是每次都比较一个字符是否在其后面出现，这种思路的时间复杂度是<code>O(n^2)</code>，效率不够高，可以考虑用空间换时间。如果我们可以统计每个字符出现的次数，可能就会变得简单的多，一般也用哈希表来解决这种问题。</p><p>哈希表是一种比较复杂的数据结构，C++标准模板库中的<code>map</code>和<code>unordered_map</code>实现了哈希表的功能，可以直接用。由于本题的特殊性，我们其实只需要一个非常简单的哈希表就能满足要求，因此我们可以考虑实现一个简单的哈希表。字符(char)是一个长度为8(bit)的数据类型，因此总共有256种可能性。我们创建一个长度为256的数组，每个字母根据其ASCII码值作为数组的下标对应数组的一个数组，而数组中存储的是每个字符出现的次数。这样我们就创建了一个大小为256、以字符ASCII码为键值的哈希表。</p><p>第一次扫描时，更新一个字符的出现次数需要时间<code>O(1)</code>，总共<code>O(n)</code>；第二次扫描时，寻找第一个出现次数为<code>1</code>的字符，时间也是<code>O(n)</code>。同时我们需要一个辅助数组，大小是<code>1KB</code>，由于数组大小是一个常数，因此认为这种算法的空间复杂度是<code>O(1)</code>。</p><p>完整实现代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">char</span> <span class="title">first_unique_char</span><span class="params">(<span class="keyword">char</span>* str)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(str == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> TABLE_SIZE = <span class="number">256</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> hash_table[TABLE_SIZE];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">unsigned</span> <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; TABLE_SIZE; i++) &#123;</span><br><span class="line">        hash_table[i] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">char</span>* pchar = str;</span><br><span class="line">    <span class="keyword">while</span>(*pchar != <span class="string">&#x27;\0&#x27;</span>) &#123;</span><br><span class="line">        hash_table[*pchar]++;</span><br><span class="line">        pchar++;</span><br><span class="line">    &#125;</span><br><span class="line">    pchar = str;</span><br><span class="line">    <span class="keyword">while</span>(*pchar != <span class="string">&#x27;\0&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span>(hash_table[*pchar] == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> *pchar;</span><br><span class="line">        &#125;</span><br><span class="line">        pchar++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span>* str = <span class="string">&quot;abaccdeff&quot;</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;First unique char of %s is %c&quot;</span>, str, first_unique_char(str));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>题目二：字符流中第一个只出现一次的字符。</p><p>实现一个函数，用来找出字符流中第一个只出现一次的字符。例如，字符流只读出<code>go</code>时，第一个只出现一次的字符是<code>g</code>；当读出<code>google</code>时，第一个只出现一次的字符时<code>l</code>。</p><p>可以定义一个数据容器来<strong>保存字符在字符流中的位置</strong>。当一个字符第一次从字符流读出来时，把位置保存在数据容器中。当字符再次从字符流中读取时，这时把它在容器中保存的值更新为一个特殊值（如负数）。而在查找第一个只出现一次的字符时，只需要遍历容器，找到最小的位置即可。</p><p>完整实现代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;limits.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CharStatistics</span> &#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        CharStatistics(): index(<span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">256</span>; i++) &#123;</span><br><span class="line">                occurrence[i] = <span class="number">-1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">char</span> ch)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(occurrence[ch] == <span class="number">-1</span>) &#123;</span><br><span class="line">                occurrence[ch] = index;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span>(occurrence[ch] &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                occurrence[ch] = <span class="number">-2</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            index++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">char</span> <span class="title">first_unique_char</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">char</span> ch = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">            <span class="keyword">int</span> min_index = INT_MAX;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">256</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span>(occurrence[i] &gt;= <span class="number">0</span> &amp;&amp; occurrence[i] &lt; min_index) &#123;</span><br><span class="line">                    ch = (<span class="keyword">char</span>)i;</span><br><span class="line">                    min_index = occurrence[i];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> ch;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="comment">// occurrence[i] : A char with ASCII value i;</span></span><br><span class="line">        <span class="comment">// occurrence[i] = -1 : not found yet</span></span><br><span class="line">        <span class="comment">// occurrence[i] = -2 : have been found for mutlple times</span></span><br><span class="line">        <span class="comment">// occurrence[i] &gt;= 0 : have been found only once</span></span><br><span class="line">        <span class="keyword">int</span> occurrence[<span class="number">256</span>];</span><br><span class="line">        <span class="keyword">int</span> index;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    CharStatistics char_statistics;</span><br><span class="line">    <span class="keyword">char</span>* stream = <span class="string">&quot;google&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">6</span>; i++) &#123;</span><br><span class="line">        char_statistics.insert(stream[i]);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;After insert %c, first unique char is %c\n&quot;</span>, stream[i],</span><br><span class="line">            char_statistics.first_unique_char());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><blockquote><p>面试题51：数组中的逆序对。</p></blockquote><p>在数组中的两个数字，如果前面一个数字大于后面的数字，则这两个数字组成一个逆序对。输入一个数组，求出这个数组中的逆序对的总数。例如，数组<code>&#123;7,5,6,4&#125;</code>中，一共有5个逆序对，分别是<code>(7,5)</code>、<code>(7,6)</code>、<code>(7,4)</code>、<code>(5,4)</code>和<code>(6,4)</code>。</p><div align="center"><p><img src="/images/s2o-c5-f6.jpg" alt="统计逆序对的过程"></p></div><div align="center"><p><img src="/images/s2o-c5-f7.jpg" alt="(d)中合并两个子数组并统计逆序对的过程"></p></div><ul><li>(a) P1指向的数字大于P2指向的数字（先比较最大的），表示数组中存在逆序对，把逆序对数目加2（后一个子数组的长度），并把7复制到辅助数组，向前移动P1和P3；</li><li>(b) P1指向的数字小于P2指向的数字，没有逆序对。把P2指向的数字复制到辅助数组，并向前移动P2和P3；</li><li>(c) P1指向的数字大于P2指向的数字，存在逆序对，把逆序对数目加1（后一个子数组的剩余长度），把5复制到辅助数组，想前移动P1和P3；</li><li>(…) 直到只剩一个元素，复制到辅助数组，结束合并，开始下一次相邻数组的合并。</li></ul><p>过程有点类似与归并排序，不过为了统计逆序对，从尾部开始合并。</p><p>完整实现代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">inverse_pair_core</span><span class="params">(<span class="keyword">int</span>* data, <span class="keyword">int</span>* copy, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(start == end) &#123;</span><br><span class="line">        copy[start] == data[start];</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> len = (end - start) / <span class="number">2</span>;</span><br><span class="line">    <span class="comment">// 注意这里交换了copy和data的位置，实现了交替使用</span></span><br><span class="line">    <span class="comment">// 一次合并排序的结果保存在data中</span></span><br><span class="line">    <span class="keyword">int</span> left = inverse_pair_core(copy, data, start, start + len);</span><br><span class="line">    <span class="keyword">int</span> right = inverse_pair_core(copy, data, start + len + <span class="number">1</span>, end);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> i = start + len;</span><br><span class="line">    <span class="keyword">int</span> j = end;</span><br><span class="line">    <span class="keyword">int</span> index_copy = end;</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(i &gt;= start &amp;&amp; j &gt;= start + len + <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span>(data[i] &gt; data[j]) &#123;</span><br><span class="line">            <span class="comment">// 前面的大于后面的</span></span><br><span class="line">            copy[index_copy--] = data[i--];</span><br><span class="line">            count += j - start - len;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 前面的小于后面的</span></span><br><span class="line">            copy[index_copy--] = data[j--];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 拷贝剩余的</span></span><br><span class="line">    <span class="keyword">while</span>(i &gt;= start) &#123;</span><br><span class="line">        copy[index_copy--] = data[i--];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(j &gt;= start + len + <span class="number">1</span>) &#123;</span><br><span class="line">        copy[index_copy--] = data[j--];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> left + right + count;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">inverse_pair</span><span class="params">(<span class="keyword">int</span>* data, <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(data == <span class="literal">nullptr</span> || len &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span>* copy = <span class="keyword">new</span> <span class="keyword">int</span>[len];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">        copy[i] = data[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> count = inverse_pair_core(data, copy, <span class="number">0</span>, len - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">delete</span>[] copy;</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> data[] = &#123;<span class="number">7</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">4</span>&#125;;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Data have %d inverse pair.\n&quot;</span>, inverse_pair(data, <span class="number">4</span>));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>归并排序的时间复杂度是<code>O(nlogn)</code>，比直观方法的<code>O(n^2)</code>要快，但同时归并需要一个长度为<code>n</code>的辅助数组，所以用了<code>O(n)</code>的空间来换时间效率的提升。</p><hr><blockquote><p>面试题52：两个链表的第一个公共节点。</p></blockquote><p>输入两个链表，找出他们的第一个公共节点。链表节点定义如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> key;</span><br><span class="line">    node* pnext;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其实有之前题目的铺垫，这里蛮容易想到根据两个链不同长度来调整起始指针的位置，调整起始后的两个指针，同步移动，当相遇时就是两个链表的公共节点，时间复杂度<code>O(m+n)</code>，<code>m</code>和<code>n</code>是两个链表的长度。</p><p>完整实现代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> key;</span><br><span class="line">    node* pnext;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">node* <span class="title">init_node</span><span class="params">(<span class="keyword">int</span> key)</span> </span>&#123; ... &#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init_list</span><span class="params">(node** pphead1, node** pphead2)</span> </span>&#123; ... &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">get_list_len</span><span class="params">(node* phead)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line">    node* pnode = phead;</span><br><span class="line">    <span class="keyword">while</span>(pnode != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        len++;</span><br><span class="line">        pnode = pnode-&gt;pnext;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> len;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">node* <span class="title">find_first_common_node</span><span class="params">(node* phead1, node* phead2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> len1 = get_list_len(phead1);</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> len2 = get_list_len(phead2);</span><br><span class="line">    <span class="keyword">if</span>(len1 == <span class="number">0</span> || len2 == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> len_diff = len1 - len2;</span><br><span class="line">    node* plong_list = phead1;</span><br><span class="line">    node* pshort_list = phead2;</span><br><span class="line">    <span class="keyword">if</span>(len2 &gt; len1) &#123;</span><br><span class="line">        len_diff = len2 - len1;</span><br><span class="line">        plong_list = phead2;</span><br><span class="line">        pshort_list = phead1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len_diff; i++) &#123;</span><br><span class="line">        plong_list = plong_list-&gt;pnext;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(plong_list != <span class="literal">nullptr</span> &amp;&amp; pshort_list != <span class="literal">nullptr</span></span><br><span class="line">          &amp;&amp; plong_list != pshort_list) &#123;</span><br><span class="line">        plong_list = plong_list-&gt;pnext;</span><br><span class="line">        pshort_list = pshort_list-&gt;pnext;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> plong_list;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    node* phead1;</span><br><span class="line">    node* phead2;</span><br><span class="line">    init_list(&amp;phead1, &amp;phead2);</span><br><span class="line">    node* first_common_node = find_first_common_node(phead1, phead2);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;First common node is %d\n&quot;</span>, first_common_node-&gt;key);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>书上还提到了一种方法，非常的巧妙，尤其是在这种需要在单向链表反向查找时，可以使用一个栈来实现逆向查询，例如在本题中，如果我们可以从两个链表的尾节点开始逆向查找，那么最后一个相同的节点，也就是第一个公共节点，可以使用两个栈来实现这个过程，时间开销<code>O(m+n)</code>，空间开销<code>O(m+n)</code>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">node* <span class="title">find_first_common_node</span><span class="params">(node* phead1, node* phead2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(phead1 == <span class="literal">nullptr</span> || phead2 == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;node*&gt; stk1, stk2;</span><br><span class="line">    <span class="keyword">while</span>(phead1 != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        stk1.push_back(phead1);</span><br><span class="line">        phead1 = phead1-&gt;pnext;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(phead2 != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        stk2.push_back(phead2);</span><br><span class="line">        phead2 = phead2-&gt;pnext;</span><br><span class="line">    &#125;</span><br><span class="line">    node* common_node = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">while</span>(!stk1.empty() &amp;&amp; !stk2.empty()) &#123;</span><br><span class="line">        <span class="keyword">if</span>(stk1[stk1.size() - <span class="number">1</span>] == stk2[stk2.size() - <span class="number">1</span>]) &#123;</span><br><span class="line">            common_node = stk1[stk1.size() - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        stk1.pop_back();</span><br><span class="line">        stk2.pop_back();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> common_node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>后一种方法虽然多了一个<code>O(m+n)</code>的空间开销，但是在一些单纯链表方法不能方便解决的时候，也不妨是一种构思的思路。</p><h2 id="4-总结"><a href="#4-总结" class="headerlink" title="4 总结"></a>4 总结</h2><p>编程面试时，面试官通常对时间复杂度和空间复杂度都会有要求，并且一般情况下面试官更加关注时间复杂度。</p><p>降低时间复杂度的第一种方法是<strong>改用更加高效的算法</strong>；第二种方法是<strong>用空间换时间</strong>。</p><p>以空间换时间并不一定都是可行的方案，还要注意辅助空间的大小，消耗空间过大也是得不偿失的。</p>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;时间与空间，是算法永恒的话题。&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="剑指Offer" scheme="https://yumi-cn.github.io/categories/%E5%89%91%E6%8C%87Offer/"/>
    
    
    <category term="笔记" scheme="https://yumi-cn.github.io/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>《剑指Offer》第4章笔记 解题的思路 P3</title>
    <link href="https://yumi-cn.github.io/2021/01/03/s2o-c4-part3/"/>
    <id>https://yumi-cn.github.io/2021/01/03/s2o-c4-part3/</id>
    <published>2021-01-03T07:45:17.000Z</published>
    <updated>2021-01-03T07:46:30.991Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>遇到复杂的问题，可以尝试将大问题分解为若干小问题。</p></blockquote><a id="more"></a><h2 id="1、2-章节"><a href="#1、2-章节" class="headerlink" title="1、2 章节"></a>1、2 章节</h2><p>包含面试题27-29。</p><p>请到《第4章笔记 解题的思路 P1》阅读这部分内容。</p><h2 id="3-章节"><a href="#3-章节" class="headerlink" title="3 章节"></a>3 章节</h2><p>包含面试题30-34。</p><p>请到《第4章笔记 高质量代码 P2》阅读这部分内容。</p><h2 id="4-分解让复杂问题简单化"><a href="#4-分解让复杂问题简单化" class="headerlink" title="4 分解让复杂问题简单化"></a>4 分解让复杂问题简单化</h2><p>在面试中，当我们遇到复杂的大问题的时候，如果能够先把大问题分解成若干个简单地小问题，然后再逐个解决这些小问题，则可能也会容易很多。</p><p>在计算机领域有一类算法叫分治法，即“分而治之”，把分解后的小问题各个解决，然后把小问题的解决方案结合起来解决大问题。</p><h2 id="面试题35-38"><a href="#面试题35-38" class="headerlink" title="面试题35-38"></a>面试题35-38</h2><blockquote><p>面试题35：复杂链表的复制。</p></blockquote><p>实现函数<code>ComplexListNode* clone(ComplexListNode* phead)</code>，复制一个复杂链表。在复杂链表中，每个节点除了有一个<code>pnext</code>指针指向下一个节点，还有一个<code>psibling</code>指针指向链表中的任意节点或者<code>nullptr</code>。节点定义如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ComplexListNode</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> value;</span><br><span class="line">    ComplexListNode* pnext;</span><br><span class="line">    ComplexListNode* psibling;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><div align="center"><p><img src="/images/s2o-c4-part3-f1.jpg" alt="一个含有5个节点的复杂链表"></p></div><ol><li>直观地思路是先复制整个链表，然后使用一个辅助存储空间来存储节点间的映射关系，例如用一个哈希表来存储<code>&lt;节点、克隆节点&gt;</code>的映射关系，这样在建立<code>psibling</code>关系时十分有用，时间开销也可以做到<code>O(n)</code>；</li><li>进一步地，可以不用借助辅助的空间来存储节点对应关系，例如<strong>直接先将克隆节点挂靠在原节点后面</strong>，用这种方式来替代哈希表，同时也可以方便地建立<code>psibling</code>关系，这种方法对应的缺陷是过程中会对原数据结构进行修改，如果外部程序允许，则可以这样操作（在一些并行程序中可能会出现问题）。</li></ol><div align="center"><p><img src="/images/s2o-c4-part3-f2.jpg"></p></div><p>完整实现代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ComplexListNode</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> value;</span><br><span class="line">    ComplexListNode* pnext;</span><br><span class="line">    ComplexListNode* psibling;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">ComplexListNode* <span class="title">init_node</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123; ... &#125;</span><br><span class="line"><span class="function">ComplexListNode* <span class="title">init_list</span><span class="params">()</span> </span>&#123; ... &#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ComplexListNode* <span class="title">clone</span><span class="params">(ComplexListNode* phead)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(phead == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ComplexListNode* pnode = phead;</span><br><span class="line">    <span class="comment">// 克隆节点</span></span><br><span class="line">    <span class="keyword">while</span>(pnode != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        ComplexListNode* pclone = init_node(pnode-&gt;value);</span><br><span class="line">        pclone-&gt;pnext = pnode-&gt;pnext;</span><br><span class="line">        pnode-&gt;pnext = pclone;</span><br><span class="line">        pnode = pclone-&gt;pnext;</span><br><span class="line">    &#125;</span><br><span class="line">    pnode = phead;</span><br><span class="line">    <span class="comment">// 建立克隆节点的sibling关系</span></span><br><span class="line">    <span class="keyword">while</span>(pnode != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span>(pnode-&gt;psibling != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            ComplexListNode* psibling = pnode-&gt;psibling;</span><br><span class="line">            ComplexListNode* pclone = pnode-&gt;pnext;</span><br><span class="line">            pclone-&gt;psibling = psibling-&gt;pnext;</span><br><span class="line">        &#125;</span><br><span class="line">        pnode = pnode-&gt;pnext-&gt;pnext;</span><br><span class="line">    &#125;</span><br><span class="line">    ComplexListNode* pclone_head = <span class="literal">nullptr</span>;</span><br><span class="line">    ComplexListNode* ptemp = <span class="literal">nullptr</span>;</span><br><span class="line">    pnode = phead;</span><br><span class="line">    <span class="comment">// 从链表中分离出克隆节点</span></span><br><span class="line">    <span class="keyword">while</span>(pnode != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span>(pclone_head == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            pclone_head = pnode-&gt;pnext;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            ptemp-&gt;pnext = pnode-&gt;pnext;</span><br><span class="line">        &#125;</span><br><span class="line">        ptemp = pnode-&gt;pnext;</span><br><span class="line">        pnode-&gt;pnext = ptemp-&gt;pnext;</span><br><span class="line">        ptemp-&gt;pnext = <span class="literal">nullptr</span>;</span><br><span class="line">        pnode = pnode-&gt;pnext;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> pclone_head;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(ComplexListNode* phead)</span> </span>&#123;</span><br><span class="line">    ComplexListNode* pnode = phead;</span><br><span class="line">    <span class="keyword">while</span>(pnode != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, pnode-&gt;value);</span><br><span class="line">        <span class="keyword">if</span>(pnode-&gt;psibling != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;-&gt;%d&quot;</span>, pnode-&gt;psibling-&gt;value);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">        pnode = pnode-&gt;pnext;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ComplexListNode* phead = init_list();</span><br><span class="line">    ComplexListNode* pclone = clone(phead);</span><br><span class="line">    print(phead);</span><br><span class="line">    print(pclone);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><blockquote><p>面试题36：二叉搜索树与双向链表。</p></blockquote><p>输入一棵二叉搜索树，将该<strong>二叉搜索树</strong>转换成一个<strong>排序的双向链表</strong>。要求不能创建任何新的节点，只能调整树中节点指针的指向。比如，输入图4.15中左边的二叉搜索树，则输出转换之后的排序双向链表。二叉树节点定义如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span></span><br><span class="line">  <span class="keyword">int</span> value;</span><br><span class="line">  node* pleft;</span><br><span class="line">  node* pright;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><div align="center"><p><img src="/images/s2o-c4-part3-f3.jpg"></p></div><p>稍微观察就可以发现，对于单个的一个节点（子树），转换为双向链表时，<strong>只需要将其左子树的最大节点和其右子树的最小节点传分别链接到两个对应指针上</strong>，递归地处理其左子树和右子树，就可以得到最终的结果。</p><p>完整实现代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> value;</span><br><span class="line">    node* pleft;</span><br><span class="line">    node* pright;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">node* <span class="title">init_node</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123; ... &#125;</span><br><span class="line"><span class="function">node* <span class="title">init_tree</span><span class="params">()</span> </span>&#123; ... &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">tree_to_list_core</span><span class="params">(node* proot, node** max, node** min)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(proot == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    node *lmax, *lmin, *rmax, *rmin;</span><br><span class="line">    lmax = lmin = rmax = rmin = <span class="literal">nullptr</span>;</span><br><span class="line">    tree_to_list_core(proot-&gt;pleft, &amp;lmax, &amp;lmin);</span><br><span class="line">    tree_to_list_core(proot-&gt;pright, &amp;rmax, &amp;rmin);</span><br><span class="line">    *max = rmax?rmax:proot; <span class="comment">// 确定头节点(最小节点)</span></span><br><span class="line">    *min = lmin?lmin:proot; <span class="comment">// 确定尾节点(最大节点)</span></span><br><span class="line">    <span class="keyword">if</span>(lmax != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        lmax-&gt;pright = proot;</span><br><span class="line">    &#125;</span><br><span class="line">    proot-&gt;pleft = lmax;</span><br><span class="line">    <span class="keyword">if</span>(rmin != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        rmin-&gt;pleft = proot;</span><br><span class="line">    &#125;</span><br><span class="line">    proot-&gt;pright = rmin;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">tree_to_list</span><span class="params">(node* proot, node** max, node** min)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(proot == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    tree_to_list_core(proot, max, min);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dual_print</span><span class="params">(node* phead, node* ptail)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 顺序打印</span></span><br><span class="line">    node* pnode = phead;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Min -&gt; Max: &quot;</span>);</span><br><span class="line">    <span class="keyword">while</span>(pnode != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, pnode-&gt;value);</span><br><span class="line">        pnode = pnode-&gt;pright;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    <span class="comment">// 逆序打印</span></span><br><span class="line">    pnode = ptail;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Max -&gt; Min: &quot;</span>);</span><br><span class="line">    <span class="keyword">while</span>(pnode != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, pnode-&gt;value);</span><br><span class="line">        pnode = pnode-&gt;pleft;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    node* proot = init_tree();</span><br><span class="line">    node *phead, *ptail;</span><br><span class="line">    phead = ptail = <span class="literal">nullptr</span>;</span><br><span class="line">    tree_to_list(proot, &amp;ptail, &amp;phead);</span><br><span class="line">    dual_print(phead, ptail);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>书上使用的方法是，<strong>在中序遍历的同时</strong>，在函数参数中加上一个已构建链表的尾节点，逐步地向尾部挂链节点，这样的方法个人逻辑上理解起来有点绕，所以我自己写的时候，对函数的定义是要同时确定<strong>重构建链表的头节点和尾节点</strong>，这样逻辑构建上感觉会更加清晰一点，并且最后可以直接返回双向链表的头节点和尾节点，无需再去重新遍历寻找，核心算法的时间效率上和书上代码并没有太大区别。</p><hr><blockquote><p>面试题37：序列化二叉树。</p></blockquote><p>请实现两个函数，分别用来序列化和反序列化二叉树。</p><p>PS：序列化(Serialization)指的是将对象的状态信息转换为可以存储或传输的形式的过程，反序列化则是通过序列化信息来重建对应状态的对象。</p><p>之前的面试题7“重建二叉树”，我们知道可以从前序遍历和中序遍历构造出一棵（也是唯一的）二叉树。受启发，可能可以尝试把一棵二叉树序列化成一个前序和一个中序，然后反序列通过两个序列重构出原二叉树。</p><p>但这样的思路有两个问题：</p><ol><li>这种方法要求二叉树不能有数值重复的节点（如果有重复的节点，在确定根节点时会出现歧义）；</li><li>只有两个序列中<strong>所有数据都读出来后</strong>才能开始反序列化，如果两个遍历数据只能从一个流中读取，那么可能要等待较长时间。</li></ol><p>实际上，如果二叉树的序列化是从根节点开始的，那么相应的反序列化在根节点的数值读出来的时候就可以开始了。因此，可以根据<strong>前序遍历的顺序来序列化二叉树</strong>，在二叉树碰到<code>nullptr</code>时，转化为一个特殊的字符(比如<code>$</code>)，另外节点的数值要用一个特殊字符(比如<code>,</code>)隔开。</p><p>完整代码实现：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> value;</span><br><span class="line">    node* pleft;</span><br><span class="line">    node* pright;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">node* <span class="title">init_node</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123; ... &#125;</span><br><span class="line"><span class="function">node* <span class="title">init_tree</span><span class="params">()</span> </span>&#123; ... &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">serialize</span><span class="params">(node* proot, <span class="keyword">char</span>*&amp; stream)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(proot == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        *stream = <span class="string">&#x27;$&#x27;</span>;</span><br><span class="line">        *(stream + <span class="number">1</span>) = <span class="string">&#x27;,&#x27;</span>;</span><br><span class="line">        *(stream + <span class="number">2</span>) = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">        stream += <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    *stream = <span class="string">&#x27;0&#x27;</span> + proot-&gt;value;</span><br><span class="line">    *(stream + <span class="number">1</span>) = <span class="string">&#x27;,&#x27;</span>;</span><br><span class="line">    *(stream + <span class="number">2</span>) = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">    stream += <span class="number">2</span>;</span><br><span class="line">    serialize(proot-&gt;pleft, stream);</span><br><span class="line">    serialize(proot-&gt;pright, stream);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">read_stream</span><span class="params">(<span class="keyword">char</span>*&amp; stream, <span class="keyword">int</span>* number)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(*stream &lt;= <span class="string">&#x27;9&#x27;</span> &amp;&amp; *stream &gt;= <span class="string">&#x27;0&#x27;</span>) &#123;</span><br><span class="line">        *number = *stream - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        stream += <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        stream += <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">deserialize</span><span class="params">(node** proot, <span class="keyword">char</span>*&amp; stream)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> number;</span><br><span class="line">    <span class="keyword">if</span>(read_stream(stream, &amp;number)) &#123;</span><br><span class="line">        *proot = init_node(number);</span><br><span class="line">        deserialize(&amp;((*proot)-&gt;pleft), stream);</span><br><span class="line">        deserialize(&amp;((*proot)-&gt;pright), stream);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">preorder_traversal</span><span class="params">(node* proot)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(proot == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, proot-&gt;value);</span><br><span class="line">    preorder_traversal(proot-&gt;pleft);</span><br><span class="line">    preorder_traversal(proot-&gt;pright);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    node* proot = init_tree();</span><br><span class="line">    <span class="keyword">char</span>* stream = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">100</span>];</span><br><span class="line">    <span class="keyword">char</span>* pchar = stream;</span><br><span class="line">    serialize(proot, pchar);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, stream);</span><br><span class="line">    node* new_proot = <span class="literal">nullptr</span>;</span><br><span class="line">    pchar = stream;</span><br><span class="line">    deserialize(&amp;proot, pchar);</span><br><span class="line">    preorder_traversal(proot);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里利用了先序遍历的节点顺序特性，使用中序或者后序就无法实现这样的效果，算是一种特殊的技巧吧，用<code>$</code>替代空指针<code>nullptr</code>，在先序遍历的同时确定之后重建的顺序。序列化中一些需要注意的细节，比如使用的替代字符<code>$</code>是否在节点<code>value</code>范围中，要使用间隔符<code>,</code>将值隔开，避免节点值产生混淆错误。</p><hr><blockquote><p>面试题38：字符串的排列。</p></blockquote><p>输入一个字符串，打印出该字符串中字符的所有排列。例如，输入字符串<code>abc</code>，则打印由字符<code>a</code>、<code>b</code>、<code>c</code>所能排列出的所有字符串<code>abc</code>、<code>acb</code>、<code>bac</code>、<code>bca</code>、<code>cab</code>和<code>cba</code>。</p><p>基础思路是使用递归来完成，例如确定一个字符后，只需要知道剩下字符串的全排列即可，在第<code>i</code>层递归时，从还未选择的字符中确定一个字符在输出的第<code>i</code>个位置，遍历所有可能性，也就是全排列的实现方式。</p><p>完整实现代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">permutation</span><span class="params">(<span class="keyword">char</span>* <span class="built_in">string</span>, <span class="keyword">bool</span>* choose, <span class="keyword">int</span> len, <span class="keyword">char</span>* output, <span class="keyword">int</span> olen)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(olen == len) &#123;</span><br><span class="line">        *(output + olen) = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, output);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(!choose[i]) &#123;</span><br><span class="line">            *(output + olen) = <span class="built_in">string</span>[i];</span><br><span class="line">            choose[i] = <span class="literal">true</span>;</span><br><span class="line">            permutation(<span class="built_in">string</span>, choose, len, output, olen + <span class="number">1</span>);</span><br><span class="line">            choose[i] = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">permutation</span><span class="params">(<span class="keyword">char</span>* <span class="built_in">string</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">string</span> == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> len = <span class="built_in">strlen</span>(<span class="built_in">string</span>);</span><br><span class="line">    <span class="keyword">char</span>* output = <span class="keyword">new</span> <span class="keyword">char</span>[len + <span class="number">1</span>];</span><br><span class="line">    output[<span class="number">0</span>] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">    <span class="keyword">bool</span>* choose = <span class="keyword">new</span> <span class="keyword">bool</span>[len];</span><br><span class="line">    <span class="built_in">memset</span>(choose, <span class="number">0</span>, <span class="keyword">sizeof</span>(choose));</span><br><span class="line">    permutation(<span class="built_in">string</span>, choose, len, output, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span>* <span class="built_in">string</span> = <span class="string">&quot;abc&quot;</span>;</span><br><span class="line">    permutation(<span class="built_in">string</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>书上的代码是通过交换原字符串中各字符的位置来实现的，自己写代码时为了确保字符串本身不被修改，所以使用了一个<code>bool* choose</code>数组来记录被选中的字符位置，以及<code>char* output</code>来记录字符的顺序（用以最后的输出）。</p><h2 id="5-总结"><a href="#5-总结" class="headerlink" title="5 总结"></a>5 总结</h2><div align="center"><p><img src="/images/s2o-c4-part3-f4.jpg" alt="解决复杂问题的3种方法：画图、举例和分解"></p></div><p>图形使抽象的问题形象化。</p><p>举例使抽象的问题具体化。</p><p>分解使复杂的问题易解化。</p>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;遇到复杂的问题，可以尝试将大问题分解为若干小问题。&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="剑指Offer" scheme="https://yumi-cn.github.io/categories/%E5%89%91%E6%8C%87Offer/"/>
    
    
    <category term="笔记" scheme="https://yumi-cn.github.io/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>《剑指Offer》第4章笔记 解题的思路 P2</title>
    <link href="https://yumi-cn.github.io/2021/01/02/s2o-c4-part2/"/>
    <id>https://yumi-cn.github.io/2021/01/02/s2o-c4-part2/</id>
    <published>2021-01-02T08:43:28.000Z</published>
    <updated>2021-01-02T08:43:43.370Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>一眼看不出问题的隐藏规律时，说不定能通过举例来发现。</p></blockquote><a id="more"></a><h2 id="1、2-章节"><a href="#1、2-章节" class="headerlink" title="1、2 章节"></a>1、2 章节</h2><p>包含面试题27-29。</p><p>请到《第4章笔记 解题的思路 P1》阅读这部分内容。</p><h2 id="3-举例让抽象问题具体化"><a href="#3-举例让抽象问题具体化" class="headerlink" title="3 举例让抽象问题具体化"></a>3 举例让抽象问题具体化</h2><p>和上一节画图的方法一样，我们也可以借助举例模拟的方法来思考分析复杂的问题。当一眼看不出问题中隐藏的规律时，可以试着用一两个具体的例子模拟操作的过程，说不定能通过具体的例子找到抽象的规律。</p><p>具体的例子也可以帮助我们向面试官解释算法思路，也能帮助我们确保代码的质量，举出来的例子可以当作测试用例检验代码的正确性。</p><h2 id="面试题-30-34"><a href="#面试题-30-34" class="headerlink" title="面试题 30-34"></a>面试题 30-34</h2><blockquote><p>面试题30：包含min函数的栈。</p></blockquote><p>定义栈的数据结构，在该类型中实现一个能够得到栈的最小元素的min函数，在该栈中，调用<code>min</code>、<code>push</code>、<code>pop</code>的时间复杂度都是<code>O(1)</code>。</p><p>这道题容易曲解成是对这一组元素的排序，就容易陷入到一个思维陷阱，开始怀疑是怎么在<code>O(n)</code>时间内做到对这些元素的排序的（常用的排序也需要<code>O(nlogn)</code>的时间），其实多举几个例子可以发现，这个过程并不完全等价于是对一组元素的排序，栈的<code>min</code>值是有条件性的，取决于栈中到底有什么样的元素，以及<strong>这些元素的入栈顺序</strong>，所以用一个相同长度的栈，来存储一个元素入栈后，栈的<code>min</code>值是多少，就可以同步地在<code>O(1)</code>时间里实现<code>min</code>的获取。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> max_len = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">MinStack</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> <span class="built_in">stack</span>[max_len];</span><br><span class="line">    <span class="keyword">int</span> min_stack[max_len];</span><br><span class="line">    <span class="keyword">int</span> anchor = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> elem)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(anchor &lt; max_len - <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="built_in">stack</span>[anchor + <span class="number">1</span>] = elem;</span><br><span class="line">            <span class="keyword">if</span>(anchor == <span class="number">-1</span> || min_stack[anchor] &gt; elem) &#123;</span><br><span class="line">                min_stack[anchor + <span class="number">1</span>] = elem;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                min_stack[anchor + <span class="number">1</span>] = min_stack[anchor];</span><br><span class="line">            &#125;</span><br><span class="line">            anchor++;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// throw error</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> pop() &#123;</span><br><span class="line">        <span class="keyword">if</span>(anchor &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            anchor--;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">stack</span>[anchor + <span class="number">1</span>];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// throw error</span></span><br><span class="line">            <span class="keyword">return</span> - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">min</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(anchor &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> min_stack[anchor];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// throw error</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    MinStack min_stack;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">        min_stack.push(<span class="number">4</span> - i);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;After push %d, min=%d\n&quot;</span>, <span class="number">4</span> - i, min_stack.min());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// After push 4, min=4</span></span><br><span class="line">    <span class="comment">// After push 3, min=3</span></span><br><span class="line">    <span class="comment">// After push 2, min=2</span></span><br><span class="line">    <span class="comment">// After push 1, min=1</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> pop = min_stack.pop();</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;After pop %d, min=%d\n&quot;</span>, pop, min_stack.min());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// After pop 1, min=2</span></span><br><span class="line">    <span class="comment">// After pop 2, min=3</span></span><br><span class="line">    <span class="comment">// After pop 3, min=4</span></span><br><span class="line">    <span class="comment">// After pop 4, min=-1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><blockquote><p>面试题31：栈的压入、弹出序列。</p></blockquote><p>输入两个整数序列，第一个序列表示栈的压入顺序，请判断第二个序列是否为该栈的弹出顺序。假设压入栈的所有数字均不相等，例如<code>&#123;1,2,3,4,5&#125;</code>是某栈的压栈序列，序列<code>&#123;4,5,3,2,1&#125;</code>是该栈的对应一个弹出序列，但<code>&#123;4,3,5,1,2&#125;</code>就不可能是该压栈的弹出序列。</p><p>PS：题目其实说的蛮含糊的，只要理解一个关键点就好了，它指的是执行一系列压栈和弹出操作，并不是先只压栈然后再只弹出，所以一个入栈顺序为<code>&#123;1,2,3,4,5&#125;</code>，出栈顺序也可能是<code>&#123;1,2,3,4,5&#125;</code>（进一个就出一个）。</p><p>比较直观的方法就是用一个栈来模拟整个流程，看这个流程是否能匹配上压栈和弹出的顺序。</p><p>每次压栈结束后，就检查剩余的出栈顺序，如果下一个出栈的元素就栈顶的元素就出栈，并且循环检查，直到无法再出栈。如果入栈都结束后，出栈顺序或者栈内不为空，则表示出栈顺序有错误。</p><p>完整实现代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">is_pop_order</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span>* ppush, <span class="keyword">const</span> <span class="keyword">int</span>* ppop, <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">bool</span> possible = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span>(ppush != <span class="literal">nullptr</span> &amp;&amp; ppop != <span class="literal">nullptr</span> &amp;&amp; len &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">int</span>* pnext_push = ppush;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">int</span>* pnext_pop = ppop;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; <span class="built_in">stack</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(pnext_pop - ppop &lt; len) &#123;</span><br><span class="line">            <span class="keyword">while</span>(<span class="built_in">stack</span>.empty() || <span class="built_in">stack</span>.top() != *pnext_pop) &#123;</span><br><span class="line">                <span class="comment">// 元素压栈</span></span><br><span class="line">                <span class="keyword">if</span>(pnext_push - ppush == len) &#123;</span><br><span class="line">                    <span class="keyword">break</span>; <span class="comment">// 元素全部已入栈</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="built_in">stack</span>.push(*pnext_push);</span><br><span class="line">                pnext_push++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span>(!<span class="built_in">stack</span>.empty() &amp;&amp; <span class="built_in">stack</span>.top() == *pnext_pop) &#123;</span><br><span class="line">                <span class="comment">// 元素出栈</span></span><br><span class="line">                <span class="built_in">stack</span>.pop();</span><br><span class="line">                pnext_pop++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(pnext_push - ppush == len &amp;&amp; pnext_pop - ppop != len) &#123;</span><br><span class="line">                <span class="comment">// 入栈已空，但出栈还未空，不是正确的出栈顺序</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">stack</span>.empty() &amp;&amp; pnext_pop - ppop == len) &#123;</span><br><span class="line">            possible = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> possible;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span>* ppush, <span class="keyword">const</span> <span class="keyword">int</span>* ppop, <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, is_pop_order(ppush, ppop, len)?<span class="string">&quot;yes&quot;</span>:<span class="string">&quot;no&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> push_order[<span class="number">5</span>] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> pop_order1[<span class="number">5</span>] = &#123;<span class="number">4</span>,<span class="number">5</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> pop_order2[<span class="number">5</span>] = &#123;<span class="number">4</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">1</span>,<span class="number">2</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> pop_order3[<span class="number">5</span>] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> pop_order4[<span class="number">5</span>] = &#123;<span class="number">5</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>&#125;;</span><br><span class="line">    test(push_order, pop_order1, <span class="number">5</span>); <span class="comment">// yes</span></span><br><span class="line">    test(push_order, pop_order2, <span class="number">5</span>); <span class="comment">// no</span></span><br><span class="line">    test(push_order, pop_order3, <span class="number">5</span>); <span class="comment">// yes</span></span><br><span class="line">    test(push_order, pop_order4, <span class="number">5</span>); <span class="comment">// yes</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><blockquote><p>面试题32：从上到下打印二叉树。</p></blockquote><p><strong>题目一</strong>：不分行从上到下打印，同一层按照从左到右的顺序打印，节点定义：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> value;</span><br><span class="line">    node* pleft;</span><br><span class="line">    node* pright;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>思路就是之前有提到过的层序遍历了，使用队列的数据结构来辅助遍历。</p><div align="center"><p><img src="/images/s2o-c4-part2-f1.jpg" alt="打印顺序：8,6,10,5,7,9,11"></p></div><p>完整实现代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> value;</span><br><span class="line">    node* pleft;</span><br><span class="line">    node* pright;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">node* <span class="title">init_node</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123; ... &#125;</span><br><span class="line"><span class="function">node* <span class="title">init_tree</span><span class="params">()</span> </span>&#123; ... &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">level_order_traversal</span><span class="params">(node* proot)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(proot == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">queue</span>&lt;node*&gt; q;</span><br><span class="line">    q.push(proot);</span><br><span class="line">    node* pnode;</span><br><span class="line">    <span class="keyword">while</span>(!q.empty()) &#123;</span><br><span class="line">        pnode = q.front();</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, pnode-&gt;value);</span><br><span class="line">        <span class="keyword">if</span>(pnode-&gt;pleft != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            q.push(pnode-&gt;pleft);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(pnode-&gt;pright != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            q.push(pnode-&gt;pright);</span><br><span class="line">        &#125;</span><br><span class="line">        q.pop();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    node* proot = init_tree();</span><br><span class="line">    level_order_traversal(proot);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>PS：书上代码用的队列是<code>deque</code>双端队列，不是很明白作者的用意，这里我就直接用普通队列<code>queue</code>了。</p><p><strong>题目二</strong>：分行从上到下打印二叉树，每一层打印到一行，例如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">8</span></span><br><span class="line"><span class="number">6</span> <span class="number">10</span></span><br><span class="line"><span class="number">5</span> <span class="number">7</span> <span class="number">9</span> <span class="number">11</span></span><br></pre></td></tr></table></figure><p>队列除了保存节点顺序，还要保存一个层数，在题目一代码基础上进行稍微的修改。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;utility&gt; // use std::pair</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;tuple&gt; // use std::tie</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> value;</span><br><span class="line">    node* pleft;</span><br><span class="line">    node* pright;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">node* <span class="title">init_node</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123; ... &#125;</span><br><span class="line"><span class="function">node* <span class="title">init_tree</span><span class="params">()</span> </span>&#123; ... &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">level_order_traversal</span><span class="params">(node* proot)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(proot == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">queue</span>&lt;<span class="built_in">std</span>::<span class="built_in">pair</span>&lt;node*, <span class="keyword">int</span>&gt;&gt; q;</span><br><span class="line">    q.push(<span class="built_in">std</span>::<span class="built_in">make_pair</span>(proot, <span class="number">1</span>));</span><br><span class="line">    node* pnode;</span><br><span class="line">    <span class="keyword">int</span> level;</span><br><span class="line">    <span class="keyword">int</span> last_level = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(!q.empty()) &#123;</span><br><span class="line">        <span class="built_in">std</span>::tie(pnode, level) = q.front();</span><br><span class="line">        <span class="keyword">if</span>(level &gt; last_level) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">            last_level = level;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\t&quot;</span>, pnode-&gt;value);</span><br><span class="line">        <span class="keyword">if</span>(pnode-&gt;pleft != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            q.push(<span class="built_in">std</span>::<span class="built_in">make_pair</span>(pnode-&gt;pleft, level + <span class="number">1</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(pnode-&gt;pright != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            q.push(<span class="built_in">std</span>::<span class="built_in">make_pair</span>(pnode-&gt;pright, level + <span class="number">1</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        q.pop();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    node* proot = init_tree();</span><br><span class="line">    level_order_traversal(proot);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>书上代码把逻辑拆分的有点复杂，不够简洁，所以就用自己的方式来写了，在队列的节点中嵌入了节点的层数，用一个变量<code>last_level</code>来保存上一次打印节点的层数，如果发现已经到了下一层，就先输出一个换行，逻辑上更加简洁。</p><p><strong>题目三</strong>：之字形打印二叉树，第一行按照从左到右顺序，第二行按照从右到左顺序，第三行从左到右，依次类推。</p><p>可以简单地理解为，奇数行照常顺序打印，而偶数行需要逆向打印，所以可以简单地给偶数行添加一个栈结构，先全部压栈，再出栈打印，其他流程照旧，即可实现题目的要求，在题目二的代码基础上稍加修改即可。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;utility&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;tuple&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> value;</span><br><span class="line">    node* pleft;</span><br><span class="line">    node* pright;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">node* <span class="title">init_node</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123; ... &#125;</span><br><span class="line"><span class="function">node* <span class="title">init_tree</span><span class="params">()</span> </span>&#123; ... &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">level_order_traversal_zigzag</span><span class="params">(node* proot)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(proot == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">queue</span>&lt;<span class="built_in">std</span>::<span class="built_in">pair</span>&lt;node*, <span class="keyword">int</span>&gt;&gt; q;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; print_stack;</span><br><span class="line">    q.push(<span class="built_in">std</span>::<span class="built_in">make_pair</span>(proot, <span class="number">1</span>));</span><br><span class="line">    node* pnode;</span><br><span class="line">    <span class="keyword">int</span> level;</span><br><span class="line">    <span class="keyword">int</span> last_level = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(!q.empty()) &#123;</span><br><span class="line">        <span class="built_in">std</span>::tie(pnode, level) = q.front();</span><br><span class="line">        <span class="keyword">if</span>(level &gt; last_level) &#123;</span><br><span class="line">            <span class="keyword">if</span>(level &amp; <span class="number">0x1</span> == <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">while</span>(!print_stack.empty()) &#123;</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;%d\t&quot;</span>, print_stack.top());</span><br><span class="line">                    print_stack.pop();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">            last_level = level;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(level &amp; <span class="number">0x1</span> == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="comment">// 奇数行直接输出</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d\t&quot;</span>, pnode-&gt;value);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 偶数行先压栈</span></span><br><span class="line">            print_stack.push(pnode-&gt;value);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(pnode-&gt;pleft != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            q.push(<span class="built_in">std</span>::<span class="built_in">make_pair</span>(pnode-&gt;pleft, level + <span class="number">1</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(pnode-&gt;pright != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            q.push(<span class="built_in">std</span>::<span class="built_in">make_pair</span>(pnode-&gt;pright, level + <span class="number">1</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        q.pop();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 最后一层是偶数层时， 需要继续清空输出</span></span><br><span class="line">    <span class="keyword">while</span>(!print_stack.empty()) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\t&quot;</span>, print_stack.top());</span><br><span class="line">        print_stack.pop();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    node* proot = init_tree();</span><br><span class="line">    level_order_traversal_zigzag(proot);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>书上的代码逻辑稍微复杂一点，要用两个栈来完成两层的循环之字输出，理解起来稍微比较难，所以我就只是简单地在题目二的基础上进行修改了，逻辑上理解起来更加方便。</p><hr><blockquote><p>面试题33：二叉搜索树的后序遍历序列。</p></blockquote><p>输入一个整数数组，判断该数组是不是<strong>某二叉搜索树的后序遍历结果</strong>。如果是则返回<code>true</code>，否则返回<code>false</code>。假设输入的数组的任意两个数字互不相同，如，<code>&#123;5,7,6,9,11,10,8&#125;</code>，则返回<code>true</code>，因为整数序列是下图的二叉搜索树的后序遍历结果，如果输入<code>&#123;7,4,6,5&#125;</code>，则返回<code>false</code>，无法找到这样的二叉搜索树。</p><div align="center"><p><img src="/images/s2o-c4-part2-f2.jpg"></p></div><p><strong>后序遍历的特点在于最后访问根节点</strong>，所以对于一个树（或子树）的后续遍历序列，根节点都是最后一个数，另外，<strong>对于二叉搜索树的一个节点，其左子树的节点都小于该节点，右子树的节点都大于该节点</strong>，在遍历序列上体现就是前一部分大于节点值，后一部分小于节点值。所以解题的思路就是递归地去分解后续遍历序列，不断的去验证各个节点子树对应的后续遍历是否满足二叉搜索树的特性即可。</p><p>完整实现代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">is_post_order</span><span class="params">(<span class="keyword">int</span> sequence[], <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(sequence == <span class="literal">nullptr</span> || start &gt; end) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(start == end) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> pstart, pend;</span><br><span class="line">    <span class="keyword">for</span>(pstart = start; pstart &lt; end; pstart++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(sequence[pstart] &gt; sequence[end]) &#123;</span><br><span class="line">            pstart--;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(pend = end - <span class="number">1</span>; pend &gt;= start; pend--) &#123;</span><br><span class="line">        <span class="keyword">if</span>(sequence[pend] &lt; sequence[end]) &#123;</span><br><span class="line">            pend++;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(pstart == pend) &#123;</span><br><span class="line">        <span class="comment">// 全偏树，此时所有节点都大于或小于子树根节点</span></span><br><span class="line">        <span class="keyword">return</span> is_post_order(sequence, start, end<span class="number">-1</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(pstart + <span class="number">1</span> == pend) &#123;</span><br><span class="line">        <span class="comment">// 左子树都小于节点，右子树都大于节点</span></span><br><span class="line">        <span class="keyword">bool</span> bleft = is_post_order(sequence, start, pstart);</span><br><span class="line">        <span class="keyword">bool</span> bright = is_post_order(sequence, pend, end<span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">return</span> bleft &amp;&amp; bright;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 不满足要求</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">(<span class="keyword">int</span> sequence[], <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, is_post_order(sequence, start, end)?<span class="string">&quot;yes&quot;</span>:<span class="string">&quot;no&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sequence1[] = &#123; <span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">9</span>,<span class="number">11</span>,<span class="number">10</span>,<span class="number">8</span> &#125;;</span><br><span class="line">    <span class="keyword">int</span> sequence2[] = &#123; <span class="number">7</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">5</span> &#125;;</span><br><span class="line">    test(sequence1, <span class="number">0</span>, <span class="number">6</span>); <span class="comment">// yes</span></span><br><span class="line">    test(sequence2, <span class="number">0</span>, <span class="number">3</span>); <span class="comment">// no</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>比较细致地考虑的话，要记得把全偏树的情况考虑到，此时根节点前面的所有节点都属于一个子树，而不是还是分左子树和右子树。</p><hr><blockquote><p>面试题34：二叉树中和为某一值的路径。</p></blockquote><p>输入<strong>一棵二叉树和一个整数</strong>，打印出二叉树中<strong>节点值的和</strong>为输入整数的所有路径。从树的根节点开始往下一直到叶节点所经过的节点形成一条路径。二叉树节点的定义如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> value;</span><br><span class="line">    node* pleft;</span><br><span class="line">    node* pright;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><div align="center"><p><img src="/images/s2o-c4-part2-f3.jpg" alt="和为22的路径有两条，10、5、7和10、12"></p></div><p>直观的方法应该就是递归地往下遍历所有情况，到叶节点的时候计算路径上的节点和，如果和等于输入的整数，则输出路径。</p><p>完整实现代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> value;</span><br><span class="line">    node* pleft;</span><br><span class="line">    node* pright;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">node* <span class="title">init_node</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123; ... &#125;</span><br><span class="line"><span class="function">node* <span class="title">init_tree</span><span class="params">()</span> </span>&#123; ... &#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;node*&gt; path; <span class="comment">// 存储路径</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">find_path</span><span class="params">(node* pnode, <span class="keyword">int</span> sum, <span class="keyword">int</span> expect_sum)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(pnode == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(pnode-&gt;pleft == <span class="literal">nullptr</span> &amp;&amp; pnode-&gt;pright == <span class="literal">nullptr</span></span><br><span class="line">        &amp;&amp; sum + pnode-&gt;value == expect_sum) &#123;</span><br><span class="line">        <span class="comment">// 满足要求，输出节点</span></span><br><span class="line">        path.push_back(pnode);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; path.size(); i++) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, path[i]-&gt;value);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">        path.pop_back();</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    path.push_back(pnode);</span><br><span class="line">    <span class="keyword">if</span>(pnode-&gt;pleft != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        find_path(pnode-&gt;pleft, sum + pnode-&gt;value, expect_sum);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(pnode-&gt;pright != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        find_path(pnode-&gt;pright, sum + pnode-&gt;value, expect_sum);</span><br><span class="line">    &#125;</span><br><span class="line">    path.pop_back();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    node* tree = init_tree();</span><br><span class="line">    find_path(tree, <span class="number">0</span>, <span class="number">22</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这道题可能会联想到提前剪枝的优化，例如当还没有到叶节点时，发现和已经大于了期望值的和，此时提前停止往下查询的操作叫做剪枝，但需要注意的是本题目中并没有限定节点的值<code>value</code>一定是正数(类型也是<code>int</code>而非<code>unsigned int</code>)，可以出现途中和大于期望值和，所以本题不能用这样的剪枝优化方法。</p><h2 id="4-分解让复杂问题简单化"><a href="#4-分解让复杂问题简单化" class="headerlink" title="4 分解让复杂问题简单化"></a>4 分解让复杂问题简单化</h2><p>包含面试题35-38。</p><p>请到《第4章笔记 高质量代码 P3》阅读这部分内容。</p>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;一眼看不出问题的隐藏规律时，说不定能通过举例来发现。&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="剑指Offer" scheme="https://yumi-cn.github.io/categories/%E5%89%91%E6%8C%87Offer/"/>
    
    
    <category term="笔记" scheme="https://yumi-cn.github.io/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>《剑指Offer》第4章笔记 解题的思路 P1</title>
    <link href="https://yumi-cn.github.io/2021/01/01/s2o-c4-part1/"/>
    <id>https://yumi-cn.github.io/2021/01/01/s2o-c4-part1/</id>
    <published>2021-01-01T08:55:16.000Z</published>
    <updated>2021-01-01T08:57:59.123Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>写代码之前理思路，举例子和画图都是很好的办法。</p></blockquote><a id="more"></a><h2 id="1-面试官谈面试思路"><a href="#1-面试官谈面试思路" class="headerlink" title="1 面试官谈面试思路"></a>1 面试官谈面试思路</h2><p>一些大佬说的话。</p><p>咕咕待更。</p><h2 id="2-画图让抽象问题形象化"><a href="#2-画图让抽象问题形象化" class="headerlink" title="2 画图让抽象问题形象化"></a>2 画图让抽象问题形象化</h2><p>画图是在面试过程中应聘者用来帮助自己分析、推理的常用手段。很多面试题很抽象，不容易找到解决办法。这时不妨画出一些与题目相关的图形，借以辅助自己观察和思考。图形能使抽象的问题具体化、形象化，说不定通过几幅图形就能找到规律，从而找到问题的解决方案。</p><p>有不少与数据结构相关的问题，比如二叉树、二维数组、链表等问题，都可以采用画图的方法来分析。</p><p>面试的时候，需要向面试官解释自己的思路，对于复杂的问题，应聘者光用言语未必能够说清楚，这个时候也可以画出几幅图形，一边看着图形一边讲解。</p><h2 id="面试题27-29"><a href="#面试题27-29" class="headerlink" title="面试题27-29"></a>面试题27-29</h2><blockquote><p>面试题27：二叉树的镜像。</p></blockquote><p>完成一个函数，输入一棵二叉树，函数输出它的镜像。二叉树节点定义：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> value;</span><br><span class="line">    node* pleft;</span><br><span class="line">    node* pright;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><div align="center"><p><img src="/images/s2o-c4-part1-f1.jpg"></p></div><p>画出一个镜像的二叉树后，观察可以发现只要简单地从上到下地交换每个节点的左右节点即可。</p><p>完整实现代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> value;</span><br><span class="line">    node* pleft;</span><br><span class="line">    node* pright;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">node* <span class="title">init_node</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123; ... &#125;</span><br><span class="line"><span class="function">node* <span class="title">init_tree</span><span class="params">()</span> </span>&#123; ... &#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">in_order_print</span><span class="params">(node* pnode)</span> </span>&#123; ... &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mirror_recursively</span><span class="params">(node* pnode)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(pnode == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    node* temp = pnode-&gt;pleft;</span><br><span class="line">    pnode-&gt;pleft = pnode-&gt;pright;</span><br><span class="line">    pnode-&gt;pright = temp;</span><br><span class="line">    mirror_recursively(pnode-&gt;pleft);</span><br><span class="line">    mirror_recursively(pnode-&gt;pright);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    node* tree = init_tree();</span><br><span class="line">    in_order_print(tree);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    mirror_recursively(tree);</span><br><span class="line"></span><br><span class="line">    in_order_print(tree);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果不使用递归，而是使用循环实现的话，可以考虑用一个队列来实现点的从上到下遍历的模拟，每访问一个节点，交换完毕后，将左右子节点加入到队列中，每次从队列中取出一个节点进行交换子节点操作，直到所有节点被处理完毕。</p><hr><blockquote><p>面试题28：对称的二叉树。</p></blockquote><p>请实现一个函数，用来判断一棵二叉树是不是对称的。如果一棵二叉树和它的镜像一样，那么它是对称的。</p><div align="center"><p><img src="/images/s2o-c4-part1-f2.jpg" alt="3棵二叉树，只有第一棵是对称的"></p></div><p>完整实现代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> value;</span><br><span class="line">    node* pleft;</span><br><span class="line">    node* pright;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">node* <span class="title">init_node</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123; ... &#125;</span><br><span class="line"><span class="function">node* <span class="title">init_tree</span><span class="params">()</span> </span>&#123; ... &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">is_symmetrical</span><span class="params">(node* pnode1, node* pnode2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(pnode1 == <span class="literal">nullptr</span> &amp;&amp; pnode2 == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(pnode1 == <span class="literal">nullptr</span> || pnode2 == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(pnode1-&gt;value == pnode2-&gt;value) &#123;</span><br><span class="line">        <span class="keyword">bool</span> lr_result = is_symmetrical(pnode1-&gt;pleft, pnode2-&gt;pright);</span><br><span class="line">        <span class="keyword">bool</span> rl_result = is_symmetrical(pnode1-&gt;pright, pnode2-&gt;pleft);</span><br><span class="line">        <span class="keyword">return</span> lr_result &amp;&amp; rl_result;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">is_symmetrical</span><span class="params">(node* proot)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(proot == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> is_symmetrical(proot-&gt;pleft, proot-&gt;pright);</span><br><span class="line">    <span class="comment">// 或者可以写为 虽然会多一倍计算过程 但代码精简到一行，有点抽象</span></span><br><span class="line">    <span class="comment">// return is_symmetrical(proot, proot);</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    node* tree = init_tree();</span><br><span class="line">    <span class="keyword">if</span>(is_symmetrical(tree)) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Tree is symmetrical.\n&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Tree is not symmetrical.\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><blockquote><p>面试题29：顺时针打印矩阵。</p></blockquote><p>输入一个矩阵，按照从外向里以顺时针的顺序依次打印出每一个数字。例如，如果输入如下矩阵，则依次打印数字1、2、3、4、8、12、16、15、15、13、9、5、6、7、11、10。</p><div align="center"><p><img src="/images/s2o-c4-part1-f3.jpg"></p></div><p>完整实现代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print_matrix_clockwise</span><span class="params">(<span class="keyword">int</span>** matrix, <span class="keyword">int</span> rows, <span class="keyword">int</span> cols)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(matrix == <span class="literal">nullptr</span> || rows &lt;= <span class="number">0</span> || cols &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> up = <span class="number">0</span>, bottom = rows<span class="number">-1</span>, left = <span class="number">0</span>, right = cols<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">int</span> i, j;</span><br><span class="line">    <span class="keyword">while</span>(up &lt; bottom &amp;&amp; left &lt; right) &#123;</span><br><span class="line">        <span class="comment">// 从左到右打印</span></span><br><span class="line">        i = up;</span><br><span class="line">        <span class="keyword">for</span>(j = left; j &lt;= right; j++) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, matrix[i][j]);</span><br><span class="line">        &#125;</span><br><span class="line">        up++;</span><br><span class="line">        <span class="comment">// 从上到下打印</span></span><br><span class="line">        j = right;</span><br><span class="line">        <span class="keyword">for</span>(i = up; i &lt;= bottom; i++) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, matrix[i][j]);</span><br><span class="line">        &#125;</span><br><span class="line">        right--;</span><br><span class="line">        <span class="comment">// 从右到左打印</span></span><br><span class="line">        i = bottom;</span><br><span class="line">        <span class="keyword">for</span>(j = right; j &gt;= left; j--) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, matrix[i][j]);</span><br><span class="line">        &#125;</span><br><span class="line">        bottom--;</span><br><span class="line">        <span class="comment">// 从下到上打印</span></span><br><span class="line">        j = left;</span><br><span class="line">        <span class="keyword">for</span>(i = bottom; i &gt;= up; i--) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, matrix[i][j]);</span><br><span class="line">        &#125;</span><br><span class="line">        left++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 当列数或行数是奇数时</span></span><br><span class="line">    <span class="comment">// 会出现多余一列或者一行的情况</span></span><br><span class="line">    <span class="keyword">if</span>(rows &amp; <span class="number">0x1</span> == <span class="number">1</span> || cols &amp; <span class="number">0x1</span> == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">// 最后一列</span></span><br><span class="line">        <span class="keyword">if</span>(up &lt; bottom) &#123;</span><br><span class="line">            j = left;</span><br><span class="line">            <span class="keyword">for</span>(i = up; i &lt;= bottom; i++) &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, matrix[i][j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 最后一行</span></span><br><span class="line">        <span class="keyword">if</span>(left &lt; right) &#123;</span><br><span class="line">            i = up;</span><br><span class="line">            <span class="keyword">for</span>(j = left; j &lt;= right; j++) &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, matrix[i][j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> rows = <span class="number">4</span>, cols = <span class="number">4</span>;</span><br><span class="line">    <span class="keyword">int</span>** matrix = <span class="keyword">new</span> <span class="keyword">int</span>*[rows];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; rows; i++) &#123;</span><br><span class="line">        matrix[i] = <span class="keyword">new</span> <span class="keyword">int</span>[cols];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; cols; j++) &#123;</span><br><span class="line">            matrix[i][j] = i * <span class="number">4</span> + j + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    print_matrix_clockwise((<span class="keyword">int</span>**)matrix, rows, cols);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在实现完整代码的时候，其中需要注意的一个问题是，二维数组的传参问题，如果想像题目一样传指针的方式传参，就需要在主函数使用动态数组的申请方式，用普通的声明方式<code>int matrix[][]</code>再强转<code>(int**)matrix</code>虽说可以传入到函数中，但访问数组会发生错误（原因暂时没有去细究了，应该和内存段的访问相关）。</p><h2 id="3-举例让抽象问题具体化"><a href="#3-举例让抽象问题具体化" class="headerlink" title="3 举例让抽象问题具体化"></a>3 举例让抽象问题具体化</h2><p>包含面试题30-34。</p><p>请到《第4章笔记 高质量代码 P2》阅读这部分内容。</p><h2 id="4-分解让复杂问题简单化"><a href="#4-分解让复杂问题简单化" class="headerlink" title="4 分解让复杂问题简单化"></a>4 分解让复杂问题简单化</h2><p>包含面试题35-38。</p><p>请到《第4章笔记 高质量代码 P3》阅读这部分内容。</p>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;写代码之前理思路，举例子和画图都是很好的办法。&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="剑指Offer" scheme="https://yumi-cn.github.io/categories/%E5%89%91%E6%8C%87Offer/"/>
    
    
    <category term="笔记" scheme="https://yumi-cn.github.io/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>《剑指Offer》第3章笔记 高质量代码 P2</title>
    <link href="https://yumi-cn.github.io/2021/01/01/s2o-c3-part2/"/>
    <id>https://yumi-cn.github.io/2021/01/01/s2o-c3-part2/</id>
    <published>2021-01-01T04:26:35.000Z</published>
    <updated>2021-01-01T04:22:23.734Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>鲁棒是英文Robust的音译，有时也翻译成健壮性。</p></blockquote><a id="more"></a><div align="center"><p><img src="/images/s2o-c3-part2-f4.jpg"></p></div><h2 id="1、2、3-章节"><a href="#1、2、3-章节" class="headerlink" title="1、2、3 章节"></a>1、2、3 章节</h2><p>请到《第3章笔记 高质量代码 P1》阅读这部分内容。</p><h2 id="4-代码的鲁棒性"><a href="#4-代码的鲁棒性" class="headerlink" title="4 代码的鲁棒性"></a>4 代码的鲁棒性</h2><p>提高代码的鲁棒性的有效途径是进行防御性编程。防御性编程是一种编程习惯，是指预见在什么地方可能会出现问题，并为这些可能出现的问题制定处理方式。</p><p>在面试时，最简单也是最实用的防御性变成就是在函数入口添加代码以验证用户输入是否符合要求。通常面试要求的是写一两个函数，我们需要格外关注这些函数的输入参数。当然并不是所有与鲁棒性相关的问题都是检查输入的参数这么简单，有时候要关注稍微隐含一点的逻辑中，可能会发生的潜在问题。</p><h2 id="面试题22-26"><a href="#面试题22-26" class="headerlink" title="面试题22-26"></a>面试题22-26</h2><blockquote><p>面试题22：链表中倒数第K个节点</p></blockquote><p>输入一个链表，输出该链表中倒数第k个节点。这里的k从1开始计数，即链表的尾节点是倒数第1个节点。如，一个链表有6个节点，从头节点开始，他们的值依次是1、2、3、4、5、6，这个链表的倒数第3个节点是值为4的节点。链表节点定义如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> value;</span><br><span class="line">    node* pnext;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这里面需要考虑到的一个问题是，虽然输入的数据是<code>k</code>是正常的整数，但还要考虑链表中是否有大于等于<code>k</code>个的节点。思路就是简单的用两个间隔距离为<code>k-1</code>的指针来解决。</p><p>完整代码实现：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> value;</span><br><span class="line">    node* pnext;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">node* <span class="title">init_node</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123; ... &#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert_node</span><span class="params">(node** phead, node* pnode)</span> </span>&#123; ... &#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(node** phead)</span> </span>&#123; ... &#125;</span><br><span class="line"></span><br><span class="line"><span class="function">node* <span class="title">find_k_to_tail</span><span class="params">(node** phead, <span class="keyword">unsigned</span> <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(phead == <span class="literal">nullptr</span> || *phead == <span class="literal">nullptr</span> || k == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    node* left = *phead;</span><br><span class="line">    node* right = *phead;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k<span class="number">-1</span> &amp;&amp; right != <span class="literal">nullptr</span>; i++) &#123;</span><br><span class="line">        right = right-&gt;pnext;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(right == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(right-&gt;pnext != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        right = right-&gt;pnext;</span><br><span class="line">        left = left-&gt;pnext;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> left;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    node** phead = <span class="keyword">new</span> node*;</span><br><span class="line">    *phead = <span class="literal">nullptr</span>;</span><br><span class="line">    node** node_list = <span class="keyword">new</span> node*[<span class="number">10</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">        node* new_node = init_node(i);</span><br><span class="line">        node_list[i] = new_node;</span><br><span class="line">        insert_node(phead, new_node);</span><br><span class="line">    &#125;</span><br><span class="line">    print(phead); <span class="comment">// 0 1 2 3 4 5 6 7 8 9</span></span><br><span class="line">    node* first_node = find_k_to_tail(phead, <span class="number">10</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;first node: %d\n&quot;</span>, first_node-&gt;value);</span><br><span class="line">    <span class="comment">// first node: 0</span></span><br><span class="line">    node* last_second_node = find_k_to_tail(phead, <span class="number">2</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;last second node: %d\n&quot;</span>, last_second_node-&gt;value);</span><br><span class="line">    <span class="comment">// last second node: 8</span></span><br><span class="line">    node* last_node = find_k_to_tail(phead, <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;last node: %d\n&quot;</span>, last_node-&gt;value);</span><br><span class="line">    <span class="comment">// last node: 9</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><blockquote><p>面试题23：链表中环的入口节点</p></blockquote><p>如果一个链表包含环，如何找出环的入口节点？例如，在如下图所示的链表中，环的入口节点是节点3。</p><div align="center"><p><img src="/images/s2o-c3-part2-f1.jpg"></p></div><ol><li>如何确定链表有环？两个指针，一个1次1步，一个1次2步，如果1次2步的指针“追上了”1次1步的指针，则代表有环，如果指针遇到<code>nullptr</code>则无环；</li><li>如果有环，如何确定环的入口在哪？假设我们知道环里面节点的个数为<code>4</code>，则可以用两个指针，第一个指针先走4步（到达图中第5个节点），第二指针从1开始，同时开始移动，当两个指针相遇时（图中会相遇在第3个节点），即是环的入口节点；</li><li>问题从“<strong>判断环的入口在哪</strong>”转换成了“<strong>如何判断一个环里有多少个节点？</strong>”；判断环里有多少个节点可以用第一步中的结果，固定一个指针，移动一个指针，当两个指针又相遇时，则可以计数出环中的节点个数。</li></ol><p>完整代码实现：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> value;</span><br><span class="line">    node* pnext;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">node* <span class="title">init_node</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123; ... &#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert_node</span><span class="params">(node** phead, node* pnode)</span> </span>&#123; ... &#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(node** phead)</span> </span>&#123; ... &#125;</span><br><span class="line"></span><br><span class="line"><span class="function">node* <span class="title">meeting_node</span><span class="params">(node** phead)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(phead == <span class="literal">nullptr</span> || *phead == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    node* pslow = (*phead)-&gt;pnext;</span><br><span class="line">    node* pfast = pslow-&gt;pnext;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(pfast != <span class="literal">nullptr</span> &amp;&amp; pfast != pslow) &#123;</span><br><span class="line">        pslow = pslow-&gt;pnext;</span><br><span class="line">        pfast = pfast-&gt;pnext;</span><br><span class="line">        <span class="keyword">if</span>(pfast != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            pfast = pfast-&gt;pnext;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(pfast == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> pfast;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">node* <span class="title">find_loop_entry</span><span class="params">(node** phead)</span> </span>&#123;</span><br><span class="line">    node* mnode = meeting_node(phead);</span><br><span class="line">    <span class="keyword">if</span>(mnode == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="comment">// 无环或输入数据错误</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 得到环中的节点数目</span></span><br><span class="line">    <span class="keyword">int</span> nodes_in_loop = <span class="number">1</span>;</span><br><span class="line">    node* pnode1 = mnode;</span><br><span class="line">    <span class="keyword">while</span>(pnode1-&gt;pnext != mnode) &#123;</span><br><span class="line">        pnode1 = pnode1-&gt;pnext;</span><br><span class="line">        nodes_in_loop++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 移动pnode1，次数为欢中节点数目</span></span><br><span class="line">    pnode1 = *phead;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nodes_in_loop; i++) &#123;</span><br><span class="line">        pnode1 = pnode1-&gt;pnext;</span><br><span class="line">    &#125;</span><br><span class="line">    node* pnode2 = *phead;</span><br><span class="line">    <span class="comment">// 再同时移动pnode1和pnode2</span></span><br><span class="line">    <span class="keyword">while</span>(pnode1 != pnode2) &#123;</span><br><span class="line">        pnode1 = pnode1-&gt;pnext;</span><br><span class="line">        pnode2 = pnode2-&gt;pnext;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> pnode1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    node** phead = <span class="keyword">new</span> node*;</span><br><span class="line">    *phead = <span class="literal">nullptr</span>;</span><br><span class="line">    node** node_list = <span class="keyword">new</span> node*[<span class="number">6</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">6</span>; i++) &#123;</span><br><span class="line">        node* new_node = init_node(i+<span class="number">1</span>);</span><br><span class="line">        node_list[i] = new_node;</span><br><span class="line">        insert_node(phead, new_node);</span><br><span class="line">    &#125;</span><br><span class="line">    print(phead);</span><br><span class="line">    <span class="comment">// 1 2 3 4 5 6</span></span><br><span class="line">    <span class="keyword">if</span>(find_loop_entry(phead) == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;No loop yet.\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 尾节点指向第3个节点</span></span><br><span class="line">    node_list[<span class="number">5</span>]-&gt;pnext = node_list[<span class="number">2</span>];</span><br><span class="line">    node* loop_entry = find_loop_entry(phead);</span><br><span class="line">    <span class="keyword">if</span>(loop_entry == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;No loop, Error.\n&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Loop entry at %d.\n&quot;</span>, loop_entry-&gt;value);</span><br><span class="line">        <span class="comment">// Loop entry at 3.</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><blockquote><p>面试题24：反转链表</p></blockquote><p>定义一个函数，输入一个链表的头节点，反转该链表并输出反转后链表的头节点，链表节点定义如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> value;</span><br><span class="line">    node* pnext;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>思路就是新建一个头结点，在遍历链表的时候，不断的把节点插入到新链表的头节点，最后完成倒序。</p><p>完整实现代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> value;</span><br><span class="line">    node* pnext;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">node* <span class="title">init_node</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123; ... &#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert_node</span><span class="params">(node** phead, node* pnode)</span> </span>&#123; ... &#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(node** phead)</span> </span>&#123; ... &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">reverse</span><span class="params">(node** phead)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(phead == <span class="literal">nullptr</span> || *phead == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    node** new_phead = <span class="keyword">new</span> node*;</span><br><span class="line">    *new_phead = <span class="literal">nullptr</span>;</span><br><span class="line">    node* pnode = *phead;</span><br><span class="line">    <span class="keyword">while</span>(pnode != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        *phead = pnode-&gt;pnext;</span><br><span class="line">        <span class="keyword">if</span>(*new_phead == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            pnode-&gt;pnext = <span class="literal">nullptr</span>;</span><br><span class="line">            *new_phead = pnode;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            pnode-&gt;pnext = *new_phead;</span><br><span class="line">            *new_phead = pnode;</span><br><span class="line">        &#125;</span><br><span class="line">        pnode = *phead;</span><br><span class="line">    &#125;</span><br><span class="line">    *phead = *new_phead;</span><br><span class="line">    *new_phead = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">delete</span> new_phead;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    node** phead = <span class="keyword">new</span> node*;</span><br><span class="line">    *phead = <span class="literal">nullptr</span>;</span><br><span class="line">    node** node_list = <span class="keyword">new</span> node*[<span class="number">10</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">        node* new_node = init_node(i+<span class="number">1</span>);</span><br><span class="line">        node_list[i] = new_node;</span><br><span class="line">        insert_node(phead, new_node);</span><br><span class="line">    &#125;</span><br><span class="line">    print(phead);</span><br><span class="line">    <span class="comment">// 1 2 3 4 5 6 7 8 9 10</span></span><br><span class="line">    reverse(phead);</span><br><span class="line">    print(phead);</span><br><span class="line">    <span class="comment">// 10 9 8 7 6 5 4 3 2 1</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><blockquote><p>面试题25：合并两个排序的链表。</p></blockquote><p>输入两个递增排序的链表，合并这两个链表并使新链表中的节点仍然是递增排序的。</p><div align="center"><p><img src="/images/s2o-c3-part2-f2.jpg"></p></div><p>思路也没有很复杂，就是不断比较头结点大小，然后插入新链表的尾部，不过要注意一些实现细节，例如其中一个链表提前为空后的插入方法、算法结束判断、输入的各种可能性。</p><p>完整实现代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> value;</span><br><span class="line">    node* pnext;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">node* <span class="title">init_node</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123; ... &#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert_node</span><span class="params">(node** phead, node* pnode)</span> </span>&#123; ... &#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(node** phead)</span> </span>&#123; ... &#125;</span><br><span class="line"></span><br><span class="line"><span class="function">node** <span class="title">order_merge</span><span class="params">(node** phead1, node** phead2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(phead1 == <span class="literal">nullptr</span> || *phead1 == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> phead2;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(phead2 == <span class="literal">nullptr</span> || *phead2 == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> phead1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    node** phead;</span><br><span class="line">    *phead = <span class="literal">nullptr</span>;</span><br><span class="line">    node* pnode = <span class="literal">nullptr</span>;</span><br><span class="line">    node* temp = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(*phead1 != <span class="literal">nullptr</span> &amp;&amp; *phead2 != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span>((*phead1)-&gt;value &lt;= (*phead2)-&gt;value) &#123;</span><br><span class="line">            temp = *phead1;</span><br><span class="line">            *phead1 = temp-&gt;pnext;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            temp = *phead2;</span><br><span class="line">            *phead2 = temp-&gt;pnext;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(*phead == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            *phead = temp;</span><br><span class="line">            pnode = *phead;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            pnode-&gt;pnext = temp;</span><br><span class="line">            pnode = temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(*phead1 != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        pnode-&gt;pnext = *phead1;</span><br><span class="line">        pnode = pnode-&gt;pnext;</span><br><span class="line">        *phead1 = (*phead1)-&gt;pnext;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(*phead2 != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        pnode-&gt;pnext = *phead2;</span><br><span class="line">        pnode = pnode-&gt;pnext;</span><br><span class="line">        *phead2 = (*phead2)-&gt;pnext;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    pnode-&gt;pnext = <span class="literal">nullptr</span>;</span><br><span class="line">    pnode = <span class="literal">nullptr</span>;</span><br><span class="line">    temp = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">delete</span> pnode;</span><br><span class="line">    <span class="keyword">delete</span> temp;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> phead;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    node** phead1 = <span class="keyword">new</span> node*;</span><br><span class="line">    node** phead2 = <span class="keyword">new</span> node*;</span><br><span class="line">    *phead1 = <span class="literal">nullptr</span>;</span><br><span class="line">    *phead2 = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">        node* new_node1 = init_node(i * <span class="number">2</span>);</span><br><span class="line">        node* new_node2 = init_node(i * <span class="number">2</span> + <span class="number">1</span>);</span><br><span class="line">        insert_node(phead1, new_node1);</span><br><span class="line">        insert_node(phead2, new_node2);</span><br><span class="line">    &#125;</span><br><span class="line">    print(phead1); <span class="comment">// 0 2 4 6</span></span><br><span class="line">    print(phead2); <span class="comment">// 1 3 5 7</span></span><br><span class="line">    node** phead3 = order_merge(phead1, phead2);</span><br><span class="line">    print(phead3); <span class="comment">// 0 1 2 3 4 5 6 7</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>书上写的是递归版本，但是这里考虑到时间效率优化（其实是没想到），就写成循环实现了，会稍微长一点点。</p><hr><blockquote><p>面试题26：树的子结构</p></blockquote><p>输入两颗二叉树<code>A</code>和<code>B</code>，判断<code>B</code>是不是<code>A</code>的子结构。二叉树节点定义：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span></span><br><span class="line">    <span class="keyword">double</span> value;</span><br><span class="line">    node* pleft;</span><br><span class="line">    node* pright;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>关于<strong>子结构</strong>的定义，如下图中的两棵二叉树，A中有一部分子树的结构和B是一样的，所以B是A的子结构。</p><div align="center"><p><img src="/images/s2o-c3-part2-f3.jpg" alt="左A，右B"></p></div><ol><li>第一步在树A中查找与根节点的值一样的节点，实际上是树的遍历；</li><li>判断树A中以R为根节点的子树是不是和树B具有相同的结构。</li></ol><p>完整实现代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span></span><br><span class="line">    <span class="keyword">double</span> value;</span><br><span class="line">    node* pleft;</span><br><span class="line">    node* pright;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">node* <span class="title">init_node</span><span class="params">(<span class="keyword">double</span> value)</span> </span>&#123; ... &#125;</span><br><span class="line"><span class="function">node* <span class="title">init_a_tree</span><span class="params">()</span> </span>&#123; ... &#125;</span><br><span class="line"><span class="function">node* <span class="title">init_b_tree</span><span class="params">()</span> </span>&#123; ... &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> eps = <span class="number">1e-7</span>;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">equal</span><span class="params">(<span class="keyword">double</span> d1, <span class="keyword">double</span> d2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>((d1 - d2) &gt; -eps &amp;&amp; (d1 - d2) &lt; eps) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">does_tree1_have_tree2</span><span class="params">(node* proot1, node* proot2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(proot2 == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(proot1 == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(!equal(proot1-&gt;value, proot2-&gt;value)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 检查左子树</span></span><br><span class="line">    <span class="keyword">bool</span> left_result = does_tree1_have_tree2(proot1-&gt;pleft, proot2-&gt;pleft);</span><br><span class="line">    <span class="comment">// 检查右子树</span></span><br><span class="line">    <span class="keyword">bool</span> right_result = does_tree1_have_tree2(proot1-&gt;pright, proot2-&gt;pright);</span><br><span class="line">    <span class="keyword">return</span> left_result &amp;&amp; right_result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">is_sub_tree</span><span class="params">(node* proot1, node* proot2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">bool</span> result = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(proot1 != <span class="literal">nullptr</span> &amp;&amp; proot2 != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span>(equal(proot1-&gt;value, proot2-&gt;value)) &#123;</span><br><span class="line">            <span class="comment">// 检查根节点是否为B树子结构</span></span><br><span class="line">            result = does_tree1_have_tree2(proot1, proot2);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(!result) &#123;</span><br><span class="line">            <span class="comment">// 检查左子树是否为B树子结构</span></span><br><span class="line">            result = is_sub_tree(proot1-&gt;pleft, proot2);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(!result) &#123;</span><br><span class="line">            <span class="comment">// 检查右子树是否为B树子结构</span></span><br><span class="line">            result = is_sub_tree(proot1-&gt;pright, proot2);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    node* tree_a = init_a_tree();</span><br><span class="line">    node* tree_b = init_b_tree();</span><br><span class="line">    <span class="keyword">if</span>(is_sub_tree(tree_a, tree_b)) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Tree A has Tree B.\n&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Tree A does not have Tree B.\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>需要注意地方有两个，一个是在使用指针前一定要先对其进行判断，另一个是注意题目给的<code>value</code>类型是<code>double</code>，在判断相等时不能只是简单地使用<code>==</code>，要使用精度阈值的判断方法<code>fabs(n1 - n2) &lt; eps</code>。</p>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;鲁棒是英文Robust的音译，有时也翻译成健壮性。&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="剑指Offer" scheme="https://yumi-cn.github.io/categories/%E5%89%91%E6%8C%87Offer/"/>
    
    
    <category term="笔记" scheme="https://yumi-cn.github.io/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>《剑指Offer》第3章笔记 高质量代码 P1</title>
    <link href="https://yumi-cn.github.io/2020/12/30/s2o-c3-part1/"/>
    <id>https://yumi-cn.github.io/2020/12/30/s2o-c3-part1/</id>
    <published>2020-12-30T11:05:35.000Z</published>
    <updated>2020-12-30T11:14:58.937Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>除了程序代码的正确性，经常我们还要关注它的鲁棒性。</p></blockquote><a id="more"></a><h2 id="1-面试官谈代码质量"><a href="#1-面试官谈代码质量" class="headerlink" title="1 面试官谈代码质量"></a>1 面试官谈代码质量</h2><blockquote><p>“一般会考查应聘人员对代码的容错处理能力，对一些特别的输入会询问应聘人员是否考虑、如何处理。不能容忍代码只是针对一种假想的‘正常值’进行处理，不考虑异常状况，也不考虑资源的回收等问题。”</p><p>—— 殷焰（支付宝，高级安全测试工程师）</p></blockquote><blockquote><p>“如果是因为粗心犯错，则可以原谅，因为毕竟面试的时候会紧张；不能容忍的是，该掌握的知识点却没有掌握，而且提醒了还不知道。”</p><p>—— 马凌洲（Autodesk，软件开发经理）</p></blockquote><blockquote><p>“最不能容忍功能错误，忽略边界情况。”</p><p>—— 尹彦（英特尔，软件工程师）</p></blockquote><blockquote><p>“如果一个程序员连变量、函数命名都毫无章法，解决一个具体问题都找不到一个最合适的数据结构，那么这会让面试官对他的印象大打折扣，因为这只能说明他程序写得太少，不够熟悉。”</p><p>—— 吴斌（英伟达，图形设计师）</p></blockquote><blockquote><p>“我会从程序的正确性和鲁棒性两方面检验代码的质量。会关注对输入参数的检查、处理错误和异常的方式、命名方式等。对于没有工作经验的学生，程序正确性之外的错误基本都能容忍，但经过提示后希望能够很快解决。对于有工作经验的人，不能容忍考虑不周到，有明显的鲁棒性错误。”</p><p>—— 田超（微软，SDE ||）</p></blockquote><hr><h2 id="2-代码的规范性"><a href="#2-代码的规范性" class="headerlink" title="2 代码的规范性"></a>2 代码的规范性</h2><p>面试官会根据应聘者写出的代码来决定是否录用他，如果应聘者代码写的不够规范，影响面试官阅读代码的兴致，那么面试官就会默默地减去几分。<strong>书写、布局和命名</strong>都决定着代码的规范性。</p><div align="center"><p><img src="/images/s2o-c3-part1-f1.jpg" alt="影响代码规范性的因素"></p></div><p>首先，<strong>清晰的规范的代码书写</strong>。写的慢一点也可以，把字母、数字、符号写清楚。</p><p>其次，<strong>清晰的规范的代码布局</strong>。缩进、对齐的一些布局格式要注意统一。</p><p>最后，<strong>合理的规范的代码命名</strong>。建议在写代码时，用完整的英文单词组合命名变量和函数。比如函数传入一个二叉树的根节点作为参数，则可以把该参数命名为<code>BinaryTreeNode* pRoot</code>，不用觉得这样多写字母会麻烦，如果一眼能看出变量、函数的用途，应聘者就能避免搞混淆而犯一些低级错误（除了循环量<code>i,j,k</code>这种，其他都要注意），同时合理的命名也能让面试官一眼读懂代码的意图。</p><hr><h2 id="3-代码的完整性"><a href="#3-代码的完整性" class="headerlink" title="3 代码的完整性"></a>3 代码的完整性</h2><p>面试官会通过检查代码是否完整来考查应聘者的思维是否全面，一般会检查代码是否完成了基本功能、输入边界值是否能得到正确地输出、是否对各种不合规范的非法输入做出了合理的错误处理。</p><h3 id="3-1-3个方面确保完整性"><a href="#3-1-3个方面确保完整性" class="headerlink" title="3.1 3个方面确保完整性"></a>3.1 3个方面确保完整性</h3><p>咕咕待更。</p><h3 id="3-2-3种错误处理的方法"><a href="#3-2-3种错误处理的方法" class="headerlink" title="3.2 3种错误处理的方法"></a>3.2 3种错误处理的方法</h3><p>咕咕待更。</p><h3 id="3-3-面试题-16-21"><a href="#3-3-面试题-16-21" class="headerlink" title="3.3 面试题 16-21"></a>3.3 面试题 16-21</h3><blockquote><p>面试题16：数值的整数次方。</p></blockquote><p>实现函数<code>double Power(double base, int exponent)</code>，求<code>base</code>的<code>exponent</code>次方，不得使用库函数，不需要考虑大数问题（只考虑结果在double的表达范围）。</p><p>完整实现代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> g_invalid_input = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">double</span> eps = <span class="number">1e-8</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">equal</span><span class="params">(<span class="keyword">double</span> lhs, <span class="keyword">double</span> rhs)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">double</span> big = (lhs &gt; rhs)?lhs:rhs;</span><br><span class="line">    <span class="keyword">double</span> small = (big != lhs)?lhs:rhs;</span><br><span class="line">    <span class="keyword">return</span> (big - small) &lt;= eps;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">power_with_unsigned_exp</span><span class="params">(<span class="keyword">double</span> base, <span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="built_in">exp</span>)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// exp只为正数，内部只关心几次方的计算</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">exp</span> == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">exp</span> == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> base;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 考虑用递归数学公式来加速幂计算</span></span><br><span class="line">        <span class="comment">// exp &gt;&gt; 1，int右移1位，等价于除以2向下取整，优化计算速度</span></span><br><span class="line">        <span class="keyword">double</span> result = power_with_unsigned_exp(base, <span class="built_in">exp</span> &gt;&gt; <span class="number">1</span>);</span><br><span class="line">        result *= result;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">exp</span> &amp; <span class="number">0x1</span> == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="comment">// 判断是否为奇数，这种方式比 % 2 == 0，速度更快</span></span><br><span class="line">            result *= base;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">power</span><span class="params">(<span class="keyword">double</span> base, <span class="keyword">int</span> <span class="built_in">exp</span>)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 考虑exp 为正、为负、为0的情况</span></span><br><span class="line"></span><br><span class="line">    g_invalid_input = <span class="literal">false</span>; <span class="comment">// 初始化全局变量</span></span><br><span class="line">    <span class="keyword">if</span>(equal(base, <span class="number">0.0</span>) &amp;&amp; <span class="built_in">exp</span> &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        g_invalid_input = <span class="literal">true</span>; <span class="comment">// 也可以考虑其他错误处理方式</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0.0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> abs_exp = (<span class="keyword">unsigned</span> <span class="keyword">int</span>)((<span class="built_in">exp</span> &lt; <span class="number">0</span>)?-<span class="built_in">exp</span>:<span class="built_in">exp</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">double</span> result = power_with_unsigned_exp(base, abs_exp);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (<span class="built_in">exp</span> &lt; <span class="number">0</span>)?(<span class="number">1.0</span> / result):(result);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; power(<span class="number">2</span>, <span class="number">4</span>) &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 16</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; power(<span class="number">10</span>, <span class="number">5</span>) &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 100000</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; power(<span class="number">13</span>, <span class="number">-2</span>) &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 0.00591716</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; power(<span class="number">0</span>, <span class="number">0</span>) &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 1</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><blockquote><p>面试题17：打印从1到最大的n位数。</p></blockquote><p>输入数字<code>n</code>，按顺序打印出<code>1</code>到最大的<code>n</code>位十进制数。比如输入3，从1、2、3一直打印到最大的3位数999。</p><p>用字符串模拟大数加法进位的方式：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">char</span>* number)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 对于前面的空0，不再打印</span></span><br><span class="line">    <span class="keyword">int</span> len = <span class="built_in">strlen</span>(number);</span><br><span class="line">    <span class="keyword">bool</span> begin = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(!begin &amp;&amp; number[i] == <span class="string">&#x27;0&#x27;</span>) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(!begin &amp;&amp; number[i] != <span class="string">&#x27;0&#x27;</span>) &#123;</span><br><span class="line">            begin = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>, number[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">increment</span><span class="params">(<span class="keyword">char</span>* number)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">bool</span> is_overflow = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">int</span> carry = <span class="number">0</span>; <span class="comment">// 进位量</span></span><br><span class="line">    <span class="keyword">int</span> len = <span class="built_in">strlen</span>(number);</span><br><span class="line">    <span class="comment">// 模拟加法进位</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = len - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="keyword">int</span> sum = number[i] - <span class="string">&#x27;0&#x27;</span> + carry;</span><br><span class="line">        <span class="keyword">if</span>(i == len - <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="comment">// 末位加1 increment</span></span><br><span class="line">            sum++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(sum &gt;= <span class="number">10</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span>(i == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// 已经在最高位，进位就溢出了</span></span><br><span class="line">                is_overflow = <span class="literal">true</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                carry = <span class="number">1</span>;</span><br><span class="line">                sum -= <span class="number">10</span>;</span><br><span class="line">                number[i] = <span class="string">&#x27;0&#x27;</span> + sum;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            number[i] = <span class="string">&#x27;0&#x27;</span> + sum;</span><br><span class="line">            carry = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> is_overflow;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print_1_to_n_max</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span>* number = <span class="keyword">new</span> <span class="keyword">char</span>[n + <span class="number">1</span>]; <span class="comment">// 多一位给结尾符 \0</span></span><br><span class="line">    <span class="built_in">memset</span>(number, <span class="string">&#x27;0&#x27;</span>, n);</span><br><span class="line">    number[n] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(!increment(number)) &#123;</span><br><span class="line">        print(number);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">delete</span>[] number;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    print_1_to_n_max(<span class="number">3</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>还可以考虑用全排列的方式，就不用再考虑进位的问题，代码就简洁了很多：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">char</span>* number)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 对于前面的空0，不再打印</span></span><br><span class="line">    <span class="keyword">int</span> len = <span class="built_in">strlen</span>(number);</span><br><span class="line">    <span class="keyword">bool</span> begin = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(!begin &amp;&amp; number[i] == <span class="string">&#x27;0&#x27;</span>) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(!begin &amp;&amp; number[i] != <span class="string">&#x27;0&#x27;</span>) &#123;</span><br><span class="line">            begin = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>, number[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(begin == <span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>); <span class="comment">// 修正部分，不打印全0的情况</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print_1_to_n_max_rec</span><span class="params">(<span class="keyword">char</span>* number, <span class="keyword">int</span> len, <span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(index == len) &#123;</span><br><span class="line">        print(number);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">        number[index] = i + <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        print_1_to_n_max_rec(number, len, index + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print_1_to_n_max_permutation</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">char</span>* number = <span class="keyword">new</span> <span class="keyword">char</span>[n + <span class="number">1</span>];</span><br><span class="line">    <span class="built_in">memset</span>(number, <span class="string">&#x27;0&#x27;</span>, n);</span><br><span class="line">    number[n] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line"></span><br><span class="line">    print_1_to_n_max_rec(number, n, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">delete</span>[] number;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    print_1_to_n_max_permutation(<span class="number">3</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不过全排列的方法有一个容易忽略的漏洞，就算按照书上的代码运行，会出现一个多余的打印情况<code>print(&quot;000&quot;)</code>，这是因为这是全排列的起点，而想修改全排列的起点为<code>001</code>还稍微有点麻烦，这个时候你会发现其实<code>print</code>并不会把<code>000</code>打印出来，但是会多打印一个<code>\n</code>换行，所以只要简单修改一下<code>print</code>，让其只在非<code>000</code>的情况下才换行，这样看起来我们的输出起点就是<code>1</code>了。</p><hr><blockquote><p>面试题18：删除链表的节点。</p></blockquote><p><strong>题目一</strong>：在O(1)的时间内删除链表节点。</p><p>给定单向链表的头指针和一个节点指针，定义一个函数在<code>O(1)</code>时间内删除该节点。链表节点与函数的定义如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> value;</span><br><span class="line">    node* pnext;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">delete_node</span><span class="params">(node** phead, node* pdelete)</span></span>;</span><br></pre></td></tr></table></figure><p>完整实现代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> value;</span><br><span class="line">    node* pnext;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">node* <span class="title">init_node</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">    node* pnode = <span class="keyword">new</span> node;</span><br><span class="line">    pnode-&gt;value = value;</span><br><span class="line">    pnode-&gt;pnext = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">return</span> pnode;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert_node</span><span class="params">(node** phead, node* pnode)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(*phead == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        *phead = pnode;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    node* temp = *phead;</span><br><span class="line">    <span class="keyword">while</span>(temp-&gt;pnext != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        temp = temp-&gt;pnext;</span><br><span class="line">    &#125;</span><br><span class="line">    temp-&gt;pnext = pnode;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">delete_node</span><span class="params">(node** phead, node* pdelete)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!phead || !pdelete) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(pdelete-&gt;pnext != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="comment">// 删除非尾节点，拷贝节点</span></span><br><span class="line">        node* pnext = pdelete-&gt;pnext;</span><br><span class="line">        pdelete-&gt;value = pnext-&gt;value;</span><br><span class="line">        pdelete-&gt;pnext = pnext-&gt;pnext;</span><br><span class="line">        <span class="comment">// 删除节点</span></span><br><span class="line">        <span class="keyword">delete</span> pnext;</span><br><span class="line">        pnext = <span class="literal">nullptr</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(*phead == pdelete) &#123;</span><br><span class="line">        <span class="comment">// 删除尾节点，并且链表只有一个节点</span></span><br><span class="line">        <span class="keyword">delete</span> pdelete;</span><br><span class="line">        pdelete = <span class="literal">nullptr</span>;</span><br><span class="line">        *phead = <span class="literal">nullptr</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 删除尾节点，只能从头找起</span></span><br><span class="line">        node* pnode = *phead;</span><br><span class="line">        <span class="keyword">while</span>(pnode-&gt;pnext != pdelete) &#123;</span><br><span class="line">            pnode = pnode-&gt;pnext;</span><br><span class="line">        &#125;</span><br><span class="line">        pnode-&gt;pnext = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">delete</span> pdelete;</span><br><span class="line">        pdelete = <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(node** phead)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(*phead == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    node* pnode = *phead;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, pnode-&gt;value);</span><br><span class="line">    <span class="keyword">while</span>(pnode-&gt;pnext != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        pnode = pnode-&gt;pnext;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, pnode-&gt;value);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    node** phead = <span class="keyword">new</span> node*;</span><br><span class="line">    *phead = <span class="literal">nullptr</span>;</span><br><span class="line">    node** node_list = <span class="keyword">new</span> node*[<span class="number">10</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">        node* new_node = init_node(i);</span><br><span class="line">        node_list[i] = new_node;</span><br><span class="line">        insert_node(phead, new_node);</span><br><span class="line">    &#125;</span><br><span class="line">    print(phead); <span class="comment">// 0 1 2 3 4 5 6 7 8 9</span></span><br><span class="line">    <span class="comment">// 删除头节点</span></span><br><span class="line">    delete_node(phead, node_list[<span class="number">0</span>]);</span><br><span class="line">    <span class="comment">// 删除尾节点</span></span><br><span class="line">    delete_node(phead, node_list[<span class="number">9</span>]);</span><br><span class="line">    <span class="comment">// 删除中间节点</span></span><br><span class="line">    delete_node(phead, node_list[<span class="number">5</span>]);</span><br><span class="line">    print(phead); <span class="comment">// 1 2 3 4 6 7 8</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码有三个需要讨论的地方：</p><ol><li><strong>关于时间复杂度</strong>，如果是尾节点，则需要<code>O(n)</code>时间，如果是非尾节点，则需要<code>O(1)</code>时间，平均情况下<code>[(n-1)*O(1) + O(n)]/n = O(1)</code>，这也是书上说明的情况，<strong>但如果你真的要较真</strong>，你说：“我就是尾节点也想做到<code>O(1)</code>时间，可不可以？” 我说当然可以，再细想一下尾节点需要<code>O(n)</code>的原因，因为我们没有办法知道它的前一个节点是什么，那整个链表里面有没有什么地方是可以让我们保留一个额外的指针的地方呢？当然有，那就是尾节点没有利用起来的<code>pnext</code>，如果你将尾节点的<code>pnext</code>指向它的前一个节点，那自然删除也只需要<code>O(1)</code>时间了，当然这会影响到一些其他过程，例如判断达到尾节点的方式就和以往的<code>pnode-&gt;pnext == nullptr</code>不同了，但方法终归是可行的，尤其是如果面试官再进一步问是否还可以更优化时；</li><li><strong>上述代码仍然不是完美代码</strong>，主要是指的完整性上，因为它基于一个假设：<strong>要删除的节点的确在链表中</strong>，需要<code>O(n)</code>的时间才能判断链表中是否包含某一个节点（不借助其他数据结构情况下），受到题目的<code>O(1)</code>时间限制，所以这部分就没有再考虑了，可以和面试官进行说明；</li><li>代码中用来<strong>删除节点的部分</strong>，用了一个保存节点的<code>node_list</code>数组，但这个数组中的节点情况并不会一直地和链表的节点情况保持一致，因为方法中涉及到了节点的拷贝，取决于删除的情况，数组<code>i</code>位置保存节点的<code>value</code>很有可能并不是<code>i</code>，也有可能链表中<code>i</code>值的节点还在，而<code>node_list</code>中<code>i</code>位置的指针已经被设置为<code>nullptr</code>。</li></ol><p><strong>题目二</strong>：删除链表中重复的节点。</p><p>在一个<strong>排序的链表</strong>中，如何删除重复的节点？</p><p>PS：这道题在书上的图3.4应该是打印出错了，初始链表的几个节点都没有打全，总之就是链表中重复的节只保留一个。另外，注意题目中的<strong>已排序</strong>条件。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> value;</span><br><span class="line">    node* pnext;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">delete_duplication</span><span class="params">(node** phead)</span></span>;</span><br></pre></td></tr></table></figure><p>完整实现代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> value;</span><br><span class="line">    node* pnext;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">node* <span class="title">init_node</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123; ... &#125;; <span class="comment">// 和上面代码的相同</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert_node</span><span class="params">(node** phead, node* pnode)</span> </span>&#123; ... &#125;; <span class="comment">// 和上面代码的相同</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(node** phead)</span> </span>&#123; ... &#125;; <span class="comment">// 和上面代码的相同</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">delete_duplication</span><span class="params">(node** phead)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(phead == <span class="literal">nullptr</span> || *phead == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    node* pprenode = <span class="literal">nullptr</span>;</span><br><span class="line">    node* pnode = *phead;</span><br><span class="line">    <span class="keyword">while</span>(pnode != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        node* pnext = pnode-&gt;pnext;</span><br><span class="line">        <span class="keyword">bool</span> need_delete = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(pnext != <span class="literal">nullptr</span> &amp;&amp; pnext-&gt;value == pnode-&gt;value) &#123;</span><br><span class="line">            need_delete = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        pprenode = pnode; <span class="comment">// 修改的代码</span></span><br><span class="line">        <span class="keyword">if</span>(!need_delete) &#123;</span><br><span class="line">            <span class="comment">// pprenode = pnode; // 原代码</span></span><br><span class="line">            pnode = pnode-&gt;pnext;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">int</span> value = pnode-&gt;value;</span><br><span class="line">            node* ptobedel = pnext; <span class="comment">// 修改的代码</span></span><br><span class="line">            <span class="comment">// node* ptobedel = pnode; // 原代码</span></span><br><span class="line">            <span class="keyword">while</span>(ptobedel != <span class="literal">nullptr</span> &amp;&amp; ptobedel-&gt;value == value) &#123;</span><br><span class="line">                pnext = ptobedel-&gt;pnext;</span><br><span class="line">                <span class="keyword">delete</span> ptobedel;</span><br><span class="line">                ptobedel = <span class="literal">nullptr</span>;</span><br><span class="line">                ptobedel = pnext;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(pprenode == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">                *phead = pnext;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                pprenode-&gt;pnext = pnext;</span><br><span class="line">            &#125;</span><br><span class="line">            pnode = pnext;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    node** phead = <span class="keyword">new</span> node*;</span><br><span class="line">    *phead = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">        node* new_node = init_node(i / <span class="number">2</span>);</span><br><span class="line">        insert_node(phead, new_node);</span><br><span class="line">    &#125;</span><br><span class="line">    print(phead); <span class="comment">// 0 0 1 1 2 2 3 3 4 4</span></span><br><span class="line">    delete_duplication(phead);</span><br><span class="line">    print(phead); <span class="comment">// 0 1 2 3 4</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>init_node</code>、<code>insert_node</code>以及<code>print</code>函数均和18题题目一的代码相同，不再赘述。</p><p>PS：需要说明的一点是，书上的<code>delete_duplication</code>代码和我这里所写的代码有细微差别，原因是<strong>对原题目的理解偏差问题</strong>，如果原题目所说的<strong>删除重复的节点</strong>不需要留下一个被重复的节点（即一个都不留），则看上面代码的原代码部分，如果是需要保留一个节点，就看修改后的部分。</p><hr><blockquote><p>面试题19：正则表达式匹配</p></blockquote><p>题目：请实现一个函数用来匹配包含 <code>.</code> 和 <code>*</code> 的正则表达式。模式中的字符 <code>.</code> 表示任意一个字符，而 <code>*</code> 表示它前面的字符可以出现任意次（含0次），匹配是指<strong>字符串的所有字符匹配整个模式</strong>，例如，字符串 <code>&quot;aaa&quot;</code> 与模式 <code>a.a</code> 和 <code>ab*ac*a</code> 匹配，但与 <code>aa.a</code> 和 <code>ab*a</code> 均不匹配。</p><p>遇到字符时，和模式串的对应字符进行比较：</p><ul><li>如果是<strong>普通字符</strong>，则直接比较匹配，后移指针；</li><li>如果是 <code>.</code>，匹配任意字符，后移指针；</li><li>如果发现字符的下一位是 <code>*</code>，就有两种情况了：<ul><li>如果是<strong>再匹配一次</strong>的情况，先检验是否匹配，如果匹配，则字符串指针后移，匹配串指针不后移；如果不匹配，则只能考虑将匹配串指针后移两位(跳过<code>*</code>)；</li><li>如果是<strong>不再匹配一次</strong>的情况，匹配串指针后移两位（跳过<code>*</code>）；</li><li>两种情况都要考虑到，所以需要用到递归来判断其中一个分支是否可行。</li></ul></li></ul><p>完整实现代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">match_core</span><span class="params">(<span class="keyword">char</span>* str, <span class="keyword">char</span>* pattern)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%c %c \n&quot;</span>, *str, *pattern);</span><br><span class="line">    <span class="keyword">if</span>(*str == <span class="string">&#x27;\0&#x27;</span> &amp;&amp; *pattern == <span class="string">&#x27;\0&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(*str != <span class="string">&#x27;\0&#x27;</span> &amp;&amp; *pattern == <span class="string">&#x27;\0&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(*(pattern + <span class="number">1</span>) == <span class="string">&#x27;*&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span>((*pattern == <span class="string">&#x27;.&#x27;</span> &amp;&amp; *str != <span class="string">&#x27;\0&#x27;</span>) || *str == *pattern) &#123;</span><br><span class="line">            <span class="keyword">return</span> match_core(str + <span class="number">1</span>, pattern) || match_core(str, pattern + <span class="number">2</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> match_core(str, pattern + <span class="number">2</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>((*pattern == <span class="string">&#x27;.&#x27;</span> &amp;&amp; *str != <span class="string">&#x27;\0&#x27;</span>) || *str == *pattern) &#123;</span><br><span class="line">        <span class="keyword">return</span> match_core(str + <span class="number">1</span>, pattern + <span class="number">1</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">match</span><span class="params">(<span class="keyword">char</span>* str, <span class="keyword">char</span>* pattern)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(str == <span class="literal">nullptr</span> || pattern == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> match_core(str, pattern);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> str[<span class="number">100</span>] = <span class="string">&quot;aaa&quot;</span>;</span><br><span class="line">    <span class="keyword">char</span> pattern[<span class="number">100</span>] = <span class="string">&quot;ab*ac*a&quot;</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Match? %s \n&quot;</span>, match(str, pattern) ? <span class="string">&quot;true&quot;</span> : <span class="string">&quot;false&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码中，需要注意的一个点是，对于匹配串的字符是<code>.</code>时，不能只是简单的只看匹配串，还要看<strong>被匹配串是否有字符可以匹配</strong>，所以不能只是简单地写为<code>if(*pattern == &#39;.&#39; || ...)</code>，应该写为<code>if((*pattern == &#39;.&#39; &amp;&amp; *str != &#39;\0&#39;) || ...)</code>，如果忽略这个细节，你不会在题目提供的几个输入输出上发现问题，但如果你多尝试其他的输入输出，尤其是当匹配串为<code>.*</code>(匹配任意字符)，你会发现结果是错误的。</p><hr><blockquote><p>面试题20：表示数值的字符串</p></blockquote><p>实现一个函数用来判断字符串是否表示数值（包括整数和小数），例如字符串<code>&quot;+100&quot;</code>、<code>&quot;5e2&quot;</code>、<code>&quot;-123&quot;</code>、<code>&quot;3.1416&quot;</code>及<code>&quot;-1E-16&quot;</code>都表示数值，但<code>&quot;12e&quot;</code>、<code>&quot;1a3.14&quot;</code>、<code>&quot;1.2.3&quot;</code>、<code>&quot;+-5&quot;</code>及<code>&quot;12e+5.4&quot;</code>都不是。</p><p>表示数值的字符串遵循模式 <code>A[.[B]][e|EC]</code> 或者 <code>.B[e|EC]</code>，其中A为数值的整数部分，B紧跟小数点为数值的小数部分，C紧跟着<code>e</code>或者<code>E</code>为数值的指数部分。A和C都是可能以<code>+</code>或者<code>-</code>开头的<code>0~9</code>的数位串，B也是<code>0~9</code>的数位串，但前面不能有正负号。</p><p>完整实现代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">scan_unsigned_inter</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>** str)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>* before = *str;</span><br><span class="line">    <span class="keyword">while</span>(**str != <span class="string">&#x27;\0&#x27;</span> &amp;&amp; **str &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; **str &lt;= <span class="string">&#x27;9&#x27;</span>) &#123;</span><br><span class="line">        (*str)++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> *str &gt; before;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">scan_integer</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>** str)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(**str == <span class="string">&#x27;+&#x27;</span> || **str == <span class="string">&#x27;-&#x27;</span>) &#123;</span><br><span class="line">        (*str)++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> scan_unsigned_inter(str);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">is_numberic</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* str)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(str == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// A[.[B]][e|EC] 或者 .B[e|EC]</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查A部分</span></span><br><span class="line">    <span class="keyword">bool</span> a_is_numeric = scan_integer(&amp;str);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">bool</span> b_is_numeric = <span class="literal">true</span>;</span><br><span class="line">    <span class="comment">// 如果碰到小数点，检查B部分</span></span><br><span class="line">    <span class="keyword">if</span>(*str == <span class="string">&#x27;.&#x27;</span>) &#123;</span><br><span class="line">        str++;</span><br><span class="line">        b_is_numeric = scan_unsigned_inter(&amp;str);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">bool</span> c_is_numeric = <span class="literal">true</span>;</span><br><span class="line">    <span class="comment">// 如果碰到e或E，检查C部分</span></span><br><span class="line">    <span class="keyword">if</span>(*str == <span class="string">&#x27;e&#x27;</span> || *str == <span class="string">&#x27;E&#x27;</span>) &#123;</span><br><span class="line">        str++;</span><br><span class="line">        c_is_numeric = scan_integer(&amp;str);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">bool</span> all_scan = (*str == <span class="string">&#x27;\0&#x27;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// (A || B) &amp;&amp; C &amp;&amp; End</span></span><br><span class="line">    <span class="keyword">return</span> (a_is_numeric || b_is_numeric) &amp;&amp; c_is_numeric &amp;&amp; all_scan;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print_is_numberic</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* str)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s %s\n&quot;</span>, str, is_numberic(str)?<span class="string">&quot;yes&quot;</span>:<span class="string">&quot;no&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    print_is_numberic(<span class="string">&quot;+100&quot;</span>); <span class="comment">// +100 yes</span></span><br><span class="line">    print_is_numberic(<span class="string">&quot;5e2&quot;</span>); <span class="comment">// 5e2 yes</span></span><br><span class="line">    print_is_numberic(<span class="string">&quot;-123&quot;</span>); <span class="comment">// -123 yes</span></span><br><span class="line">    print_is_numberic(<span class="string">&quot;3.1416&quot;</span>); <span class="comment">// 3.1416 yes</span></span><br><span class="line">    print_is_numberic(<span class="string">&quot;-1E-16&quot;</span>); <span class="comment">// -1E-16 yes</span></span><br><span class="line">    print_is_numberic(<span class="string">&quot;12e&quot;</span>); <span class="comment">// 12e no</span></span><br><span class="line">    print_is_numberic(<span class="string">&quot;1a3.14&quot;</span>); <span class="comment">// 1a3.14 no</span></span><br><span class="line">    print_is_numberic(<span class="string">&quot;1.2.3&quot;</span>); <span class="comment">// 1.2.3 no</span></span><br><span class="line">    print_is_numberic(<span class="string">&quot;+-5&quot;</span>); <span class="comment">// +-5 no</span></span><br><span class="line">    print_is_numberic(<span class="string">&quot;12e+5.4&quot;</span>); <span class="comment">// 12e+5.4 no</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码中需要注意的一个点是，书上原代码中是把各部分判断拆开计算逻辑合并的，但是我为了更加直观地写出其中逻辑思路，将各部分的判断都留到了最后，最后我们如果稍微一疏忽，容易就写成<code>A || B &amp;&amp; C &amp;&amp; End</code>，在C++中，<strong>逻辑运算符的结合反向是从左到右的</strong>，所以有可能你会把这种写法理解成<code>(A || B) &amp;&amp; C &amp;&amp; End</code>，<strong>但是</strong>，<strong>逻辑运算符之间的优先级顺序是</strong>，<code>! &gt; &amp;&amp; &gt; ||</code>，这会导致计算结果等价于<code>A || (B &amp;&amp; C &amp;&amp; End)</code>，即只要<code>A==true</code>就会判定为数字，这当然不正确的，所以要得到正确的结果，应该显式的写为<code>(A || B) &amp;&amp; C &amp;&amp; End</code>，避免计算错误。</p><hr><blockquote><p>面试题21：调整数组顺序使奇数位于偶数前面</p></blockquote><p>输入一个整数数组，实现一个函数来调整该数组中数字的顺序，使得<strong>所有奇数位于数组的前半部分</strong>，<strong>所有偶数位于数组的后半部分</strong>。</p><p>针对这道题的最优解法，在数组头尾设置两个指针，依次开始向中间扫描，如果左指针遇到偶数则停下，右指针遇到奇数则停下，然后交换两个指针指向的内容，直到两个指针相遇，算法停止，最后结果满足题目要求。</p><p>完整实现代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">reorder_odd_even</span><span class="params">(<span class="keyword">int</span>* <span class="built_in">array</span>, <span class="keyword">unsigned</span> <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">array</span> == <span class="literal">nullptr</span> || len == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span>* pleft = <span class="built_in">array</span>;</span><br><span class="line">    <span class="keyword">int</span>* pright = <span class="built_in">array</span> + len - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(pleft &lt; pright) &#123;</span><br><span class="line">        <span class="comment">// 左指针遇到偶数停</span></span><br><span class="line">        <span class="keyword">while</span>(pleft &lt; pright &amp;&amp; (*pleft &amp; <span class="number">0x1</span>) != <span class="number">0</span>) &#123;</span><br><span class="line">            pleft++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 右指针遇到奇数停</span></span><br><span class="line">        <span class="keyword">while</span>(pleft &lt; pright &amp;&amp; (*pright &amp; <span class="number">0x1</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">            pright--;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> temp = *pleft;</span><br><span class="line">        *pleft = *pright;</span><br><span class="line">        *pright = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> <span class="built_in">array</span>[<span class="number">10</span>] = &#123;<span class="number">0</span>, <span class="number">2</span>, <span class="number">9</span>, <span class="number">1</span>, <span class="number">6</span>, <span class="number">5</span>, <span class="number">8</span>, <span class="number">7</span>, <span class="number">3</span>, <span class="number">4</span>&#125;;</span><br><span class="line">    reorder_odd_even(<span class="built_in">array</span>, <span class="number">10</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, <span class="built_in">array</span>[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 3 7 9 1 5 6 8 2 0 4</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可扩展的解法，不固定其中的判别逻辑，可以将<strong>任意两类定义的数据</strong>进行这样的前后分离：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 这里用到的是一个函数指针，将一个函数传给另一个函数内部使用</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">reorder</span><span class="params">(<span class="keyword">int</span>* <span class="built_in">array</span>, <span class="keyword">unsigned</span> <span class="keyword">int</span> len, <span class="keyword">bool</span> (*func)(<span class="keyword">int</span>))</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">array</span> == <span class="literal">nullptr</span> || len == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span>* pleft = <span class="built_in">array</span>;</span><br><span class="line">    <span class="keyword">int</span>* pright = <span class="built_in">array</span> + len - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(pleft &lt; pright) &#123;</span><br><span class="line">        <span class="comment">// 左指针遇到偶数停</span></span><br><span class="line">        <span class="keyword">while</span>(pleft &lt; pright &amp;&amp; !func(*pleft)) &#123;</span><br><span class="line">            pleft++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 右指针遇到奇数停</span></span><br><span class="line">        <span class="keyword">while</span>(pleft &lt; pright &amp;&amp; func(*pright)) &#123;</span><br><span class="line">            pright--;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> temp = *pleft;</span><br><span class="line">        *pleft = *pright;</span><br><span class="line">        *pright = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">is_even</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (n &amp; <span class="number">0x1</span>) == <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">is_odd</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (n &amp; <span class="number">0x1</span>) != <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> <span class="built_in">array</span>[<span class="number">10</span>] = &#123;<span class="number">0</span>, <span class="number">2</span>, <span class="number">9</span>, <span class="number">1</span>, <span class="number">6</span>, <span class="number">5</span>, <span class="number">8</span>, <span class="number">7</span>, <span class="number">3</span>, <span class="number">4</span>&#125;;</span><br><span class="line">    reorder(<span class="built_in">array</span>, <span class="number">10</span>, is_even);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, <span class="built_in">array</span>[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 3 7 9 1 5 6 8 2 0 4</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    reorder(<span class="built_in">array</span>, <span class="number">10</span>, is_odd);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, <span class="built_in">array</span>[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 4 0 2 8 6 5 1 9 7 3</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="4-代码的鲁棒性"><a href="#4-代码的鲁棒性" class="headerlink" title="4 代码的鲁棒性"></a>4 代码的鲁棒性</h2><p>请到《第3章笔记 高质量代码 P2》阅读这部分内容。</p>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;除了程序代码的正确性，经常我们还要关注它的鲁棒性。&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="剑指Offer" scheme="https://yumi-cn.github.io/categories/%E5%89%91%E6%8C%87Offer/"/>
    
    
    <category term="笔记" scheme="https://yumi-cn.github.io/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>1月的计划</title>
    <link href="https://yumi-cn.github.io/2020/12/23/plan-2021-01/"/>
    <id>https://yumi-cn.github.io/2020/12/23/plan-2021-01/</id>
    <published>2020-12-23T10:10:23.000Z</published>
    <updated>2020-12-26T02:44:55.040Z</updated>
    
    <content type="html"><![CDATA[<p>距离2021的春招实习只有2个半月了，要开始争分夺秒了（唉，好想给女儿做二创啊）。</p><p>感觉前两个月因为各种各样的情况，看书写笔记的效率还是有点低（投入的时间确实也不够多），还有同时要看几本难啃的书确实不容易，之后要分清一下多个任务的主次了。</p><a id="more"></a><p>12月剩下时间的规划：</p><ul><li><strong>《剑指Offer》</strong>第3、4章，暂时不再写完整的博客了，只贴部分题目的完整实现代码；</li><li><strong>《3D游戏与计算机图形学中的数学方法》</strong>第4、5、6章，暂时不再写完整博客，会先简单写一些重要知识点摘录（自己打公式太费时间了）；</li><li><strong>《Real Time Rendering 4th》</strong>第2、3、4章，不再写完整博客，翻译还是有点费时费力，先看一遍过一下好了，主要作为3D数学方法那本书的知识补充。</li></ul><p>1月的规划：</p><ul><li><strong>《剑指Offer》</strong>第5、6章，不写完整博客，只贴部分题目的完整实现代码；</li><li><strong>《3D游戏与计算机图形学中的数学方法》</strong>第6-9章，暂时不再写完整博客，会先简单写一些重要知识点摘录；</li><li><strong>《Real Time Rendering 4th》</strong>第5-11章，只读，不写博客；</li><li><strong>《Effective C++》</strong>的55个条款，尽量都写写代码尝试实践，每一个其实都涉及到不少原本C++中的知识点，应该都要同步学习或者复习一下。</li></ul><p>其实就算是真的完成了这么多阅读的任务，还是有很多<strong>知识盲区</strong>，比如Unity3D、UE4、OpenGL、DirectX、RTX系列技术这种。</p><p>2月的初步规划（除掉过年，可能只有大半月的时间）：</p><ul><li><strong>面试笔试题</strong>，稍微刷一点面试常见的算法题(尤其是mid和hard难度的)，数量控制在100题以内吧，找到用C++解题的手感；</li><li><strong>引擎面试题</strong>，只能去收集各大厂引擎、渲染方面的面经贴，然后总结各种各样的点，有必要的话拓展去了解；</li><li><strong>OpenGL</strong>，估计至少要走一遍指南吧，代码都敲一敲；</li><li><strong>Unity3D入门和《Unity Shader 入门精要》</strong>，主要是了解Unity方面的相关知识；</li><li><strong>各大厂的简历投递</strong>，别忘了投简历了，注意提前收集他们的时间。</li></ul><p>3月的初步规划（基本上到了冲刺阶段了，剩下半个月时间）：</p><ul><li><strong>面试笔试题</strong>，每日做题的任务照常安排着走；</li><li><strong>引擎面试题</strong>，继续看收集的那些面试问题，顺带复习一下以前的笔记；</li><li><strong>《游戏引擎架构》</strong>，半个月简单刷一下这本书的大致内容，做到都有一定了解即可，当作知识广度阅读资料。</li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;距离2021的春招实习只有2个半月了，要开始争分夺秒了（唉，好想给女儿做二创啊）。&lt;/p&gt;
&lt;p&gt;感觉前两个月因为各种各样的情况，看书写笔记的效率还是有点低（投入的时间确实也不够多），还有同时要看几本难啃的书确实不容易，之后要分清一下多个任务的主次了。&lt;/p&gt;</summary>
    
    
    
    <category term="计划-Flags" scheme="https://yumi-cn.github.io/categories/%E8%AE%A1%E5%88%92-Flags/"/>
    
    
  </entry>
  
  <entry>
    <title>《剑指Offer》第2章笔记 算法和数据操作</title>
    <link href="https://yumi-cn.github.io/2020/12/20/s2o-c2-algorithm/"/>
    <id>https://yumi-cn.github.io/2020/12/20/s2o-c2-algorithm/</id>
    <published>2020-12-20T05:57:08.000Z</published>
    <updated>2020-12-20T05:57:53.072Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>考算法的面试题也备受面试官青睐（老折磨人了）。</p></blockquote><a id="more"></a><p>通常<strong>排序和查找</strong>是面试时考查算法的重点，准备的时候要重点掌握二分查找、归并排序和快速排序，要做到随时正确、完整地写出它们地代码。</p><p>二维数组上搜索路径的一些题目可以尝试用回溯法，通常回溯法适合用递归代码实现，如果面试官不允许递归实现，再尝试用栈来模拟递归过程。</p><p>如果是求解某个问题的最优解，并且问题可以分为子问题解决，就可以尝试用动态规划，如果在分解子问题中，满足一些特定条件就可以找到最优解，可以考虑用贪婪最优法。</p><hr><h2 id="1-递归和循环"><a href="#1-递归和循环" class="headerlink" title="1 递归和循环"></a>1 递归和循环</h2><ul><li>递归的代码通常比循环更加简洁，但代价是效率不够高，并且还有递归栈层数限制；</li><li>在一些题目中简单的递归会增加不必要的重复计算；</li><li>应用动态规划解决问题时，大部分都是递归方法分析问题，有些问题会出现子问题重复计算，到时候会讨论如何用循环替换递归实现；</li></ul><blockquote><p>面试题10：斐波那契数列</p></blockquote><p>题目一：求斐波那契数列的第n项，<code>f(0) = 0, f(1) = 1, f(n) = f(n-1) + f(n-2)</code>。</p><p>最简单的递归法就不在说明了，这里直接写一下不用重复计算的思路，当需要求解第n项时，需要求解前n-1项，通过观察可以发现从第2项开始计算，可以避免重复计算的问题。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> max_n = <span class="number">1000</span>;</span><br><span class="line"><span class="comment">// 如果不需要缓存，使用两个变量求解即可</span></span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> store[max_n];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">fibonacci</span><span class="params">(<span class="keyword">unsigned</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n &gt;= max_n) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>; <span class="comment">// Throw Error</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (store[n] != <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> store[n];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            store[i] = store[i<span class="number">-1</span>] + store[i<span class="number">-2</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> store[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::fill(&amp;store[<span class="number">0</span>], &amp;store[max_n], <span class="number">-1</span>);</span><br><span class="line">    store[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    store[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; fibonacci(<span class="number">50</span>) &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>书上还有一个<code>O(logn)</code>的算法，要使用到一个数学公式：</p><div>$$\left[\begin{matrix}f(n) & f(n-1) \\f(n-1) & f(n-2)\end{matrix}\right]=\left[\begin{matrix}1 & 1 \\1 & 0\end{matrix}\right]^{n-1}$$</div><p>公式可以用数学归纳法证明，问题就转换为如何求矩阵乘方，如果只是简单地从0开始循环，n次方需要n次元素，时间复杂度仍然是<code>O(n)</code>，并不比前面的方法快，但是其中的乘方有如下性质：</p><div>$$a^{n}=\left\{\begin{array}{rcl}a^{n/2} \cdot a^{n/2}, & & n\ is\ even \\a^{(n-1)/2} \cdot a^{(n-1)/2} \cdot a, & & n\ is\ odd\end{array}\right.$$</div><p>从公式可以看出，如果想求得n次方，就要先求得n/2次方，再把n/2次方的结果平方一下即可，时间复杂度为<code>O(logn)</code>。</p><p>不过算法仅做了解，很少会这么去写，实现起来也比较复杂。</p><p>还有不少面试题可以看成是斐波那契数列的应用：</p><p>题目二：青蛙跳台阶问题。</p><p>一只青蛙一次可以跳上1级台阶，也可以跳上2级台阶，求该青蛙跳上一个n级的台阶总共有多少种跳法。</p><p>将问题看作是求解函数f(n)，当青蛙第1次跳1级，则下一次求解f(n-1)，如果青蛙第1次跳2级，则下一次求解f(n-2)，所以其实本质还是斐波那契数列<code>f(n)=f(n-1)+f(n-2)</code>。</p><hr><h2 id="2-查询和排序"><a href="#2-查询和排序" class="headerlink" title="2 查询和排序"></a>2 查询和排序</h2><p>查询相对于排序较为简单，不外乎顺序查找、二分查找、哈希表查找和二叉排序树查找。<br>在面试的时候，不管是用循环还是递归，面试官都期待应聘者能够信手拈来写出<strong>完整正确地二分查找代码</strong>，否则可能连继续面试的兴趣都没有。</p><p>排序比查找要复杂一点，面试官会经常要求应聘者比较 插入排序、冒泡排序、归并排序、快速排序等不同算法的优劣。</p><p>实现快速排序算法的关键在于先在数组中选择一个数字，接下来把数组中的数字分为两部分，比选择的数字小的数字移到数组左边，比选择的数字大的数字移到数组的右边（递增排序）。</p><p>（然后就是一段基本上在哪本书上都能看到的快速排序代码）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">partition</span><span class="params">(<span class="keyword">int</span> data[], <span class="keyword">int</span> len, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(data == <span class="literal">nullptr</span> || len &lt;=<span class="number">0</span> || start &lt; <span class="number">0</span> || end &gt;= len) &#123;</span><br><span class="line">        <span class="function"><span class="built_in">std</span>::logic_error <span class="title">ex</span><span class="params">(<span class="string">&quot;Invalid Parameters&quot;</span>)</span></span>;</span><br><span class="line">        <span class="keyword">throw</span> <span class="built_in">std</span>::exception(ex);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> index = random_in_range(start, end);</span><br><span class="line">    swap(&amp;data[index], &amp;data[end]); <span class="comment">// end位置存储比较元素</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> small = start - <span class="number">1</span>; <span class="comment">// small用来指向存放小于比较元素的位置</span></span><br><span class="line">    <span class="keyword">for</span>(index = start; index &lt; end; index++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(data[index] &lt; data[end]) &#123;</span><br><span class="line">            <span class="comment">// 比比较元素小的就交换到small的地方</span></span><br><span class="line">            small++;</span><br><span class="line">            <span class="keyword">if</span>(small != index) &#123;</span><br><span class="line">                <span class="comment">// 如果位置相同就没必要再交换了</span></span><br><span class="line">                swap(&amp;data[index], &amp;data[small]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    small++;</span><br><span class="line">    swap(&amp;data[small], &amp;data[end]); <span class="comment">// 比较元素也放回对应位置</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> small; <span class="comment">// 返回比较元素的位置，划分左右两个子数组</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面是<code>partition</code>部分的代码，快速排序的其中一步，选择锚元素(比较元素)，将数组start-end区域的元素划分为两部分，一部分小于锚元素，另一部分大于锚元素。</p><p>完整的运行代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ctime&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;exception&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">random_in_range</span><span class="params">(<span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">    srand((<span class="keyword">unsigned</span>)time(<span class="literal">NULL</span>));</span><br><span class="line">    <span class="keyword">return</span> rand() % (end - start + <span class="number">1</span>) + start;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>* lhs, <span class="keyword">int</span>* rhs)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> temp = *lhs;</span><br><span class="line">    *lhs = *rhs;</span><br><span class="line">    *rhs = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">partition</span><span class="params">(<span class="keyword">int</span> data[], <span class="keyword">int</span> len, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(data == <span class="literal">nullptr</span> || len &lt;=<span class="number">0</span> || start &lt; <span class="number">0</span> || end &gt;= len) &#123;</span><br><span class="line">        <span class="function"><span class="built_in">std</span>::logic_error <span class="title">ex</span><span class="params">(<span class="string">&quot;Invalid Parameters&quot;</span>)</span></span>;</span><br><span class="line">        <span class="keyword">throw</span> <span class="built_in">std</span>::exception(ex);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> index = random_in_range(start, end);</span><br><span class="line">    swap(&amp;data[index], &amp;data[end]); <span class="comment">// end位置存储比较元素</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> small = start - <span class="number">1</span>; <span class="comment">// small用来指向存放小于比较元素的位置</span></span><br><span class="line">    <span class="keyword">for</span>(index = start; index &lt; end; index++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(data[index] &lt; data[end]) &#123;</span><br><span class="line">            <span class="comment">// 比比较元素小的就交换到small的地方</span></span><br><span class="line">            small++;</span><br><span class="line">            <span class="keyword">if</span>(small != index) &#123;</span><br><span class="line">                <span class="comment">// 如果位置相同就没必要再交换了</span></span><br><span class="line">                swap(&amp;data[index], &amp;data[small]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    small++;</span><br><span class="line">    swap(&amp;data[small], &amp;data[end]); <span class="comment">// 比较元素也放回对应位置</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> small; <span class="comment">// 返回比较元素的位置，划分左右两个子数组</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">quick_sort</span><span class="params">(<span class="keyword">int</span> data[], <span class="keyword">int</span> len, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(start == end) &#123;</span><br><span class="line">        <span class="keyword">return</span>; <span class="comment">// 单个元素，不用排序</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> index = partition(data, len, start, end);</span><br><span class="line">    <span class="keyword">if</span>(index &gt; start) &#123;</span><br><span class="line">        quick_sort(data, len, start, index<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(index &lt; end) &#123;</span><br><span class="line">        quick_sort(data, len, start+<span class="number">1</span>, end);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> data[] = &#123;<span class="number">9</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">7</span>, <span class="number">5</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">6</span>&#125;;</span><br><span class="line">    quick_sort(data, <span class="number">10</span>, <span class="number">0</span>, <span class="number">9</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, data[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>partition</code>函数除了可以用在快速排序中，还可以用来实现在长度n数组中查找第k大的数字，面试题39“数组中出现次数超过一半的数字”和面试题40“最小的k个数”都可以用这个函数来解决。</p><p>不同排序的适用场合也不尽相同，快速排序虽然总体的平均效率最好，但不是任何时候都是最优的算法（只是在平均效率上满足O(nlogn)，可以找出一些最坏的情况），所以在面试的时候，如果面试官要求实现一个排序算法，可以先问清楚这个排序<strong>应用的环境是什么</strong>、<strong>有哪些约束条件</strong>等等，得到足够多的信息之后再选择合适的排序算法。</p><blockquote><p>面试题11：旋转数组的最小数字</p></blockquote><p>把一个数组最开始的若干的元素搬到数组的末尾，称之为数组的旋转，输入一个递增排序的数组的一个旋转，输出旋转数组的最小元素。例如{3, 4, 5, 1, 2}是{1, 2, 3, 4, 5}的一个旋转，数组的最小值是1。</p><ul><li>思路1：简单遍历数组求最小值（无论正序还是逆序），时间开销都是O(n)，大概率不是一个最优解；</li><li>思路2：递增排序的一个区间满足性质, <strong>首元素一定小于尾元素</strong>，如果考虑到元素可以重复，即如果<strong>首元素大于等于尾元素</strong>，则该区间可能并不是<strong>非递减的</strong>。</li><li>思路3：思路2通过二分区间判断实现起来还是有一点复杂，还可以进一步地简化思路，每一次判断<code>mid</code>和<code>start</code>、<code>end</code>位置上元素大小关系，如果<code>mid&gt;=start</code>，证明<code>mid</code>位于前面的递增区间，下一步在<code>mid-end</code>中找最小元素；如果<code>mid&lt;=end</code>，证明<code>mid</code>位于后面的递增区间，下一步在<code>start-mid</code>中找最小元素。</li></ul><p>按照思路3，<code>start</code>总是指向前面递增数组的元素、<code>end</code>总是指向后面递增数组的元素，当<code>start</code>和<code>end</code>中间没有其他元素时，<code>end</code>就指向后面递增元素的第一个，也就是最小的数字，这也是循环结束的条件。</p><div align="center"><p><img src="/images/s2o-c2-ag-cv-11.1.jpg" alt="在数组{3,4,5,1,2}中查找最小值的过程"></p></div><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">min</span><span class="params">(<span class="keyword">int</span>* numbers, <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(numbers == <span class="literal">nullptr</span> || len &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="function"><span class="built_in">std</span>::logic_error <span class="title">ex</span><span class="params">(<span class="string">&quot;Invalid parameters&quot;</span>)</span></span>;</span><br><span class="line">        <span class="keyword">throw</span> <span class="built_in">std</span>::exception(ex);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> index1 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> index2 = len - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> index_mid = index1;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(numbers[index1] &gt;= numbers[index2]) &#123;</span><br><span class="line">        <span class="keyword">if</span>(index2 - index1 == <span class="number">1</span>) &#123;</span><br><span class="line">            index_mid = index2;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        index_mid = (index1 + index2) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(numbers[index_mid] &gt;= numbers[index1]) &#123;</span><br><span class="line">            <span class="comment">// mid在前面的递增数组中，min在后面</span></span><br><span class="line">            index1 = index_mid;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(numbers[index_mid] &lt;= numbers[index2]) &#123;</span><br><span class="line">            <span class="comment">// mid在后面的递增数组中，min在前面</span></span><br><span class="line">            index2 = index_mid;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> numbers[index_mid];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但上面的方法还有一些特殊情况没有考虑到：</p><ul><li>如果只搬动了0个元素到后面，即排序数组本身，上面的方法就不再适用了，但因为此时数组中一个数字就是最小的数字，可以直接返回；</li><li>如果<code>index1</code>和<code>index2</code>指向的元素相等，甚至他们都和<code>index_mid</code>指向的元素想等时，应该如何处理呢？这个时候无法简单地判断出<code>min</code>在前面还是后面（参考下面图），所以只能采取简单的遍历法（如果是递归函数实现的话可以都向下计算然后比对最小值）。</li></ul><div align="center"><p><img src="/images/s2o-c2-ag-cv-11.2.jpg" alt="数组{0,1,1,1,1}的两个旋转数组"></p></div><p>完整代码实现：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;exception&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">min_in_order</span><span class="params">(<span class="keyword">int</span>* numbers, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> min = numbers[start];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = start + <span class="number">1</span>; i &lt;= end; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(min &gt; numbers[i]) &#123;</span><br><span class="line">            min = numbers[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> min;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">min</span><span class="params">(<span class="keyword">int</span>* numbers, <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(numbers == <span class="literal">nullptr</span> || len &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="function"><span class="built_in">std</span>::logic_error <span class="title">ex</span><span class="params">(<span class="string">&quot;Invalid parameters&quot;</span>)</span></span>;</span><br><span class="line">        <span class="keyword">throw</span> <span class="built_in">std</span>::exception(ex);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> index1 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> index2 = len - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> index_mid = index1;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(numbers[index1] &gt;= numbers[index2]) &#123;</span><br><span class="line">        <span class="keyword">if</span>(index2 - index1 == <span class="number">1</span>) &#123;</span><br><span class="line">            index_mid = index2;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        index_mid = (index1 + index2) / <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(numbers[index1] == numbers[index2]</span><br><span class="line">            &amp;&amp; numbers[index_mid] == numbers[index1]) &#123;</span><br><span class="line">            <span class="comment">// index1 mid index2 均相等，顺序查找</span></span><br><span class="line">                <span class="keyword">return</span> min_in_order(numbers, index1, index2);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(numbers[index_mid] &gt;= numbers[index1]) &#123;</span><br><span class="line">            <span class="comment">// mid在前面的递增数组中，min在后面</span></span><br><span class="line">            index1 = index_mid;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(numbers[index_mid] &lt;= numbers[index2]) &#123;</span><br><span class="line">            <span class="comment">// mid在后面的递增数组中，min在前面</span></span><br><span class="line">            index2 = index_mid;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> numbers[index_mid];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> numbers[] = &#123;<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">1</span>, <span class="number">2</span>&#125;;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, min(numbers, <span class="number">5</span>)); <span class="comment">// 1</span></span><br><span class="line">    <span class="keyword">int</span> onumbers[] = &#123;<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>&#125;;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, min(onumbers, <span class="number">5</span>)); <span class="comment">// 0</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="3-回溯法"><a href="#3-回溯法" class="headerlink" title="3 回溯法"></a>3 回溯法</h2><p>回溯法可以看成蛮力法的升级，它从解决问题的每一步可能选项理选出一个可行的解决方法。<br>回溯法非常适合由多个步骤组成的问题，并且每个步骤都有多个选项。</p><p>用回溯法解决的问题的所有选项可以形象地用树状结构表示。在某一步有<code>n</code>个可能的选项，该步骤可以看成是树状结构中的一个节点，每个选项看成树中节点连接线。树的叶节点对应对应着终结状态，如果在叶节点的状态满足题目的约束条件，则找到了一个可行的解决方案。</p><p>如果叶节点的状态不满足约束，则只好回溯到它的上一个节点再尝试其他的选项，如果上一个节点所有可能的选项都已经试过，找下一种可能选项时，需要再次回溯到上一个节点（依次类推）。如果所有节点的所有选项都已经尝试过仍然不能达到满足约束条件的终结状态，则该问题无解。</p><p>以面试题12来说明回溯法的应用方法。</p><blockquote><p>面试题12：矩阵中的路径</p></blockquote><p>设计一个函数，用来判断一个矩阵中是否存在一条包含某字符串所有字符的路径。路径可以从矩阵中的任意一格开始，每一步可以在矩阵中向左、右、上、下移动一格。如果一条路径经过了矩阵的某一格，那么该路径不能再次进入该格子。</p><div align="center"><p><img src="/images/s2o-c2-ag-cv-12.1.jpg" alt="一个字符矩阵的例子"></p></div><p>用回溯法解决的典型题，首先在矩阵中任选一个格子作为路径的起点，然后尝试匹配字符串，如果位置字符匹配，则在临近格子中寻找下一步格子，重复上述过程，直到路径上所有字符都在矩阵中找到相应的位置。</p><p>由于回溯法的递归特性，路径可以被看成一个栈，当在矩阵中定位了路径中前n个字符位置之后，在与第n个字符对应的格子的周围都没有找到第n+1字符，这时候只好在路径上回到第n-1字符，重新定位第n个字符。</p><p>由于路径不能重复进入矩阵的格子，所以要定义和字符矩阵大小一样的布尔值矩阵，用来标识路径已经进入了哪些格子。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt; // include memset()</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">has_path_core</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* matrix, <span class="keyword">int</span> rows, <span class="keyword">int</span> cols, <span class="keyword">int</span> row,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">int</span> col, <span class="keyword">const</span> <span class="keyword">char</span>* str, <span class="keyword">int</span>&amp; path_len, <span class="keyword">bool</span>* visited)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(str[path_len] == <span class="string">&#x27;\0&#x27;</span>) &#123;</span><br><span class="line">        <span class="comment">// 前面的字符都找到相应位置了</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">bool</span> has_path = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span>(row &gt;= <span class="number">0</span> &amp;&amp; row &lt; rows &amp;&amp; col &gt;= <span class="number">0</span> &amp;&amp; col &lt; cols</span><br><span class="line">        &amp;&amp; matrix[row * cols + col] == str[path_len]</span><br><span class="line">        &amp;&amp; !visited[row * cols + col]) &#123;</span><br><span class="line">        path_len++;</span><br><span class="line">        visited[row*col + col] = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">        has_path = has_path_core(matrix, rows, cols, row, col<span class="number">-1</span>, str, path_len, visited)</span><br><span class="line">                || has_path_core(matrix, rows, cols, row<span class="number">-1</span>, col, str, path_len, visited)</span><br><span class="line">                || has_path_core(matrix, rows, cols, row, col+<span class="number">1</span>, str, path_len, visited)</span><br><span class="line">                || has_path_core(matrix, rows, cols, row+<span class="number">1</span>, col, str, path_len, visited);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(!has_path) &#123;</span><br><span class="line">            path_len--;</span><br><span class="line">            visited[row * cols + col] = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> has_path;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">has_path</span><span class="params">(<span class="keyword">char</span>* matrix, <span class="keyword">int</span> rows, <span class="keyword">int</span> cols, <span class="keyword">char</span>* str)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(matrix == <span class="literal">nullptr</span> || rows &lt; <span class="number">1</span> || cols &lt; <span class="number">1</span> || str == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">bool</span>* visited = <span class="keyword">new</span> <span class="keyword">bool</span>[rows * cols];</span><br><span class="line">    <span class="built_in">memset</span>(visited, <span class="number">0</span>, rows * cols);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> path_len = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> row = <span class="number">0</span>; row &lt; rows; row++) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> col = <span class="number">0</span>; col &lt; cols; col++) &#123;</span><br><span class="line">            <span class="comment">// 从点(row, col)出发去寻找path</span></span><br><span class="line">            <span class="keyword">if</span>(has_path_core(matrix, rows, cols, row, col, str, path_len, visited)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">delete</span>[] visited;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> matrix[<span class="number">12</span>] = &#123; <span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;t&#x27;</span>,<span class="string">&#x27;g&#x27;</span>, <span class="string">&#x27;c&#x27;</span>,<span class="string">&#x27;f&#x27;</span>,<span class="string">&#x27;c&#x27;</span>,<span class="string">&#x27;s&#x27;</span>, <span class="string">&#x27;j&#x27;</span>,<span class="string">&#x27;d&#x27;</span>,<span class="string">&#x27;e&#x27;</span>,<span class="string">&#x27;h&#x27;</span> &#125;;</span><br><span class="line">    <span class="keyword">char</span> str1[<span class="number">10</span>] = <span class="string">&quot;bfce&quot;</span>;</span><br><span class="line">    <span class="keyword">if</span>(has_path(matrix, <span class="number">3</span>, <span class="number">4</span>, str1)) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; str1 &lt;&lt; <span class="string">&quot; in matrxi.&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; str1 &lt;&lt; <span class="string">&quot; not in matrxi.&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// bfce in matrxi.</span></span><br><span class="line">    <span class="keyword">char</span> str2[<span class="number">10</span>] = <span class="string">&quot;abfb&quot;</span>;</span><br><span class="line">    <span class="keyword">if</span>(has_path(matrix, <span class="number">3</span>, <span class="number">4</span>, str2)) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; str2 &lt;&lt; <span class="string">&quot; in matrxi.&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; str2 &lt;&lt; <span class="string">&quot; not in matrxi.&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// abfb not in matrxi.</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>面试题13：机器人的运动范围</p></blockquote><p>地上有一个<code>m</code>行<code>n</code>列的方格。一个机器人从<code>(0,0)</code>的格子开始移动，它每次可以向左、右、上、下移动一格，但不能进入<strong>行坐标和列坐标的数位之和</strong>大于<code>k</code>的格子。例如，当<code>k</code>为<code>18</code>时，机器人能进入方法<code>(35, 37)</code>，因为<code>3+5+3+7=18</code>，但不能进入方格<code>(35, 38)</code>，因为<code>3+5+3+8=19</code>，请问该机器人能够到达多少格子？</p><p>机器人从<code>(0,0)</code>开始移动，准备进入<code>(i,j)</code>时，要检查坐标的数位来判断是否能够进入，如果能进入，再判断是否能进入4个相邻的格子（不包含已走格子）。</p><p>完整代码实现：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">get_digit_sum</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(num &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        sum += num % <span class="number">10</span>;</span><br><span class="line">        num /= <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span> threshold, <span class="keyword">int</span> rows, <span class="keyword">int</span> cols, <span class="keyword">int</span> row, <span class="keyword">int</span> col, <span class="keyword">bool</span>* visited)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(row &gt;= <span class="number">0</span> &amp;&amp; row &lt; rows &amp;&amp; col &gt;= <span class="number">0</span> &amp;&amp; col &lt; cols</span><br><span class="line">        &amp;&amp; get_digit_sum(row) + get_digit_sum(col) &lt;= threshold</span><br><span class="line">        &amp;&amp; !visited[row * cols + col]) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">moving_count_core</span><span class="params">(<span class="keyword">int</span> threshold, <span class="keyword">int</span> rows, <span class="keyword">int</span> cols, <span class="keyword">int</span> row, <span class="keyword">int</span> col, <span class="keyword">bool</span>* visited)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 检查当前是否可达</span></span><br><span class="line">    <span class="keyword">if</span>(check(threshold, rows, cols, row, col, visited)) &#123;</span><br><span class="line">        visited[row * cols + col] = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">        count = <span class="number">1</span></span><br><span class="line">            + moving_count_core(threshold, rows, cols, row - <span class="number">1</span>, col, visited)</span><br><span class="line">            + moving_count_core(threshold, rows, cols, row, col - <span class="number">1</span>, visited)</span><br><span class="line">            + moving_count_core(threshold, rows, cols, row + <span class="number">1</span>, col, visited)</span><br><span class="line">            + moving_count_core(threshold, rows, cols, row, col + <span class="number">1</span>, visited);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回计数</span></span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">moving_count</span><span class="params">(<span class="keyword">int</span> threshold, <span class="keyword">int</span> rows, <span class="keyword">int</span> cols)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(threshold &lt; <span class="number">0</span> || rows &lt;= <span class="number">0</span> || cols &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">bool</span> *visited = <span class="keyword">new</span> <span class="keyword">bool</span>[rows * cols];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; rows * cols; i++) &#123;</span><br><span class="line">        visited[i] = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从(0, 0)出发，计数count</span></span><br><span class="line">    <span class="keyword">int</span> count = moving_count_core(threshold, rows, cols, <span class="number">0</span>, <span class="number">0</span>, visited);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">delete</span>[] visited;</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; moving_count(<span class="number">-1</span>, <span class="number">1</span>, <span class="number">1</span>) &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 0</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; moving_count(<span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>) &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 1</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; moving_count(<span class="number">12</span>, <span class="number">40</span>, <span class="number">40</span>) &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 770</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; moving_count(<span class="number">18</span>, <span class="number">40</span>, <span class="number">40</span>) &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 1484</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="4-动态规划与贪婪算法"><a href="#4-动态规划与贪婪算法" class="headerlink" title="4 动态规划与贪婪算法"></a>4 动态规划与贪婪算法</h2><p>如果面试题是求一个问题的最优解(通常是<strong>求最大值或者最小值</strong>)，而且该问题能够被分解成若干个子问题，子问题之间还有重叠的更小子问题，就可以考虑用动态规划来解决这个问题。</p><p>在应用动态规划之前，要先分析<strong>是否能把大问题分解成小问题</strong>，分解后的<strong>每个小问题也存在最优解</strong>，如果把<strong>小问题的最优解组合起来能够得到整个问题的最优解</strong>，则可以应用动态规划来解决这个问题。</p><p>在一些题目情况中，相同子问题在分解大问题的过程中重复出现，为了避免重复求解相同子问题，可以用从下往上的顺序先计算小问题的最优解并存储下来，再以此为基础求取大问题的最优解。在应用动态规划解决问题的时候，我们总是从解决最小问题开始，并把已经解决的子问题的最优解存储下来（大部分题目一般用一维或者二维数组里），并把子问题的最优解组合起来逐步解决大的问题。</p><p>在应用动态规划时，每一步都面临若干个选择，在求解时只能把所有的可能尝试一遍，然后比较得出最优的选择。</p><p>贪婪算法和动态规划不一样，贪婪算法每一步都可以根据规则做出一个最优的选择，基于这个找到最优解，但贪婪算法需要证明每一步的选择是可以保证最后获得最优结果，有时候不要想当然的应用贪婪算法。</p><blockquote><p>面试题14：剪绳子</p></blockquote><p>给你一根长度为<code>n</code>的绳子，请把绳子剪成<code>m</code>段(<code>m</code>、<code>n</code>都是整数，<code>n&gt;1</code>并且<code>m&gt;1</code>)，每段绳子的长度记为<code>k[0],k[1],...,k[m]</code>，请问 <code>k[0] x k[1] x ... x k[m]</code>可能的最大乘积是多少？例如，当绳子的长度是8时，我们把它剪成长度分为2、3、3的三段，此时得到的最大乘积是18。</p><p>Tips：这道题里面的一个比较含糊不清的地方是对<code>m</code>的界定，有些题目中可能<code>m</code>也是一个输入量，指计算在这个<code>m</code>段限定条件下<code>n</code>长度绳子的最大结果值（基本上就是另一类题了），而在本书的这道题目中并没有将<code>m</code>看作一个单独的输入量，只是说明后续的计算流程用，在面试遇到这样的情况可以向面试官询问对<code>m</code>的作用界定。</p><ul><li>思路1：暴力遍历，第一步有<code>n-1</code>种剪法，第二步有<code>n-2</code>种剪法，…，剪到底的话需要剪<code>n</code>步（每一步可以剪多个绳子），所以可以简单估算时间复杂度<code>O(n^2)</code>；</li><li>思路2：动态规划；</li><li>思路3：尝试用贪婪算法来解决。</li></ul><p>先讲一下<strong>动态规划的解法</strong>。</p><p>首先定义函数<code>f(n)</code>为把长度为<code>n</code>的绳子剪成若干段后各段长度乘积的最大值。在剪第一刀时，有<code>n-1</code>中可能的选择，因此有<code>f(n)=max(f(i) x f(n-i))</code>，其中<code>0&lt;i&lt;n</code>。</p><p>这是一个从上至下的递归公式，递归会产生很多重复计算，所以一个更好的办法是按照从下而上的顺序计算，也就是说我们先得到<code>f(2)</code>、<code>f(3)</code>，再得到<code>f(4)</code>、<code>f(5)</code>，直到得到<code>f(n)</code>。比较容易得知<code>f(1)=0</code>、<code>f(2)=1</code>以及<code>f(3)=2</code>，之后就按照迭代公式计算，得到<code>f(n)</code>。</p><p>Tips：书上这个题目的解析里面，个人觉得有一点疏漏，<code>f(k-1)</code>的定义应该是在<strong>剪后的乘积最大</strong>和<strong>不剪的自身长度</strong>中的最大值，即<code>f(k-1)=max(&#123;f(i) x f(k-i), k=1,2,...,n-1&#125;), </code>，因为只有在计算<code>f(n)</code>的时候是必须要剪断的(因为<code>m&gt;1</code>)，而剩下的子段不是一定要剪断，所以<code>f(k-1), k=1,2,...,n-1</code>的计算方式不能完全照搬<code>f(n)</code>的公式，例如<code>f(1)</code>作为一个长度为<code>1</code>的子段，因为并不是一定要剪，所以其本身可以返回的最大长度是<code>1</code>，而不是<code>0</code>，否则对于一个长度为<code>n</code>的绳子，在剪为<code>1</code>长度和<code>n-1</code>长度的两个子段时，使用<code>f(1)=0</code>，就会导致计算的结果错误，因为在这个情况下是有最后的值的，而并不是<code>0*f(n-1)=0</code>，所以按照修正后的定义，当是子段的时候，<code>f(1)=1</code>，<code>f(2)=2</code>，<code>f(3)=3</code>，<code>f(4)=4</code>，<code>f(5)=6</code>，…，可以发现虽然在<code>k&gt;3</code>这部分定义修正没有意义，但对于<code>k&lt;=3</code>部分是有意义的。</p><p>完整实现代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">max_product_after_cutting_dyprog</span><span class="params">(<span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(len &lt; <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(len == <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(len == <span class="number">3</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 循环替代递归，减少重复子任务，动态规划法</span></span><br><span class="line">    <span class="keyword">int</span>* products = <span class="keyword">new</span> <span class="keyword">int</span>[len + <span class="number">1</span>];</span><br><span class="line">    products[<span class="number">0</span>] = <span class="number">0</span>; <span class="comment">// f(0)=0</span></span><br><span class="line">    products[<span class="number">1</span>] = <span class="number">1</span>; <span class="comment">// 修正定义的f(1)=1</span></span><br><span class="line">    products[<span class="number">2</span>] = <span class="number">2</span>; <span class="comment">// 修正定义的f(2)=2</span></span><br><span class="line">    products[<span class="number">3</span>] = <span class="number">3</span>; <span class="comment">// 修正定义的f(3)=3</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> max = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">4</span>; i &lt;= len; i++) &#123;</span><br><span class="line">        max = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= i/<span class="number">2</span>; j++) &#123;</span><br><span class="line">            <span class="keyword">int</span> product = products[j] * products[i - j];</span><br><span class="line">            <span class="keyword">if</span>(max &lt; product) &#123;</span><br><span class="line">                max = product;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// products[i] = max; // 书上该行的位置，个人觉得没必要</span></span><br><span class="line">        &#125;</span><br><span class="line">        products[i] = max; <span class="comment">// 个人意见的修正，虽然不影响结果</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    max = products[len];</span><br><span class="line">    <span class="keyword">delete</span>[] products;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> max;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 结果是36</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; max_product_after_cutting_dyprog(<span class="number">10</span>) &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Tips：上面的代码除了调整过一行的位置以外，基本上没有修改，可以看到代码中对<code>f(1)</code>、<code>f(2)</code>和<code>f(3)</code>的定义都是符合我之前说的修正后的定义，而不是作者说明的什么<code>f(1)=0</code>、<code>f(2)=1</code>以及<code>f(3)=2</code>，所以也侧面证明之前我对定义的修正是正确的。</p><p>接着看一下<strong>贪婪算法的解法</strong>。</p><p>如果按照如下的策略来剪绳子，则得到的各段绳子的长度乘积最大，当<code>n&gt;=5</code>时，尽可能多地剪长度为<code>3</code>的绳子；当剩下的绳子长度为<code>4</code>时，把绳子剪成两段长度为<code>2</code>的绳子。</p><p>完整实现代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">max_product_after_cutting_greedy</span><span class="params">(<span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(len &lt; <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(len == <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(len == <span class="number">3</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 尽可能剪为长度为3的绳子段</span></span><br><span class="line">    <span class="keyword">int</span> times_of_3 = len / <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 剩余长度为4时，不再减去3</span></span><br><span class="line">    <span class="keyword">if</span>(len - times_of_3 * <span class="number">3</span> == <span class="number">1</span>) &#123;</span><br><span class="line">        times_of_3 -= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 代表有多少个2段</span></span><br><span class="line">    <span class="keyword">int</span> times_of_2 = (len - times_of_3 * <span class="number">3</span>) / <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">int</span>)(<span class="built_in">pow</span>(<span class="number">3</span>, times_of_3) * <span class="built_in">pow</span>(<span class="number">2</span>, times_of_2));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 结果是36，和动态规划法相同</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; max_product_after_cutting_greedy(<span class="number">10</span>) &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>证明一些这种思路的正确性：</p><ul><li>首先，当<code>n&gt;=5</code>时，我们可以证明<code>2(n-2)&gt;n</code>并且<code>3(n-3)&gt;n</code>（剪出一长度2子段或剪出一长度<code>3</code>子段），也就是说，当绳子剩下的长度大于等于<code>5</code>时，就把它剪成<code>3</code>或者<code>2</code>的子段，另外，<code>n&gt;=5</code>时，<code>3(n-3)&gt;=2(n-2)</code>，因此我们应该尽可能地多剪长度为<code>3</code>的绳子段（<strong>其实书上的这部分证明还并不够严谨，可以自行去严谨地证明</strong>）。</li><li>那么当长度为4时，可以简单推出最大的情况就是<code>2*2</code>或者不剪的<code>4</code>。</li></ul><hr><h2 id="5-位运算"><a href="#5-位运算" class="headerlink" title="5 位运算"></a>5 位运算</h2><p>位运算是把<strong>数字用二进制表示</strong>之后，对每一位上<code>0</code>或者<code>1</code>的运算，二进制及其位运算是现代计算机学科的基石，很多底层的技术都离不开位运算（都是基石了咋离得开嘛），因为与位运算相关的题目也经常出现在面试中。</p><p>在微软产品Excel中，用A表示第1列，B表示第2列，…，Z表示第26列，AA表示第27列，AB表示第28列，…，以此类推，写出一个函数，输入用字母表示的列号，输出第几列，这就是一个典型的进制转换题目。</p><p>位运算总共只有5种运算：与 <code>&amp;</code>、或 <code>||</code>、异或 <code>^</code>、左移<code>&lt;&lt;</code>和右移<code>&gt;&gt;</code>。</p><p>与、或和异或运算规律可以用下表进行总结：</p><div align="center"><p><img src="/images/s2o-c2-ag-t-2.1.jpg"></p></div><p>左移运算法<code>m &lt;&lt; n</code>表示把<code>m</code>左移<code>n</code>位，在左移<code>n</code>位时，最左边的<code>n</code>位将被丢弃，同时在最右边补上<code>n</code>个<code>0</code>，比如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">00001010</span> &lt;&lt; <span class="number">2</span> = <span class="number">00101000</span></span><br><span class="line"><span class="number">10001010</span> &lt;&lt; <span class="number">3</span> = <span class="number">01010000</span></span><br></pre></td></tr></table></figure><p>右移运算符<code>m &gt;&gt; n</code>表示把<code>m</code>右移<code>n</code>位，在右移<code>n</code>位时，最右边的<code>n</code>位将被丢弃，但是在右移时处理最左边位的情形要稍微复杂一点：</p><ul><li>如果数字是一个无符号数值，则用0填补最左边的n位；</li><li>如果数字是一个有符号数值，则用数字的符号位填补最左边的n位；<ul><li>数字是正数，右移补0；</li><li>数字是负数，左移补1。</li></ul></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">00001010</span> &gt;&gt; <span class="number">2</span> = <span class="number">00000010</span></span><br><span class="line"><span class="number">10001010</span> &gt;&gt; <span class="number">3</span> = <span class="number">11110001</span></span><br></pre></td></tr></table></figure><p>面试题15“二进制中1的个数”就是直接考查位运算的例子，而面试56“数组中数字出现的次数”、面试题65“不用加减乘除做加法”等都是根据位运算的特点来解决问题。</p><blockquote><p>面试题15：二进制中1的个数</p></blockquote><p>实现一个函数，输入一个整数，输出该数二进制表示中1的个数，例如，把9表示成二进制是1001，有2个1，所以输出2。</p><ul><li><strong>可能会引起死循环</strong>的解法：判断整数二进制最右边是否为<code>1</code>，然后进行右移一位再进行判断，直到整个整数变为<code>0</code>为止，至于如何判断一个整数的最右边是不是<code>1</code>，只要把整数和<code>1</code>做位与(<code>&amp;</code>)运算看结果是不是<code>1</code>就只知道了，这个方法的问题在于对于负数的处理会导致死循环，如果是负数，则右移会在首位补<code>1</code>，数字永远不会变为<code>0</code>，最后变为<code>0xffffffff</code>导致死循环；</li><li><strong>常规解法</strong>：为了避免死循环，可以<strong>不右移</strong>输入的数字<code>n</code>，而转为<strong>左移</strong>用来校验的数字<code>1</code>，依次校验数字<code>n</code>的每一位是否为<code>1</code>；</li></ul><p>常规解法的代码实现：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">number_of_1</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> flag = <span class="number">1</span>; <span class="comment">// unsigned int 才能采集到符号位</span></span><br><span class="line">    <span class="comment">// 循环次数取决于操作系统中int的存储位数，一般是4字节，32位</span></span><br><span class="line">    <span class="keyword">while</span>(flag) &#123; <span class="comment">// 1从左边溢出后，flag会变成0</span></span><br><span class="line">        <span class="keyword">if</span>(num &amp; flag) &#123; <span class="comment">// 非0 即 该位有1</span></span><br><span class="line">            count++;</span><br><span class="line">        &#125;</span><br><span class="line">        flag = flag &lt;&lt; <span class="number">1</span>; <span class="comment">// 赋值更新</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; number_of_1(<span class="number">255</span>) &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 8</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; number_of_1(<span class="number">-1</span>) &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 32</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>令人惊喜的解法</strong>：先分析一下把一个数减去1的情况，如果一个整数不等于0，则二进制中<strong>至少有一位是1</strong>，假设这个数最右边为1，则减1导致最后一位为0，其余位保持不变；假设最后一位是0，如果最右边的1位于第m位，则减一时，第m位由1变0，m位之后的所有0都变成1，m之前的所有位保持不变。根据这两种情况，可以发现把一个整数减1，都是把最右边的1变成0，如果右边有0，则所有0变成1，如果把一个<strong>整数</strong>和<strong>它减去1的结果</strong>做<strong>位与运算</strong>，相当于把最右边的1变成0。以1100为例，减1结果是1011，1100和1011做位运算，结果是1000，即相比于1100把最右边的1变成0。所以最后的思路是，把一个整数减1，再和原整数做与运算，就把最右边1变为0，那么一个二进制中有多少1就可以进行多少次这样的操作。</li></ul><p>完整代码实现：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">number_of_1_sp</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(num) &#123;</span><br><span class="line">        count++;</span><br><span class="line">        num = (num - <span class="number">1</span>) &amp; num;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; number_of_1_sp(<span class="number">255</span>) &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 8</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; number_of_1_sp(<span class="number">-1</span>) &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 32</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;考算法的面试题也备受面试官青睐（老折磨人了）。&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="剑指Offer" scheme="https://yumi-cn.github.io/categories/%E5%89%91%E6%8C%87Offer/"/>
    
    
    <category term="笔记" scheme="https://yumi-cn.github.io/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>《3D图形的数学》第3章笔记 变换</title>
    <link href="https://yumi-cn.github.io/2020/12/12/3dmath-c3/"/>
    <id>https://yumi-cn.github.io/2020/12/12/3dmath-c3/</id>
    <published>2020-12-12T12:52:19.000Z</published>
    <updated>2020-12-12T15:18:18.379Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>3D游戏开发过程中，通常需要以某种方式对向量进行变换。</p></blockquote><a id="more"></a><p>通常用到的变换包括<strong>平移、缩放和旋转</strong>。</p><h2 id="1-通用变换"><a href="#1-通用变换" class="headerlink" title="1 通用变换"></a>1 通用变换</h2><p>通常把 \(n \times n\) 可逆矩阵M看成是一个从坐标系到另一个坐标系的变换矩阵。</p><p>M的列给出了坐标轴从原坐标系到新坐标系的映射；\(M^{-1}\)的列给出了坐标轴从新坐标系到原坐标系的映射。</p><p>PS：书上的上面两句话，可以尝试从M乘以一个坐标轴单位向量的结果角度来考量，也就理解M的列是如何对一个向量或者坐标的各个轴的处理的。</p><p>多个变换可以串联起来，也可以将多个变换矩阵的乘积用一个矩阵来表示，例如 \(G(MP)=(GM)P\)，其中G/M是变换矩阵，P是坐标或向量，先做M变换再做G变换的结果可以用一个(GM)矩阵来存储，这样可以对顶点做无数次的变换，不需要额外的存储空间和计算开销。</p><h3 id="1-1-正交矩阵"><a href="#1-1-正交矩阵" class="headerlink" title="1.1 正交矩阵"></a>1.1 正交矩阵</h3><p><strong>正交矩阵的转置等于其逆矩阵</strong>。</p><p><strong>【定义3.1】</strong> 一个n阶可逆方阵M，当且仅当 \(M^{-1}=M^{T}\)时，M为正交矩阵。</p><p><strong>【定理3.2】</strong> 如果向量组 \(V_{1}, V_{2}, \cdots, V_{n}\)构成的一个正交向量集合，则以 \(V_{j}, (1 \leq j \leq n)\)作为第j列的n阶方阵是正交矩阵。</p><p>正交矩阵还有另外一个性质，用于变换向量时，<strong>正交矩阵不改变向量的长度和角度</strong>（一般指的是两个同样变换的向量夹角）。</p><p><strong>【定理3.3】</strong> 如果n阶方阵M正交，则M具有保证长度和角度不变的特性。</p><p>Tips：证明可以先从不改变两个向量的内积入手，然后再说明对单个向量不改变长度，再推出不改变角度。</p><p>由于这样的特性，使用正交矩阵变换可以保持坐标系的整体结构，所以正交矩阵只能用于表示旋转和反射（在某一方向上将点镜像的运算）的组合。</p><h3 id="1-2-手向性"><a href="#1-2-手向性" class="headerlink" title="1.2 手向性"></a>1.2 手向性</h3><p>在三维空间中，由3D向量 \(V_{1}, V_{2}, V_{3}\) 构成的坐标系的基具有手向性。对于<strong>右手基</strong>，有 \((V_{1} \times V_{2}) \cdot V_{3} &gt; 0\)，即在右手坐标系中， \(V_{1}, V_{2}\)的叉积(右手法则下)的方向与 \(V_{3}\)的方向形成一个锐角，如果是一个<strong>正交规范的右手基</strong>，则有 \(V_{1} \times V_{2} = V_{3}\)；若\((V_{1} \times V_{2}) \cdot V_{3} &lt; 0\)，那么是<strong>左手基</strong>。</p><p>进行<strong>奇数次的反射操作</strong>，会改变手向性，<strong>偶数次的反射</strong>相当与一次旋转。通过考查变换矩阵的行列式可以判定矩阵是否存在反射，若<strong>行列式为负</strong>，则存在反射，用其对任意基的向量进行变换操作后，基的手向性发生改变。如果行列式是正的，则不改变手向性。</p><p>另外，正交矩阵的行列式值只可能是1或-1，如果为1，则矩阵只有旋转；如果为-1，则表示旋转操作后再进行一次反射。</p><hr><h2 id="2-缩放变换"><a href="#2-缩放变换" class="headerlink" title="2 缩放变换"></a>2 缩放变换</h2><p>用a作为系数缩放向量P，只需要计算 \(P^{‘}=aP\)，在三维空间中，运算也可以表示为和矩阵的乘积：</p><div>$$P^{'}=\left[\begin{matrix}a & 0 & 0 \\0 & a & 0 \\0 & 0 & a\end{matrix}\right]\left[\begin{matrix}P_{x} \\P_{y} \\P_{z}\end{matrix}\right]\tag{3.8}$$</div><p>这种缩放成为<strong>统一缩放</strong>（各个轴相同缩放系数），如果希望在x,y,z轴以不同的值缩放向量，可以改变对角线上的元素（不再是相同的一个a），这种缩放称为<strong>非统一缩放</strong>。</p><div>$$P^{'}=\left[\begin{matrix}a & 0 & 0 \\0 & b & 0 \\0 & 0 & c\end{matrix}\right]\left[\begin{matrix}P_{x} \\P_{y} \\P_{z}\end{matrix}\right]\tag{3.9}$$</div><p>如果想在<strong>3个任意轴上进行非统一缩放</strong>，就要用到稍微复杂的缩放过程。假设以a,b,c为系数，在U,V,W轴方向上进行缩放，就需要先从坐标系(U,V,W)变换到坐标系(i,j,k) （这一步乘以[U V W]的逆矩阵变换到UVW为ijk坐标轴的空间中），然后在(i,j,k)坐标系中计算缩放（乘以缩放矩阵），最后再还原到(U,V,W)坐标系（乘以[U V W]矩阵变换到原本的ijk坐标轴空间中）。</p><div>$$P^{'}=\left[\begin{matrix}U_{x} & V_{x} & W_{x} \\U_{y} & V_{y} & W_{y} \\U_{z} & V_{z} & W_{z}\end{matrix}\right]\left[\begin{matrix}a & 0 & 0 \\0 & b & 0 \\0 & 0 & c\end{matrix}\right]\left[\begin{matrix}U_{x} & V_{x} & W_{x} \\U_{y} & V_{y} & W_{y} \\U_{z} & V_{z} & W_{z}\end{matrix}\right]^{-1}\left[\begin{matrix}P_{x} \\P_{y} \\P_{z}\end{matrix}\right]\tag{3.10}$$</div><p>Tips：这一段其实说的有点绕，但其实理解第一步就可以理解后面了，关于为什么是乘以逆矩阵，是因为(U,V,W)中的目标 \(P^{uvw}\) 有以下的表示方法：</p><div>$$P^{uvw}_{x}\left[\begin{matrix}U_{x} \\U_{y} \\U_{z}\end{matrix}\right]+P^{uvw}_{y}\left[\begin{matrix}W_{x} \\W_{y} \\W_{z}\end{matrix}\right]+P^{uvw}_{z}\left[\begin{matrix}V_{x} \\V_{y} \\V_{z}\end{matrix}\right]\\ =\left[\begin{matrix}U_{x} & V_{x} & W_{x} \\U_{y} & V_{y} & W_{y} \\U_{z} & V_{z} & W_{z}\end{matrix}\right]\left[\begin{matrix}P^{uvw}_{x} \\P^{uvw}_{y} \\P^{uvw}_{z}\end{matrix}\right]=\left[\begin{matrix}P_{x} \\P_{y} \\P_{z}\end{matrix}\right]$$</div><p>所以要求得(U,V,W)坐标系下的坐标 \(P^{uvw}\) 就要用原坐标乘以矩阵[U V W]的逆矩阵：</p><div>$$\left[\begin{matrix}P^{uvw}_{x} \\P^{uvw}_{y} \\P^{uvw}_{z}\end{matrix}\right]=\left[\begin{matrix}U_{x} & V_{x} & W_{x} \\U_{y} & V_{y} & W_{y} \\U_{z} & V_{z} & W_{z}\end{matrix}\right]^{-1}\left[\begin{matrix}P_{x} \\P_{y} \\P_{z}\end{matrix}\right]$$</div><p>这也就解释了第一步为什么乘以的是逆矩阵，后面也就相同的方法来解释了。</p><hr><h2 id="3-旋转变换"><a href="#3-旋转变换" class="headerlink" title="3 旋转变换"></a>3 旋转变换</h2><p>得到将坐标系绕x,y或z轴旋转 \(\theta\)角的矩阵并不难，当A轴指向我们时，所看到的旋转时逆时针方向。</p><p>首先看一下二维空间旋转的通用公式，如图3.2所示，通过交换x和y坐标，并将新的x坐标取负，得到(-y,x)，就能够将位于xy平面线上的二维向量P进行90°的逆时针旋转。设旋转向量为Q，则有 \( Q=&lt;-P_{y}, P_{x}&gt;\)。向量P和Q组成了xy平面的一个正交基，因此xy平面的任意向量都可以用这两个向量的线性组合来表示。</p><div align="center"><p><img src="/images/3d-math-c3-3-1.jpg"></p></div><p>如图3.3所示，任意向量P以 \(\theta\)角旋转后所形成的二维向量 \(P^{‘}\)，都可以用分别平行于P和Q的分量来表示。</p><div>$$P^{'} = Pcos\theta + Qsin\theta \tag{3.11}$$</div><p>带入Q的坐标计算，可以有：</p><div>$$\begin{aligned}P^{'}_{x} &= P_{x}cos\theta - P_{y}sin\theta \\P^{'}_{y} &= P_{y}cos\theta + P_{x}sin\theta\end{aligned}\tag{3.12}$$</div><p>用矩阵改写则有：</p><div>$$P^{'} =\left[\begin{matrix}cos\theta & -sin\theta \\sin\theta & cos\theta\end{matrix}\right]P\tag{3.13}$$</div><p>将单位矩阵的第3行和第3列加入到等式3.13中的2D旋转矩阵，就可以扩展成3D空间中绕z轴的三维旋转，在旋转过程中z坐标保持不变，绕z轴旋转 \(\theta\) 角度的旋转矩阵 \(R_{z}(\theta)\)可以表示为：</p><div>$$R_{z}(\theta) =\left[\begin{matrix}cos\theta & -sin\theta & 0 \\sin\theta & cos\theta & 0 \\0 & 0 & 1\end{matrix}\right]\tag{3.14}$$</div><p>同样，可以分别得到绕x轴和绕y轴旋转\theta角度的旋转矩阵 \(R_{x}(\theta)\) 和 \(R_{y}(\theta)\)：</p><div>$$\begin{aligned}R_{x}(\theta) =\left[\begin{matrix}1 & 0 & 0 \\0 & cos\theta & -sin\theta \\0 & sin\theta & cos\theta\end{matrix}\right]\\R_{y}(\theta) =\left[\begin{matrix}cos\theta & 0 & sin\theta \\0 & 1 & 0 \\-sin\theta & 0 & cos\theta\end{matrix}\right]\end{aligned}\tag{3.15}$$</div><h3 id="3-1-绕任意轴旋转"><a href="#3-1-绕任意轴旋转" class="headerlink" title="3.1 绕任意轴旋转"></a>3.1 绕任意轴旋转</h3><p>如果如果希望将向量P绕一个<strong>任意轴旋转</strong> \(\theta\) 角，选定的任意轴以单位向量A表示，那么可以先将向量P分解为平行于A和垂直于A的分量。<br>如图3.4所示，由于平行分量在旋转过程中保持不变，所以只需要计算垂直于A的分量的旋转。</p><div align="center"><p><img src="/images/3d-math-c3-3-2.jpg"></p></div><p>A是一个单位向量，P在A上地投影为（公式1.18）：</p><div>$$proj_{A}P = \frac{P \cdot A}{A^{2}} A = (P \cdot A)A\tag{3.16}$$</div><p>P垂直于A的分量为（公式1.19）：</p><div>$$perp_{A} P = P - proj_{A} P = P - (P \cdot A)A\tag{3.17}$$</div><p>将垂直于A的分量进行旋转，再加上平行分量，就得到最终的旋转结果。</p><p>垂直分量的旋转实在垂直于A轴的平面内进行的，平面中可以用垂直分量和垂直分量旋转90°所形成的向量组成一组正交基，就可以表达该平面内的任意向量，垂直分量旋转90°的向量可以用 \(A \times P\) 得到。</p><p>用下面的公式表示 \(perp_{A}P\)旋转 \(\theta\)角，即：</p><div>$$[P - (P \cdot A)A]cos\theta + (A \times P)sin\theta\tag{3.18}$$</div><p>再加上平行分量 \(proj_{A}P\)，就可以得到P绕A轴旋转的公式：</p><div>$$P^{'} = [P - (P \cdot A)A]cos\theta + (A \times P)sin\theta + (P \cdot A)A \\= Pcos\theta + (A \times P)sin\theta + (P \cdot A)A(1 - cos\theta)\tag{3.19}$$</div><p>将其中的 \(A \times P\)和 \((P \cdot A)A\)替换为等价矩阵形式，就可以更加具体的表示出旋转矩阵 \(R_{A}(\theta)\)，公式过于繁杂就不再赘述。</p><h2 id="4-齐次坐标"><a href="#4-齐次坐标" class="headerlink" title="4 齐次坐标"></a>4 齐次坐标</h2><p>还有一个重要的变换是平移操作，在空间中平移坐标系，只需要简单地添加偏移向量，并不会影响坐标轴的方向和尺度，但这种矩阵无法用 \(3 \times 3\)的矩阵来直接表示，需要加一个平移分量：</p><div>$$P^{'} = MP + T \tag{3.22}$$</div><p>M为可逆变换矩阵，T是平移向量。</p><h3 id="4-1-四维变换"><a href="#4-1-四维变换" class="headerlink" title="4.1 四维变换"></a>4.1 四维变换</h3><p>可以用一种统一的数学形式来简洁而优雅地表示这些变换（包含平移操作），为了做到这一点，需要将向量从三维扩展到四维，使用 \(4 \times 4\)矩阵来表示变换操作，给3D点P增加一个坐标，并将这个扩展的第四坐标(称为w坐标)的值设为1。</p><p>构造一个  \(4 \times 4\)变换矩阵F，F对应于变换矩阵M和3D平移变换T：</p><div>$$F =\left[\begin{matrix}M & T \\0 & 1\end{matrix}\right]=\left[\begin{matrix}M_{11} & M_{12} & M_{13} & T_{x} \\M_{21} & M_{22} & M_{23} & T_{y} \\M_{31} & M_{32} & M_{33} & T_{z} \\0 & 0 & 0 & 1\end{matrix}\right]\tag{3.24}$$</div><p>这个矩阵乘以向量 \(P=&lt;P_{x}, P_{y}, P_{z}, 1&gt;\) 就等效于公式3.22，同时结果w坐标保持为1.</p><h3 id="4-2-点向量和方向向量"><a href="#4-2-点向量和方向向量" class="headerlink" title="4.2 点向量和方向向量"></a>4.2 点向量和方向向量</h3><p>Tips：书上把点坐标叫做点向量还是蛮奇怪的，就理解成点坐标就行了。</p><p>由于方向向量不会受平移变换的影响，所以在其扩展四维时，其w坐标设置为0（其实也可以从两个点坐标相减的角度理解，两个w相减就是0了），这个时候F矩阵中只有左上的 \(3 \times 3\) 部分可以影响方向向量。</p><h3 id="4-3-坐标的几何解释"><a href="#4-3-坐标的几何解释" class="headerlink" title="4.3 坐标的几何解释"></a>4.3 坐标的几何解释</h3><p>假设有一个四维点 \(P=&lt;x, y, z, w&gt;\)，其中坐标不为0，这里定义P在三维空间的映像，<br>如果用 \(\widetilde{P}\)表示P在 \(w=1\)的三维空间中的投影，\(\widetilde{P}\)可以用下面的公式来表示：</p><div>$$\widetilde{P} = <\frac{x}{w}, \frac{y}{w}, \frac{z}{w}>\tag{3.28}$$</div><div align="center"><p><img src="/images/3dmath-c3-3.6.jpg" alt="图3.6 四维点P在三维空间的投影"></p></div><p>如图3.6所示（图中省略z轴为了方便表示），三维点 \(\widetilde{P}\) 对应于连接点P与原点的直线和 \(w=1\)的平面的交点，从这一点可以知道，对四维向量P作任意系数乘积，其结果都对应于三维空间中一个相同的点，在第4章5节中详细讨论这种投影在三维图形中的重要性。</p><h2 id="5-法向量的变换"><a href="#5-法向量的变换" class="headerlink" title="5 法向量的变换"></a>5 法向量的变换</h2><p>一个多边形模型的顶点除了需要表示空间位置外，还要包含一些附加信息，这些信息用来表示<strong>该顶点是如何融合到周围的曲面中的</strong>。一般情况下，顶点可能有<strong>切线向量</strong>和<strong>法线向量</strong>与之关联。<strong>当变换一个模型时，不但要变换顶点，同时还要对与顶点有关的向量进行变换</strong>。</p><p>可通过求两个顶点之间的差来计算<strong>切线向量</strong>，所以经过<strong>变换的切线向量</strong>可以表示为<strong>两个变换点的差</strong>。如果使用一个矩阵来变换顶点位置，也可以用这个矩阵来变换顶点的切向量。图3.7所示所示为用一个<strong>非正交矩阵M变换法向量N</strong>时发生的情况，变换后的法向量最终不垂直于变换后的表面。</p><div align="center"><p><img src="/images/3dmath-c3-3.7.jpg" alt="图3.7 用非正交矩阵M变换法向量"></p></div><p>因为切线方向和法线方向是垂直的，所以同一顶点的切向量T和法向量N必须满足等式 \(N \cdot T = 0\)，并且必须保证变换后的切向量 \(T^{‘}\)和法向量 \(N^{‘}\)仍然满足等式，设变换矩阵为M，有 \(T^{‘}=MT\)，设变换N所需的矩阵为G，有：</p><div>$$N^{'} \cdot T^{'} = (GN) \cdot (MT) = 0\tag{3.29}$$</div><p>经过简单的运算，可以得到：</p><div>$$(GN) \cdot (MT) = (GN)^{T}(MT) = N^{T}G^{T}MT\tag{3.30}$$</div><p>由于 \(N^{T}T=0\)，如果 \(G^{T}M=I\)，则等式 \(N^{T}G^{T}MT\) 肯定成立。<br>因此可以得出 \(G=(M^{-1})^{T}\)。可以看出，用变换点的矩阵的逆转置矩阵，就能正确地变换法向量，<strong>必须通过这种方式变换的向量称为协变向量</strong>，用矩阵M以通常方式变换的向量（点或切向量）称为<strong>逆变向量</strong>。</p><p><strong>如果矩阵M是正交的</strong>，那么 \(M^{-1}=M^{T}\)，因此 \((M^{-1})^{T}=M\)，所以当M是正交矩阵时，<strong>法向量变换过程的求逆转置运算就可以避免</strong>，这一点适用于本章前面提到的当M等于旋转矩阵的情况。</p><h2 id="6-四元数"><a href="#6-四元数" class="headerlink" title="6 四元数"></a>6 四元数</h2><p>四元数是三维图像编程人员用来表示旋转的另一种数学形式。</p><p>在许多情况下，用四元数代替旋转矩阵会有很多的好处，因为四元数需要的存储空间更少，四元数之间的<strong>连接运算</strong>需要的算术运算更少，在产生平滑的三维动画时，用四元数更容易进行修改。</p><h3 id="6-1-四元数数学"><a href="#6-1-四元数数学" class="headerlink" title="6.1 四元数数学"></a>6.1 四元数数学</h3><p>四元数集合，被数学家们称为哈密顿四元数环(ring of Hamiltonian quaternions)，用H表示，可以理解为四维向量空间，空间中的元素q具有以下形式：</p><div>$$q = [w, x, y, z] = w + xi + yj + zk\tag{3.31}$$</div><p>四元数经常写为 \(q=s+v\)的形式，其中s表示数量部分，对应于q中的w分量，v表示向量部分，对应于q中的x,y,z分量。</p><p>四元数集合是复数集合的自然扩展，四元数的乘法服从分配率，并且虚部i,j,k之间的乘法服从下面的规则：</p><div>$$\begin{aligned}i^{2} &= j^{2} = k^{2} = -1 \\ij &= -ji = k \\jk &= -kj = i \\ki &= -ik = j\end{aligned}\tag{3.32}$$</div><p>四元数式的乘法是不可交换的，因此运算要注意顺序。</p><p>两个四元数 \(q_{1}=w_{1}+x_{1}i+y_{1}j+z_{1}k\) 和 \(q_{2}=w_{2}+x_{2}i+y_{2}j+z_{2}k\) 的乘积 \(q_{1}q_{2}\) 为：</p><div>$$q_{1}q_{2} = \\(w_{1}w_{2} - x_{1}x_{2} - y_{1}y_{2} - z_{1}z_{2}) + \\(w_{1}x_{2} + x_{1}w_{2} + y_{1}z_{2} - z_{1}y_{1})i + \\(w_{1}y_{2} - x_{1}z_{2} + y_{1}w_{2} + z_{1}x_{2})j + \\(w_{1}z_{2} + x_{1}y_{2} - y_{1}x_{2} + z_{1}w_{2})k\tag{3.33}$$</div><p>如果写成数量-向量形式，则 \(q_{1}=s_{1}+v_{1}\) 和 \(q_{2}=s_{2}+v_{2}\) 的乘积可以写成如下形式：</p><div>$$q_{1}q_{2} = s_{1}s_{2} - v_{1} \cdot v_{2} + s_{1}v_{2} + s_{2}v_{1} + v_{1} \times v_{2}\tag{3.34}$$</div><p>和复数一样，四元数有共轭。</p><p><strong>【定义3.4】</strong> 四元数 \(q=s+v\)的共轭，记为 \(\bar{q}\)，定义为 \(\bar{q}=s-v\)。</p><p>通过简单的运算，就可以发现q与其共轭 \(\bar{q}\)的乘积等于q自身的点积，也就是等于q模的平方。</p><div>$$q \bar{q} = \bar{q} q = q \cdot q = ||q||^{2} = q^{2}\tag{3.35}$$</div><p><strong>【定理3.5】</strong> 非零的四元数的逆，记为 \(q^{-1}\)，则有：</p><div>$$q^{-1} = \frac{\bar{q}}{q^{2}}\tag{3.36}$$</div><h3 id="6-2-四元数的旋转"><a href="#6-2-四元数的旋转" class="headerlink" title="6.2 四元数的旋转"></a>6.2 四元数的旋转</h3><p>三维空间的旋转可以理解为 \(R^{3}\) 到自身 的映射函数 \(\varphi\)。由于\(\varphi\)代表旋转，所以它必须包含长度、角度、旋转方向等信息。如果有：</p><div>$$||\varphi(P)||=||P||\tag{3.39}$$</div><p>则<strong>长度保持不变</strong>。</p><p>如果对任意两个点 \(P_{1}\) 和 \(P_{2}\)有：</p><div>$$\varphi(P_{1}) \cdot \varphi(P_{2}) = P_{1} \cdot P_{2}\tag{3.40}$$</div><p>则从原点到两个点 \(P_{1}\) 和 \(P_{2}\)的连线所形成的<strong>夹角保持不变</strong>。</p><p>最后，如果：</p><div>$$\varphi(P_{1}) \times \varphi(P_{2}) = \varphi(P_{1} \times P_{2})\tag{3.41}$$</div><p>则<strong>手向性也保持</strong>不变。</p><p>如果满足条件 \(\varphi(s+v)=s+\varphi(v)\)，则函数 \(\varphi\)可以扩展为H到自身的映射，这样就允许将公式(3.40)重写为：</p><div>$$\varphi(P_{1}) \cdot \varphi(P_{2}) = \varphi(P_{1} \cdot P_{2})\tag{3.42}$$</div><p>如果将 \(P_{1}\)和 \(P_{2}\)看成是数量部分为0的四元数，根据 \(P_{1}P_{2} = -P_{1} \cdot P_{2} + P_{1} \times P_{2}\)，就可以将等式(3.41)和(3.42)合并成一个等式，在该等式中可以<strong>保持角度不变和手向性不变</strong>，公式如下：</p><div>$$\varphi(P_{1})\varphi(P_{2}) = \varphi(P_{1}P_{2})\tag{3.43}$$</div><p>满足这种等式的函数 \(\varphi\) 称为是<strong>同态</strong>的。</p><p>这一类函数可以用下面的公式给出：</p><div>$$\varphi_{q}(P) = qPq^{-1}\tag{3.44}$$</div><p>其中q是一个非0的四元数，且满足等式(3.39)（长度不变）和(3.43)（角度不变、手向性不变），因此可以表示旋转的集合。</p><p>现在需要找到一个关于四元数q的公式，q对应于 \(\theta\)角绕A轴的旋转。<br>简单的计算表明 \(\varphi_{aq}=\varphi_{q}\) 适用于任何非零数量a，为了简单起见，只涉及单位四元数。设 \(q=s+v\) 是<strong>单位四元数</strong>，则 \(q^{-1}=s-v\)，对于给定的点P，有：</p><div>$$\begin{aligned}qPq^{-1} &= (s + v)P(s - v) \\&= (-v \cdot P + sP + v \times P)(s - v) \\&= -sv \cdot P + s^{2}P + sv \times P + (v \cdot P)v - sPv - (v \times P)v \\&= s^{2}P + 2sv \times P + (v \cdot P)v - v \times P \times v\end{aligned}\tag{3.47}$$</div><p>对叉积 \(v \times P \times v\) 使用定理1.9(6)，这个等式就变为：</p><div>$$\begin{aligned}v \times (P \times v) = v \times P \times v = v^{2}P - (v \cdot P) v \\qP^{-1}q = (s^{2}-v^{2})P + 2sv \times P + 2(v \cdot P)v\end{aligned}\tag{3.48}$$</div><p>设 \(v=tA\)，其中A为单位向量，则上式可改写为：</p><div>$$qP^{-1}q = (s^{2}-v^{2})P + 2stA \times P + 2t^{2}(A \cdot P)A\tag{3.49}$$</div><p>比较等式(3.19)给出的绕任意轴旋转的公式，可以推出下面的等式：</p><div>$$P^{'} = [P - (P \cdot A)A]cos\theta + (A \times P)sin\theta + (P \cdot A)A \\= Pcos\theta + (A \times P)sin\theta + (P \cdot A)A(1 - cos\theta)\tag{3.19}$$</div><div>$$\begin{aligned}s^{2} - t^{2} &= cos\theta \\2st &= sin\theta \\2t^{2} &= 1 - cos\theta\end{aligned}\tag{3.50}$$</div><p>由第三个等式可以得出：</p><div>$$t = \sqrt{\frac{1-cos\theta}{2}} = sin\frac{\theta}{2}\tag{3.51}$$</div><p>结合式(3.50)中第一和第三个等式，可以得出 \(s^{2}+t^{2}=1\)，因此可以肯定 \(s=cos\frac{\theta}{2}\)。</p><p>现在可以用下面的等式给出对应于 \(\theta\)角绕A轴旋转的单位四元数q为：</p><div>$$q = cos\frac{\theta}{2} + Asin\frac{\theta}{2}\tag{3.52}$$</div><p>这里应注意：四元数q的<strong>任意数量乘积</strong>(特别是-q)表示的是相同的旋转，这是因为之前说的\(\varphi_{aq}=\varphi_{q}\) 适用于任何非零数量a。</p><div>$$(aq)P(aq)^{-1} = aqP \frac{q^{-1}}{a} = qP^{-1}q\tag{3.53}$$</div><p>两个四元数的乘积也可以表示一个旋转，乘积 \(q_{1}q_{2}\) 表示<strong>先以</strong> \(q_{2}\)，<strong>后以</strong> \(q_{1}\)进行旋转：</p><div>$$q_{1}(q_{2}Pq_{2}^{-1})q_{1}^{-1} = (q_{1}q_{2})P(q_{1}q_{2})^{-1}\tag{3.54}$$</div><p>可以将任意多的四元数结合起来，形成表示一系列旋转的一个四元数，<br>将两个四元数相乘需要做16次乘法和加法运算，而两个 \(3 \times 3\) 矩阵相乘需要27次这样的操作，因此当对物体进行多次旋转时，应用四元数可以获得较高的计算效率。</p><p>经常需要将一个四元数变成等价的 \(3 \times 3\)旋转矩阵的形式。<br>利用等式(1.25)和(1.20)，可以确定对应于四元数 \(q = s + tA\)的矩阵公式。</p><div>$$P \times Q =\left[\begin{matrix}0 & -P_{z} & P_{y} \\P_{z} & 0 & -P_{x} \\-P_{y} & P_{x} & 0\end{matrix}\right]\left[\begin{matrix}Q_{x} \\Q_{y} \\Q_{z}\end{matrix}\right]\tag{1.25}$$</div><div>$$proj_{Q} P = \frac{1}{Q^{2}}\left[\begin{matrix}Q_{x}^{2} & Q_{x}Q_{y} & Q_{x}Q_{z} \\Q_{x}Q_{y} & Q_{y}^{2} & Q_{y}Q_{z} \\Q_{x}Q_{z} & Q_{y}Q_{z} & Q_{z}^{2}\end{matrix}\right]\left[\begin{matrix}P_{x} \\P_{y} \\P_{z}\end{matrix}\right]\tag{1.20}$$</div><p>然后将等式(3.49)改写成矩阵形式(和3.1节中用的技巧类似），由此可得：</p><div>$$qPq_{-1} =\left[\begin{matrix}s^{2}-t^{2} & 0 & 0 \\0 & s^{2}-t^{2} & 0 \\0 & 0 & s^{2}-t^{2}\end{matrix}\right]P + \\2st\left[\begin{matrix}0 & -A_{z} & A_{y} \\A_{z} & 0 & -A_{x} \\-A_{y} & A_{x} & 0\end{matrix}\right]P + \\2t^{2}\left[\begin{matrix}A_{x}^{2} & A_{x}A_{y} & A_{x}A_{z} \\A_{x}A_{y} & A_{y}^{2} & A_{y}A_{z} \\A_{x}A_{z} & A_{y}A_{z} & A_{z}^{2}\end{matrix}\right]P\tag{3.55}$$</div><p>将四元数p写成四维向量 \(q=&lt;w,x,y,z&gt;\)，那么 \(w=s, x=tA_{x}, y=tA_{y}, z=tA_{z}\)，因此A是单位向量，所以 \(x^{2}+y^{2}+z^{2} = t^{2}A^{2} = t^{2}\)，以 \(w,x,y,z\)为分量，则公式(3.55)可以改写为：</p><div>$$qPq_{-1} =\left[\begin{matrix}w^{2}-x^{2}-y^{2}-z^{2} & 0 & 0 \\0 & w^{2}-x^{2}-y^{2}-z^{2} & 0 \\0 & 0 & w^{2}-x^{2}-y^{2}-z^{2}\end{matrix}\right]P + \\2w\left[\begin{matrix}0 & -z & y \\z & 0 & -x \\-y & x & 0\end{matrix}\right]P + \\2\left[\begin{matrix}x^{2} & xy & xz \\xy & y^{2} & yz \\xz & yz & z^{2}\end{matrix}\right]P\tag{3.56}$$</div><p>因为q是单位四元数，满足 \(w^{2} + x^{2} + y^{2} + z^{2} = 1\)，所以有：</p><div>$$w^{2} - x^{2} - y^{2} - z^{2} = 1 - 2x^{2} - 2y^{2} - 2z^{2}\tag{3.57}$$</div><p>根据该等式，并结合前面的三个矩阵，可以得到用来计算矩阵 \(R_{q}\) 的公式，这里的 \(R_{q}\) 表示对应于四元数q的旋转矩阵，公式为：</p><div>$$R_{q} = \left[\begin{matrix}1-2y^{2}-2z^{2} & 2xy-2wz & 2xz+2wy \\2xy+2wz & 1-2x^{2}-2z^{2} & 2yz-2wx \\2xz-2wy & 2yz+2wx & 1-2x^{2}-2y^{2}\end{matrix}\right]\tag{3.58}$$</div><h3 id="6-3-球形线性插值"><a href="#6-3-球形线性插值" class="headerlink" title="6.3 球形线性插值"></a>6.3 球形线性插值</h3><p>因为四元数是用向量表示的，所以很适合于插值运算。<br>在产生一个物理动画的过程中，在产生位于两个预先计算的关键帧之间的中间过渡定位时，插值非常有用。</p><p>最简单的插值类型是<strong>线性插值</strong>，对于两个四元数 \(q_{1}\)和 \(q_{2}\)，线性插值后所得的四元数 \(q_{t}\)为：</p><div>$$q(t) = (1-t)q_{1} + tq_{2} \tag{3.59}$$</div><p>当t在0和1之间变化时，函数 \(q(t)\)在连接 \(q_{1}\)和 \(q_{2}\)的线段上平滑变化。</p><div align="center"><p><img src="/images/3d-math-c3-6-3.jpg" alt="四元数的线性插值"></p></div><p>如上图所示，\(q(t)\)并不保持 \(q_{1}\)和 \(q_{2}\)的单位长度，但可以使用下面的函数在任意点位置对 \(q(t)\)进行重新规格化：</p><div>$$q(t)=\frac{(1-t)q_{1} + tq_{2}}{||(1-t)q_{1} + tq_{2}||}\tag{3.60}$$</div><p>尽管线性插值是很有效的，但由等式(3.60)得出的函数 \(q(t)\)并没有以恒定的速率描绘 \(q_{1}\)和 \(q_{2}\)间的过渡弧线，这是线性插值的弊端。如下图所示，\(q_{1},q_{2}\)之间的角度变化速率在端点时相对较慢，在中间的地方最快。</p><div align="center"><p><img src="/images/3d-math-c3-6-4.jpg" alt="arccos(q(t)·q1)的曲线"></p></div><p>我们希望找到一个函数 \(q(t)\)，用它对四元数 \(q_{1}\)和 \(q_{2}\)进行插值时，<br>会保持其单位长度不变并且以恒定的速率扫过位于 \(q_{1}\)和 \(q_{2}\)之间的夹角。</p><p>如果 \(q_{1}\)和 \(q_{2}\)的夹角为 \(\theta\)，那么这个函数将会产生一个四元数，该四元数在 \(q(t)\)和 \(q_{1}\)之间形成一个夹角 \(\theta t\)，这里t在0在1之间取值。</p><p>如下图所示，四元数 \(q(t)\)位于连接 \(q_{1}\)和 \(q_{2}\)的弧上，与 \(q_{1}\)构成夹角 \(\theta t\)，与 \(q_{2}\)构成夹角 \(\theta(1-t)\)，可以将 \(q(t)\)写成：</p><div>$$q(t) = a(t)q_{1} + b(t)q_{2} \tag{3.61}$$</div><div align="center"><p><img src="/images/3d-math-c3-6-5.jpg" alt="图(a)和图(b) 用相似三角形得到分量长度"></p></div><p>如图(a)所示，可以构造相似三角形来确定长度 \(a(t)\)，\(q_{1}\)到以原点和 \(q_{2}\)为端点的线段的垂直距离为 \(||q_{1}||sin\theta\)，而 \(q(t)\)到该线段的垂直距离为 \(||q(t)||sin(\theta(1-t))\)，根据相似三角形，可以由：</p><p>Tips：书上说的这个相似三角形在图(a)中并不明显，是以角 \(\theta\)为共同角，将边 \(||q(t)||sin(\theta(1-t))\) 平移到左边，构成的一个小三角形。</p><div>$$\frac{a(t)}{||q(t)||sin(\theta(1-t))} =\frac{||q_{1}||}{||q||sin\theta}$$</div><p>所以有：</p><div>$$\frac{a(t)}{||q_{1}||} =\frac{||q(t)||sin(\theta(1-t))}{||q||sin\theta}\tag{3.62}$$</div><p>由于 \(||q_{1}||=1\)，\(||q(t)||=1\)，可以将上式简化为：</p><div>$$a(t) = \frac{sin(\theta(1-t))}{sin\theta}\tag{3.63}$$</div><p>图(b)表示了求长度 \(b(t)\)的相同过程，有结果：</p><div>$$b(t) = \frac{sin(\theta t)}{sin\theta}\tag{3.64}$$</div><p>可以将球型线性插值函数 \(q(t)\)定义如下：</p><div>$$q(t)= \frac{sin(\theta(1-t))}{sin\theta}q_{1} + \frac{sin(\theta t)}{sin\theta}q_{2}\tag{3.65}$$</div><p>这里的角 \(\theta\) 为：</p><div>$$\theta = arccos(q_{1} \cdot q_{2})\tag{3.66}$$</div><p>\(sin\theta\)计算：</p><div>$$sin\theta = \sqrt{1-(q_{1} \cdot q_{2})^{2}}\tag{3.67}$$</div><p>因为四元数 \(q\) 和\(-q\)表示<strong>相同的旋转</strong>，所以选择四元数 \(q_{1}\)和 \(q_{2}\)的正负号时一般要满足 \(q_{1} \cdot q_{2} \geq 0\)，这样可以保证以最短路径的方式进行插值。</p>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;3D游戏开发过程中，通常需要以某种方式对向量进行变换。&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="3D游戏与图形学的数学" scheme="https://yumi-cn.github.io/categories/3D%E6%B8%B8%E6%88%8F%E4%B8%8E%E5%9B%BE%E5%BD%A2%E5%AD%A6%E7%9A%84%E6%95%B0%E5%AD%A6/"/>
    
    
    <category term="笔记" scheme="https://yumi-cn.github.io/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>《实时渲染 4th》第1章笔记 导论</title>
    <link href="https://yumi-cn.github.io/2020/12/09/rtr-c1/"/>
    <id>https://yumi-cn.github.io/2020/12/09/rtr-c1/</id>
    <published>2020-12-09T11:12:14.000Z</published>
    <updated>2020-12-09T14:01:50.228Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>实时渲染一般指计算机里的快速图像生成。</p></blockquote><a id="more"></a><p>PS：原书《Real Time Rendering 4th》全英文，有些词翻译如果不够好还请见谅。</p><p>Tips：屏幕刷新率(refresh rate)和显示频率(display rate)在现在是有区别的；</p><blockquote><p>We will not be able to cover every topic in depth, so our goal is to present key concepts and terminology, explain the most robust and practical algorithms in the field, and provide pointers to the best places to go for more information.</p></blockquote><p>虽然这本书没有覆盖到实时渲染涉及到的每一个主题，但本书的目的是呈现关键概念和术语、解释最鲁邦和实用的算法、提供深入了解这些内容的方向指引。</p><h2 id="1-内容概览"><a href="#1-内容概览" class="headerlink" title="1 内容概览"></a>1 内容概览</h2><ul><li><strong>第2章 图形渲染管线</strong>：<code>The Graphics Rendering Pipeline</code>，实时渲染的核心是通过什么样的步骤来将场景传达到显示上；</li><li><strong>第3章 图形处理单元</strong>：<code>The Graphics Processing Unit</code>，现代GPU中一般通过一组计算单元(fixed-function and programmable units)来实现渲染管线；</li><li><strong>第4章 变换</strong>：<code>Transforms</code>，变换是操作物体位置、方向、大小以及形状、控制摄像机位置和视角的基本工具；</li><li><strong>第5章 着色基础</strong>：<code>Shading Basics</code>，着色一般指的是通过材质(Material)和光源(Light)来表现物体，还有一些相关的主题，例如抗锯齿（反走样 antialiasing）、透明处理以及Gamma矫正；</li><li><strong>第6章 纹理</strong>：<code>Texturing</code>，纹理贴图用于在物体表面呈现纹理；</li><li><strong>第7章 光影</strong>：<code>Shadows</code>，光影让场景更有真实情感，会介绍一些快速计算光影的流行算法；</li><li><strong>第8章 光和颜色</strong>：<code>Light and Color</code>，讲解计算机是如何如何量化光和颜色，以及把这些量化转换成显示量纲的方法；</li><li><strong>第9章 基于物理的着色</strong>：<code>Physically Based Shading</code>，基于物理的着色会更加接近真实；</li><li><strong>第10章 局部光照</strong>：<code>Local Illumination</code>，主要介绍一些渲染复杂光源的算法，例如光源本身具有物理形状；</li><li><strong>第11章 全局光照</strong>：<code>Global Illumination</code>，模拟光源和场景之间的交互的算法，进一步增加场景的真实度；</li><li><strong>第12章 图像效果</strong>：<code>Image-Space Effects</code>，GPU擅长快速处理图像，首先介绍图像滤波(image filtering)和重投影(reprojection)技术，然后介绍一些流行的后期效果，例如镜头光晕(lens flares)、动态模糊(motion blur)以及景深(depth of field)；</li><li><strong>第13章 几何之外</strong>：<code>Beyond Polygons</code>，三角形不一定总是最快或最真实地描述物体的方式，还有其他方式，例如图片(images)、点云(point clouds)、体素(voxels)等；</li><li><strong>第14章 体渲染和透光渲染</strong>：<code>Volumetric and Translucency Rendering</code>，介绍体积材质(volumetric material)（例如云、烟、雾）的表达方式以及和光的交互，大到气象效果，小到头发渲染；</li><li><strong>第15章 非真实渲染</strong>：<code>Non-Photorealistic Rendering</code>，主要介绍一些风格渲染，例如卡通渲染(cartoon shading)、水彩效果(watercolor<br>effects)；</li><li><strong>第16章 几何技术</strong>：<code>Polygonal Techniques</code>，几何体数据的来源各种各样，如果需要又快又好地渲染，就需要进行一定处理，涉及到几何数据表达和压缩方法；</li><li><strong>第17章 曲线和曲面</strong>：<code>Curves and Curved Surfaces</code>，复杂的表面表达提供的优势在于更好的在质量和速度中进行取舍，表达越简洁，曲面就越光滑；</li><li><strong>第18章 管线优化</strong>：<code>Pipeline Optimization</code>，寻找渲染瓶颈来优化速度，涉及到一些多线程技术；</li><li><strong>第19章 加速算法</strong>：<code>Acceleration Algorithms</code>，比快更快，Various<br>forms of culling and level of detail rendering are covered；</li><li><strong>第20章 高效着色</strong>：<code>Efficient Shading</code>，越多的光源，渲染就越慢，在渲染前无法知道是否需要渲染会造成资源浪费，使用一些方法可以解决这些问题；</li><li><strong>第21章 虚拟现实和增强现实</strong>：<code>Virtual and Augmented Reality</code>，这些领域有很多特定的技术难题，也有一些相应方法来高效快速的生成图像；</li><li><strong>第22章 相交检测</strong>：<code>Intersection Test Methods</code>，深入介绍一些几何相交检测的高效算法；</li><li><strong>第23章 图形硬件</strong>：<code>Graphics Hardware</code>，图形硬件的一些细节，例如色彩深度(color depth)、帧缓冲(framebuffers)和基础架构类型；</li><li><strong>第24章 面向未来</strong>：<code>The Future</code>，Take a guess (we do)。</li></ul><p>还有一些没有收录在实体书中，在<a href="http://www.realtimerendering.com/">realtimerendering.com</a>上更新的章节：</p><ul><li><strong>碰撞检测</strong>：<code>Collision Detection</code>，The 3rd edition’s chapter on this subject has been fully updated, but could not fit in the bounds of the physical book；</li><li><strong>实时光线追踪</strong>：<code>Real-Time Ray Tracing</code>，API support for this area was announced in March 2018, too late for inclusion in the book, so we wrote an additional chapter about the subject as a whole.</li><li><strong>附录</strong>：<code>Appendices</code>，The two appendices, Some Linear Algebra and Trigonometry, also had to be cut from the physical book.</li></ul><h2 id="2-标记和定义"><a href="#2-标记和定义" class="headerlink" title="2 标记和定义"></a>2 标记和定义</h2><h3 id="2-1-数学标记"><a href="#2-1-数学标记" class="headerlink" title="2.1 数学标记"></a>2.1 数学标记</h3><div align="center"><p><img src="/images/rtr-c1-t1.1.jpg" alt="表1.1 本书中的大部分标记"></p></div><p><strong>向量或者点</strong>通常用粗体小写字母表示，并且其内部组成一般写为：</p><div>$$\textbf{v} =\left(\begin{matrix}v_{x} \\v_{y} \\v_{z}\end{matrix}\right)$$</div><p>在图形学领域中一般用列向量的表达方式，有时候为了书面方便也会写成行向量。</p><p>书中使用到<strong>矩阵</strong>大多是 \(2 \times 2\)，\(3 \times 3\) 和\(4 \times 4\)，以\(3 \times 3\)矩阵为例，说明矩阵的表示方式：</p><div>$$\textbf{M} =\left(\begin{matrix}m_{00} & m_{01} & m_{02} \\m_{10} & m_{11} & m_{12} \\m_{20} & m_{21} & m_{22}\end{matrix}\right)\tag{1.1}$$</div><p>有时候为了表达需求，会只关注行向量或者列向量的内容，矩阵也可以写为：</p><div>$$\textbf{M} =\left(\begin{matrix}\textbf{m}_{,0} & \textbf{m}_{,1} & \textbf{m}_{,2}\end{matrix}\right)=\left(\begin{matrix}\textbf{m}_{0,}^{T} \\\textbf{m}_{1,}^{T} \\\textbf{m}_{2,}^{T}\end{matrix}\right)\tag{1.2}$$</div><p>其中 \(\textbf{m}_{,j}\) 代表第j列向量，\(\textbf{m}_{i,}\) 代表第i行向量。</p><p><strong>平面</strong>的数学表示是 \(\pi:\textbf{n}\cdot\textbf{x} + d = 0\)，其中 \(\textbf{n}\)是平面的法向量，\(d\)是标量，平面将空间分为两个子空间，正子空间是 \(\textbf{n}\cdot\textbf{x} + d &gt; 0\)，相应的负子空间是 \(\textbf{n}\cdot\textbf{x} + d &lt; 0\)</p><p>三角形通常用三个点来表示，例如有不共线的三点 \(\textbf{v}_{0}, \textbf{v}_{1}, \textbf{v}_{2}\)，构成的三角形是 \(\bigtriangleup\textbf{v}_{0}\textbf{v}_{1}\textbf{v}_{2}\)。</p><div align="center"><p><img src="/images/rtr-c1-t1.2.jpg" alt="表1.2 数学运算的标记"></p></div><p>大部分都应该是比较常见的，需要稍微特殊说明的几个：</p><ol start="4"><li>主要用于二维向量，求二维向量的垂直向量，例如有 \(\textbf{v}=(v_{x}, v_{y})\)，\(\textbf{v}^{\perp}=(-v_{y}, v_{x})\)；</li><li>将x映射为非负空间数，当其为负值时会变为0；</li><li>和8较为类似，映射到0-1空间中，大于1变为1，小于0变为0；</li><li><code>binomial coefficients</code>，二项式系数，\(\left(\begin{matrix}n \\ k\end{matrix}\right) = \frac{n!}{k!(n-k)!}\)。</li></ol><p>一般把 \(x=0, y=0, z=0\) 叫做 坐标平面(coordinate<br>planes)或者轴对齐平面(axis-aligned planes)，将轴 \(\textbf{e}_{x}=(1, 0, 0), \textbf{e}_{y}=(0, 1, 0), \textbf{e}_{z}=(0, 0, 1)\)叫做主轴(main axes)或者主方向(main directions)，也分别叫做x轴(x-axis)，y轴(y-axis)和z轴(z-axis)。</p><div align="center"><p><img src="/images/rtr-c1-t1.3.jpg" alt="表1.3 其他需要说明的数学函数"></p></div><p>C语言数学函数 <code>atan2(y,x)</code> 有时候被经常提及到，它是<code>arctan(x)</code>的一个拓展，主要区别在于 \(-\frac{\pi}{2} &lt; arctan(x) &lt; \frac{\pi}{2}\)，\(0 \lep atan2(y, x) &lt; 2\pi\)，一种常用操作是计算<code>arctan(y/x)</code>，但是当<code>x=0</code>时会出现除0问题（尽管可能本意是表达一个无穷大数，但C语言会报除0错误），而这时候使用<code>atan2(y,x)</code>可以避免这样的问题。</p><p><code>log(n)</code>函数一般指的是自然数<code>e</code>为底数，而不是以<code>10</code>为底数。</p><p>默认情况下均使用右手坐标系。</p><p>颜色一般用一个三元向量表示，<code>(red, green, blue)</code>，各项的值都在[0,1]。</p><h3 id="2-2-几何定义"><a href="#2-2-几何定义" class="headerlink" title="2.2 几何定义"></a>2.2 几何定义</h3><p>最原石的一些基础渲染元(basic rendering primitives, also called drawing primitives)，最常用的是点、线和三角形。</p><p>在本书中，一组几何体(a collection of geometric entities)通常叫做一个<strong>模型</strong>(model)或者<strong>对象</strong>(object)；<strong>场景</strong>(scene)指的是环境中一组需要渲染模型，场景一般也包括材质描述、光线以及视角定义。</p><p>也有些不是使用点、线和三角形这种基础渲染元表达的模型，例如点云、函数表达（贝塞尔曲线）。</p><h3 id="2-3-Shading和Shader？"><a href="#2-3-Shading和Shader？" class="headerlink" title="2.3 Shading和Shader？"></a>2.3 Shading和Shader？</h3><p>本书中的 <strong>Shading</strong> 和 <strong>Shader</strong> 是两个截然不同但是又有关联的概念：</p><ul><li>前者指的是计算机生成的视觉表达(computer-generated visual appearance)，例如shading model、shading equation以及toon shading这些概念原理；</li><li>后者指的是渲染系统中的一个可编程单元，例如vertex shader、shading language。</li></ul><p>尽管他们用词形式上有一些混淆，但是要通过语境上下文来判断其指的是哪个概念（在书本以外可能会单独开一页来讲一些概念的区分）。</p>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;实时渲染一般指计算机里的快速图像生成。&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="Real Time Rendering 4th" scheme="https://yumi-cn.github.io/categories/Real-Time-Rendering-4th/"/>
    
    
    <category term="笔记" scheme="https://yumi-cn.github.io/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>《剑指Offer》第2章笔记 树</title>
    <link href="https://yumi-cn.github.io/2020/12/07/s2o-c2-tree/"/>
    <id>https://yumi-cn.github.io/2020/12/07/s2o-c2-tree/</id>
    <published>2020-12-07T12:18:45.000Z</published>
    <updated>2020-12-07T12:17:45.992Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>树的操作会涉及大量指针，因此与树相关的面试题都不太容易。</p></blockquote><a id="more"></a><p>树的逻辑很简单：</p><ul><li>除根节点之外，每个节点只有一个父节点，根节点没有父节点；</li><li>除叶节点之外，每个节点都有一个或多个子节点，叶节点没有子节点；</li><li>父节点和子节点之间用指针链接。</li></ul><p>面试中大部分都是<strong>二叉树</strong>，在二叉树中每个节点最多只能有两个子节点。</p><p>二叉树中最重要的操作是如何遍历数结构，按照某种顺序访问树的所有节点，通常有几种遍历方式：</p><ul><li>前序：父-&gt;左子-&gt;右子；</li><li>中序：左子-&gt;父-&gt;右子；</li><li>后序：左子-&gt;右子-&gt;父；</li><li>层序：从根节点层到叶节点层，按层输出，每一层按照从左到右输出。</li></ul><p>二叉树中又有一些特例：</p><ul><li><strong>二叉搜索树</strong>：在二叉搜索树中，左子节点总是小于或等于父节点，右子节点总是大于或等于父节点，可以平均在<code>O(logn)</code>的时间内根据值在二叉树中查找节点；</li><li><strong>堆</strong>：堆分为最大堆和最小堆，在最大堆中，根节点的值最大，最小堆中的根节点值最小（其他节点按子树递推），有很多需要快速找到最大值或最小值的问题都可以用堆来解决；</li><li><strong>红黑树</strong>：把树中的节点定义为红、黑两种颜色，并通过规则确保<strong>从根节点到叶节点的最长路径</strong>的长度<strong>不超过</strong>最短路径的两倍；在C++的STL中，<code>set</code>、<code>multiset</code>、<code>map</code>、<code>multimap</code>等都是基于红黑树实现的。</li></ul><blockquote><p>面试题7：重建二叉树</p></blockquote><p>输入二叉树的前序和中序遍历结果，重建该二叉树，假设输入的前序中序结构中都不含有重复的数字。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 二叉树节点定义</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">  <span class="keyword">int</span> value;</span><br><span class="line">  Node* left;</span><br><span class="line">  Node* right;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><div align="center"><p><img src="/images/s2o-c2-tree-cv-7.jpg"></p></div><p>在前序遍历中，第一个数字总是树的根节点；但在中序遍历中，根节点的值在序列中间，左子树的值位于根节点左边，右子树的值位于根节点右边；所以<strong>对于一个子树</strong>，我们在<strong>前序中寻找其根节点</strong>（第一个出现的值），然后在<strong>中序中根据根节点的位置</strong>，把<strong>剩下的点</strong>分为<strong>左子树和右子树</strong>。</p><p>完整代码实现：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;exception&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> value;</span><br><span class="line">    Node* left;</span><br><span class="line">    Node* right;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Node* construct_core</span><br><span class="line">(</span><br><span class="line">    <span class="keyword">int</span>* po_start, <span class="keyword">int</span>* po_end,</span><br><span class="line">    <span class="keyword">int</span>* io_start, <span class="keyword">int</span>* io_end</span><br><span class="line">) &#123;</span><br><span class="line">    <span class="keyword">int</span> root_value = po_start[<span class="number">0</span>];</span><br><span class="line">    Node* root = <span class="keyword">new</span> Node();</span><br><span class="line">    root-&gt;value = root_value;</span><br><span class="line">    root-&gt;left = root-&gt;right = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">if</span>(po_start == po_end) &#123;</span><br><span class="line">        <span class="keyword">if</span>(io_start == io_end &amp;&amp; *po_start == *io_start) &#123;</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// Windows Ver Error</span></span><br><span class="line">            <span class="built_in">std</span>::logic_error ex(<span class="string">&quot;Invalid input&quot;</span>);</span><br><span class="line">            <span class="keyword">throw</span> <span class="built_in">std</span>::exception(ex);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span>* io_root = io_start;</span><br><span class="line">    <span class="keyword">while</span>(io_root &lt;= io_end &amp;&amp; *io_root != root_value) &#123;</span><br><span class="line">        io_root++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(io_root == io_end &amp;&amp; *io_root != root_value) &#123;</span><br><span class="line">        <span class="comment">// Windows Ver Error</span></span><br><span class="line">        <span class="function"><span class="built_in">std</span>::logic_error <span class="title">ex</span><span class="params">(<span class="string">&quot;Invalid input&quot;</span>)</span></span>;</span><br><span class="line">        <span class="keyword">throw</span> <span class="built_in">std</span>::exception(ex);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> left_len = io_root - io_start;</span><br><span class="line">    <span class="keyword">int</span>* left_po_end = po_start + left_len;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(left_len &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        root-&gt;left = construct_core(po_start+<span class="number">1</span>, left_po_end, io_start, io_root<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(left_len &lt; po_end - po_start) &#123;</span><br><span class="line">        root-&gt;right = construct_core(left_po_end + <span class="number">1</span>, po_end, io_root+<span class="number">1</span>, io_end);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Node* <span class="title">construct</span><span class="params">(<span class="keyword">int</span>* preodr, <span class="keyword">int</span>* inodr, <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(preodr == <span class="literal">nullptr</span> || inodr == <span class="literal">nullptr</span> || len &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> construct_core(preodr, preodr + len - <span class="number">1</span>,</span><br><span class="line">            inodr, inodr + len - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">post_order_print</span><span class="params">(Node* node)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(node != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        post_order_print(node-&gt;left);</span><br><span class="line">        post_order_print(node-&gt;right);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, node-&gt;value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> preodr[<span class="number">8</span>] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">7</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">8</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> inodr[<span class="number">8</span>] = &#123;<span class="number">4</span>, <span class="number">7</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">3</span>, <span class="number">8</span>, <span class="number">6</span>&#125;;</span><br><span class="line">    Node* root = construct(preodr, inodr, <span class="number">8</span>);</span><br><span class="line">    post_order_print(root); <span class="comment">// 7 4 2 5 8 6 3 1</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>面试题8：二叉树的下一个节点</p></blockquote><p>给定二叉树和其中的一个节点，如何<strong>找出中序遍历序列的下一个节点</strong>？树节点除了有左右子节点指针，还有一个指向父节点的指针。</p><p>这类题目一般从各类情况具体分析入手：</p><ul><li>如果<strong>节点有右子树</strong>，则下一个节点就是<strong>右子树中的最左子节点</strong>；</li><li>如果<strong>节点没有右子树</strong>：<ul><li>如果该节点是<strong>父节点的左子节点</strong>，<strong>父节点</strong>就是下一个节点；</li><li>并且该节点是<strong>父节点的右子节点</strong>，按照中序遍历的逻辑，需要继续往上寻找，<strong>直到找到某一个节点A，这个节点A是A父节点的左子节点</strong>，如果不存在这样的节点，那就代表原节点为最后一个遍历节点了，没有下一个节点。</li></ul></li></ul><p>面试中遇到这种题，大概率只需要编写指定功能的函数部分，不需要编写完整的代码，所以需要对面试官询问具体的输入输出情况。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> value;</span><br><span class="line">    Node* left;</span><br><span class="line">    Node* right;</span><br><span class="line">    Node* parent;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">Node* <span class="title">find_next</span><span class="params">(Node* node)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(node == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Node* next = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">if</span>(node-&gt;right != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="comment">// 右子树的最左子节点（不一定需要是叶节点）</span></span><br><span class="line">        Node* temp = node-&gt;right;</span><br><span class="line">        <span class="keyword">while</span>(temp-&gt;left != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            temp = temp-&gt;left;</span><br><span class="line">        &#125;</span><br><span class="line">        next = temp;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (node-&gt;parent != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="comment">// 寻找满足条件的祖先节点</span></span><br><span class="line">        <span class="comment">// 某个节点是其父节点的左子节点</span></span><br><span class="line">        Node* temp = node;</span><br><span class="line">        Node* parent = node-&gt;parent;</span><br><span class="line">        <span class="keyword">while</span>(parent != <span class="literal">nullptr</span> &amp;&amp; temp == parent-&gt;right) &#123;</span><br><span class="line">            temp = parent;</span><br><span class="line">            parent = parent-&gt;parent;</span><br><span class="line">        &#125;</span><br><span class="line">        next = parent;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;树的操作会涉及大量指针，因此与树相关的面试题都不太容易。&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="剑指Offer" scheme="https://yumi-cn.github.io/categories/%E5%89%91%E6%8C%87Offer/"/>
    
    
    <category term="笔记" scheme="https://yumi-cn.github.io/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>《剑指Offer》第2章笔记 栈和队列</title>
    <link href="https://yumi-cn.github.io/2020/12/07/s2o-c2-stk-queue/"/>
    <id>https://yumi-cn.github.io/2020/12/07/s2o-c2-stk-queue/</id>
    <published>2020-12-07T12:17:27.000Z</published>
    <updated>2020-12-07T14:14:52.856Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>栈：先进后出，队列：先进先出。</p></blockquote><a id="more"></a><p>栈是一个非常常见的数据结构，在计算机领域被广泛应用，比如操作系统会给每个线程创建一个栈用来存储函数调用时各个函数的参数、返回地址以及临时变量等。栈的特点是<strong>后进先出</strong>。</p><p>在栈中通常需要<code>O(n)</code>时间才能找到栈最大或者最小的元素，如果想<code>O(1)</code>时间内找到则需要做特殊的设计。</p><p>队列是另一种很重要的数据结构，队列的特点是<strong>先进先出</strong>。</p><blockquote><p>面试题9：用两个栈实现队列</p></blockquote><p>使用栈实现队列的两个函数<code>appendTail</code>和<code>deleteHead</code>，分别完成在队列尾部插入节点和在队列头部删除节点的功能。</p><p>一个典型的队列定义：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="class"><span class="keyword">class</span> <span class="title">CQueue</span> &#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        CQueue(<span class="keyword">void</span>);</span><br><span class="line">        ~CQueue(<span class="keyword">void</span>);</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">appendTail</span><span class="params">(<span class="keyword">const</span> T&amp; node)</span></span>;</span><br><span class="line">        <span class="function">T <span class="title">deleteHead</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="built_in">stack</span>&lt;T&gt; stack1;</span><br><span class="line">        <span class="built_in">stack</span>&lt;T&gt; stack2;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>至于这道题的解法，基于一个简单的原理，将一组数先进行依次进栈、再依次出栈入栈到另一个栈里，再全部进行出栈，就完成了一个简单的队列先进先出。但如果只是单纯的依赖这样的过程，无法极大程度地利用栈的空间（例如用于出栈<code>deleteHead</code>的栈满时，用于进栈<code>appendTail</code>其实还可以继续利用起来）。</p><p>定义stack1为入队栈，stack2为出队栈。</p><ul><li>入队操作：<ul><li>当stack1不满时，直接入栈；</li><li>当stack1满时：<ul><li>如果stack2为空，将stack1中的元素依次出栈入栈stack2；</li><li>如果stack2中有元素，则无法入队；</li></ul></li></ul></li><li>出队操作：<ul><li>当stack2中有元素是，直接出栈；</li><li>当stack2为空时：<ul><li>如果stack1不为空，将stack1所有元素依次出栈入栈stack2，再出栈栈顶元素；</li><li>如果stack1为空，则队列为空，无法出队；</li></ul></li></ul></li></ul><p>完整实现代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;exception&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="class"><span class="keyword">class</span> <span class="title">CQueue</span> &#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="comment">// CQueue(void);</span></span><br><span class="line">        <span class="comment">// ~CQueue(void);</span></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">appendTail</span><span class="params">(<span class="keyword">const</span> T&amp; node)</span></span>;</span><br><span class="line">        <span class="function">T <span class="title">deleteHead</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">stack</span>&lt;T&gt; stack1;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">stack</span>&lt;T&gt; stack2;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="keyword">void</span> CQueue&lt;T&gt;::appendTail(<span class="keyword">const</span> T&amp; element) &#123;</span><br><span class="line">    <span class="comment">// 不限制栈容量时，直接入栈</span></span><br><span class="line">    stack1.push(element);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; T CQueue&lt;T&gt;::deleteHead() &#123;</span><br><span class="line">    <span class="keyword">if</span>(stack2.size() &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">while</span>(stack1.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            T&amp; data = stack1.top(); <span class="comment">// Why use T&amp;</span></span><br><span class="line">            stack1.pop();</span><br><span class="line">            stack2.push(data);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(stack2.size() == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// Throw Empty Error</span></span><br><span class="line">        <span class="function"><span class="built_in">std</span>::logic_error <span class="title">ex</span><span class="params">(<span class="string">&quot;queue is empty&quot;</span>)</span></span>;</span><br><span class="line">        <span class="keyword">throw</span> <span class="built_in">std</span>::exception(ex);</span><br><span class="line">    &#125;</span><br><span class="line">    T head = stack2.top();</span><br><span class="line">    stack2.pop();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    CQueue&lt;<span class="keyword">int</span>&gt; cqueue;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">        cqueue.appendTail(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; cqueue.deleteHead() &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">5</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">        cqueue.appendTail(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">7</span>; i++) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; cqueue.deleteHead() &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>相关题目：用两个队列实现一个栈。</p><p>简单分析一下思路，模仿入栈操作时，只能用使用入队操作，当需要出栈时，元素在队列尾部，只能将前面所有元素进行出队才能获取到，而出队剩下的元素就继续进入到第二个队列中。</p>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;栈：先进后出，队列：先进先出。&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="剑指Offer" scheme="https://yumi-cn.github.io/categories/%E5%89%91%E6%8C%87Offer/"/>
    
    
    <category term="笔记" scheme="https://yumi-cn.github.io/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>《3D图形的数学》第2章笔记 矩阵</title>
    <link href="https://yumi-cn.github.io/2020/12/01/3dmath-c2/"/>
    <id>https://yumi-cn.github.io/2020/12/01/3dmath-c2/</id>
    <published>2020-12-01T09:19:10.000Z</published>
    <updated>2020-12-01T12:51:52.499Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>在三维变换中，矩阵运算是最常用的表达方式。</p></blockquote><a id="more"></a><h2 id="1-矩阵的性质"><a href="#1-矩阵的性质" class="headerlink" title="1 矩阵的性质"></a>1 矩阵的性质</h2><p>一个 \(n \times m\) 的矩阵M就是一个有n行和m列的数组，如果 \(n = m\) 则矩阵M是方阵，把矩阵M第j列的第i行元素（或者第i行第j列）记作 \(M_{ij}\)。</p><p><strong>矩阵M的转置</strong>，记作 \(\textbf{M}^{T}\)，是一个\(m \times n\)矩阵，其中 \(M_{ij}^{T} = M_{ji}\)。</p><p><strong>矩阵的数乘</strong>，或者叫标量乘积，和向量类似，是乘以矩阵的每个元素。</p><p><strong>矩阵的加法</strong>，两个相同大小的矩阵，对应行列的元素相加。</p><p><strong>矩阵的乘法</strong>，如果矩阵F的行数和矩阵G的列数相等，则矩阵F和G可以相乘，假设F是\(n \times m\)的矩阵，G是\(m \times p\)的矩阵，FG就是\(n \times p\)的矩阵，FG在(i, j)位置上的元素可以表示为：</p><div>$$(\textbf{F}\textbf{G})_{ij} = \sum_{k=1}^{m}F_{ik}G_{kj} = \textbf{F}_{i*} \cdot \textbf{G}_{*j} \tag{2.5}$$</div><p>其实也可以看作是矩阵F的第i行和矩阵G的第j列元素之间的点积。</p><p><strong>单位阵</strong>是\(n \times n\)的矩阵，记作\(\textbf{I}_{n}\)，对于\(n \times n\)的矩阵M，有 \( \textbf{M} \textbf{I}_{n}\) = \(\textbf{I}_{n} \textbf{M}\) = \(\textbf{M}\)。</p><div>$$\textbf{I}_{n} =\left[\begin{matrix}1 & 0 & \cdots & 0 \\0 & 1 & \cdots & 0 \\\vdots & \vdots & \ddots & \vdots \\0 & 0 & \cdots & 1\end{matrix}\right]\tag{2.6}$$</div><p>因为单位阵尺寸由情况而定，所以通常把下标n去掉，记作 \(\textbf{I}\)。</p><p><strong>【定理2.1】</strong> 矩阵有以下性质：</p><ul><li>矩阵加法满足交换律和结合律；</li><li>系数加法乘矩阵、系数乘矩阵加法，均满足分配率；</li></ul><p><strong>【定理2.2】</strong> 还具有以下性质：</p><ul><li>系数乘矩阵先后不影响结果；</li><li>矩阵连乘，先后不影响结果；</li><li>\((\textbf{F}\textbf{G})^{T}=\textbf{G}^{T}\textbf{F}^{T}\)。</li></ul><h2 id="2-线性方程组"><a href="#2-线性方程组" class="headerlink" title="2 线性方程组"></a>2 线性方程组</h2><p>矩阵提供了一种有效并且简便的线性方程组表示法，例如线性方程组：</p><div>$$\begin{aligned}3x + 2y - 3z &= 5 \\4x - 3y + 6z &= 1 \\x - z &= 3\end{aligned}\tag{2.10}$$</div><p>可以用以下矩阵形式表示：</p><div>$$\left[\begin{matrix}3 & 2 & -3 \\4 & -3 & 6 \\1 & 0 & -1\end{matrix}\right]\left[\begin{matrix}x \\y \\z\end{matrix}\right]= \left[\begin{matrix}5 \\1 \\3\end{matrix}\right]\tag{2.11}$$</div><p>在未知向量&lt;x,y,z&gt;前面的矩阵叫做<strong>系数矩阵</strong>，在等号右边的列向量叫做<strong>常数向量</strong>。常数向量不为0的线性方程组叫做<strong>非齐次方程组</strong>，常数向量为0叫做<strong>齐次方程组</strong>。</p><p>把系数矩阵和常数向量并置一起（称为增广矩阵），执行基本行变换，就可以得到线性方程组的解。</p><p><strong>【定义2.3】</strong> 所谓<strong>基本行变换</strong>就是对一个矩阵执行以下三种变换之一：</p><ul><li>两行相互交换；</li><li>一行和不为0的系数相乘；</li><li>一行与一个不为0的系数乘后加到另一行上。</li></ul><p>方程(2.11)为例，写出增广矩阵：</p><div>$$\left[\begin{array}{ccc|c}3 & 2 & -3 & 5 \\4 & -3 & 6 & 1 \\1 & 0 & -1 & 3\end{array}\right]\tag{2.12}$$</div><p>对线性方程组的增广矩阵进行的行变换不会影响线性方程组的解，只是使线性方程组更加容易计算（可以同步理解成，一般求方程组解的步骤，使用方程组互相带入化简，使得方程组最后较容易解出值）。</p><p><strong>当用行变换求解一个线性方程组时，目标是把系数矩阵变换为它的最简形式</strong>。</p><p><strong>【定义2.4】</strong> 当且仅当一个矩阵满足一下条件，称为最简形式：</p><ul><li>每一个非0行，最左边的非0元素，即前导元素，必须为1；</li><li>每一个非0行均在全0行前面，或者说，全0行在矩阵底部；</li><li>如果一行前导元素在第j列，则其他行第j列的元素均为0；</li><li>对任意两个非0行 \(i_{2}\) 和 \(i_{1}\)，如果满足\(i_{2} &gt; i_{1}\)，并且相应的前导元素分别位于\(j_{2}\)和\(j_{1}\)列，则必然存在\(j_{2} &gt; j_{1}\)。</li></ul><p>或者简单来说，对于最简形式的矩阵，前导元素是向下向右的趋势的，并且，包含前导元素的列只有一个1，其他元素都为0。</p><p>一个最简形式矩阵例子：</p><div>$$\left[\begin{matrix}1 & 0 & -3 & 0 \\0 & 1 & 2 & 0 \\0 & 0 & 0 & 1 \\0 & 0 & 0 & 0 \end{matrix}\right]\tag{2.14}$$</div><p><strong>【算法2.6】</strong> 把一个线性方程组的 \(n \times (n+1)\) 增广矩阵M变换为最简形式，以下每一步的M在逐渐更新，而不是保持原始状态：</p><ol><li>下标i=1；</li><li>下标j=1，从第1列到第n列开始循环；</li><li>找到一个满足行号 \(k \geq i\)，并且 \(\textbf{M}_{kj} \neq 0\) 的行，如果不存在，跳到步骤8；</li><li>如果 \(k \neq i\)，交换第k行和第i行；</li><li>使矩阵M的元素(i, j)变为1：将第i行乘以 \(1 / \textbf{M}_{ij}\)；</li><li>把第j列中除第i行之外的元素变为0：对于每一行r，\(1 \leq r \leq n\) 且 \(r \neq i\)，将第i行乘 \(-\textbf{M}_{rj}\)加到第r行上；</li><li>i加1；</li><li>如果\(j \leq n\)，j加1，跳到步骤3。</li></ol><p>简单来说，就是每次找到第j列上的前导元素在哪一行，然后把这一行放在对应的位置上，让前导元素变1，再清除第j列上的其它元素，直到再找不到有前导元素的行，算法停止。</p><p>对于化简到最简形式后，如何判断方程组解的情况，有以下规律：</p><ul><li>如果系数矩阵的最简形式是一个单位阵，<strong>方程组有唯一解</strong>；</li><li>如果有一行或多行全为0，方程组要么无解，要么有无穷多解；</li><li>如果某一行系数矩阵为0而常数向量不为0，<strong>则方程组无解</strong>。</li></ul><h2 id="3-逆矩阵"><a href="#3-逆矩阵" class="headerlink" title="3 逆矩阵"></a>3 逆矩阵</h2><p>对一个\(n \times n\)的矩阵M而言，如果存在一个矩阵\(M^{-1}\)，使得 \(\textbf{M}\textbf{M}^{-1}=\textbf{M}^{-1}\textbf{M}=\textbf{I}\)，则称矩阵M是可逆的，矩阵\(M^{-1}\)叫做M的逆矩阵。</p><p>并不是每个矩阵都可逆，没有逆矩阵的矩阵叫做奇异矩阵，例如任何一行或一列为0的矩阵就是奇异矩阵。</p><p><strong>【定理2.9】</strong> 有一行或一列全为0的矩阵是不可逆的。</p><p><strong>【定理2.10】</strong> 一个矩阵M是可逆的，当且仅当\(M^{T}\)是可逆的。</p><p><strong>证明：</strong></p><p>假设M是可逆的，则\(M^{-1}\)存在，所以有：</p><div>$$\textbf{M}^{T}(\textbf{M}^{-1})^{T} =(\textbf{M}^{-1}\textbf{M})^{T} = \textbf{I}^{T} = \textbf{I}\tag{2.29}$$</div><p>并且</p><div>$$(\textbf{M}^{-1})^{T}\textbf{M}^{T} =(\textbf{M}\textbf{M}^{-1})^{T} = \textbf{I}^{T} = \textbf{I}\tag{2.30}$$</div><p>因此，\((\textbf{M}^{-1})^{T}\)是 \(\textbf{M}^{T}\)的逆矩阵。</p><p>类似，如果假设\(\textbf{M}^{T}\)是可逆的，则\((\textbf{M}{T})^{-1}\)存在：</p><div>$$\textbf{M}[(\textbf{M}^{T})^{-1}]^{T} =[(\textbf{M}^{T})^{-1}\textbf{M}^{T})]^{T} =\textbf{I}^{T} = \textbf{I}\tag{2.31}$$</div><p>而且</p><div>$$[(\textbf{M}^{T})^{-1}]^{T}\textbf{M} =[(\textbf{M}^{T}(\textbf{M}^{T})^{-1})]^{T} =\textbf{I}^{T} = \textbf{I}\tag{2.32}$$</div><p>因此，\([(\textbf{M}^{T})^{-1}]^{T}\)是M的逆矩阵。</p><p><strong>【定理2.11】</strong> 如果F和G都是\(n \times n\)的可逆矩阵，那么FG也是可逆的，并且 \((\textbf{F}\textbf{G})^{-1}\) = \(\textbf{G}^{-1}\textbf{F}^{-1}\)。</p><p>求矩阵最简形式的方法（算法2.6）也可以用来计算矩阵逆矩阵，为了计算\(n \times n\)矩阵的逆矩阵，在矩阵的右边并接一个单位阵，以形成一个\(n \times 2n\)的矩阵。</p><div>$$\left[\begin{array}{cccc|cccc}M_{11} & M_{12} & \cdots & M_{1n} & 1 & 0 & \cdots & 0 \\M_{21} & M_{22} & \cdots & M_{2n} & 0 & 1 & \cdots & 0 \\\vdots & \vdots & \ddots & \vdots & \vdots & \vdots & \ddots & \vdots \\M_{n1} & M_{n2} & \cdots & M_{nn} & 0 & 0 & \cdots & 1\end{array}\right]\tag{2.34}$$</div><p>对整个矩阵执行基本行变换操作，直到其左边的\(n \times n\)矩阵变为单位阵，这时右边的\(n \times n\)部分就是M的逆矩阵，如果左边无法化为单位矩阵，则该矩阵不可逆。</p><p><strong>【定理2.14】</strong> 假设(n \times n\)矩阵 \(M^{‘}\)是(n \times n\)矩阵M进行基本变换后得到的矩阵，则有 \(M^{‘}=EM\)，其中E是对单位阵进行相同的基本变换的最终矩阵。</p><p>把<strong>单位阵</strong>经过<strong>行变换</strong>后得到的矩阵称为<strong>初等矩阵</strong>，如果为了把矩阵M变为单位阵而必须经过k次基本行变换，那么：</p><div>$$\textbf{I} = \textbf{E}_{k}\textbf{E}_{k-1} \cdots \textbf{E}_{1}\textbf{M}\tag{2.47}$$</div><p>其中矩阵 \(\textbf{E}_{1}, \textbf{E}_{2}, \cdots, \textbf{E}_{k}\)是单位阵对应的k次行变换的初等矩阵，也就是说，矩阵 \(\textbf{E}_{k}\textbf{E}_{k-1} \cdots \textbf{E}_{1}\)之间的积即为M的逆矩阵。</p><p><strong>【定理2.15】</strong> 当且仅当矩阵M的<strong>行是一个线性无关向量集</strong>时，(n \times n\)矩阵M是可逆的。</p><h2 id="4-行列式"><a href="#4-行列式" class="headerlink" title="4 行列式"></a>4 行列式</h2><p>方阵的行列式得到的是一个标量，矩阵M的行列式记作\(det \textbf{M}\)，行列式使用垂直线取代矩阵两侧的括号。</p><div>$$det \textbf{M} =\left|\begin{matrix}M_{11} & M_{12} & M_{13} \\M_{21} & M_{22} & M_{23} \\M_{31} & M_{32} & M_{33}\end{matrix}\right|\tag{2.50}$$</div><p>\(n \times n\)矩阵M的行列式的值由一个递推公式给出，用符号 \(M^{|i, j|}\)表示原始矩阵M中第i行和第j列删除后行程的 \((n-1) \times (n-1)\)矩阵，用这种方法，行列式值可用以下方法计算：</p><div>$$det \textbf{M} = \sum_{i=1}^{n}(-1)^{i+k}M_{ik} det \textbf{M}^{|i,k|}\tag{2.53}$$</div><div>$$det \textbf{M} = \sum_{i=1}^{n}(-1)^{k+j}M_{kj} det \textbf{M}^{|k,j|}\tag{2.54}$$</div><p>其中k是满足条件 \(1 \leq k \leq n\)的任意常数。</p><p>二阶矩阵的行列式公式：</p><div>$$\left|\begin{matrix}a & b \\c & d\end{matrix}\right|= ad - bc\tag{2.55}$$</div><p>三阶矩阵的行列式公式：</p><div>$$\begin{aligned}\left|\begin{matrix}a_{11} & a_{12} & a_{13} \\a_{21} & a_{22} & a_{23} \\a_{31} & a_{32} & a_{33}\end{matrix}\right|= a_{11}det\textbf{M}^{|1,1|} - a_{12}det\textbf{M}^{|1,2|} + a_{13}det\textbf{M}^{|1,3|} \\= a_{11}(a_{22}a_{33}-a_{23}a_{32}) -a_{12}(a_{21}a_{33}-a_{23}a_{31}) +a_{13}(a_{21}a_{32}-a_{22}a_{31})\end{aligned}\tag{2.56}$$</div><p><strong>【定理2.16】</strong> 执行基本变换对一个矩阵的行列式有以下性质：</p><ul><li>两行交换，行列式取反；</li><li>矩阵一行乘比例系数a则行列式变为原来的a倍；</li><li>把一行的若干倍加到另一行对行列式没有影响。</li></ul><p><strong>【推论2.17】</strong> 如果矩阵有相同行，则行列式为0。</p><p><strong>【定理2.18】</strong> \(n \times n\)矩阵M当且仅当 \(det \textbf{M} \neq 0\)时是可逆的。</p><p><strong>【定理2.19】</strong> 对任意两个 \(n \times n\)的矩阵F和G，有 \(det\textbf{F}\textbf{G}=det\textbf{F}det\textbf{G}\)。</p><p>Tips：初等矩阵乘积的行列式等于行列式的乘积。</p><p><strong>【定理2.20】</strong> 假设F是 \(n \times n\)矩阵，如果另一 \(n \times n\)矩阵G的元素为：</p><div>$$G_{ij} = (-1)^{i + j} \frac{det \textbf{F}^{|j, i|}}{det \textbf{F}}\tag{2.62}$$</div><p>那么 \(\textbf{G}=\textbf{F}^{-1}\)。</p><p>通过定理2.20可以推出图形学中经常用的几个逆矩阵计算公式主要是2阶和3阶的。</p><p>2阶方阵逆矩阵公式：</p><div>$$\textbf{A}^{-1} = \frac{1}{det \textbf{A}}\left[\begin{matrix}A_{22} & -A_{12}\\-A_{21} & A_{11}\end{matrix}\right]\tag{2.63}$$</div><p>3阶方阵逆矩阵公式：</p><div>$$\textbf{B}^{-1} = \frac{1}{det \textbf{B}}\left[\begin{matrix}B_{22}B_{33}-B_{23}B_{32} & B_{13}B_{32}-B_{12}B_{33} & B_{12}B_{23}-B_{13}B_{22} \\B_{23}B_{31}-B_{21}B_{33} & B_{11}B_{33}-B_{13}B_{31} & B_{13}B_{21}-B_{11}B_{23} \\B_{21}B_{32}-B_{22}B_{31} & B_{12}B_{31}-B_{11}B_{32} & B_{11}B_{22}-B_{12}B_{21}\end{matrix}\right]$$</div><h2 id="5-特征值与特征向量"><a href="#5-特征值与特征向量" class="headerlink" title="5 特征值与特征向量"></a>5 特征值与特征向量</h2><p>对于<strong>可逆方阵</strong>，<strong>必然</strong>存在一个<strong>向量</strong>，当该<strong>向量与可逆方阵相乘</strong>时，<strong>向量只会发生大小变换而方向不变</strong>，即，对于n阶方阵M，存在着非0的n维向量 \(\textbf{V}_{1}, \textbf{V}_{2}, \cdots, \textbf{V}_{n}\)满足：</p><div>$$\textbf{M}\textbf{V}_{i} = \lambda_{i}\textbf{V}_{i}\tag{2.65}$$</div><p>其中比例系数 \(\lambda_{i}\) 称为矩阵M的特征值，而向量 \(\textbf{V}_{i}\)是对应特征值的特征向量。</p><p>对式（2.65）进行变换可得到矩阵的特征值：</p><div>$$(\textbf{M}-\lambda_{i}\textbf{I})\textbf{V}_{i} = \textbf{0}\tag{2.66}$$</div><p>对于非0向量 \(\textbf{V}_{i}\)，如果上式成立，矩阵 \(\textbf{M}-\lambda_{i}\textbf{I}\)一定是奇异矩阵（不可逆），否则就可以对其求逆，得到:</p><div>$$\textbf{V}_{i} = (\textbf{M}-\lambda_{i}\textbf{I})^{-1}\textbf{0} = \textbf{0}\tag{2.67}$$</div><p>这个非0向量矛盾，所以矩阵 \(\textbf{M}-\lambda_{i}\textbf{I}\)的行列式为0，因此可以通过：</p><div>$$det(\textbf{M}-\lambda\textbf{I}) = 0\tag{2.68}$$</div><p>计算出矩阵的特征值解，由2.68式得出的关于 \(\lambda\)的n阶多项式叫做矩阵M的特征多项式，多项式的根就是矩阵M的特征值。</p><p>一旦矩阵的特征值求得，就可以代入式(2.66)，计算出相应的特征向量，因为矩阵 \(\textbf{M}-\lambda_{i}\textbf{I}\) 是奇异的，所以简化形式至少有一行全为0，所以有无穷多解（比如特征向量的系数倍数向量也是特征向量），因此特征向量可以表示成任意常数的形式，如果有必要也可以取特征向量的长度为1。</p><p>通常，<strong>如果矩阵特征值是复数，则相应的特征向量也含有复数元素</strong>；确保有实数特征值以及相应的实数特征向量的矩阵是<strong>对称矩阵</strong>。</p><p><strong>【定义2.23】</strong> 一个n阶方阵，当且仅当 对任意i和j均有 \(M_{ij}=M_{ji}\) 时是对称矩阵，也就是说如果矩阵元素关于主对角线对称，则该矩阵就成为<strong>对称矩阵</strong>。</p><p><strong>【定理2.24】</strong> 矩阵<strong>元素为实数</strong>的对称矩阵的特征值也是实数。</p><p><strong>【定理2.25】</strong> 对应于<strong>对称矩阵</strong>M的<strong>不同特征值的特征向量</strong>是<strong>正交</strong>的。</p><h2 id="6-对角化"><a href="#6-对角化" class="headerlink" title="6 对角化"></a>6 对角化</h2><p>对角矩阵（对称矩阵的特例），只在主对角线上有非0元素的矩阵。</p><p>给定方阵M，如果能找到一个矩阵A使得 \(\textbf{A}^{-1}\textbf{M}\textbf{A}\) 是对角矩阵，那么就说矩阵A将矩阵M对角化了。</p><p><strong>【定理2.26】</strong> 假设M是特征值为 \(\lambda_{1}, \lambda_{2}, \cdots, \lambda_{n}\)的n阶方阵，且与特征值对应的特征向量 \(\textbf{V}_{1}, \textbf{V}_{2}, \cdots, \textbf{V}_{n}\) 是一个<strong>线性无关集</strong>，则矩阵A：</p><div>$$A = [ \textbf{V}_{1} \textbf{V}_{2} \cdots \textbf{V}_{n} ]\tag{2.82}$$</div><p>可以将矩阵M对角化，而且 \(\textbf{A}^{-1}\textbf{M}\textbf{A}\) 的主对角元素是矩阵M的特征值，即：</p><div>$$\textbf{A}^{-1}\textbf{M}\textbf{A} =\left[\begin{matrix}\lambda_{1} & 0 & \cdots & 0 \\0 & \lambda_{2} & \cdots & 0\\\vdots & \vdots & \ddots & \vdots\\0 & 0 & \cdots & \lambda_{n}\end{matrix}\right]\tag{2.83}$$</div><p>相反，如果存在一个可逆矩阵A使得 \(\textbf{A}^{-1}\textbf{M}\textbf{A}\) 是一个对角阵，则矩阵A的列必然是矩阵M的特征向量，而 \(\textbf{A}^{-1}\textbf{M}\textbf{A}\) 的对角线元素则是矩阵M的特征值。</p>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;在三维变换中，矩阵运算是最常用的表达方式。&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="3D游戏与图形学的数学" scheme="https://yumi-cn.github.io/categories/3D%E6%B8%B8%E6%88%8F%E4%B8%8E%E5%9B%BE%E5%BD%A2%E5%AD%A6%E7%9A%84%E6%95%B0%E5%AD%A6/"/>
    
    
    <category term="笔记" scheme="https://yumi-cn.github.io/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>《剑指Offer》第2章笔记 链表</title>
    <link href="https://yumi-cn.github.io/2020/11/30/s2o-c2-linked/"/>
    <id>https://yumi-cn.github.io/2020/11/30/s2o-c2-linked/</id>
    <published>2020-11-30T11:09:59.000Z</published>
    <updated>2020-11-30T12:17:30.456Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>链表应该是面试时被提及最频繁的数据结构。</p></blockquote><a id="more"></a><p>链表的结构很简单，它由指针把若干个节点连接成链状结构，链表的创建、插入节点、删除节点等操作都只需要20行左右的代码就能实现，代码量比较适合面试（哈希表、有向图等复杂的一个操作可能就需要很多代码）。</p><p>链表是一种动态数据结构，创建链表时，无须知道链表长度，插入节点时，只需要为新节点分配内存，然后调整指针的指向来确保新节点被链接到链表中；内存分配不是在创建链表时一次性完成的，而是每添加一个节点分配一次内存。</p><p>典型的单向链表节点定义：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> value;</span><br><span class="line">    Node* next;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>往链表末尾添加一个节点：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add_to_tail</span><span class="params">(Node** phead, <span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 头结点是一个指针的指针</span></span><br><span class="line">    Node* pnew = <span class="keyword">new</span> Node();</span><br><span class="line">    pnew-&gt;value = value;</span><br><span class="line">    pnew-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">if</span>(*phead == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="comment">// 创建头节点</span></span><br><span class="line">        *phead = pnew;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 添加节点到尾部</span></span><br><span class="line">        Node* pnode = *phead;</span><br><span class="line">        <span class="keyword">while</span>(pnode-&gt;next != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            pnode = pnode-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        pnode-&gt;next = pnew;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>想要在链表中找到第i个节点，那我们只能从头结点开始遍历链表，时间效率为<code>O(n)</code>，而在数组中只需要<code>O(1)</code>的时间。</p><p>找到第一个含有某值节点并删除该节点的代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">remove_node</span><span class="params">(Node** phead, <span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(phead==<span class="literal">nullptr</span> || *phead==<span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Node* p_delete = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">if</span>((*phead)-&gt;value == value) &#123;</span><br><span class="line">        <span class="comment">// 头结点删除需要单独考虑操作</span></span><br><span class="line">        p_delete = *phead;</span><br><span class="line">        *phead = (*phead)-&gt;next;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        Node* pnode = *phead;</span><br><span class="line">        <span class="comment">// 寻找删除节点的前一个节点</span></span><br><span class="line">        <span class="keyword">while</span>(pnode-&gt;next != <span class="literal">nullptr</span></span><br><span class="line">            &amp;&amp; pnode-&gt;next-&gt;value != value) &#123;</span><br><span class="line">                pnode = pnode-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(pnode-&gt;next != <span class="literal">nullptr</span> &amp;&amp; pnode-&gt;next-&gt;value == value) &#123;</span><br><span class="line">            <span class="comment">// 调整删除节点前一个节点的链接</span></span><br><span class="line">            p_delete = pnode-&gt;next;</span><br><span class="line">            pnode-&gt;next = pnode-&gt;next-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(p_delete != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="keyword">delete</span> p_delete;</span><br><span class="line">        p_delete = <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一些特殊形式的链表也会被经常考到：</p><ul><li>环形链表：链表末尾节点指向头结点（面试题62）；</li><li>双向链表：节点还有一个指向前一个节点的指针（面试题36）；</li><li>复杂链表：节点还有拥有指向任意节点的指针（面试题35）。</li></ul><blockquote><p>面试题6：从尾到头打印链表</p></blockquote><p>输入一个链表的头节点，从尾到头反过来打印每个节点的值。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> value;</span><br><span class="line">    Node* next;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>Tips：如果打算修改输入数据，最好先问面试官是不是允许修改，这里假设面试官不能改变链表的结构。</p><p>这道题目需要先访问的节点后输出，可以想到使用栈这种数据结构，每次访问到节点，就压到栈中，输出的时候只需要循环出栈即可。</p><p>完整代码实现：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> value;</span><br><span class="line">    Node* next;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add_to_tail</span><span class="params">(Node** phead, <span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 头结点是一个指针的指针</span></span><br><span class="line">    Node* pnew = <span class="keyword">new</span> Node();</span><br><span class="line">    pnew-&gt;value = value;</span><br><span class="line">    pnew-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">if</span>(*phead == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="comment">// 创建头节点</span></span><br><span class="line">        *phead = pnew;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 添加节点到尾部</span></span><br><span class="line">        Node* pnode = *phead;</span><br><span class="line">        <span class="keyword">while</span>(pnode-&gt;next != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            pnode = pnode-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        pnode-&gt;next = pnew;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">reverse_print</span><span class="params">(Node** phead)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(phead==<span class="literal">nullptr</span> || *phead==<span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">stack</span>&lt;Node*&gt; pstack;</span><br><span class="line">    Node* pnode = *phead;</span><br><span class="line">    <span class="keyword">while</span>(pnode != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        pstack.push(pnode);</span><br><span class="line">        pnode = pnode-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(!pstack.empty()) &#123;</span><br><span class="line">        pnode = pstack.top();</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\t&quot;</span>, pnode-&gt;value);</span><br><span class="line">        pstack.pop();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> values[] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line">    Node** phead = <span class="keyword">new</span> Node*;</span><br><span class="line">    *phead = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">        add_to_tail(phead, values[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    reverse_print(phead);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>具体的实现中需要注意到的一个点是头节点的初始化，因为是指针的指针，所以需要先申请一个<strong>Node指针类型的指针</strong>，<code>new Node*</code>，然后再将头结点指向的节点设置为<code>nullptr</code>，这样才不会在访问时出错。</p><p>如果可以使用栈结构来实现，也可以考虑使用递归的方式实现，通过递归访问，只有在返回函数的时候再输出节点，就可以实现逆序输出。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 调用的时候要使用 *phead</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">reverse_print_rec</span><span class="params">(Node* node)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(node == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    reverse_print_rec(node-&gt;next);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\t&quot;</span>, node-&gt;value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>递归的代码相比于使用栈会简洁很多，但是使用递归是有代价的，函数递归使用的栈空间通常会有限制（比自己建立栈的空间要小），所以如果链表过于长可能会导致函数调用栈溢出。</p>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;链表应该是面试时被提及最频繁的数据结构。&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="剑指Offer" scheme="https://yumi-cn.github.io/categories/%E5%89%91%E6%8C%87Offer/"/>
    
    
    <category term="笔记" scheme="https://yumi-cn.github.io/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>《剑指Offer》第2章笔记 字符串</title>
    <link href="https://yumi-cn.github.io/2020/11/28/s2o-c2-string/"/>
    <id>https://yumi-cn.github.io/2020/11/28/s2o-c2-string/</id>
    <published>2020-11-28T14:06:05.000Z</published>
    <updated>2020-11-30T11:09:14.812Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>字符串的使用频率非常高，为了优化，很多语言都对字符串做了特殊的规定。</p></blockquote><a id="more"></a><p>C/C++中每个字符串都以字符 <code>\0</code> 做为结尾，这样便于运行时判断字符数组的尾部，由于这个特点，字符串数组的长度比真实字符串长度要多1才可以，这样容易导致一些错误：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> str[<span class="number">10</span>];</span><br><span class="line"><span class="built_in">strcpy</span>(str, <span class="string">&quot;0123456789&quot;</span>); <span class="comment">// Error</span></span><br></pre></td></tr></table></figure><p>为了节省内存，C/C++把常量字符串放到一个单独的内存区域，当几个指针赋值给相同的常量字符串时，实际上会指向相同的内存地址。但用常量内存来初始化字符数组时，情况又有所不同了，看下面的例子：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> str1[] = <span class="string">&quot;hello world&quot;</span>;</span><br><span class="line">    <span class="keyword">char</span> str2[] = <span class="string">&quot;hello world&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span>* str3 = <span class="string">&quot;hello world&quot;</span>;</span><br><span class="line">    <span class="keyword">char</span>* str4 = <span class="string">&quot;hello world&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;str1 =%p\n&quot;</span>, str1); <span class="comment">// 0061fe04</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;str2 =%p\n&quot;</span>, str2); <span class="comment">// 0061fdf8</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;str3 =%p\n&quot;</span>, str3); <span class="comment">// 00409001</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;str4 =%p\n&quot;</span>, str4); <span class="comment">// 00409001</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>str1</code>和<code>str2</code>是两个字符数组，在初始化赋值时，运行时为为他们分配两个长度为12字节的内存空间，并把字符串赋值到数组中去（而不是直接拷贝字符串常量地址），所以他们的初始地址是不同的。</p><p><code>str3</code>和<code>str4</code>是两个指针，不需要再分配内存来存储内容，只需要传递地址，所以他们就拷贝了同一个地址。</p><blockquote><p>面试题5：替换空格</p></blockquote><p>实现一个函数，把字符串的每个空格替换成<code>%20</code>，例如输入<code>We are happy.</code>，则输出<code>We%20are%20happy.</code>。</p><p>题目来自于网络编程中的URL特殊字符编码，有时候服务器不一定支持一些特殊字符URL，所以需要先将特殊转换成ASCII码的两位十六进制表示，比如空格的ASCII码是<code>32</code>，即十六进制的<code>0x20</code>，空格被替换成<code>%20</code>，比如<code>#</code>的ASCII码为35，十六进制<code>0x23</code>，在URL中被替换成<code>%23</code>。</p><p>一般有两种解决方向：</p><ul><li>在原字符数组上进行处理；</li><li>申请新字符数组，将新内容写进去；</li></ul><p>在面试过程中遇到这样的问题，如果确定题目中没有限定说明，可以向面试官进一步地问清楚应该考虑什么样的限定条件。</p><p>在这里我们假设（作者假设）面试官需要在原字符数组上替换，输入的字符串后面有足够多的内存空间。</p><p>我们仍然从最简思路入手：</p><ul><li><strong>思路1</strong>：在字符串中进行遍历，当碰到空格时，将空格替换为<code>%20</code>，由于替换的字符串比空格多2个字符，为了放入<code>%20</code>，所以要将后续的字符串后移两位，重复该操作直到字符串没有空格。</li></ul><p>假设字符串长度<code>n</code>，对于每个空格字符，需要移动后面<code>O(n)</code>个字符，所以时间开销是<code>O(n^2)</code>。</p><p>显然这个方法过于简单，还不是最优解，观察可以发现，有些字符串被反复后移，但其实对于一个固定空格个数的字符串，这些字符串所应该处的最终位置我们是可以计算出来的，比如<code>We are happy.</code>中<code>We</code>前面没有空格，不需要向后移动，<code>are</code>前面有1个空格，所以字符串会被后移2位，<code>happy.</code>前面有2个空格，需要移动4位。</p><p>所以对于某些字符串其最终的位置反而是通过计算得到的，不需要反复的重复移动（拷贝字符串时间开销大）。</p><ul><li><strong>思路2</strong>：使用一个空格计数器，在移动字符串时，根据当前空格计数器来判断当前字符需要后移多少位，然后直接将字符移动到目标位置上，遇到空格时，根据计算的后移位置，直接顺序写入<code>%20</code>。时间开销因为只需要遍历一次字符串，所以是<code>O(n)</code>。</li></ul><p>这样的思路还是有亿点点问题需要考虑，如果从头开始移动字符串，则后面的字符串还没有空出来时，就需要先移动后面的字符串，这样就导致问题变得稍微有点复杂，所以我们可以反过来，从尾部开始处理移动操作。</p><ul><li><strong>思路3</strong>：先遍历一次字符串，统计空格出现次数，计算最终字符串的长度，然后从尾部开始处理移动，申请两个指针，一个指向原字符位置，一个指向移动目标位置，当遇到普通字符时，直接转移，遇到空格时，在目标位置写入替换字符串。时间开销仍然是<code>O(n)</code>。</li></ul><p>完整实现代码:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">replace</span><span class="params">(<span class="keyword">char</span>* str, <span class="keyword">char</span>* ori, <span class="keyword">char</span>* rep)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(str != <span class="literal">nullptr</span> &amp;&amp; ori != <span class="literal">nullptr</span> &amp;&amp; rep != <span class="literal">nullptr</span></span><br><span class="line">       &amp;&amp; <span class="built_in">strlen</span>(str) &gt; <span class="number">0</span> &amp;&amp; <span class="built_in">strlen</span>(ori) &gt; <span class="number">0</span> &amp;&amp; <span class="built_in">strlen</span>(rep) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> ori_len = <span class="built_in">strlen</span>(ori);</span><br><span class="line">        <span class="keyword">int</span> rep_len = <span class="built_in">strlen</span>(rep);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">strlen</span>(str); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">strncmp</span>((str+i), ori, ori_len) == <span class="number">0</span>) &#123;</span><br><span class="line">                count++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(count == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">char</span>* po = str + <span class="built_in">strlen</span>(str) + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">char</span>* pr = po + count * (rep_len - ori_len);</span><br><span class="line">        <span class="keyword">while</span>(po &gt;= str) &#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">strncmp</span>(po, ori, ori_len) == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">char</span>* tmp = rep + (rep_len - <span class="number">1</span>); tmp &gt;= rep; tmp--) &#123;</span><br><span class="line">                    *pr = *tmp;</span><br><span class="line">                    pr--;</span><br><span class="line">                &#125;</span><br><span class="line">                po--;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                *pr = *po;</span><br><span class="line">                po--;</span><br><span class="line">                pr--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> str[<span class="number">100</span>] = <span class="string">&quot;We are happy.&quot;</span>;</span><br><span class="line">    <span class="keyword">char</span> ori[<span class="number">10</span>] = <span class="string">&quot; &quot;</span>;</span><br><span class="line">    <span class="keyword">char</span> rep[<span class="number">10</span>] = <span class="string">&quot;%20&quot;</span>;</span><br><span class="line">    <span class="keyword">if</span>(replace(str, ori, rep)) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, str);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Error\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Tips：代码和原作者的实现有出入，实现了相对来说比较通用的字符串替换，但是方法以及代码仅仅只针对这道题目而言是有效的，还有非常多该题目以外的问题其实是没有考虑到的，例如需要被替换不是单个的空格而是多个空格甚至是任意字符、替换的字符串如果长度小于被替换字符串该怎么处理，等等（修改上述代码中的初始字符串即可看到结果会出现问题）；不过不在这里继续讨论，可以自行尝试思考。</p><blockquote><p>拓展题练习题： 已排序的两个数组A1和A2，A1尾部有足够多的空间容纳A2，将A2的所有数组插入A1中，并且最终A1中所有数字是有序的。</p></blockquote>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;字符串的使用频率非常高，为了优化，很多语言都对字符串做了特殊的规定。&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="剑指Offer" scheme="https://yumi-cn.github.io/categories/%E5%89%91%E6%8C%87Offer/"/>
    
    
    <category term="笔记" scheme="https://yumi-cn.github.io/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>《3D图形的数学》第1章笔记 向量</title>
    <link href="https://yumi-cn.github.io/2020/11/27/3dmath-c1/"/>
    <id>https://yumi-cn.github.io/2020/11/27/3dmath-c1/</id>
    <published>2020-11-27T12:14:23.000Z</published>
    <updated>2020-11-28T09:18:55.646Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>对于成功的3D程序猿，掌握如何进行向量运算是一种基本的技能要求。</p></blockquote><a id="more"></a><blockquote><p>原书：《3D游戏与计算机图形学中的数学方法》 by Eric.Lengyel</p></blockquote><h2 id="1-向量的形式"><a href="#1-向量的形式" class="headerlink" title="1 向量的形式"></a>1 向量的形式</h2><p>一个n维向量<strong>V</strong>可以表示为：</p><div>$$\textbf{V} = < V_{1}, V_{2}, ... , V_{n} > \tag{1.1}$$</div><p>系数a和向量<strong>V</strong>的乘积可以定义为：</p><div>$$a\textbf{V} = < aV_{1}, aV_{2}, ... , aV_{n} > \tag{1.4}$$</div><p>向量加减运算：</p><div>$$\textbf{P} + \textbf{Q}= < P_{1} + Q_{1}, P_{2} + Q_{2}, ... , P_{n} + Q_{n} > \tag{1.5}$$</div><p><strong>【定理1.1】</strong>对于给定的任何两个系数a和b，以及任何三个向量<strong>P</strong>、<strong>Q</strong>和<strong>R</strong>，有以下运算规律：</p><ul><li>\(\textbf{P} + \textbf{Q} = \textbf{Q} + \textbf{P}\)</li><li>\((\textbf{P} + \textbf{Q}) + \textbf{R} = \textbf{P} + (\textbf{Q} + \textbf{R})\)</li><li>\((ab)\textbf{P} = a(b\textbf{P})\)</li><li>\(a(\textbf{P} + \textbf{Q}) = a\textbf{P} + a\textbf{Q}\)</li><li>\((a + b)\textbf{P} = a\textbf{P} + b\textbf{P}\)</li></ul><p>n维向量<strong>V</strong>的模，||<strong>V</strong>||：</p><div>$$\textbf{||V||} = \sqrt{\sum_{i=1}^{n} V_{i}^{2}} \tag{1.6}$$</div><p>模也称为向量的范数或者长度，模为1的向量称为单位向量。</p><p>设向量<strong>V</strong>表示一个三维点或方向，则公式(1.6)可以展开为：</p><div>$$\textbf{||V||} = \sqrt{V_{x}^{2} + V_{y}^{2} + V_{z}^{2}} \tag{1.7}$$</div><p>如果向量V至少有至少有一个非零分量，可以通过乘 \(1/\textbf{||V||}\) 得到V方向上的一个单位向量，也叫做单位化、规格化。</p><p><strong>【定理1.2】</strong> 对于任意给定系数a，任意的两个向量<strong>P</strong>和<strong>Q</strong>，有以下性质：</p><ul><li>\( \textbf{||P||} \geq 0 \)</li><li>当且仅当 \( \textbf{||P||}=&lt;0, 0, …, 0&gt; \)时，\( \textbf{||P||}=0 \)</li><li>\( \textbf{||aP||}=|a|\textbf{||P||} \)</li><li>\( \textbf{||P + Q||} \leq \textbf{||P||} + \textbf{||Q||} \)</li></ul><p>其中的第4条，可以由三角不等式得到。</p><h2 id="2-点积"><a href="#2-点积" class="headerlink" title="2 点积"></a>2 点积</h2><p><strong>向量间</strong>的<strong>点积</strong>，也叫做<strong>数量积</strong>或<strong>内积</strong>，3D图形中经常用点积来度量两个向量指向的差异。</p><p><strong>【定理1.3】</strong> 两个n维向量P和Q的点积，记作P·Q，即：</p><div>$$\textbf{P} \cdot \textbf{Q}= \sum_{i=1}^{n} P_{i}Q_{i} \tag{1.9}$$</div><p>向量的点积等于两个向量的对应分量乘积之和。</p><p>在三维空间中，有：</p><div>$$\textbf{P} \cdot \textbf{Q}= P_{x}Q_{x} + P_{y}Q_{y} + P_{z}Q_{z} \tag{1.10}$$</div><p><strong>【定理1.4】</strong> 对于给定的两个向量P和Q，点积满足公式：</p><div>$$\textbf{P} \cdot \textbf{Q}= \textbf{||P||}\textbf{||Q||} cos \alpha \tag{1.12}$$</div><p>\(\alpha\)是向量P和Q之间的夹角（详细的说是P和Q的起点、终点决定的平面夹角）。</p><p>Tips：定理1.4的证明要用到余弦定理，一个三角形有三条边\(a,b,c\)，\(a,b\)夹角是\(\alpha\)时，三边满足等式关系\(c^{2} = a^{2} + b^{2} - 2abcos\alpha\)。</p><p>定理1.4可以得出两个结论：</p><ul><li>当且仅当 \(\textbf{P} \cdot \textbf{Q} = 0\) 时， 向量P和向量Q相互垂直。点积为0的向量称为正交向量，零向量和任意向量正交；</li><li>点积正负号说明两个向量的方向情况，例如在看平面法线和平面外一点，可以查看点相对于平面的位置，是在法线同侧（点积为正）还是在不同侧（点积为负）。</li></ul><p><strong>【定理1.5】</strong> 对于任意给定系数a，任意的两个向量<strong>P</strong>和<strong>Q</strong>，有以下性质：</p><ul><li>\( \textbf{P} \cdot \textbf{Q} = \textbf{Q} \cdot \textbf{P} \)</li><li>\( (a\textbf{P}) \cdot \textbf{Q} = a(\textbf{P} \cdot \textbf{Q}) \)</li><li>\( \textbf{P} \cdot (\textbf{Q} + \textbf{R}) = \textbf{P} \cdot \textbf{Q} + \textbf{P} \cdot \textbf{R} \)</li><li>\( \textbf{P} \cdot \textbf{P} = \textbf{||P||}^{2} \)</li><li>\( | \textbf{P} \cdot \textbf{Q} | \leq \textbf{||P||} \cdot \textbf{||Q||} \)</li></ul><p>向量P在向量Q上的投影长度：</p><div>$$\textbf{||P||}cos\alpha= \frac{\textbf{P}\cdot\textbf{Q}}{\textbf{||Q||}} \tag{1.17}$$</div><p>如果再乘以单位向量 \( \frac{\textbf{Q}}{\textbf{||Q||}} \)，就可以得到具有该长度并且平行于Q的一个向量，即表示向量P到向量Q的投影，记作\( proj_{\textbf{Q}} \textbf{P} \)：</p><div>$$proj_{\textbf{Q}}\textbf{P} = \frac{\textbf{P} \cdot \textbf{Q}}{\textbf{||Q||}^{2}} \textbf{Q} \tag{1.18}$$</div><p>P到Q的投影也可以看作是一个线性变换过程，所以可以表示为矩阵和向量乘积，三维情况下，\( proj_{\textbf{Q}} \textbf{P} \) 也可以用下面的公式计算：</p><div>$$proj_{\textbf{Q}} \textbf{P} = \frac{1}{\textbf{Q}^{2}}\left[\begin{matrix}Q_{x}^{2} & Q_{x}Q_{y} & Q_{x}Q_{z} \\Q_{x}Q_{y} & Q_{y}^{2} & Q_{y}Q_{z} \\Q_{x}Q_{z} & Q_{y}Q_{z} & Q_{z}^{2}\end{matrix}\right]\left[\begin{matrix}P_{x} \\P_{y} \\P_{z}\end{matrix}\right]\tag{1.20}$$</div><p>向量P相对于向量Q的垂直分量记作\( perp_{\textbf{Q}} \textbf{P} \)，可以用向量P减去投影分量得到垂直分量：</p><div>$$perp_{\textbf{Q}} \textbf{P} = \textbf{P} - proj_{\textbf{Q}} \textbf{P} \tag{1.19}$$</div><h2 id="3-叉积"><a href="#3-叉积" class="headerlink" title="3 叉积"></a>3 叉积</h2><p>两个三维向量的叉积又称为向量积，结果是一个新的向量，这个向量垂直于原来的两个向量。</p><p>在3D图形学中，已知曲面上一点的两个不同方向的切向量，就可以通过求叉积得到曲面在该点的法向量。</p><p><strong>【定义1.6】</strong> 两个3D向量P和Q的叉积记作 \(\textbf{P} \times \textbf{Q}\)，结果向量为：</p><div>$$\textbf{P} \times \textbf{Q}= <P_{y}Q_{z} - P_{z}Q_{y},P_{z}Q_{x} - P_{x}Q_{z},P_{x}Q_{y} - P_{y}Q_{x} > \tag{1.21}$$</div><p>便于记忆的一个工具是伪行列式：</p><div>$$\textbf{P} \times \textbf{Q} =\left|\begin{matrix}i & j & k \\P_{x} & P_{y} & P_{z} \\Q_{x} & Q_{y} & Q_{z}\end{matrix}\right|\tag{1.22}$$</div><p>这里i,j,k是x,y,z轴的单位向量：</p><div>$$\begin{aligned}\textbf{i} &= <1, 0, 0> \\\textbf{j} &= <0, 1, 0> \\\textbf{k} &= <0, 0, 1>\end{aligned}\tag{1.23}$$</div><p>叉积\(\textbf{P} \times \textbf{Q}\)也可以用线性变换的形式表示，变换矩阵派生于P，作用于Q：</p><div>$$\textbf{P} \times \textbf{Q} =\left[\begin{matrix}0 & -P_{z} & P_{y} \\P_{z} & 0 & -P_{x} \\-P_{y} & P_{x} & 0\end{matrix}\right]\left[\begin{matrix}Q_{x} \\Q_{y} \\Q_{z}\end{matrix}\right]\tag{1.25}$$</div><p>Tips：原书P7的公式(1.25)有疏漏，变换矩阵中出现了Q的分量。</p><p>对于任意给定的三个3D向量P、Q和R，等式 \((\textbf{P} \times \textbf{Q}) \cdot \textbf{R}\) 的值可以通过伪行列式乘以R得到：</p><div>$$(\textbf{P} \times \textbf{Q}) \cdot \textbf{R} =\left|\begin{matrix}R_{x} & R_{y} & R_{z} \\P_{x} & P_{y} & P_{z} \\Q_{x} & Q_{y} & Q_{z}\end{matrix}\right|=\left|\begin{matrix}P_{x} & P_{y} & P_{z} \\Q_{x} & Q_{y} & Q_{z} \\R_{x} & R_{y} & R_{z}\end{matrix}\right|\tag{1.27}$$</div><p>Tips：行列式表达我在这里书写了两种表达形式，第一种是延续之前伪行列式的写法，只是将R替代了ijk的位置，第二种写法来自于书上，遵循PQR的出现次序的记忆法，两者的值根据初等变化法则是相等的。</p><p>如果P、Q和R中任何一个可以表示为其他两个向量的线性组合，则行列式的值为0（根据垂直法则和点积定理推导）。</p><p><strong>【定理1.8】</strong> 对于给定的两个3D向量P和Q，叉积\(\textbf{P} \times \textbf{Q}\)满足下面公式：</p><div>$$||\textbf{P} \times \textbf{Q}|| = \textbf{||P||}\textbf{||Q||}sin\alpha \tag{1.28}$$</div><p>\(\alpha\)为P和Q的夹角。</p><p>由定理1.8可知，叉积\(\textbf{P} \times \textbf{Q}\)的模等于由向量P和Q组成的平行四边形的面积。因此，一个三角形的顶点\(V_{1}, V_{2}, V_{3}\)，可以计算其面积A:</p><div>$$A = \frac{1}{2} || (V_{2} - V_{1}) \times (V_{3} - V_{1}) || \tag{1.32}$$</div><p>叉积得到的非零向量一定垂直于原本的两个向量，但满足要求的有两种方向，为了确定叉积方向，引入叉积遵循的<strong>右手法则</strong>。例如，使用右手手指指向P方向，手心朝向Q反向，则大拇指就是叉积\(\textbf{P} \times \textbf{Q}\)的方向。</p><p>空间轴的单位向量ijk，按照圆形循环的方式排序，i在j之前，j在k之前，k在i之前，则这样的顺序叉积乘等于第三个向量：</p><div>$$\begin{aligned} \textbf{i} \times \textbf{j} &= \textbf{k} \\ \textbf{j} \times \textbf{k} &= \textbf{i} \\ \textbf{k} \times \textbf{i} &= \textbf{j}\end{aligned}\tag{1.33}$$</div><p>反之，按照相反的顺序相接的叉乘等于第三个向量的负值。</p><p><strong>【定理1.9】</strong> 对于给定系数a，b和任意三个3D向量P、Q和R，有以下性质：</p><ul><li>\( \textbf{P} \times \textbf{Q} = - (\textbf{Q} \times \textbf{P}) \)</li><li>\( (a\textbf{P}) \times \textbf{Q} = a(\textbf{P} \times \textbf{Q}) \)</li><li>\( \textbf{P} \times (\textbf{Q} + \textbf{R}) = \textbf{P} \times \textbf{Q} + \textbf{P} \times \textbf{R} \)</li><li>\( \textbf{P} \times \textbf{P} = \textbf{0} = &lt;0, 0, 0&gt; \)</li><li>\( (\textbf{P} \times \textbf{Q}) \cdot \textbf{R} = (\textbf{R} \times \textbf{P}) \cdot \textbf{Q} = (\textbf{Q} \times \textbf{R}) \cdot \textbf{P} \) （注意顺序，满足圆形循环）</li><li>\( \textbf{P} \times (\textbf{Q} \times \textbf{P}) = \textbf{P} \times \textbf{Q} \times \textbf{P} = \textbf{P}^{2}\textbf{Q} - (\textbf{P} \cdot \textbf{Q}) \textbf{P} \)</li></ul><p>前五条都比较容易证明，稍微说一下最后一条的证明方式：</p><div>$$\begin{aligned}\textbf{P} \times (\textbf{Q} \times \textbf{P}) &= \textbf{P} \times [-(\textbf{P} \times \textbf{Q})] \\ &= [\textbf{P} \times -(\textbf{P} \times \textbf{Q})] \\ &= -[-(\textbf{P} \times \textbf{Q}) \times \textbf{P}] \\ &= (\textbf{P} \times \textbf{Q}) \times \textbf{P} \\ &= \textbf{P} \times \textbf{Q} \times \textbf{P}\end{aligned}\tag{1.35}$$</div><p>后面的具体计算式，是通过对三个分量分别求值得到的结果，不再赘述。</p><p>由定理1.9可以得到 <strong>叉积不满足交换律和结合律</strong>。</p><h2 id="4-向量空间"><a href="#4-向量空间" class="headerlink" title="4 向量空间"></a>4 向量空间</h2><p><strong>【定理1.10】</strong> 向量空间是一个集合V，元素成为向量，下面定义向量空间中的加法和乘数，并介绍一些性质：</p><ul><li>V对于加法运算封闭；</li><li>V对于乘数运算封闭；</li><li>V中存在一个零元素 \(\textbf{0}\)；</li><li>V中任意向量P存在向量Q使其 \( \textbf{P} + \textbf{Q} = \textbf{0}\)；</li><li>加法满足结合律；</li><li>乘数满足结合律；</li><li>乘数对于加法满足分配率，\( a(\textbf{P} + \textbf{Q}) = a\textbf{P} + a\textbf{Q}\)；</li><li>系数加法对于乘数满足分配率，\( (a + b)\textbf{P} = a\textbf{P} + b\textbf{P}\)。</li></ul><p>将由n元组组成的向量空间记作 \(R^{n}\)，比如三维的向量空间记作\(R^{3}\)。</p><p>每一个向量空间都可以由一组向量的线性组合来生成，生成向量空间的向量组成为基。</p><p><strong>【定义1.11】</strong> 对于一组向量 {\( \textbf{e}_{1}, \textbf{e}_{2}, …, \textbf{e}_{n} \)}，<strong>如果不存在</strong>这样一组实数 {\(a_{1}, a_{2}, …, a_{n}\)}，其中<strong>至少有一个</strong> \(a_{i}\) 不为0，使得下式成立：</p><div>$$a_{1}\textbf{e}_{1} + a_{2}\textbf{e}_{2} + \cdots + a_{n}\textbf{e}_{n} = 0 \tag{1.40}$$</div><p><strong>则称这组向量线性无关，否则称向量组线性相关</strong>。</p><p>一个n维向量空间可以由n个线性无关的向量组成的向量集合生成，这个向量组成为基。</p><p><strong>【定义1.12】</strong> 向量空间V的基B是一个由n个线性无关的向量组成的集合，即 \(\textbf{B}\)={\(\textbf{e}_{1}, \textbf{e}_{2}, …, \textbf{e}_{n} \)}，对于向量空间V中的任意一个元素P，都存在一组实数使得：</p><div>$$\textbf{P} = a_{1}\textbf{e}_{1} + a_{2}\textbf{e}_{2} + \cdots + a_{n}\textbf{e}_{n} \tag{1.41}$$</div><p>任意空间向量\(R^{n}\)都具有无限个基，对基的形式进行一些限定后，可以使基具有特定的性质。</p><p><strong>【定义1.13】</strong> 对于向量空间的基\(\textbf{B}\)={\(\textbf{e}_{1}, \textbf{e}_{2}, …, \textbf{e}_{n} \)}，如果对于任意 \(i \neq j\) 都有 \(\textbf{e}_{i} \cdot \textbf{e}_{j} = 0\)，则该基为正交基。</p><p><strong>【定理1.14】</strong> 对于给定的两个向量 \(\textbf{e}_{1}\) 和 \(\textbf{e}_{2}\)， 如果\(\textbf{e}_{1} \cdot \textbf{e}_{2} = 0\)，则\(\textbf{e}_{1}\) 和 \(\textbf{e}_{2}\)线性无关。</p><p>对基的另一个形式限定就是基的所有向量都具有单位长度（更简单化了），引入Kronecker delta符号 \(\delta_{ij}\)，定义如下：</p><div>$$\delta_{ij} =\left\{\begin{aligned} 1, i&=j  \\ 0, i&\neq j\end{aligned}\right.\tag{1.42}$$</div><p><strong>【定理1.15】</strong> 如果对于每一对 \((i, j)\) 有 \(\textbf{e}_{i} \cdot \textbf{e}_{j} = \delta_{ij}\)，则基 \(\beta\)={\(\textbf{e}_{1}, \textbf{e}_{2}, …, \textbf{e}_{n} \)}称为向量空间的正交规范基。</p><p>显然向量组{\(\textbf{i}, \textbf{j}, \textbf{k}\)}是\(R^{3}\)的一个正交规范基。</p><p>有一个方法可以将具有n个线性无关向量的向量组转换为向量空间\(R^{n}\)的正交基，基本思想是减去向量在前面每个向量上的投影，结果肯定和前面所有的向量正交。</p><p><strong>【定理1.16】</strong> <strong>Gram-Schmidt 正交规范化：</strong> 对于由n个线性无关想了组成的向量组\(\textbf{B}\)={\(\textbf{e}_{1}, \textbf{e}_{2}, …, \textbf{e}_{n} \)}，算法可以产生向量组\(\beta\)={\(\textbf{e}_{1}^{‘}, \textbf{e}_{2}^{‘}, …, \textbf{e}_{n}^{‘} \)}，当 \(i \neq j\)时，\(\textbf{e}_{i}^{i} \cdot \textbf{e}_{j}^{i} = 0\)。</p><ol><li>设 \(\textbf{e}_{1}^{‘} = \textbf{e}_{1}\)；</li><li>从i=2开始；</li><li>从\(\textbf{e}_{i}\)中减去\(\textbf{e}_{i}\)在向量\(\textbf{e}_{1}^{‘}, \textbf{e}_{2}^{‘}, …, \textbf{e}_{i-1}^{‘} \)上地投影，结果为\(\textbf{e}_{i}^{‘}\)，即</li></ol><div>$$\textbf{e}_{i}^{'} =\textbf{e}_{i} - \sum_{k=1}^{i-1} proj_{\textbf{e}_{k}} \textbf{e}_{i} =\textbf{e}_{i} - \sum_{k=1}^{i-1} \frac{\textbf{e}_{i} \cdot \textbf{e}_{k}}{\textbf{e}_{k}^{2}} \textbf{e}_{k} \tag{1.43}$$</div><ol start="4"><li>如果i &lt; n，i加1，重复步骤3。</li><li>如果需要进一步生成正交规范基，就对每个\(\textbf{e}_{i}^{‘}\)进行规范化。</li></ol>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;对于成功的3D程序猿，掌握如何进行向量运算是一种基本的技能要求。&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="3D游戏与图形学的数学" scheme="https://yumi-cn.github.io/categories/3D%E6%B8%B8%E6%88%8F%E4%B8%8E%E5%9B%BE%E5%BD%A2%E5%AD%A6%E7%9A%84%E6%95%B0%E5%AD%A6/"/>
    
    
    <category term="笔记" scheme="https://yumi-cn.github.io/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>《剑指Offer》第2章笔记 数组</title>
    <link href="https://yumi-cn.github.io/2020/11/26/s2o-c2-array/"/>
    <id>https://yumi-cn.github.io/2020/11/26/s2o-c2-array/</id>
    <published>2020-11-26T13:57:25.000Z</published>
    <updated>2020-11-28T14:12:10.637Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>数据结构是技术面的重点，主要围绕数组、字符串、链表、树、栈以及队列这几种常见的数据结构展开。</p></blockquote><a id="more"></a><p>嗯，除了语言和算法以外的最重要的（废话）。</p><hr><p>数组的一些特点（主要是指C/C++中的基础数组类型）：</p><ul><li>连续的内存，按照顺序存储；</li><li>创建时需要指定数组的容量大小；</li><li><code>O(1)</code>时间读/写任何位置元素；</li></ul><p>为了解决基础数组空间效率不高的问题，人们设计了动态数组，比如 <code>C++ STL</code> 中的 <code>vector</code> ，其中为了避免空间浪费，先为数组开辟小空间，当数据数目超过容量时，再重新分配一块更大的空间，把之间的数据复制到新的数组中，再把之前的内存释放（一般没有延续之前地址往后申请内存的操作，所以只能整块申请，然后再释放掉新的），但是这样就会带来内存空间申请和数据迁移的时间开销，因此使用动态数组要尽量减少改变数组容量大小的操作。</p><blockquote><p>在C/C++中，数组和指针既相互关联又有区别。</p></blockquote><p>声明一个数组时，数组的名字也是一个指针（不可修改的指针变量），该指针指向数组的第一个元素。需要注意的是，C/C++不会主动记录数组的大小，所以在访问数组元素时，程序要确保不会超过边界。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">get_size</span><span class="params">(<span class="keyword">int</span> data[])</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">sizeof</span>(data);</span><br><span class="line">&#125;Error: Cannot find module &#x27;gulplog&#x27;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> data1[] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line">  <span class="keyword">int</span> size1 = <span class="keyword">sizeof</span>(data1);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span>* data2 = data1;</span><br><span class="line">  <span class="keyword">int</span> size2 = <span class="keyword">sizeof</span>(data2);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span> size3 = get_size(data1);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%d, %d, %d&quot;</span>, size1, size2, size3);</span><br><span class="line">  <span class="comment">// 20, 4, 4</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>在上面的代码中：</p><ul><li><code>sizeof(data1) == 20</code>：<code>sizeof(data1)</code>求数组的大小（字节数），<code>data1</code>包含5个整数，每个整数4字节，所以20字节；</li><li><code>sizeof(data2) == 4</code>：<code>data2</code>声明是指针，尽管指向了数组指针，但本质仍然是指针，在32位系统上，对任意指针求<code>sizeof</code>都是4(32位系统是4个字节的地址)；</li><li><code>get_size(data1) == 4</code>：在C/C++中，数组作为函数参数传递时，会退化为同类型的指针，尽管函数声明的是数组参数，但还是会退化为指针（语言概念特色），所以结果仍然是4。</li></ul><hr><blockquote><p>面试题3 题目一：找出数组中重复的数字。</p></blockquote><p>数组长度n，数字都在 <code>0</code> - <code>n-1</code> 的范围内，数组中某些数字重复，但不知道有几个数字重复，请找出数组中任意一个重复数字；例如<code>&#123;2, 3, 1, 0, 2, 5, 3&#125;</code>，重复数字2或者3。</p><ul><li><strong>思路1</strong>：简单的排序再搜索就可以，但需要 <code>O(nlogn)</code> 的时间开销；</li><li><strong>改进思路2</strong>：常用的一种优化思路是使用哈希表，从头到尾记录所有数字的出现次数，如果次数大于2就是重复的数字，时间开销降低到了 <code>O(n)</code> ，但凭空多了哈希表的 <code>O(n)</code> 开销；</li></ul><p>大部分的人都能想到第二种方法，然后书的作者会介绍第三种方法：</p><blockquote><p>数字都在0~n-1的范围内，如果数组不重复，则数字i出现在下标i的位置，如果重复，则某些位置有多个数字，同时有些位置没有数字。</p></blockquote><p>但我觉得对这种方法的阐述，<strong>稍微有点凭空跳脱</strong>，没有和之前提到的前两种思路有任何延续，所以一时可能较于难以理解这里的思路，尤其是之后的算法流程。</p><p>我们可以延续之前的<strong>改进思路2</strong>，使用哈希表的优点是时间开销少，缺点是多了空间开销，那么进一步的优化思路是：<strong>如何减少空间上的开销？</strong></p><p>在已知数字出现在 <code>0</code> ~ <code>n-1</code> 范围内时，哈希表的一种简单实现是位置<code>i</code>存储数字<code>i</code>的出现频率：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> <span class="built_in">array</span>[<span class="number">5</span>] = &#123;<span class="number">1</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">0</span>, <span class="number">2</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> hash[<span class="number">5</span>] = &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>&#125;;</span><br><span class="line">... <span class="comment">// for num in array to finish hash</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; hash &lt;&lt; <span class="built_in">endl</span>; <span class="comment">// [1, 1, 1, 2, 0]</span></span><br></pre></td></tr></table></figure><p>那么，你可以想到的一种优化思路是：原数组存储的数字在读取过一次后其实就没有作用了，所以在数字<code>i</code>被读取了之后，<strong>将它“自己的位置”作为哈希表的存储位</strong>，<strong>不就不需要额外的空间了么</strong>？</p><p>更加细节地，在数字<code>i</code>被读取了过后，尽管它本身可能不在位置<code>i</code>上，可以把原本位置<code>i</code>的数字替换到当前的位置，最后我们使用位置<code>i</code>作为数字<code>i</code>的哈希表存储位，就完成了一步操作；对全数组的数字都执行这样的操作，就可以找出重复的数字了。</p><p>这个方法本质上是延续哈希表的思路，并且具体实现的方式你就会发现和作者提出的方法是一致的，所以我猜测作者的实质本意是将改进思路2的一种延续优化，但并没有在书中进行说明这种思路转变，稍微有点儿可惜。</p><p>PS：这样的改进思路在延续了简单哈希表实现的同时，也延续了这样的哈希表缺点，即无法处理<code>0</code> ~ <code>n-1</code> 范围以外的数字情况。</p><p>从头到尾依次扫描数组中的每个数字，当扫描到位置<code>i</code>的数字<code>m</code>时，判断<code>m==i</code>：</p><ul><li>如果相等，说明数字<code>i</code>在位置<code>i</code>上，继续执行；</li><li>如果不相等，将位置<code>m</code>上的数字交换到位置<code>i</code>上，位置<code>m</code>上放置了数字<code>m</code>，从位置<code>i</code>继续下一步判断；如果在交换之前发现，位置<code>m</code>上已经是数字<code>m</code>了，那么就说明数字<code>m</code>重复了，程序结束。</li></ul><p>一个栗子：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">1</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">0</span>, <span class="number">2</span>] <span class="comment">// i=0</span></span><br><span class="line">[<span class="number">3</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">0</span>, <span class="number">2</span>] <span class="comment">// i=0 1 on 1</span></span><br><span class="line">[<span class="number">0</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">2</span>] <span class="comment">// i=0 3 on 3</span></span><br><span class="line">[<span class="number">0</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">2</span>] <span class="comment">// i=0 0 on 0</span></span><br><span class="line">[<span class="number">0</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">2</span>] <span class="comment">// i=1 1 on 1</span></span><br><span class="line">[<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">3</span>] <span class="comment">// i=2 2 on 2</span></span><br><span class="line">[<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">3</span>] <span class="comment">// i=3 3 on 3</span></span><br><span class="line">[<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">3</span>] <span class="comment">// i=4 3 already on 3, 3 repeat</span></span><br></pre></td></tr></table></figure><p>完整代码实现：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find_repeat</span><span class="params">(<span class="keyword">int</span> <span class="built_in">array</span>[], <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(i &lt; len) &#123;</span><br><span class="line">        <span class="keyword">int</span> m = <span class="built_in">array</span>[i];</span><br><span class="line">        <span class="keyword">if</span>(m != i) &#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">array</span>[m] != m) &#123;</span><br><span class="line">                <span class="comment">// swap</span></span><br><span class="line">                <span class="keyword">int</span> temp = <span class="built_in">array</span>[m];</span><br><span class="line">                <span class="built_in">array</span>[m] = m;</span><br><span class="line">                <span class="built_in">array</span>[i] = temp;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> m;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> len;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> <span class="built_in">array</span>[] = &#123;<span class="number">1</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">0</span>, <span class="number">2</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> len = <span class="keyword">sizeof</span>(<span class="built_in">array</span>) / <span class="keyword">sizeof</span>(<span class="built_in">array</span>[<span class="number">0</span>]);</span><br><span class="line">    <span class="keyword">int</span> dup = find_repeat(<span class="built_in">array</span>, len);</span><br><span class="line">    <span class="keyword">if</span>(dup == len) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;No Repeat Number\n&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Repeat Number: %d\n&quot;</span>, dup);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在其中还可以加上前一节提到的安全、边界等问题的考虑，在下面贴的作者的实现里面可以看到：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">duplicate</span><span class="params">(<span class="keyword">int</span> <span class="built_in">array</span>[], <span class="keyword">int</span> len, <span class="keyword">int</span>* dup)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 考虑参数失效</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">array</span> == <span class="literal">nullptr</span> || len &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 考虑超过边界</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">array</span>[i] &lt; <span class="number">0</span> || <span class="built_in">array</span>[i] &gt; len - <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 实现比较优雅 流程相同</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="built_in">array</span>[i] != i) &#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">array</span>[i] == <span class="built_in">array</span>[<span class="built_in">array</span>[i]]) &#123;</span><br><span class="line">                *dup = <span class="built_in">array</span>[i];</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// swap</span></span><br><span class="line">                <span class="keyword">int</span> temp = <span class="built_in">array</span>[i];</span><br><span class="line">                <span class="built_in">array</span>[i] = <span class="built_in">array</span>[temp];</span><br><span class="line">                <span class="built_in">array</span>[temp] = temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><blockquote><p>面试题3 题目二：不修改数组找出重复的数字。</p></blockquote><p>在长度n+1的数组里的所有数字都在1~n的范围内，所以数组至少有一个数字是重复的。请找出数组中任意一个重复的数字，但不能修改输入的数组。</p><p>这一题虽然可以像题目一那样，只需要多开辟一个n+1长度的辅助数组，用来解决问题，但是这样就多了O(n)的空间开销。</p><p>一般在这种限定情况下，很难再和题目一一样做到时间、空间开销非常小的情况下完成任务，所以可以退一步，不需要缩减到O(n)时间，比如维持和快排复杂度O(nlogn)相同情况下，达成O(1)的空间开销也是一种优化的思路。</p><p>因为出发点不同，我们再次退回到最简单的方法：</p><ul><li>没有额外的空间帮助记录时，就只能每次判断一个数字是否有重复，即判断n次，每次有n长度的遍历开销，也就是O(n^2)；</li></ul><p>所以有<strong>两个优化的方向</strong>：（1）减少判断的次数n；（2）减少遍历长度n。</p><p>在没有额外信息辅助的情况下，优化（2）一般是很难做的（因为每个数只有遍历了全部才知道是否有重复），所以我们可以尝试优化（1）的部分。</p><p>最简单思路下，只有遍历了1~n的n个数在数组中的情况，才能知道谁重复了，我们可以用一些技巧来减少需要判断的次数。</p><p>其实非常巧妙，这条技巧就在题目中：“1~n范围内的数，在长度n+1的数组中必然存在一个重复”，这个命题成立的原因是，如果你遍历一次数组，统计1~n范围内数字的出现次数(n+1)，出现情况是大于n的（这里的n指1~n的这个范围长度），进一步地推广到一个普适命题“i~j范围内的数，在长度n+1的数组中，如果出现次数大于(j-i+1)，那必然存在重复”；</p><p>也就是意味着我们只用使用一次O(n)的遍历时间，就可以确定一个范围的数字是否存在重复。这样的性质可以让我们不断地缩小所需要判断的数字范围，这也就是时间开销上的优化。</p><p>具体地，我们可以联想到二分法：</p><ul><li>一开始将范围1~n分为两部分，一半是1~m，另一半是m+1~n；</li><li>如果范围1~m的数字的统计次数大于m，则这个范围内有重复的数字；否则另一半m+1~n的区间里一定有包含重复的数字；</li><li>继续二分存在重复数字的范围，重复步骤；</li><li>直到确定到某个重复数字。</li></ul><p>比如说题目给的例子{ 2, 3, 5, 4, 3, 2, 6, 7 }：</p><ul><li>[1-4]范围的数字出现5次，[5-7]范围的数字出现3次，重复在[1-4];</li><li>[1-2]范围的数字出现2次，[3-4]范围的数字出现3次，重复在[3-4]；</li><li>[3]数字出现2次，[4]数字出现1次，重复数字是3。</li></ul><p>然后简单分析一下时间复杂度，每次遍历统计的时间开销不变O(n)，因为数字范围二分，一共需要走O(logn)步，所以在O(nlogn)时间中可以找出重复数字。</p><p>完整代码实现：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">is_repeat</span><span class="params">(<span class="keyword">int</span> <span class="built_in">array</span>[], <span class="keyword">int</span> len, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">array</span>[i] &lt;= end &amp;&amp; <span class="built_in">array</span>[i] &gt;= start) &#123;</span><br><span class="line">            count += <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count &gt; (end - start + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find_repeat</span><span class="params">(<span class="keyword">int</span> <span class="built_in">array</span>[], <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> start = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> end = len<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">while</span>(end != start) &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = (end + start) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(is_repeat(<span class="built_in">array</span>, len, start, mid)) &#123;</span><br><span class="line">            end = mid;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            start = mid+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> start;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> <span class="built_in">array</span>[] = &#123;<span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">6</span>, <span class="number">7</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> len = <span class="keyword">sizeof</span>(<span class="built_in">array</span>) / <span class="keyword">sizeof</span>(<span class="built_in">array</span>[<span class="number">0</span>]);</span><br><span class="line">    <span class="keyword">int</span> dup = find_repeat(<span class="built_in">array</span>, len);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Repeat Number: %d\n&quot;</span>, dup); <span class="comment">// 3</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Tips：上述代码没有考虑一些安全、边界问题，所以比较简短。</p><p>需要指出的一点是，上面的使用的这种方法不能保证找出所有重复的数字，例如其中的2也是重复数字，但是算法只找出了3，一个原因是因为只会检查其中一半范围，例如检查到前一半有重复的时候，就不会再检查后一半范围了，另一个原因是算法无法确定是其中一个数字出现2次还是几次。</p><hr><blockquote><p>面试题4：二维数组中的查找</p></blockquote><p>在一个二维整数数组中，每一行从左到右递增，每一列从上到下递增，判断数组中是否含有指定数字。</p><p>例如：</p><div>$$\begin{matrix}1 & 2 & 8 & 9 \\2 & 4 & 9 & 12 \\4 & 7 & 10 & 13 \\6 & 8 & 11 & 15\end{matrix}$$</div><p>当一个数和矩阵中间的一个数比较时，除了相等，还有两种情况：</p><ul><li>(a)当查询数字<strong>小于</strong>目标数字时，说明目标数字<strong>一定不会出现在左上角</strong>，剩下需要判断的区域在其右边和下边；</li><li>(b)当查询数字<strong>大于</strong>目标数字时，说明目标数字<strong>一定不会出现在右下角</strong>，剩下需要判断的区域在其左边和上边。</li></ul><div align="center"><p><img src="/images/s2o-c2-array-cv4.jpg" alt="比较的两种情况"></p></div><p>当我们按照常规思路，尝试从<code>(0,0)</code>出发，向右下角进行搜索时，我们跳转到下一格只有通过2种方式，从上转移到下，和从左转移到右，如果我们把已遍历的位置称为“已知信息”，我们可以看到这种搜索方式，<strong>大部分“已知信息”都集中在左上部</strong>，这在比较出现的两种情况中，要么无法提供任何信息，要么只能提供重叠区域的信息，<strong>无法让转移确定下一次的方向</strong>。</p><p>所以为了<strong>避免“已知信息”的浪费</strong>，我们可以尝试从右上角<code>(0, n-1)</code>出发，向左下角进行搜索，这样会提供更多的信息，如果发生向下转移，代表上边没有比目标数更大的，如果发生向左转移，代表右边的数比目标数更大，所以导致更加明确的在左下角区域中搜索目标数。</p><div align="center"><p><img src="/images/s2o-c2-array-cv4-2.jpg" alt="例子"></p></div><p>完整代码实现：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> matrix[][<span class="number">4</span>], <span class="keyword">int</span> rows, <span class="keyword">int</span> cols, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> j = cols - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(i &lt; rows &amp;&amp; j &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span>(matrix[i][j] &lt; target) &#123;</span><br><span class="line">            i++;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(matrix[i][j] &gt; target) &#123;</span><br><span class="line">            j--;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> matrix[][<span class="number">4</span>] = &#123;</span><br><span class="line">        &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">8</span>, <span class="number">9</span>&#125;,</span><br><span class="line">        &#123;<span class="number">2</span>, <span class="number">4</span>, <span class="number">9</span>, <span class="number">12</span>&#125;,</span><br><span class="line">        &#123;<span class="number">4</span>, <span class="number">7</span>, <span class="number">10</span>, <span class="number">13</span>&#125;,</span><br><span class="line">        &#123;<span class="number">6</span>, <span class="number">8</span>, <span class="number">11</span>, <span class="number">15</span>&#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">int</span> target = <span class="number">7</span>;</span><br><span class="line">    <span class="keyword">if</span>(find(matrix, <span class="number">4</span>, <span class="number">4</span>, target)) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Found!\n&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Not Found!\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;数据结构是技术面的重点，主要围绕数组、字符串、链表、树、栈以及队列这几种常见的数据结构展开。&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="剑指Offer" scheme="https://yumi-cn.github.io/categories/%E5%89%91%E6%8C%87Offer/"/>
    
    
    <category term="笔记" scheme="https://yumi-cn.github.io/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>《剑指Offer》第2章笔记 编程语言</title>
    <link href="https://yumi-cn.github.io/2020/11/25/s2o-c2-lg/"/>
    <id>https://yumi-cn.github.io/2020/11/25/s2o-c2-lg/</id>
    <published>2020-11-25T12:57:25.000Z</published>
    <updated>2020-11-28T09:20:58.171Z</updated>
    
    <content type="html"><![CDATA[<p>第2章主要围绕<strong>编程语言</strong>、<strong>数据结构</strong>和<strong>算法</strong>，介绍技术面所需要的“基础知识”。</p><a id="more"></a><h2 id="编程语言"><a href="#编程语言" class="headerlink" title="编程语言"></a>编程语言</h2><p>书里代码都是用 <code>C/C++/C#</code> 实现的，后面分别从 <code>C++</code> 和 <code>C#</code> 语言的角度来讲述其中一些被问道的细节点，这样的细节点因为篇幅限制，不可能都写进书里，所以还需要通过阅读对应编程语言的书籍来进阶了解，同时其他语言的使用者也可以从其中窥探到面试官在针对语言掌握的考量时，都是从什么样的角度出发的。</p><h3 id="C"><a href="#C" class="headerlink" title="C++"></a>C++</h3><p>通常语言面试的问题有3种类型：</p><ol><li>对于语言中概念的理解程度；</li><li>面对代码，分析运行结果（或错误）；</li><li>在上下文环境中，定义类型或实现函数。</li></ol><p>作者推荐的几本C++书，根据自己的情况选择阅读顺序：</p><ul><li><strong>《Effective C++》</strong>：书中列举了C++经常出现的问题以及解决这些问题的技巧（大多是面试官比较喜欢问的方向），适合面试之前突击C++；</li><li><strong>《C++ Primer》</strong>：人称C++全书，适合全面了解的时候阅读，也可以当作宝典查询；</li><li><strong>《深度探索C++对象模型》</strong>：深度了解C++对象的内部机制，介绍很多较为底层的知识点；</li><li><strong>《The C++ Programming Language》</strong>：C++圣经（大概），适合全面深入掌握C++。</li></ul><p>下面通过一道面试题（第3种类型）来表现一下这类题目是如何考查语言知识点的。</p><blockquote><p>面试题1：赋值运算符函数，如下为类型CMyString的声明，请为该类型添加赋值运算符函数。</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CMyString</span> &#123;</span></span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    CMyString(<span class="keyword">char</span>* pData=<span class="literal">nullptr</span>);</span><br><span class="line">    CMyString(<span class="keyword">const</span> CMyString&amp; str);</span><br><span class="line">    ~CMyString(<span class="keyword">void</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">char</span>* m_pData;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>Tips：赋值运算符主要负责变量在进行赋值 <code>=</code> 运算时，如何处理变量对象内部成员变化。</p><p>定义C++中的<strong>赋值运算符</strong>函数时，需要关注点有：</p><ul><li><strong>返回值类型声明为引用，函数结束前返回实例自身的引用</strong>，因为返回引用才允许连续赋值的情况，例如 <code>str1 = str2 = str3</code>，否则无法通过编译；</li><li>把<strong>传入的参数类型声明为常量引用</strong>，如果不是引用，形参到实参传递会调用一次复制构造函数（函数的传值引用），引用可以避免这样的开销；同时因为赋值运算并不会修改传入的实例的状态，所以应进一步加上 <code>const</code> 关键字；</li><li><strong>释放实例自身已有的内存</strong>，主要在对象有动态分配内存情况下考虑，如果忘记在分配新内存前释放旧内存空间，程序旧出现了内存泄漏(memory leakge)，这块内存无法被回收使用（资源浪费、占用空间导致空间不够用）；</li><li><strong>判断传入参数和当前实例</strong>(*this)是不是同一个实例，是则不进行赋值，如果不判断就直接赋值，在同一个实例情况下，会导致在还没有拷贝到传入参数（自己）的内存时，就释放自己的内存，这也就导致传入参数的内存被释放了（因为函数是传引用），最后找不到待赋值的内容。</li></ul><p>经典解法：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line">CMyString&amp; CMyString::<span class="keyword">operator</span>=(<span class="keyword">const</span> CMyString&amp; str) &#123;</span><br><span class="line">  <span class="keyword">if</span>(<span class="keyword">this</span> == &amp;str) &#123;  <span class="comment">// 对象的 this 是一个地址</span></span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;     <span class="comment">// 传对象 而不是地址</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">delete</span> []m_pData;   <span class="comment">// 数组的释放方式</span></span><br><span class="line">  m_pData = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">  m_pData = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="built_in">strlen</span>(str.m_pData) + <span class="number">1</span>]; <span class="comment">// 申请新空间，多的1位给&#x27;\0&#x27;</span></span><br><span class="line">  <span class="built_in">strcpy</span>(m_pData, str.m_pData); <span class="comment">// 复制 赋值</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果对自己有更高的要求，应该再进一步地考虑其中涉及到的问题。</p><p>前面的函数中，<strong>分配内存之前先释放了内存</strong>，如果在分配内存时，内存不足就会导致 <code>new char</code> 排除异常，<code>m_pData</code>将是一个空指针，并且无法回退到之前的结果，也就是说一旦赋值运算符内部抛出了异常，实例不再保持有效的状态（并不是原有的状态），这违背了异常安全性（Exception Safety）原则（正常情况下，如果抛出异常也不应该导致内容被错误操作）。</p><ul><li>简单的方法是先用 <code>new</code> 分配新内容，再 <code>delete</code> 释放已有的；</li><li>更好的办法是<strong>创建一个临时实例</strong>，再交换临时实例和原来的实例。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line">CMyString&amp; CMyString::<span class="keyword">operator</span>=(<span class="keyword">const</span> CMyString&amp; str) &#123;</span><br><span class="line">  <span class="keyword">if</span>(<span class="keyword">this</span> == &amp;str) &#123;</span><br><span class="line">    CMyString tmp(str); <span class="comment">// 复制构造函数</span></span><br><span class="line">    <span class="built_in">std</span>::swap(m_pData, tmp.m_pData); <span class="comment">// 交换地址</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当 <code>tmp</code> 局部变量遇到 <code>if</code> 结束时，会自动调用它的析构函数，会把交换下来的 <code>this</code> 的 <code>m_pData</code> 所指向的内存释放掉；在新的代码中，在复制构造函数中分配内存，如果由于内存不足抛出异常时，由于此时还没有修改原来的实例状态，实例的状态依旧是有效的（原有的），也就保证了异常安全性。</p><p>完整代码（包含所有实现和测试）：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CMyString</span> &#123;</span></span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    CMyString(<span class="keyword">char</span>* pData); <span class="comment">// 第一个参数设定默认值会导致无法通过编译</span></span><br><span class="line">    CMyString(<span class="keyword">const</span> CMyString&amp; str);</span><br><span class="line">    ~CMyString(<span class="keyword">void</span>);</span><br><span class="line">    CMyString&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> CMyString&amp; str); <span class="comment">// 赋值运算符函数声明</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">void</span>)</span></span>; <span class="comment">// 标准输出函数</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">char</span>* m_pData;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 构造函数</span></span><br><span class="line">CMyString::CMyString(<span class="keyword">char</span>* pData) &#123;</span><br><span class="line">    <span class="keyword">if</span>(pData != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        m_pData = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="built_in">strlen</span>(pData) + <span class="number">1</span>];</span><br><span class="line">        <span class="built_in">strcpy</span>(m_pData, pData);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 复制构造函数</span></span><br><span class="line">CMyString::CMyString(<span class="keyword">const</span> CMyString&amp; str) &#123;</span><br><span class="line">    <span class="keyword">if</span>(str.m_pData != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        m_pData = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="built_in">strlen</span>(str.m_pData) + <span class="number">1</span>];</span><br><span class="line">        <span class="built_in">strcpy</span>(m_pData, str.m_pData);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 析构函数</span></span><br><span class="line">CMyString::~CMyString(<span class="keyword">void</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span>(m_pData != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="keyword">delete</span> []m_pData;</span><br><span class="line">        m_pData = <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CMyString::print</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; m_pData &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 赋值运算符函数</span></span><br><span class="line">CMyString&amp; CMyString::<span class="keyword">operator</span>=(<span class="keyword">const</span> CMyString&amp; str) &#123;</span><br><span class="line">  <span class="keyword">if</span>(<span class="keyword">this</span> != &amp;str) &#123;</span><br><span class="line">    CMyString tmp(str); <span class="comment">// 复制构造函数</span></span><br><span class="line">    <span class="built_in">std</span>::swap(m_pData, tmp.m_pData); <span class="comment">// 交换地址</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 测试CMyString</span></span><br><span class="line">    <span class="function">CMyString <span class="title">str1</span><span class="params">(<span class="string">&quot;Sword&quot;</span>)</span></span>;</span><br><span class="line">    <span class="function">CMyString <span class="title">str2</span><span class="params">(<span class="string">&quot;2&quot;</span>)</span></span>;</span><br><span class="line">    <span class="function">CMyString <span class="title">str3</span><span class="params">(<span class="string">&quot;Offer&quot;</span>)</span></span>;</span><br><span class="line">    str1 = str2 = str3;</span><br><span class="line">    str1.print(); <span class="comment">// Offer</span></span><br><span class="line">    str2.print(); <span class="comment">// Offer</span></span><br><span class="line">    str3.print(); <span class="comment">// Offer</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果完整的去实现上面这个题目，会引出一些非常容易忽略的细节问题（并且会导致严重错误），例如在初始化变量 <code>str1</code> 时，<code>CMyString str1(&quot;Sword&quot;);</code>，其中所传入的参数一般都是程序声明的<strong>字符串常量</strong>，如果在构造函数中简单地实现为：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Mem Error</span></span><br><span class="line">CMyString::CMyString(<span class="keyword">char</span>* pData) &#123;</span><br><span class="line">    m_pData = pData;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>就会导致赋值运算符函数中的析构函数调用过程发生错误，因为析构函数中的 <code>delete []m_pData</code> 的delete操作符只负责操作堆(Heap)中的内存区域(因为new只在堆里申请内存区域)，如果使用delete操作符去释放一个字符串常量指针所指向的区域，就会发生错误（大概是访问越界）。</p><p>所以在初始化时应该使用和delete对应的new操作，在堆中申请内存，再把传入参数的内容复制到其中。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">CMyString::CMyString(<span class="keyword">char</span>* pData) &#123;</span><br><span class="line">    <span class="keyword">if</span>(pData != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        m_pData = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="built_in">strlen</span>(pData) + <span class="number">1</span>];</span><br><span class="line">        <span class="built_in">strcpy</span>(m_pData, pData);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="C-1"><a href="#C-1" class="headerlink" title="C#"></a>C#</h3><p>因为还没怎么学C#的东西，C#的部分暂时跳过，记录一下推荐的书：</p><ul><li>《Professional C#》：特点是附录中有描述C#和其他语言的区别；</li><li>《CLR Via C#》：深入介绍C#，对CLR和.NET进行剖析，可以方便理解装箱卸箱、垃圾回收、反射等概念。</li></ul><blockquote><p>面试题2：实现Singleton模式（单例模式）</p></blockquote><p>暂时跳过。</p><p>涉及到设计模式的部分，列举一些可以参考阅读的资料：</p><ul><li>《设计模式：C++常用设计模式》：<a href="https://refactoringguru.cn/design-patterns/cpp">https://refactoringguru.cn/design-patterns/cpp</a> ；</li><li>《Head First 设计模式》：感觉是一本比较老的书，可能之后看看吧；</li><li>《Game Programming Patterns》：<a href="http://gameprogrammingpatterns.com/contents.html">http://gameprogrammingpatterns.com/contents.html</a> 。</li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;第2章主要围绕&lt;strong&gt;编程语言&lt;/strong&gt;、&lt;strong&gt;数据结构&lt;/strong&gt;和&lt;strong&gt;算法&lt;/strong&gt;，介绍技术面所需要的“基础知识”。&lt;/p&gt;</summary>
    
    
    
    <category term="剑指Offer" scheme="https://yumi-cn.github.io/categories/%E5%89%91%E6%8C%87Offer/"/>
    
    
    <category term="笔记" scheme="https://yumi-cn.github.io/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>《剑指Offer》第1章笔记</title>
    <link href="https://yumi-cn.github.io/2020/11/24/s2o-c1/"/>
    <id>https://yumi-cn.github.io/2020/11/24/s2o-c1/</id>
    <published>2020-11-24T04:57:25.000Z</published>
    <updated>2020-11-28T09:20:54.477Z</updated>
    
    <content type="html"><![CDATA[<p>第1章主要介绍的是几种面试方式的不同流程以及注意事项。</p><blockquote><p>“…技术面试中的5个要素，是全书的大纲,…”</p></blockquote><a id="more"></a><h2 id="远程桌面面试"><a href="#远程桌面面试" class="headerlink" title="远程桌面面试"></a>远程桌面面试</h2><ul><li>思考清楚再开始编码；</li><li>良好的代码命名和缩进对齐；</li><li>单元测试、断点调试。</li></ul><h2 id="面试的3个环节"><a href="#面试的3个环节" class="headerlink" title="面试的3个环节"></a>面试的3个环节</h2><p>行为面试、技术面试、应聘者提问。</p><h3 id="行为面试"><a href="#行为面试" class="headerlink" title="行为面试"></a>行为面试</h3><ol start="0"><li>自我介绍：30s-1min，介绍主要学习和工作经历；</li><li>项目经验：STAR模型描述项目经历；<ul><li>Situation：简短的项目背景；</li><li>Task：自己完成的任务，注意区分“参与”和“负责”；</li><li>Action：如何完成任务的，详细介绍自己完成任务的方式方法；</li><li>Result：自己的贡献，尝试量化自己的产出，让人直接接收到你的成果。</li></ul></li><li>掌握技能：注意区分“了解”、“熟悉”和“精通”；<ul><li>了解：上过课、看过书，但没有做过实际项目，通常只建议有用的时候再写；</li><li>熟悉：通常的情况，指能够独立解决大部分问题；</li><li>精通：得心应手，能够轻松回答领域内的绝大多数问题。</li></ul></li><li>为什么跳槽：尽量不说抱怨层面的原因，多从自我发展的角度阐述选择的理由。</li></ol><h3 id="技术面试"><a href="#技术面试" class="headerlink" title="技术面试"></a>技术面试</h3><p>平均1个小时的面试，技术面试会占据40-50分钟的时间。</p><p>总的来说面试官关注应聘者的5种素质：</p><ul><li>扎实的基础知识：编程语言、数据结构和算法；</li><li>能写高质量的代码：代码鲁棒性，边界考虑（另外还需要注意代码规范或者风格）；</li><li>分析问题的思路清晰：从简单完备的思路出发，用各种方法来尝试优化，例如画图形象化，举例具象化，分解简单化；</li><li>能够优化时间、空间效率：熟知数据结构优缺点，熟练掌握常用算法；</li><li>学习、沟通、综合能力。</li></ul><p>PS：5个要素分别对应本书的第2、3、4、5、6章节内容。</p><h3 id="应聘者提问"><a href="#应聘者提问" class="headerlink" title="应聘者提问"></a>应聘者提问</h3><p>如果觉得面试后临时想比较困难，可以在面试前提前准备一些问题。</p><p>主要围绕公司、职位、项目等工作上的事情，不太适合问较远较模糊或者和工薪相关的问题（之后再和HR聊也可以）。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;第1章主要介绍的是几种面试方式的不同流程以及注意事项。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;“…技术面试中的5个要素，是全书的大纲,…”&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="剑指Offer" scheme="https://yumi-cn.github.io/categories/%E5%89%91%E6%8C%87Offer/"/>
    
    
    <category term="笔记" scheme="https://yumi-cn.github.io/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
</feed>
