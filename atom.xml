<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>画码余生</title>
  
  <subtitle>副标题</subtitle>
  <link href="https://yumi-cn.github.io/atom.xml" rel="self"/>
  
  <link href="https://yumi-cn.github.io/"/>
  <updated>2020-11-28T09:18:55.646Z</updated>
  <id>https://yumi-cn.github.io/</id>
  
  <author>
    <name>Yumiko</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>《3D图形的数学》第1章笔记 向量</title>
    <link href="https://yumi-cn.github.io/2020/11/27/3dmath-c1/"/>
    <id>https://yumi-cn.github.io/2020/11/27/3dmath-c1/</id>
    <published>2020-11-27T12:14:23.000Z</published>
    <updated>2020-11-28T09:18:55.646Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>对于成功的3D程序猿，掌握如何进行向量运算是一种基本的技能要求。</p></blockquote><a id="more"></a><blockquote><p>原书：《3D游戏与计算机图形学中的数学方法》 by Eric.Lengyel</p></blockquote><h2 id="1-向量的形式"><a href="#1-向量的形式" class="headerlink" title="1 向量的形式"></a>1 向量的形式</h2><p>一个n维向量<strong>V</strong>可以表示为：</p><div>$$\textbf{V} = < V_{1}, V_{2}, ... , V_{n} > \tag{1.1}$$</div><p>系数a和向量<strong>V</strong>的乘积可以定义为：</p><div>$$a\textbf{V} = < aV_{1}, aV_{2}, ... , aV_{n} > \tag{1.4}$$</div><p>向量加减运算：</p><div>$$\textbf{P} + \textbf{Q}= < P_{1} + Q_{1}, P_{2} + Q_{2}, ... , P_{n} + Q_{n} > \tag{1.5}$$</div><p><strong>【定理1.1】</strong>对于给定的任何两个系数a和b，以及任何三个向量<strong>P</strong>、<strong>Q</strong>和<strong>R</strong>，有以下运算规律：</p><ul><li>\(\textbf{P} + \textbf{Q} = \textbf{Q} + \textbf{P}\)</li><li>\((\textbf{P} + \textbf{Q}) + \textbf{R} = \textbf{P} + (\textbf{Q} + \textbf{R})\)</li><li>\((ab)\textbf{P} = a(b\textbf{P})\)</li><li>\(a(\textbf{P} + \textbf{Q}) = a\textbf{P} + a\textbf{Q}\)</li><li>\((a + b)\textbf{P} = a\textbf{P} + b\textbf{P}\)</li></ul><p>n维向量<strong>V</strong>的模，||<strong>V</strong>||：</p><div>$$\textbf{||V||} = \sqrt{\sum_{i=1}^{n} V_{i}^{2}} \tag{1.6}$$</div><p>模也称为向量的范数或者长度，模为1的向量称为单位向量。</p><p>设向量<strong>V</strong>表示一个三维点或方向，则公式(1.6)可以展开为：</p><div>$$\textbf{||V||} = \sqrt{V_{x}^{2} + V_{y}^{2} + V_{z}^{2}} \tag{1.7}$$</div><p>如果向量V至少有至少有一个非零分量，可以通过乘 \(1/\textbf{||V||}\) 得到V方向上的一个单位向量，也叫做单位化、规格化。</p><p><strong>【定理1.2】</strong> 对于任意给定系数a，任意的两个向量<strong>P</strong>和<strong>Q</strong>，有以下性质：</p><ul><li>\( \textbf{||P||} \geq 0 \)</li><li>当且仅当 \( \textbf{||P||}=&lt;0, 0, …, 0&gt; \)时，\( \textbf{||P||}=0 \)</li><li>\( \textbf{||aP||}=|a|\textbf{||P||} \)</li><li>\( \textbf{||P + Q||} \leq \textbf{||P||} + \textbf{||Q||} \)</li></ul><p>其中的第4条，可以由三角不等式得到。</p><h2 id="2-点积"><a href="#2-点积" class="headerlink" title="2 点积"></a>2 点积</h2><p><strong>向量间</strong>的<strong>点积</strong>，也叫做<strong>数量积</strong>或<strong>内积</strong>，3D图形中经常用点积来度量两个向量指向的差异。</p><p><strong>【定理1.3】</strong> 两个n维向量P和Q的点积，记作P·Q，即：</p><div>$$\textbf{P} \cdot \textbf{Q}= \sum_{i=1}^{n} P_{i}Q_{i} \tag{1.9}$$</div><p>向量的点积等于两个向量的对应分量乘积之和。</p><p>在三维空间中，有：</p><div>$$\textbf{P} \cdot \textbf{Q}= P_{x}Q_{x} + P_{y}Q_{y} + P_{z}Q_{z} \tag{1.10}$$</div><p><strong>【定理1.4】</strong> 对于给定的两个向量P和Q，点积满足公式：</p><div>$$\textbf{P} \cdot \textbf{Q}= \textbf{||P||}\textbf{||Q||} cos \alpha \tag{1.12}$$</div><p>\(\alpha\)是向量P和Q之间的夹角（详细的说是P和Q的起点、终点决定的平面夹角）。</p><p>Tips：定理1.4的证明要用到余弦定理，一个三角形有三条边\(a,b,c\)，\(a,b\)夹角是\(\alpha\)时，三边满足等式关系\(c^{2} = a^{2} + b^{2} - 2abcos\alpha\)。</p><p>定理1.4可以得出两个结论：</p><ul><li>当且仅当 \(\textbf{P} \cdot \textbf{Q} = 0\) 时， 向量P和向量Q相互垂直。点积为0的向量称为正交向量，零向量和任意向量正交；</li><li>点积正负号说明两个向量的方向情况，例如在看平面法线和平面外一点，可以查看点相对于平面的位置，是在法线同侧（点积为正）还是在不同侧（点积为负）。</li></ul><p><strong>【定理1.5】</strong> 对于任意给定系数a，任意的两个向量<strong>P</strong>和<strong>Q</strong>，有以下性质：</p><ul><li>\( \textbf{P} \cdot \textbf{Q} = \textbf{Q} \cdot \textbf{P} \)</li><li>\( (a\textbf{P}) \cdot \textbf{Q} = a(\textbf{P} \cdot \textbf{Q}) \)</li><li>\( \textbf{P} \cdot (\textbf{Q} + \textbf{R}) = \textbf{P} \cdot \textbf{Q} + \textbf{P} \cdot \textbf{R} \)</li><li>\( \textbf{P} \cdot \textbf{P} = \textbf{||P||}^{2} \)</li><li>\( | \textbf{P} \cdot \textbf{Q} | \leq \textbf{||P||} \cdot \textbf{||Q||} \)</li></ul><p>向量P在向量Q上的投影长度：</p><div>$$\textbf{||P||}cos\alpha= \frac{\textbf{P}\cdot\textbf{Q}}{\textbf{||Q||}} \tag{1.17}$$</div><p>如果再乘以单位向量 \( \frac{\textbf{Q}}{\textbf{||Q||}} \)，就可以得到具有该长度并且平行于Q的一个向量，即表示向量P到向量Q的投影，记作\( proj_{\textbf{Q}} \textbf{P} \)：</p><div>$$proj_{\textbf{Q}}\textbf{P} = \frac{\textbf{P} \cdot \textbf{Q}}{\textbf{||Q||}^{2}} \textbf{Q} \tag{1.18}$$</div><p>P到Q的投影也可以看作是一个线性变换过程，所以可以表示为矩阵和向量乘积，三维情况下，\( proj_{\textbf{Q}} \textbf{P} \) 也可以用下面的公式计算：</p><div>$$proj_{\textbf{Q}} \textbf{P} = \frac{1}{\textbf{Q}^{2}}\left[\begin{matrix}Q_{x}^{2} & Q_{x}Q_{y} & Q_{x}Q_{z} \\Q_{x}Q_{y} & Q_{y}^{2} & Q_{y}Q_{z} \\Q_{x}Q_{z} & Q_{y}Q_{z} & Q_{z}^{2}\end{matrix}\right]\left[\begin{matrix}P_{x} \\P_{y} \\P_{z}\end{matrix}\right]\tag{1.20}$$</div><p>向量P相对于向量Q的垂直分量记作\( perp_{\textbf{Q}} \textbf{P} \)，可以用向量P减去投影分量得到垂直分量：</p><div>$$perp_{\textbf{Q}} \textbf{P} = \textbf{P} - proj_{\textbf{Q}} \textbf{P} \tag{1.19}$$</div><h2 id="3-叉积"><a href="#3-叉积" class="headerlink" title="3 叉积"></a>3 叉积</h2><p>两个三维向量的叉积又称为向量积，结果是一个新的向量，这个向量垂直于原来的两个向量。</p><p>在3D图形学中，已知曲面上一点的两个不同方向的切向量，就可以通过求叉积得到曲面在该点的法向量。</p><p><strong>【定义1.6】</strong> 两个3D向量P和Q的叉积记作 \(\textbf{P} \times \textbf{Q}\)，结果向量为：</p><div>$$\textbf{P} \times \textbf{Q}= <P_{y}Q_{z} - P_{z}Q_{y},P_{z}Q_{x} - P_{x}Q_{z},P_{x}Q_{y} - P_{y}Q_{x} > \tag{1.21}$$</div><p>便于记忆的一个工具是伪行列式：</p><div>$$\textbf{P} \times \textbf{Q} =\left|\begin{matrix}i & j & k \\P_{x} & P_{y} & P_{z} \\Q_{x} & Q_{y} & Q_{z}\end{matrix}\right|\tag{1.22}$$</div><p>这里i,j,k是x,y,z轴的单位向量：</p><div>$$\begin{aligned}\textbf{i} &= <1, 0, 0> \\\textbf{j} &= <0, 1, 0> \\\textbf{k} &= <0, 0, 1>\end{aligned}\tag{1.23}$$</div><p>叉积\(\textbf{P} \times \textbf{Q}\)也可以用线性变换的形式表示，变换矩阵派生于P，作用于Q：</p><div>$$\textbf{P} \times \textbf{Q} =\left[\begin{matrix}0 & -P_{z} & P_{y} \\P_{z} & 0 & -P_{x} \\-P_{y} & P_{x} & 0\end{matrix}\right]\left[\begin{matrix}Q_{x} \\Q_{y} \\Q_{z}\end{matrix}\right]\tag{1.25}$$</div><p>Tips：原书P7的公式(1.25)有疏漏，变换矩阵中出现了Q的分量。</p><p>对于任意给定的三个3D向量P、Q和R，等式 \((\textbf{P} \times \textbf{Q}) \cdot \textbf{R}\) 的值可以通过伪行列式乘以R得到：</p><div>$$(\textbf{P} \times \textbf{Q}) \cdot \textbf{R} =\left|\begin{matrix}R_{x} & R_{y} & R_{z} \\P_{x} & P_{y} & P_{z} \\Q_{x} & Q_{y} & Q_{z}\end{matrix}\right|=\left|\begin{matrix}P_{x} & P_{y} & P_{z} \\Q_{x} & Q_{y} & Q_{z} \\R_{x} & R_{y} & R_{z}\end{matrix}\right|\tag{1.27}$$</div><p>Tips：行列式表达我在这里书写了两种表达形式，第一种是延续之前伪行列式的写法，只是将R替代了ijk的位置，第二种写法来自于书上，遵循PQR的出现次序的记忆法，两者的值根据初等变化法则是相等的。</p><p>如果P、Q和R中任何一个可以表示为其他两个向量的线性组合，则行列式的值为0（根据垂直法则和点积定理推导）。</p><p><strong>【定理1.8】</strong> 对于给定的两个3D向量P和Q，叉积\(\textbf{P} \times \textbf{Q}\)满足下面公式：</p><div>$$||\textbf{P} \times \textbf{Q}|| = \textbf{||P||}\textbf{||Q||}sin\alpha \tag{1.28}$$</div><p>\(\alpha\)为P和Q的夹角。</p><p>由定理1.8可知，叉积\(\textbf{P} \times \textbf{Q}\)的模等于由向量P和Q组成的平行四边形的面积。因此，一个三角形的顶点\(V_{1}, V_{2}, V_{3}\)，可以计算其面积A:</p><div>$$A = \frac{1}{2} || (V_{2} - V_{1}) \times (V_{3} - V_{1}) || \tag{1.32}$$</div><p>叉积得到的非零向量一定垂直于原本的两个向量，但满足要求的有两种方向，为了确定叉积方向，引入叉积遵循的<strong>右手法则</strong>。例如，使用右手手指指向P方向，手心朝向Q反向，则大拇指就是叉积\(\textbf{P} \times \textbf{Q}\)的方向。</p><p>空间轴的单位向量ijk，按照圆形循环的方式排序，i在j之前，j在k之前，k在i之前，则这样的顺序叉积乘等于第三个向量：</p><div>$$\begin{aligned} \textbf{i} \times \textbf{j} &= \textbf{k} \\ \textbf{j} \times \textbf{k} &= \textbf{i} \\ \textbf{k} \times \textbf{i} &= \textbf{j}\end{aligned}\tag{1.33}$$</div><p>反之，按照相反的顺序相接的叉乘等于第三个向量的负值。</p><p><strong>【定理1.9】</strong> 对于给定系数a，b和任意三个3D向量P、Q和R，有以下性质：</p><ul><li>\( \textbf{P} \times \textbf{Q} = - (\textbf{Q} \times \textbf{P}) \)</li><li>\( (a\textbf{P}) \times \textbf{Q} = a(\textbf{P} \times \textbf{Q}) \)</li><li>\( \textbf{P} \times (\textbf{Q} + \textbf{R}) = \textbf{P} \times \textbf{Q} + \textbf{P} \times \textbf{R} \)</li><li>\( \textbf{P} \times \textbf{P} = \textbf{0} = &lt;0, 0, 0&gt; \)</li><li>\( (\textbf{P} \times \textbf{Q}) \cdot \textbf{R} = (\textbf{R} \times \textbf{P}) \cdot \textbf{Q} = (\textbf{Q} \times \textbf{R}) \cdot \textbf{P} \) （注意顺序，满足圆形循环）</li><li>\( \textbf{P} \times (\textbf{Q} \times \textbf{P}) = \textbf{P} \times \textbf{Q} \times \textbf{P} = \textbf{P}^{2}\textbf{Q} - (\textbf{P} \cdot \textbf{Q}) \textbf{P} \)</li></ul><p>前五条都比较容易证明，稍微说一下最后一条的证明方式：</p><div>$$\begin{aligned}\textbf{P} \times (\textbf{Q} \times \textbf{P}) &= \textbf{P} \times [-(\textbf{P} \times \textbf{Q})] \\ &= [\textbf{P} \times -(\textbf{P} \times \textbf{Q})] \\ &= -[-(\textbf{P} \times \textbf{Q}) \times \textbf{P}] \\ &= (\textbf{P} \times \textbf{Q}) \times \textbf{P} \\ &= \textbf{P} \times \textbf{Q} \times \textbf{P}\end{aligned}\tag{1.35}$$</div><p>后面的具体计算式，是通过对三个分量分别求值得到的结果，不再赘述。</p><p>由定理1.9可以得到 <strong>叉积不满足交换律和结合律</strong>。</p><h2 id="4-向量空间"><a href="#4-向量空间" class="headerlink" title="4 向量空间"></a>4 向量空间</h2><p><strong>【定理1.10】</strong> 向量空间是一个集合V，元素成为向量，下面定义向量空间中的加法和乘数，并介绍一些性质：</p><ul><li>V对于加法运算封闭；</li><li>V对于乘数运算封闭；</li><li>V中存在一个零元素 \(\textbf{0}\)；</li><li>V中任意向量P存在向量Q使其 \( \textbf{P} + \textbf{Q} = \textbf{0}\)；</li><li>加法满足结合律；</li><li>乘数满足结合律；</li><li>乘数对于加法满足分配率，\( a(\textbf{P} + \textbf{Q}) = a\textbf{P} + a\textbf{Q}\)；</li><li>系数加法对于乘数满足分配率，\( (a + b)\textbf{P} = a\textbf{P} + b\textbf{P}\)。</li></ul><p>将由n元组组成的向量空间记作 \(R^{n}\)，比如三维的向量空间记作\(R^{3}\)。</p><p>每一个向量空间都可以由一组向量的线性组合来生成，生成向量空间的向量组成为基。</p><p><strong>【定义1.11】</strong> 对于一组向量 {\( \textbf{e}_{1}, \textbf{e}_{2}, …, \textbf{e}_{n} \)}，<strong>如果不存在</strong>这样一组实数 {\(a_{1}, a_{2}, …, a_{n}\)}，其中<strong>至少有一个</strong> \(a_{i}\) 不为0，使得下式成立：</p><div>$$a_{1}\textbf{e}_{1} + a_{2}\textbf{e}_{2} + \cdots + a_{n}\textbf{e}_{n} = 0 \tag{1.40}$$</div><p><strong>则称这组向量线性无关，否则称向量组线性相关</strong>。</p><p>一个n维向量空间可以由n个线性无关的向量组成的向量集合生成，这个向量组成为基。</p><p><strong>【定义1.12】</strong> 向量空间V的基B是一个由n个线性无关的向量组成的集合，即 \(\textbf{B}\)={\(\textbf{e}_{1}, \textbf{e}_{2}, …, \textbf{e}_{n} \)}，对于向量空间V中的任意一个元素P，都存在一组实数使得：</p><div>$$\textbf{P} = a_{1}\textbf{e}_{1} + a_{2}\textbf{e}_{2} + \cdots + a_{n}\textbf{e}_{n} \tag{1.41}$$</div><p>任意空间向量\(R^{n}\)都具有无限个基，对基的形式进行一些限定后，可以使基具有特定的性质。</p><p><strong>【定义1.13】</strong> 对于向量空间的基\(\textbf{B}\)={\(\textbf{e}_{1}, \textbf{e}_{2}, …, \textbf{e}_{n} \)}，如果对于任意 \(i \neq j\) 都有 \(\textbf{e}_{i} \cdot \textbf{e}_{j} = 0\)，则该基为正交基。</p><p><strong>【定理1.14】</strong> 对于给定的两个向量 \(\textbf{e}_{1}\) 和 \(\textbf{e}_{2}\)， 如果\(\textbf{e}_{1} \cdot \textbf{e}_{2} = 0\)，则\(\textbf{e}_{1}\) 和 \(\textbf{e}_{2}\)线性无关。</p><p>对基的另一个形式限定就是基的所有向量都具有单位长度（更简单化了），引入Kronecker delta符号 \(\delta_{ij}\)，定义如下：</p><div>$$\delta_{ij} =\left\{\begin{aligned} 1, i&=j  \\ 0, i&\neq j\end{aligned}\right.\tag{1.42}$$</div><p><strong>【定理1.15】</strong> 如果对于每一对 \((i, j)\) 有 \(\textbf{e}_{i} \cdot \textbf{e}_{j} = \delta_{ij}\)，则基 \(\beta\)={\(\textbf{e}_{1}, \textbf{e}_{2}, …, \textbf{e}_{n} \)}称为向量空间的正交规范基。</p><p>显然向量组{\(\textbf{i}, \textbf{j}, \textbf{k}\)}是\(R^{3}\)的一个正交规范基。</p><p>有一个方法可以将具有n个线性无关向量的向量组转换为向量空间\(R^{n}\)的正交基，基本思想是减去向量在前面每个向量上的投影，结果肯定和前面所有的向量正交。</p><p><strong>【定理1.16】</strong> <strong>Gram-Schmidt 正交规范化：</strong> 对于由n个线性无关想了组成的向量组\(\textbf{B}\)={\(\textbf{e}_{1}, \textbf{e}_{2}, …, \textbf{e}_{n} \)}，算法可以产生向量组\(\beta\)={\(\textbf{e}_{1}^{‘}, \textbf{e}_{2}^{‘}, …, \textbf{e}_{n}^{‘} \)}，当 \(i \neq j\)时，\(\textbf{e}_{i}^{i} \cdot \textbf{e}_{j}^{i} = 0\)。</p><ol><li>设 \(\textbf{e}_{1}^{‘} = \textbf{e}_{1}\)；</li><li>从i=2开始；</li><li>从\(\textbf{e}_{i}\)中减去\(\textbf{e}_{i}\)在向量\(\textbf{e}_{1}^{‘}, \textbf{e}_{2}^{‘}, …, \textbf{e}_{i-1}^{‘} \)上地投影，结果为\(\textbf{e}_{i}^{‘}\)，即</li></ol><div>$$\textbf{e}_{i}^{'} =\textbf{e}_{i} - \sum_{k=1}^{i-1} proj_{\textbf{e}_{k}} \textbf{e}_{i} =\textbf{e}_{i} - \sum_{k=1}^{i-1} \frac{\textbf{e}_{i} \cdot \textbf{e}_{k}}{\textbf{e}_{k}^{2}} \textbf{e}_{k} \tag{1.43}$$</div><ol start="4"><li>如果i &lt; n，i加1，重复步骤3。</li><li>如果需要进一步生成正交规范基，就对每个\(\textbf{e}_{i}^{‘}\)进行规范化。</li></ol>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;对于成功的3D程序猿，掌握如何进行向量运算是一种基本的技能要求。&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="3D游戏与图形学的数学" scheme="https://yumi-cn.github.io/categories/3D%E6%B8%B8%E6%88%8F%E4%B8%8E%E5%9B%BE%E5%BD%A2%E5%AD%A6%E7%9A%84%E6%95%B0%E5%AD%A6/"/>
    
    
    <category term="笔记" scheme="https://yumi-cn.github.io/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>《剑指Offer》第2章笔记 数组</title>
    <link href="https://yumi-cn.github.io/2020/11/26/s2o-c2-array/"/>
    <id>https://yumi-cn.github.io/2020/11/26/s2o-c2-array/</id>
    <published>2020-11-26T13:57:25.000Z</published>
    <updated>2020-11-28T13:47:43.550Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>数据结构是技术面的重点，主要围绕数组、字符串、链表、树、栈以及队列这几种常见的数据结构展开。</p></blockquote><a id="more"></a><p>嗯，除了语言和算法以外的最重要的（废话）。</p><hr><p>数组的一些特点（主要是指C/C++中的基础数组类型）：</p><ul><li>连续的内存，按照顺序存储；</li><li>创建时需要指定数组的容量大小；</li><li><code>O(1)</code>时间读/写任何位置元素；</li></ul><p>为了解决基础数组空间效率不高的问题，人们设计了动态数组，比如 <code>C++ STL</code> 中的 <code>vector</code> ，其中为了避免空间浪费，先为数组开辟小空间，当数据数目超过容量时，再重新分配一块更大的空间，把之间的数据复制到新的数组中，再把之前的内存释放（一般没有延续之前地址往后申请内存的操作，所以只能整块申请，然后再释放掉新的），但是这样就会带来内存空间申请和数据迁移的时间开销，因此使用动态数组要尽量减少改变数组容量大小的操作。</p><blockquote><p>在C/C++中，数组和指针既相互关联又有区别。</p></blockquote><p>声明一个数组时，数组的名字也是一个指针（不可修改的指针变量），该指针指向数组的第一个元素。需要注意的是，C/C++不会主动记录数组的大小，所以在访问数组元素时，程序要确保不会超过边界。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">get_size</span><span class="params">(<span class="keyword">int</span> data[])</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">sizeof</span>(data);</span><br><span class="line">&#125;Error: Cannot find module &#x27;gulplog&#x27;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> data1[] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line">  <span class="keyword">int</span> size1 = <span class="keyword">sizeof</span>(data1);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span>* data2 = data1;</span><br><span class="line">  <span class="keyword">int</span> size2 = <span class="keyword">sizeof</span>(data2);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span> size3 = get_size(data1);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%d, %d, %d&quot;</span>, size1, size2, size3);</span><br><span class="line">  <span class="comment">// 20, 4, 4</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>在上面的代码中：</p><ul><li><code>sizeof(data1) == 20</code>：<code>sizeof(data1)</code>求数组的大小（字节数），<code>data1</code>包含5个整数，每个整数4字节，所以20字节；</li><li><code>sizeof(data2) == 4</code>：<code>data2</code>声明是指针，尽管指向了数组指针，但本质仍然是指针，在32位系统上，对任意指针求<code>sizeof</code>都是4(32位系统是4个字节的地址)；</li><li><code>get_size(data1) == 4</code>：在C/C++中，数组作为函数参数传递时，会退化为同类型的指针，尽管函数声明的是数组参数，但还是会退化为指针（语言概念特色），所以结果仍然是4。</li></ul><hr><blockquote><p>面试题3 题目一：找出数组中重复的数字。</p></blockquote><p>数组长度n，数字都在 <code>0</code> - <code>n-1</code> 的范围内，数组中某些数字重复，但不知道有几个数字重复，请找出数组中任意一个重复数字；例如<code>&#123;2, 3, 1, 0, 2, 5, 3&#125;</code>，重复数字2或者3。</p><ul><li><strong>思路1</strong>：简单的排序再搜索就可以，但需要 <code>O(nlogn)</code> 的时间开销；</li><li><strong>改进思路2</strong>：常用的一种优化思路是使用哈希表，从头到尾记录所有数字的出现次数，如果次数大于2就是重复的数字，时间开销降低到了 <code>O(n)</code> ，但凭空多了哈希表的 <code>O(n)</code> 开销；</li></ul><p>大部分的人都能想到第二种方法，然后书的作者会介绍第三种方法：</p><blockquote><p>数字都在0~n-1的范围内，如果数组不重复，则数字i出现在下标i的位置，如果重复，则某些位置有多个数字，同时有些位置没有数字。</p></blockquote><p>但我觉得对这种方法的阐述，<strong>稍微有点凭空跳脱</strong>，没有和之前提到的前两种思路有任何延续，所以一时可能较于难以理解这里的思路，尤其是之后的算法流程。</p><p>我们可以延续之前的<strong>改进思路2</strong>，使用哈希表的优点是时间开销少，缺点是多了空间开销，那么进一步的优化思路是：<strong>如何减少空间上的开销？</strong></p><p>在已知数字出现在 <code>0</code> ~ <code>n-1</code> 范围内时，哈希表的一种简单实现是位置<code>i</code>存储数字<code>i</code>的出现频率：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> <span class="built_in">array</span>[<span class="number">5</span>] = &#123;<span class="number">1</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">0</span>, <span class="number">2</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> hash[<span class="number">5</span>] = &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>&#125;;</span><br><span class="line">... <span class="comment">// for num in array to finish hash</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; hash &lt;&lt; <span class="built_in">endl</span>; <span class="comment">// [1, 1, 1, 2, 0]</span></span><br></pre></td></tr></table></figure><p>那么，你可以想到的一种优化思路是：原数组存储的数字在读取过一次后其实就没有作用了，所以在数字<code>i</code>被读取了之后，<strong>将它“自己的位置”作为哈希表的存储位</strong>，<strong>不就不需要额外的空间了么</strong>？</p><p>更加细节地，在数字<code>i</code>被读取了过后，尽管它本身可能不在位置<code>i</code>上，可以把原本位置<code>i</code>的数字替换到当前的位置，最后我们使用位置<code>i</code>作为数字<code>i</code>的哈希表存储位，就完成了一步操作；对全数组的数字都执行这样的操作，就可以找出重复的数字了。</p><p>这个方法本质上是延续哈希表的思路，并且具体实现的方式你就会发现和作者提出的方法是一致的，所以我猜测作者的实质本意是将改进思路2的一种延续优化，但并没有在书中进行说明这种思路转变，稍微有点儿可惜。</p><p>PS：这样的改进思路在延续了简单哈希表实现的同时，也延续了这样的哈希表缺点，即无法处理<code>0</code> ~ <code>n-1</code> 范围以外的数字情况。</p><p>从头到尾依次扫描数组中的每个数字，当扫描到位置<code>i</code>的数字<code>m</code>时，判断<code>m==i</code>：</p><ul><li>如果相等，说明数字<code>i</code>在位置<code>i</code>上，继续执行；</li><li>如果不相等，将位置<code>m</code>上的数字交换到位置<code>i</code>上，位置<code>m</code>上放置了数字<code>m</code>，从位置<code>i</code>继续下一步判断；如果在交换之前发现，位置<code>m</code>上已经是数字<code>m</code>了，那么就说明数字<code>m</code>重复了，程序结束。</li></ul><p>一个栗子：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">1</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">0</span>, <span class="number">2</span>] <span class="comment">// i=0</span></span><br><span class="line">[<span class="number">3</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">0</span>, <span class="number">2</span>] <span class="comment">// i=0 1 on 1</span></span><br><span class="line">[<span class="number">0</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">2</span>] <span class="comment">// i=0 3 on 3</span></span><br><span class="line">[<span class="number">0</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">2</span>] <span class="comment">// i=0 0 on 0</span></span><br><span class="line">[<span class="number">0</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">2</span>] <span class="comment">// i=1 1 on 1</span></span><br><span class="line">[<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">3</span>] <span class="comment">// i=2 2 on 2</span></span><br><span class="line">[<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">3</span>] <span class="comment">// i=3 3 on 3</span></span><br><span class="line">[<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">3</span>] <span class="comment">// i=4 3 already on 3, 3 repeat</span></span><br></pre></td></tr></table></figure><p>完整代码实现：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find_repeat</span><span class="params">(<span class="keyword">int</span> <span class="built_in">array</span>[], <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(i &lt; len) &#123;</span><br><span class="line">        <span class="keyword">int</span> m = <span class="built_in">array</span>[i];</span><br><span class="line">        <span class="keyword">if</span>(m != i) &#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">array</span>[m] != m) &#123;</span><br><span class="line">                <span class="comment">// swap</span></span><br><span class="line">                <span class="keyword">int</span> temp = <span class="built_in">array</span>[m];</span><br><span class="line">                <span class="built_in">array</span>[m] = m;</span><br><span class="line">                <span class="built_in">array</span>[i] = temp;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> m;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> len;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> <span class="built_in">array</span>[] = &#123;<span class="number">1</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">0</span>, <span class="number">2</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> len = <span class="keyword">sizeof</span>(<span class="built_in">array</span>) / <span class="keyword">sizeof</span>(<span class="built_in">array</span>[<span class="number">0</span>]);</span><br><span class="line">    <span class="keyword">int</span> dup = find_repeat(<span class="built_in">array</span>, len);</span><br><span class="line">    <span class="keyword">if</span>(dup == len) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;No Repeat Number\n&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Repeat Number: %d\n&quot;</span>, dup);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在其中还可以加上前一节提到的安全、边界等问题的考虑，在下面贴的作者的实现里面可以看到：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">duplicate</span><span class="params">(<span class="keyword">int</span> <span class="built_in">array</span>[], <span class="keyword">int</span> len, <span class="keyword">int</span>* dup)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 考虑参数失效</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">array</span> == <span class="literal">nullptr</span> || len &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 考虑超过边界</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">array</span>[i] &lt; <span class="number">0</span> || <span class="built_in">array</span>[i] &gt; len - <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 实现比较优雅 流程相同</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="built_in">array</span>[i] != i) &#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">array</span>[i] == <span class="built_in">array</span>[<span class="built_in">array</span>[i]]) &#123;</span><br><span class="line">                *dup = <span class="built_in">array</span>[i];</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// swap</span></span><br><span class="line">                <span class="keyword">int</span> temp = <span class="built_in">array</span>[i];</span><br><span class="line">                <span class="built_in">array</span>[i] = <span class="built_in">array</span>[temp];</span><br><span class="line">                <span class="built_in">array</span>[temp] = temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><blockquote><p>面试题3 题目二：不修改数组找出重复的数字。</p></blockquote><p>在长度n+1的数组里的所有数字都在1~n的范围内，所以数组至少有一个数字是重复的。请找出数组中任意一个重复的数字，但不能修改输入的数组。</p><p>这一题虽然可以像题目一那样，只需要多开辟一个n+1长度的辅助数组，用来解决问题，但是这样就多了O(n)的空间开销。</p><p>一般在这种限定情况下，很难再和题目一一样做到时间、空间开销非常小的情况下完成任务，所以可以退一步，不需要缩减到O(n)时间，比如维持和快排复杂度O(nlogn)相同情况下，达成O(1)的空间开销也是一种优化的思路。</p><p>因为出发点不同，我们再次退回到最简单的方法：</p><ul><li>没有额外的空间帮助记录时，就只能每次判断一个数字是否有重复，即判断n次，每次有n长度的遍历开销，也就是O(n^2)；</li></ul><p>所以有<strong>两个优化的方向</strong>：（1）减少判断的次数n；（2）减少遍历长度n。</p><p>在没有额外信息辅助的情况下，优化（2）一般是很难做的（因为每个数只有遍历了全部才知道是否有重复），所以我们可以尝试优化（1）的部分。</p><p>最简单思路下，只有遍历了1~n的n个数在数组中的情况，才能知道谁重复了，我们可以用一些技巧来减少需要判断的次数。</p><p>其实非常巧妙，这条技巧就在题目中：“1~n范围内的数，在长度n+1的数组中必然存在一个重复”，这个命题成立的原因是，如果你遍历一次数组，统计1~n范围内数字的出现次数(n+1)，出现情况是大于n的（这里的n指1~n的这个范围长度），进一步地推广到一个普适命题“i~j范围内的数，在长度n+1的数组中，如果出现次数大于(j-i+1)，那必然存在重复”；</p><p>也就是意味着我们只用使用一次O(n)的遍历时间，就可以确定一个范围的数字是否存在重复。这样的性质可以让我们不断地缩小所需要判断的数字范围，这也就是时间开销上的优化。</p><p>具体地，我们可以联想到二分法：</p><ul><li>一开始将范围1~n分为两部分，一半是1~m，另一半是m+1~n；</li><li>如果范围1~m的数字的统计次数大于m，则这个范围内有重复的数字；否则另一半m+1~n的区间里一定有包含重复的数字；</li><li>继续二分存在重复数字的范围，重复步骤；</li><li>直到确定到某个重复数字。</li></ul><p>比如说题目给的例子{ 2, 3, 5, 4, 3, 2, 6, 7 }：</p><ul><li>[1-4]范围的数字出现5次，[5-7]范围的数字出现3次，重复在[1-4];</li><li>[1-2]范围的数字出现2次，[3-4]范围的数字出现3次，重复在[3-4]；</li><li>[3]数字出现2次，[4]数字出现1次，重复数字是3。</li></ul><p>然后简单分析一下时间复杂度，每次遍历统计的时间开销不变O(n)，因为数字范围二分，一共需要走O(logn)步，所以在O(nlogn)时间中可以找出重复数字。</p><p>完整代码实现：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">is_repeat</span><span class="params">(<span class="keyword">int</span> <span class="built_in">array</span>[], <span class="keyword">int</span> len, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">array</span>[i] &lt;= end &amp;&amp; <span class="built_in">array</span>[i] &gt;= start) &#123;</span><br><span class="line">            count += <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count &gt; (end - start + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find_repeat</span><span class="params">(<span class="keyword">int</span> <span class="built_in">array</span>[], <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> start = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> end = len<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">while</span>(end != start) &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = (end + start) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(is_repeat(<span class="built_in">array</span>, len, start, mid)) &#123;</span><br><span class="line">            end = mid;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            start = mid+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> start;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> <span class="built_in">array</span>[] = &#123;<span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">6</span>, <span class="number">7</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> len = <span class="keyword">sizeof</span>(<span class="built_in">array</span>) / <span class="keyword">sizeof</span>(<span class="built_in">array</span>[<span class="number">0</span>]);</span><br><span class="line">    <span class="keyword">int</span> dup = find_repeat(<span class="built_in">array</span>, len);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Repeat Number: %d\n&quot;</span>, dup); <span class="comment">// 3</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Tips：上述代码没有考虑一些安全、边界问题，所以比较简短。</p><p>需要指出的一点是，上面的使用的这种方法不能保证找出所有重复的数字，例如其中的2也是重复数字，但是算法只找出了3，一个原因是因为只会检查其中一半范围，例如检查到前一半有重复的时候，就不会再检查后一半范围了，另一个原因是算法无法确定是其中一个数字出现2次还是几次。</p><hr><blockquote><p>面试题4：二维数组中的查找</p></blockquote><p>在一个二维整数数组中，每一行从左到右递增，每一列从上到下递增，判断数组中是否含有指定数字。</p><p>例如：</p><div>$$\begin{matrix}1 & 2 & 8 & 9 \\2 & 4 & 9 & 12 \\4 & 7 & 10 & 13 \\6 & 8 & 11 & 15\end{matrix}$$</div><p>当一个数和矩阵中间的一个数比较时，除了相等，还有两种情况：</p><ul><li>(a)当查询数字<strong>小于</strong>目标数字时，说明目标数字<strong>一定不会出现在左上角</strong>，剩下需要判断的区域在其右边和下边；</li><li>(b)当查询数字<strong>大于</strong>目标数字时，说明目标数字<strong>一定不会出现在右下角</strong>，剩下需要判断的区域在其左边和上边。</li></ul><div align="center"><p><img src="/images/s2o-c2-array-cv4.jpg" alt="比较的两种情况"></p></div><p>当我们按照常规思路，尝试从<code>(0,0)</code>出发，向右下角进行搜索时，我们跳转到下一格只有通过2种方式，从上转移到下，和从左转移到右，如果我们把已遍历的位置称为“已知信息”，我们可以看到这种搜索方式，<strong>大部分“已知信息”都集中在左上部</strong>，这在比较出现的两种情况中，要么无法提供任何信息，要么只能提供重叠区域的信息，<strong>无法让转移确定下一次的方向</strong>。</p><p>所以为了<strong>避免“已知信息”的浪费</strong>，我们可以尝试从右上角<code>(0, n-1)</code>出发，向左下角进行搜索，这样会提供更多的信息，如果发生向下转移，代表上边没有比目标数更大的，如果发生向左转移，代表右边的数比目标数更大，所以导致更加明确的在左下角区域中搜索目标数。</p><div align="center"><p><img src="/images/s2o-c2-array-cv4-2.jpg" alt="例子"></p></div><p>完整代码实现：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> matrix[][<span class="number">4</span>], <span class="keyword">int</span> rows, <span class="keyword">int</span> cols, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> j = cols - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(i &lt; rows &amp;&amp; j &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span>(matrix[i][j] &lt; target) &#123;</span><br><span class="line">            i++;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(matrix[i][j] &gt; target) &#123;</span><br><span class="line">            j--;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> matrix[][<span class="number">4</span>] = &#123;</span><br><span class="line">        &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">8</span>, <span class="number">9</span>&#125;,</span><br><span class="line">        &#123;<span class="number">2</span>, <span class="number">4</span>, <span class="number">9</span>, <span class="number">12</span>&#125;,</span><br><span class="line">        &#123;<span class="number">4</span>, <span class="number">7</span>, <span class="number">10</span>, <span class="number">13</span>&#125;,</span><br><span class="line">        &#123;<span class="number">6</span>, <span class="number">8</span>, <span class="number">11</span>, <span class="number">15</span>&#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">int</span> target = <span class="number">7</span>;</span><br><span class="line">    <span class="keyword">if</span>(find(matrix, <span class="number">4</span>, <span class="number">4</span>, target)) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Found!\n&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Not Found!\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;数据结构是技术面的重点，主要围绕数组、字符串、链表、树、栈以及队列这几种常见的数据结构展开。&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="剑指Offer" scheme="https://yumi-cn.github.io/categories/%E5%89%91%E6%8C%87Offer/"/>
    
    
    <category term="笔记" scheme="https://yumi-cn.github.io/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>《剑指Offer》第2章笔记 编程语言</title>
    <link href="https://yumi-cn.github.io/2020/11/25/s2o-c2-lg/"/>
    <id>https://yumi-cn.github.io/2020/11/25/s2o-c2-lg/</id>
    <published>2020-11-25T12:57:25.000Z</published>
    <updated>2020-11-28T09:20:58.171Z</updated>
    
    <content type="html"><![CDATA[<p>第2章主要围绕<strong>编程语言</strong>、<strong>数据结构</strong>和<strong>算法</strong>，介绍技术面所需要的“基础知识”。</p><a id="more"></a><h2 id="编程语言"><a href="#编程语言" class="headerlink" title="编程语言"></a>编程语言</h2><p>书里代码都是用 <code>C/C++/C#</code> 实现的，后面分别从 <code>C++</code> 和 <code>C#</code> 语言的角度来讲述其中一些被问道的细节点，这样的细节点因为篇幅限制，不可能都写进书里，所以还需要通过阅读对应编程语言的书籍来进阶了解，同时其他语言的使用者也可以从其中窥探到面试官在针对语言掌握的考量时，都是从什么样的角度出发的。</p><h3 id="C"><a href="#C" class="headerlink" title="C++"></a>C++</h3><p>通常语言面试的问题有3种类型：</p><ol><li>对于语言中概念的理解程度；</li><li>面对代码，分析运行结果（或错误）；</li><li>在上下文环境中，定义类型或实现函数。</li></ol><p>作者推荐的几本C++书，根据自己的情况选择阅读顺序：</p><ul><li><strong>《Effective C++》</strong>：书中列举了C++经常出现的问题以及解决这些问题的技巧（大多是面试官比较喜欢问的方向），适合面试之前突击C++；</li><li><strong>《C++ Primer》</strong>：人称C++全书，适合全面了解的时候阅读，也可以当作宝典查询；</li><li><strong>《深度探索C++对象模型》</strong>：深度了解C++对象的内部机制，介绍很多较为底层的知识点；</li><li><strong>《The C++ Programming Language》</strong>：C++圣经（大概），适合全面深入掌握C++。</li></ul><p>下面通过一道面试题（第3种类型）来表现一下这类题目是如何考查语言知识点的。</p><blockquote><p>面试题1：赋值运算符函数，如下为类型CMyString的声明，请为该类型添加赋值运算符函数。</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CMyString</span> &#123;</span></span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    CMyString(<span class="keyword">char</span>* pData=<span class="literal">nullptr</span>);</span><br><span class="line">    CMyString(<span class="keyword">const</span> CMyString&amp; str);</span><br><span class="line">    ~CMyString(<span class="keyword">void</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">char</span>* m_pData;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>Tips：赋值运算符主要负责变量在进行赋值 <code>=</code> 运算时，如何处理变量对象内部成员变化。</p><p>定义C++中的<strong>赋值运算符</strong>函数时，需要关注点有：</p><ul><li><strong>返回值类型声明为引用，函数结束前返回实例自身的引用</strong>，因为返回引用才允许连续赋值的情况，例如 <code>str1 = str2 = str3</code>，否则无法通过编译；</li><li>把<strong>传入的参数类型声明为常量引用</strong>，如果不是引用，形参到实参传递会调用一次复制构造函数（函数的传值引用），引用可以避免这样的开销；同时因为赋值运算并不会修改传入的实例的状态，所以应进一步加上 <code>const</code> 关键字；</li><li><strong>释放实例自身已有的内存</strong>，主要在对象有动态分配内存情况下考虑，如果忘记在分配新内存前释放旧内存空间，程序旧出现了内存泄漏(memory leakge)，这块内存无法被回收使用（资源浪费、占用空间导致空间不够用）；</li><li><strong>判断传入参数和当前实例</strong>(*this)是不是同一个实例，是则不进行赋值，如果不判断就直接赋值，在同一个实例情况下，会导致在还没有拷贝到传入参数（自己）的内存时，就释放自己的内存，这也就导致传入参数的内存被释放了（因为函数是传引用），最后找不到待赋值的内容。</li></ul><p>经典解法：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line">CMyString&amp; CMyString::<span class="keyword">operator</span>=(<span class="keyword">const</span> CMyString&amp; str) &#123;</span><br><span class="line">  <span class="keyword">if</span>(<span class="keyword">this</span> == &amp;str) &#123;  <span class="comment">// 对象的 this 是一个地址</span></span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;     <span class="comment">// 传对象 而不是地址</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">delete</span> []m_pData;   <span class="comment">// 数组的释放方式</span></span><br><span class="line">  m_pData = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">  m_pData = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="built_in">strlen</span>(str.m_pData) + <span class="number">1</span>]; <span class="comment">// 申请新空间，多的1位给&#x27;\0&#x27;</span></span><br><span class="line">  <span class="built_in">strcpy</span>(m_pData, str.m_pData); <span class="comment">// 复制 赋值</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果对自己有更高的要求，应该再进一步地考虑其中涉及到的问题。</p><p>前面的函数中，<strong>分配内存之前先释放了内存</strong>，如果在分配内存时，内存不足就会导致 <code>new char</code> 排除异常，<code>m_pData</code>将是一个空指针，并且无法回退到之前的结果，也就是说一旦赋值运算符内部抛出了异常，实例不再保持有效的状态（并不是原有的状态），这违背了异常安全性（Exception Safety）原则（正常情况下，如果抛出异常也不应该导致内容被错误操作）。</p><ul><li>简单的方法是先用 <code>new</code> 分配新内容，再 <code>delete</code> 释放已有的；</li><li>更好的办法是<strong>创建一个临时实例</strong>，再交换临时实例和原来的实例。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line">CMyString&amp; CMyString::<span class="keyword">operator</span>=(<span class="keyword">const</span> CMyString&amp; str) &#123;</span><br><span class="line">  <span class="keyword">if</span>(<span class="keyword">this</span> == &amp;str) &#123;</span><br><span class="line">    CMyString tmp(str); <span class="comment">// 复制构造函数</span></span><br><span class="line">    <span class="built_in">std</span>::swap(m_pData, tmp.m_pData); <span class="comment">// 交换地址</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当 <code>tmp</code> 局部变量遇到 <code>if</code> 结束时，会自动调用它的析构函数，会把交换下来的 <code>this</code> 的 <code>m_pData</code> 所指向的内存释放掉；在新的代码中，在复制构造函数中分配内存，如果由于内存不足抛出异常时，由于此时还没有修改原来的实例状态，实例的状态依旧是有效的（原有的），也就保证了异常安全性。</p><p>完整代码（包含所有实现和测试）：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CMyString</span> &#123;</span></span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    CMyString(<span class="keyword">char</span>* pData); <span class="comment">// 第一个参数设定默认值会导致无法通过编译</span></span><br><span class="line">    CMyString(<span class="keyword">const</span> CMyString&amp; str);</span><br><span class="line">    ~CMyString(<span class="keyword">void</span>);</span><br><span class="line">    CMyString&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> CMyString&amp; str); <span class="comment">// 赋值运算符函数声明</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">void</span>)</span></span>; <span class="comment">// 标准输出函数</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">char</span>* m_pData;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 构造函数</span></span><br><span class="line">CMyString::CMyString(<span class="keyword">char</span>* pData) &#123;</span><br><span class="line">    <span class="keyword">if</span>(pData != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        m_pData = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="built_in">strlen</span>(pData) + <span class="number">1</span>];</span><br><span class="line">        <span class="built_in">strcpy</span>(m_pData, pData);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 复制构造函数</span></span><br><span class="line">CMyString::CMyString(<span class="keyword">const</span> CMyString&amp; str) &#123;</span><br><span class="line">    <span class="keyword">if</span>(str.m_pData != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        m_pData = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="built_in">strlen</span>(str.m_pData) + <span class="number">1</span>];</span><br><span class="line">        <span class="built_in">strcpy</span>(m_pData, str.m_pData);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 析构函数</span></span><br><span class="line">CMyString::~CMyString(<span class="keyword">void</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span>(m_pData != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="keyword">delete</span> []m_pData;</span><br><span class="line">        m_pData = <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CMyString::print</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; m_pData &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 赋值运算符函数</span></span><br><span class="line">CMyString&amp; CMyString::<span class="keyword">operator</span>=(<span class="keyword">const</span> CMyString&amp; str) &#123;</span><br><span class="line">  <span class="keyword">if</span>(<span class="keyword">this</span> != &amp;str) &#123;</span><br><span class="line">    CMyString tmp(str); <span class="comment">// 复制构造函数</span></span><br><span class="line">    <span class="built_in">std</span>::swap(m_pData, tmp.m_pData); <span class="comment">// 交换地址</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 测试CMyString</span></span><br><span class="line">    <span class="function">CMyString <span class="title">str1</span><span class="params">(<span class="string">&quot;Sword&quot;</span>)</span></span>;</span><br><span class="line">    <span class="function">CMyString <span class="title">str2</span><span class="params">(<span class="string">&quot;2&quot;</span>)</span></span>;</span><br><span class="line">    <span class="function">CMyString <span class="title">str3</span><span class="params">(<span class="string">&quot;Offer&quot;</span>)</span></span>;</span><br><span class="line">    str1 = str2 = str3;</span><br><span class="line">    str1.print(); <span class="comment">// Offer</span></span><br><span class="line">    str2.print(); <span class="comment">// Offer</span></span><br><span class="line">    str3.print(); <span class="comment">// Offer</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果完整的去实现上面这个题目，会引出一些非常容易忽略的细节问题（并且会导致严重错误），例如在初始化变量 <code>str1</code> 时，<code>CMyString str1(&quot;Sword&quot;);</code>，其中所传入的参数一般都是程序声明的<strong>字符串常量</strong>，如果在构造函数中简单地实现为：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Mem Error</span></span><br><span class="line">CMyString::CMyString(<span class="keyword">char</span>* pData) &#123;</span><br><span class="line">    m_pData = pData;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>就会导致赋值运算符函数中的析构函数调用过程发生错误，因为析构函数中的 <code>delete []m_pData</code> 的delete操作符只负责操作堆(Heap)中的内存区域(因为new只在堆里申请内存区域)，如果使用delete操作符去释放一个字符串常量指针所指向的区域，就会发生错误（大概是访问越界）。</p><p>所以在初始化时应该使用和delete对应的new操作，在堆中申请内存，再把传入参数的内容复制到其中。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">CMyString::CMyString(<span class="keyword">char</span>* pData) &#123;</span><br><span class="line">    <span class="keyword">if</span>(pData != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        m_pData = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="built_in">strlen</span>(pData) + <span class="number">1</span>];</span><br><span class="line">        <span class="built_in">strcpy</span>(m_pData, pData);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="C-1"><a href="#C-1" class="headerlink" title="C#"></a>C#</h3><p>因为还没怎么学C#的东西，C#的部分暂时跳过，记录一下推荐的书：</p><ul><li>《Professional C#》：特点是附录中有描述C#和其他语言的区别；</li><li>《CLR Via C#》：深入介绍C#，对CLR和.NET进行剖析，可以方便理解装箱卸箱、垃圾回收、反射等概念。</li></ul><blockquote><p>面试题2：实现Singleton模式（单例模式）</p></blockquote><p>暂时跳过。</p><p>涉及到设计模式的部分，列举一些可以参考阅读的资料：</p><ul><li>《设计模式：C++常用设计模式》：<a href="https://refactoringguru.cn/design-patterns/cpp">https://refactoringguru.cn/design-patterns/cpp</a> ；</li><li>《Head First 设计模式》：感觉是一本比较老的书，可能之后看看吧；</li><li>《Game Programming Patterns》：<a href="http://gameprogrammingpatterns.com/contents.html">http://gameprogrammingpatterns.com/contents.html</a> 。</li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;第2章主要围绕&lt;strong&gt;编程语言&lt;/strong&gt;、&lt;strong&gt;数据结构&lt;/strong&gt;和&lt;strong&gt;算法&lt;/strong&gt;，介绍技术面所需要的“基础知识”。&lt;/p&gt;</summary>
    
    
    
    <category term="剑指Offer" scheme="https://yumi-cn.github.io/categories/%E5%89%91%E6%8C%87Offer/"/>
    
    
    <category term="笔记" scheme="https://yumi-cn.github.io/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>《剑指Offer》第1章笔记</title>
    <link href="https://yumi-cn.github.io/2020/11/24/s2o-c1/"/>
    <id>https://yumi-cn.github.io/2020/11/24/s2o-c1/</id>
    <published>2020-11-24T04:57:25.000Z</published>
    <updated>2020-11-28T09:20:54.477Z</updated>
    
    <content type="html"><![CDATA[<p>第1章主要介绍的是几种面试方式的不同流程以及注意事项。</p><blockquote><p>“…技术面试中的5个要素，是全书的大纲,…”</p></blockquote><a id="more"></a><h2 id="远程桌面面试"><a href="#远程桌面面试" class="headerlink" title="远程桌面面试"></a>远程桌面面试</h2><ul><li>思考清楚再开始编码；</li><li>良好的代码命名和缩进对齐；</li><li>单元测试、断点调试。</li></ul><h2 id="面试的3个环节"><a href="#面试的3个环节" class="headerlink" title="面试的3个环节"></a>面试的3个环节</h2><p>行为面试、技术面试、应聘者提问。</p><h3 id="行为面试"><a href="#行为面试" class="headerlink" title="行为面试"></a>行为面试</h3><ol start="0"><li>自我介绍：30s-1min，介绍主要学习和工作经历；</li><li>项目经验：STAR模型描述项目经历；<ul><li>Situation：简短的项目背景；</li><li>Task：自己完成的任务，注意区分“参与”和“负责”；</li><li>Action：如何完成任务的，详细介绍自己完成任务的方式方法；</li><li>Result：自己的贡献，尝试量化自己的产出，让人直接接收到你的成果。</li></ul></li><li>掌握技能：注意区分“了解”、“熟悉”和“精通”；<ul><li>了解：上过课、看过书，但没有做过实际项目，通常只建议有用的时候再写；</li><li>熟悉：通常的情况，指能够独立解决大部分问题；</li><li>精通：得心应手，能够轻松回答领域内的绝大多数问题。</li></ul></li><li>为什么跳槽：尽量不说抱怨层面的原因，多从自我发展的角度阐述选择的理由。</li></ol><h3 id="技术面试"><a href="#技术面试" class="headerlink" title="技术面试"></a>技术面试</h3><p>平均1个小时的面试，技术面试会占据40-50分钟的时间。</p><p>总的来说面试官关注应聘者的5种素质：</p><ul><li>扎实的基础知识：编程语言、数据结构和算法；</li><li>能写高质量的代码：代码鲁棒性，边界考虑（另外还需要注意代码规范或者风格）；</li><li>分析问题的思路清晰：从简单完备的思路出发，用各种方法来尝试优化，例如画图形象化，举例具象化，分解简单化；</li><li>能够优化时间、空间效率：熟知数据结构优缺点，熟练掌握常用算法；</li><li>学习、沟通、综合能力。</li></ul><p>PS：5个要素分别对应本书的第2、3、4、5、6章节内容。</p><h3 id="应聘者提问"><a href="#应聘者提问" class="headerlink" title="应聘者提问"></a>应聘者提问</h3><p>如果觉得面试后临时想比较困难，可以在面试前提前准备一些问题。</p><p>主要围绕公司、职位、项目等工作上的事情，不太适合问较远较模糊或者和工薪相关的问题（之后再和HR聊也可以）。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;第1章主要介绍的是几种面试方式的不同流程以及注意事项。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;“…技术面试中的5个要素，是全书的大纲,…”&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="剑指Offer" scheme="https://yumi-cn.github.io/categories/%E5%89%91%E6%8C%87Offer/"/>
    
    
    <category term="笔记" scheme="https://yumi-cn.github.io/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>11月的计划</title>
    <link href="https://yumi-cn.github.io/2020/11/19/plan-2020/"/>
    <id>https://yumi-cn.github.io/2020/11/19/plan-2020/</id>
    <published>2020-11-18T16:00:00.000Z</published>
    <updated>2020-11-27T13:55:01.557Z</updated>
    
    <content type="html"><![CDATA[<p>11月大概还剩下一周的时间，主要是在尝试起步学一些东西：</p><ul><li>《剑指Offer》：大概前几章，简单过一下摸一下这本书的安排规律，每章尽量写一点浓缩知识点；</li><li>《3D游戏与计算机图形学中的数学方法》：之前把Games101课程简单过了一下，再通过刷这本书巩固一下基础的数学。</li></ul><a id="more"></a><p>12月的初步规划：</p><ul><li>《剑指Offer》；</li><li>《3D游戏与计算机图形学中的数学方法》；</li><li>《Fundamentals of Computer Graphics》 。</li></ul><p>1月的初步规划：</p><ul><li>《Effictive C++》；</li><li>《Real Time Rendering 4th》；</li><li>《游戏引擎架构》。</li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;11月大概还剩下一周的时间，主要是在尝试起步学一些东西：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;《剑指Offer》：大概前几章，简单过一下摸一下这本书的安排规律，每章尽量写一点浓缩知识点；&lt;/li&gt;
&lt;li&gt;《3D游戏与计算机图形学中的数学方法》：之前把Games101课程简单过了一下，再通过刷这本书巩固一下基础的数学。&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="计划-Flags" scheme="https://yumi-cn.github.io/categories/%E8%AE%A1%E5%88%92-Flags/"/>
    
    
  </entry>
  
</feed>
