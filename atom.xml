<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>画码余生</title>
  
  <subtitle>副标题</subtitle>
  <link href="https://yumi-cn.github.io/atom.xml" rel="self"/>
  
  <link href="https://yumi-cn.github.io/"/>
  <updated>2021-01-02T08:43:43.370Z</updated>
  <id>https://yumi-cn.github.io/</id>
  
  <author>
    <name>Yumiko</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>《剑指Offer》第4章笔记 解题的思路 P2</title>
    <link href="https://yumi-cn.github.io/2021/01/02/s2o-c4-part2/"/>
    <id>https://yumi-cn.github.io/2021/01/02/s2o-c4-part2/</id>
    <published>2021-01-02T08:43:28.000Z</published>
    <updated>2021-01-02T08:43:43.370Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>一眼看不出问题的隐藏规律时，说不定能通过举例来发现。</p></blockquote><a id="more"></a><h2 id="1、2-章节"><a href="#1、2-章节" class="headerlink" title="1、2 章节"></a>1、2 章节</h2><p>包含面试题27-29。</p><p>请到《第4章笔记 解题的思路 P1》阅读这部分内容。</p><h2 id="3-举例让抽象问题具体化"><a href="#3-举例让抽象问题具体化" class="headerlink" title="3 举例让抽象问题具体化"></a>3 举例让抽象问题具体化</h2><p>和上一节画图的方法一样，我们也可以借助举例模拟的方法来思考分析复杂的问题。当一眼看不出问题中隐藏的规律时，可以试着用一两个具体的例子模拟操作的过程，说不定能通过具体的例子找到抽象的规律。</p><p>具体的例子也可以帮助我们向面试官解释算法思路，也能帮助我们确保代码的质量，举出来的例子可以当作测试用例检验代码的正确性。</p><h2 id="面试题-30-34"><a href="#面试题-30-34" class="headerlink" title="面试题 30-34"></a>面试题 30-34</h2><blockquote><p>面试题30：包含min函数的栈。</p></blockquote><p>定义栈的数据结构，在该类型中实现一个能够得到栈的最小元素的min函数，在该栈中，调用<code>min</code>、<code>push</code>、<code>pop</code>的时间复杂度都是<code>O(1)</code>。</p><p>这道题容易曲解成是对这一组元素的排序，就容易陷入到一个思维陷阱，开始怀疑是怎么在<code>O(n)</code>时间内做到对这些元素的排序的（常用的排序也需要<code>O(nlogn)</code>的时间），其实多举几个例子可以发现，这个过程并不完全等价于是对一组元素的排序，栈的<code>min</code>值是有条件性的，取决于栈中到底有什么样的元素，以及<strong>这些元素的入栈顺序</strong>，所以用一个相同长度的栈，来存储一个元素入栈后，栈的<code>min</code>值是多少，就可以同步地在<code>O(1)</code>时间里实现<code>min</code>的获取。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> max_len = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">MinStack</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> <span class="built_in">stack</span>[max_len];</span><br><span class="line">    <span class="keyword">int</span> min_stack[max_len];</span><br><span class="line">    <span class="keyword">int</span> anchor = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> elem)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(anchor &lt; max_len - <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="built_in">stack</span>[anchor + <span class="number">1</span>] = elem;</span><br><span class="line">            <span class="keyword">if</span>(anchor == <span class="number">-1</span> || min_stack[anchor] &gt; elem) &#123;</span><br><span class="line">                min_stack[anchor + <span class="number">1</span>] = elem;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                min_stack[anchor + <span class="number">1</span>] = min_stack[anchor];</span><br><span class="line">            &#125;</span><br><span class="line">            anchor++;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// throw error</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> pop() &#123;</span><br><span class="line">        <span class="keyword">if</span>(anchor &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            anchor--;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">stack</span>[anchor + <span class="number">1</span>];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// throw error</span></span><br><span class="line">            <span class="keyword">return</span> - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">min</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(anchor &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> min_stack[anchor];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// throw error</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    MinStack min_stack;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">        min_stack.push(<span class="number">4</span> - i);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;After push %d, min=%d\n&quot;</span>, <span class="number">4</span> - i, min_stack.min());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// After push 4, min=4</span></span><br><span class="line">    <span class="comment">// After push 3, min=3</span></span><br><span class="line">    <span class="comment">// After push 2, min=2</span></span><br><span class="line">    <span class="comment">// After push 1, min=1</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> pop = min_stack.pop();</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;After pop %d, min=%d\n&quot;</span>, pop, min_stack.min());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// After pop 1, min=2</span></span><br><span class="line">    <span class="comment">// After pop 2, min=3</span></span><br><span class="line">    <span class="comment">// After pop 3, min=4</span></span><br><span class="line">    <span class="comment">// After pop 4, min=-1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><blockquote><p>面试题31：栈的压入、弹出序列。</p></blockquote><p>输入两个整数序列，第一个序列表示栈的压入顺序，请判断第二个序列是否为该栈的弹出顺序。假设压入栈的所有数字均不相等，例如<code>&#123;1,2,3,4,5&#125;</code>是某栈的压栈序列，序列<code>&#123;4,5,3,2,1&#125;</code>是该栈的对应一个弹出序列，但<code>&#123;4,3,5,1,2&#125;</code>就不可能是该压栈的弹出序列。</p><p>PS：题目其实说的蛮含糊的，只要理解一个关键点就好了，它指的是执行一系列压栈和弹出操作，并不是先只压栈然后再只弹出，所以一个入栈顺序为<code>&#123;1,2,3,4,5&#125;</code>，出栈顺序也可能是<code>&#123;1,2,3,4,5&#125;</code>（进一个就出一个）。</p><p>比较直观的方法就是用一个栈来模拟整个流程，看这个流程是否能匹配上压栈和弹出的顺序。</p><p>每次压栈结束后，就检查剩余的出栈顺序，如果下一个出栈的元素就栈顶的元素就出栈，并且循环检查，直到无法再出栈。如果入栈都结束后，出栈顺序或者栈内不为空，则表示出栈顺序有错误。</p><p>完整实现代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">is_pop_order</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span>* ppush, <span class="keyword">const</span> <span class="keyword">int</span>* ppop, <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">bool</span> possible = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span>(ppush != <span class="literal">nullptr</span> &amp;&amp; ppop != <span class="literal">nullptr</span> &amp;&amp; len &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">int</span>* pnext_push = ppush;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">int</span>* pnext_pop = ppop;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; <span class="built_in">stack</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(pnext_pop - ppop &lt; len) &#123;</span><br><span class="line">            <span class="keyword">while</span>(<span class="built_in">stack</span>.empty() || <span class="built_in">stack</span>.top() != *pnext_pop) &#123;</span><br><span class="line">                <span class="comment">// 元素压栈</span></span><br><span class="line">                <span class="keyword">if</span>(pnext_push - ppush == len) &#123;</span><br><span class="line">                    <span class="keyword">break</span>; <span class="comment">// 元素全部已入栈</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="built_in">stack</span>.push(*pnext_push);</span><br><span class="line">                pnext_push++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span>(!<span class="built_in">stack</span>.empty() &amp;&amp; <span class="built_in">stack</span>.top() == *pnext_pop) &#123;</span><br><span class="line">                <span class="comment">// 元素出栈</span></span><br><span class="line">                <span class="built_in">stack</span>.pop();</span><br><span class="line">                pnext_pop++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(pnext_push - ppush == len &amp;&amp; pnext_pop - ppop != len) &#123;</span><br><span class="line">                <span class="comment">// 入栈已空，但出栈还未空，不是正确的出栈顺序</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">stack</span>.empty() &amp;&amp; pnext_pop - ppop == len) &#123;</span><br><span class="line">            possible = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> possible;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span>* ppush, <span class="keyword">const</span> <span class="keyword">int</span>* ppop, <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, is_pop_order(ppush, ppop, len)?<span class="string">&quot;yes&quot;</span>:<span class="string">&quot;no&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> push_order[<span class="number">5</span>] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> pop_order1[<span class="number">5</span>] = &#123;<span class="number">4</span>,<span class="number">5</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> pop_order2[<span class="number">5</span>] = &#123;<span class="number">4</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">1</span>,<span class="number">2</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> pop_order3[<span class="number">5</span>] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> pop_order4[<span class="number">5</span>] = &#123;<span class="number">5</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>&#125;;</span><br><span class="line">    test(push_order, pop_order1, <span class="number">5</span>); <span class="comment">// yes</span></span><br><span class="line">    test(push_order, pop_order2, <span class="number">5</span>); <span class="comment">// no</span></span><br><span class="line">    test(push_order, pop_order3, <span class="number">5</span>); <span class="comment">// yes</span></span><br><span class="line">    test(push_order, pop_order4, <span class="number">5</span>); <span class="comment">// yes</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><blockquote><p>面试题32：从上到下打印二叉树。</p></blockquote><p><strong>题目一</strong>：不分行从上到下打印，同一层按照从左到右的顺序打印，节点定义：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> value;</span><br><span class="line">    node* pleft;</span><br><span class="line">    node* pright;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>思路就是之前有提到过的层序遍历了，使用队列的数据结构来辅助遍历。</p><div align="center"><p><img src="/images/s2o-c4-part2-f1.jpg" alt="打印顺序：8,6,10,5,7,9,11"></p></div><p>完整实现代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> value;</span><br><span class="line">    node* pleft;</span><br><span class="line">    node* pright;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">node* <span class="title">init_node</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123; ... &#125;</span><br><span class="line"><span class="function">node* <span class="title">init_tree</span><span class="params">()</span> </span>&#123; ... &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">level_order_traversal</span><span class="params">(node* proot)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(proot == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">queue</span>&lt;node*&gt; q;</span><br><span class="line">    q.push(proot);</span><br><span class="line">    node* pnode;</span><br><span class="line">    <span class="keyword">while</span>(!q.empty()) &#123;</span><br><span class="line">        pnode = q.front();</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, pnode-&gt;value);</span><br><span class="line">        <span class="keyword">if</span>(pnode-&gt;pleft != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            q.push(pnode-&gt;pleft);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(pnode-&gt;pright != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            q.push(pnode-&gt;pright);</span><br><span class="line">        &#125;</span><br><span class="line">        q.pop();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    node* proot = init_tree();</span><br><span class="line">    level_order_traversal(proot);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>PS：书上代码用的队列是<code>deque</code>双端队列，不是很明白作者的用意，这里我就直接用普通队列<code>queue</code>了。</p><p><strong>题目二</strong>：分行从上到下打印二叉树，每一层打印到一行，例如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">8</span></span><br><span class="line"><span class="number">6</span> <span class="number">10</span></span><br><span class="line"><span class="number">5</span> <span class="number">7</span> <span class="number">9</span> <span class="number">11</span></span><br></pre></td></tr></table></figure><p>队列除了保存节点顺序，还要保存一个层数，在题目一代码基础上进行稍微的修改。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;utility&gt; // use std::pair</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;tuple&gt; // use std::tie</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> value;</span><br><span class="line">    node* pleft;</span><br><span class="line">    node* pright;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">node* <span class="title">init_node</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123; ... &#125;</span><br><span class="line"><span class="function">node* <span class="title">init_tree</span><span class="params">()</span> </span>&#123; ... &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">level_order_traversal</span><span class="params">(node* proot)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(proot == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">queue</span>&lt;<span class="built_in">std</span>::<span class="built_in">pair</span>&lt;node*, <span class="keyword">int</span>&gt;&gt; q;</span><br><span class="line">    q.push(<span class="built_in">std</span>::<span class="built_in">make_pair</span>(proot, <span class="number">1</span>));</span><br><span class="line">    node* pnode;</span><br><span class="line">    <span class="keyword">int</span> level;</span><br><span class="line">    <span class="keyword">int</span> last_level = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(!q.empty()) &#123;</span><br><span class="line">        <span class="built_in">std</span>::tie(pnode, level) = q.front();</span><br><span class="line">        <span class="keyword">if</span>(level &gt; last_level) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">            last_level = level;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\t&quot;</span>, pnode-&gt;value);</span><br><span class="line">        <span class="keyword">if</span>(pnode-&gt;pleft != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            q.push(<span class="built_in">std</span>::<span class="built_in">make_pair</span>(pnode-&gt;pleft, level + <span class="number">1</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(pnode-&gt;pright != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            q.push(<span class="built_in">std</span>::<span class="built_in">make_pair</span>(pnode-&gt;pright, level + <span class="number">1</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        q.pop();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    node* proot = init_tree();</span><br><span class="line">    level_order_traversal(proot);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>书上代码把逻辑拆分的有点复杂，不够简洁，所以就用自己的方式来写了，在队列的节点中嵌入了节点的层数，用一个变量<code>last_level</code>来保存上一次打印节点的层数，如果发现已经到了下一层，就先输出一个换行，逻辑上更加简洁。</p><p><strong>题目三</strong>：之字形打印二叉树，第一行按照从左到右顺序，第二行按照从右到左顺序，第三行从左到右，依次类推。</p><p>可以简单地理解为，奇数行照常顺序打印，而偶数行需要逆向打印，所以可以简单地给偶数行添加一个栈结构，先全部压栈，再出栈打印，其他流程照旧，即可实现题目的要求，在题目二的代码基础上稍加修改即可。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;utility&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;tuple&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> value;</span><br><span class="line">    node* pleft;</span><br><span class="line">    node* pright;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">node* <span class="title">init_node</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123; ... &#125;</span><br><span class="line"><span class="function">node* <span class="title">init_tree</span><span class="params">()</span> </span>&#123; ... &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">level_order_traversal_zigzag</span><span class="params">(node* proot)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(proot == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">queue</span>&lt;<span class="built_in">std</span>::<span class="built_in">pair</span>&lt;node*, <span class="keyword">int</span>&gt;&gt; q;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; print_stack;</span><br><span class="line">    q.push(<span class="built_in">std</span>::<span class="built_in">make_pair</span>(proot, <span class="number">1</span>));</span><br><span class="line">    node* pnode;</span><br><span class="line">    <span class="keyword">int</span> level;</span><br><span class="line">    <span class="keyword">int</span> last_level = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(!q.empty()) &#123;</span><br><span class="line">        <span class="built_in">std</span>::tie(pnode, level) = q.front();</span><br><span class="line">        <span class="keyword">if</span>(level &gt; last_level) &#123;</span><br><span class="line">            <span class="keyword">if</span>(level &amp; <span class="number">0x1</span> == <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">while</span>(!print_stack.empty()) &#123;</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;%d\t&quot;</span>, print_stack.top());</span><br><span class="line">                    print_stack.pop();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">            last_level = level;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(level &amp; <span class="number">0x1</span> == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="comment">// 奇数行直接输出</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d\t&quot;</span>, pnode-&gt;value);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 偶数行先压栈</span></span><br><span class="line">            print_stack.push(pnode-&gt;value);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(pnode-&gt;pleft != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            q.push(<span class="built_in">std</span>::<span class="built_in">make_pair</span>(pnode-&gt;pleft, level + <span class="number">1</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(pnode-&gt;pright != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            q.push(<span class="built_in">std</span>::<span class="built_in">make_pair</span>(pnode-&gt;pright, level + <span class="number">1</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        q.pop();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 最后一层是偶数层时， 需要继续清空输出</span></span><br><span class="line">    <span class="keyword">while</span>(!print_stack.empty()) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\t&quot;</span>, print_stack.top());</span><br><span class="line">        print_stack.pop();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    node* proot = init_tree();</span><br><span class="line">    level_order_traversal_zigzag(proot);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>书上的代码逻辑稍微复杂一点，要用两个栈来完成两层的循环之字输出，理解起来稍微比较难，所以我就只是简单地在题目二的基础上进行修改了，逻辑上理解起来更加方便。</p><hr><blockquote><p>面试题33：二叉搜索树的后序遍历序列。</p></blockquote><p>输入一个整数数组，判断该数组是不是<strong>某二叉搜索树的后序遍历结果</strong>。如果是则返回<code>true</code>，否则返回<code>false</code>。假设输入的数组的任意两个数字互不相同，如，<code>&#123;5,7,6,9,11,10,8&#125;</code>，则返回<code>true</code>，因为整数序列是下图的二叉搜索树的后序遍历结果，如果输入<code>&#123;7,4,6,5&#125;</code>，则返回<code>false</code>，无法找到这样的二叉搜索树。</p><div align="center"><p><img src="/images/s2o-c4-part2-f2.jpg"></p></div><p><strong>后序遍历的特点在于最后访问根节点</strong>，所以对于一个树（或子树）的后续遍历序列，根节点都是最后一个数，另外，<strong>对于二叉搜索树的一个节点，其左子树的节点都小于该节点，右子树的节点都大于该节点</strong>，在遍历序列上体现就是前一部分大于节点值，后一部分小于节点值。所以解题的思路就是递归地去分解后续遍历序列，不断的去验证各个节点子树对应的后续遍历是否满足二叉搜索树的特性即可。</p><p>完整实现代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">is_post_order</span><span class="params">(<span class="keyword">int</span> sequence[], <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(sequence == <span class="literal">nullptr</span> || start &gt; end) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(start == end) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> pstart, pend;</span><br><span class="line">    <span class="keyword">for</span>(pstart = start; pstart &lt; end; pstart++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(sequence[pstart] &gt; sequence[end]) &#123;</span><br><span class="line">            pstart--;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(pend = end - <span class="number">1</span>; pend &gt;= start; pend--) &#123;</span><br><span class="line">        <span class="keyword">if</span>(sequence[pend] &lt; sequence[end]) &#123;</span><br><span class="line">            pend++;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(pstart == pend) &#123;</span><br><span class="line">        <span class="comment">// 全偏树，此时所有节点都大于或小于子树根节点</span></span><br><span class="line">        <span class="keyword">return</span> is_post_order(sequence, start, end<span class="number">-1</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(pstart + <span class="number">1</span> == pend) &#123;</span><br><span class="line">        <span class="comment">// 左子树都小于节点，右子树都大于节点</span></span><br><span class="line">        <span class="keyword">bool</span> bleft = is_post_order(sequence, start, pstart);</span><br><span class="line">        <span class="keyword">bool</span> bright = is_post_order(sequence, pend, end<span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">return</span> bleft &amp;&amp; bright;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 不满足要求</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">(<span class="keyword">int</span> sequence[], <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, is_post_order(sequence, start, end)?<span class="string">&quot;yes&quot;</span>:<span class="string">&quot;no&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sequence1[] = &#123; <span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">9</span>,<span class="number">11</span>,<span class="number">10</span>,<span class="number">8</span> &#125;;</span><br><span class="line">    <span class="keyword">int</span> sequence2[] = &#123; <span class="number">7</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">5</span> &#125;;</span><br><span class="line">    test(sequence1, <span class="number">0</span>, <span class="number">6</span>); <span class="comment">// yes</span></span><br><span class="line">    test(sequence2, <span class="number">0</span>, <span class="number">3</span>); <span class="comment">// no</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>比较细致地考虑的话，要记得把全偏树的情况考虑到，此时根节点前面的所有节点都属于一个子树，而不是还是分左子树和右子树。</p><hr><blockquote><p>面试题34：二叉树中和为某一值的路径。</p></blockquote><p>输入<strong>一棵二叉树和一个整数</strong>，打印出二叉树中<strong>节点值的和</strong>为输入整数的所有路径。从树的根节点开始往下一直到叶节点所经过的节点形成一条路径。二叉树节点的定义如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> value;</span><br><span class="line">    node* pleft;</span><br><span class="line">    node* pright;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><div align="center"><p><img src="/images/s2o-c4-part2-f3.jpg" alt="和为22的路径有两条，10、5、7和10、12"></p></div><p>直观的方法应该就是递归地往下遍历所有情况，到叶节点的时候计算路径上的节点和，如果和等于输入的整数，则输出路径。</p><p>完整实现代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> value;</span><br><span class="line">    node* pleft;</span><br><span class="line">    node* pright;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">node* <span class="title">init_node</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123; ... &#125;</span><br><span class="line"><span class="function">node* <span class="title">init_tree</span><span class="params">()</span> </span>&#123; ... &#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;node*&gt; path; <span class="comment">// 存储路径</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">find_path</span><span class="params">(node* pnode, <span class="keyword">int</span> sum, <span class="keyword">int</span> expect_sum)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(pnode == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(pnode-&gt;pleft == <span class="literal">nullptr</span> &amp;&amp; pnode-&gt;pright == <span class="literal">nullptr</span></span><br><span class="line">        &amp;&amp; sum + pnode-&gt;value == expect_sum) &#123;</span><br><span class="line">        <span class="comment">// 满足要求，输出节点</span></span><br><span class="line">        path.push_back(pnode);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; path.size(); i++) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, path[i]-&gt;value);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">        path.pop_back();</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    path.push_back(pnode);</span><br><span class="line">    <span class="keyword">if</span>(pnode-&gt;pleft != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        find_path(pnode-&gt;pleft, sum + pnode-&gt;value, expect_sum);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(pnode-&gt;pright != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        find_path(pnode-&gt;pright, sum + pnode-&gt;value, expect_sum);</span><br><span class="line">    &#125;</span><br><span class="line">    path.pop_back();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    node* tree = init_tree();</span><br><span class="line">    find_path(tree, <span class="number">0</span>, <span class="number">22</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这道题可能会联想到提前剪枝的优化，例如当还没有到叶节点时，发现和已经大于了期望值的和，此时提前停止往下查询的操作叫做剪枝，但需要注意的是本题目中并没有限定节点的值<code>value</code>一定是正数(类型也是<code>int</code>而非<code>unsigned int</code>)，可以出现途中和大于期望值和，所以本题不能用这样的剪枝优化方法。</p><h2 id="4-分解让复杂问题简单化"><a href="#4-分解让复杂问题简单化" class="headerlink" title="4 分解让复杂问题简单化"></a>4 分解让复杂问题简单化</h2><p>包含面试题35-38。</p><p>请到《第4章笔记 高质量代码 P3》阅读这部分内容。</p>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;一眼看不出问题的隐藏规律时，说不定能通过举例来发现。&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="剑指Offer" scheme="https://yumi-cn.github.io/categories/%E5%89%91%E6%8C%87Offer/"/>
    
    
    <category term="笔记" scheme="https://yumi-cn.github.io/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>《剑指Offer》第4章笔记 解题的思路 P1</title>
    <link href="https://yumi-cn.github.io/2021/01/01/s2o-c4-part1/"/>
    <id>https://yumi-cn.github.io/2021/01/01/s2o-c4-part1/</id>
    <published>2021-01-01T08:55:16.000Z</published>
    <updated>2021-01-01T08:57:59.123Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>写代码之前理思路，举例子和画图都是很好的办法。</p></blockquote><a id="more"></a><h2 id="1-面试官谈面试思路"><a href="#1-面试官谈面试思路" class="headerlink" title="1 面试官谈面试思路"></a>1 面试官谈面试思路</h2><p>一些大佬说的话。</p><p>咕咕待更。</p><h2 id="2-画图让抽象问题形象化"><a href="#2-画图让抽象问题形象化" class="headerlink" title="2 画图让抽象问题形象化"></a>2 画图让抽象问题形象化</h2><p>画图是在面试过程中应聘者用来帮助自己分析、推理的常用手段。很多面试题很抽象，不容易找到解决办法。这时不妨画出一些与题目相关的图形，借以辅助自己观察和思考。图形能使抽象的问题具体化、形象化，说不定通过几幅图形就能找到规律，从而找到问题的解决方案。</p><p>有不少与数据结构相关的问题，比如二叉树、二维数组、链表等问题，都可以采用画图的方法来分析。</p><p>面试的时候，需要向面试官解释自己的思路，对于复杂的问题，应聘者光用言语未必能够说清楚，这个时候也可以画出几幅图形，一边看着图形一边讲解。</p><h2 id="面试题27-29"><a href="#面试题27-29" class="headerlink" title="面试题27-29"></a>面试题27-29</h2><blockquote><p>面试题27：二叉树的镜像。</p></blockquote><p>完成一个函数，输入一棵二叉树，函数输出它的镜像。二叉树节点定义：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> value;</span><br><span class="line">    node* pleft;</span><br><span class="line">    node* pright;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><div align="center"><p><img src="/images/s2o-c4-part1-f1.jpg"></p></div><p>画出一个镜像的二叉树后，观察可以发现只要简单地从上到下地交换每个节点的左右节点即可。</p><p>完整实现代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> value;</span><br><span class="line">    node* pleft;</span><br><span class="line">    node* pright;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">node* <span class="title">init_node</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123; ... &#125;</span><br><span class="line"><span class="function">node* <span class="title">init_tree</span><span class="params">()</span> </span>&#123; ... &#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">in_order_print</span><span class="params">(node* pnode)</span> </span>&#123; ... &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mirror_recursively</span><span class="params">(node* pnode)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(pnode == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    node* temp = pnode-&gt;pleft;</span><br><span class="line">    pnode-&gt;pleft = pnode-&gt;pright;</span><br><span class="line">    pnode-&gt;pright = temp;</span><br><span class="line">    mirror_recursively(pnode-&gt;pleft);</span><br><span class="line">    mirror_recursively(pnode-&gt;pright);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    node* tree = init_tree();</span><br><span class="line">    in_order_print(tree);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    mirror_recursively(tree);</span><br><span class="line"></span><br><span class="line">    in_order_print(tree);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果不使用递归，而是使用循环实现的话，可以考虑用一个队列来实现点的从上到下遍历的模拟，每访问一个节点，交换完毕后，将左右子节点加入到队列中，每次从队列中取出一个节点进行交换子节点操作，直到所有节点被处理完毕。</p><hr><blockquote><p>面试题28：对称的二叉树。</p></blockquote><p>请实现一个函数，用来判断一棵二叉树是不是对称的。如果一棵二叉树和它的镜像一样，那么它是对称的。</p><div align="center"><p><img src="/images/s2o-c4-part1-f2.jpg" alt="3棵二叉树，只有第一棵是对称的"></p></div><p>完整实现代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> value;</span><br><span class="line">    node* pleft;</span><br><span class="line">    node* pright;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">node* <span class="title">init_node</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123; ... &#125;</span><br><span class="line"><span class="function">node* <span class="title">init_tree</span><span class="params">()</span> </span>&#123; ... &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">is_symmetrical</span><span class="params">(node* pnode1, node* pnode2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(pnode1 == <span class="literal">nullptr</span> &amp;&amp; pnode2 == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(pnode1 == <span class="literal">nullptr</span> || pnode2 == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(pnode1-&gt;value == pnode2-&gt;value) &#123;</span><br><span class="line">        <span class="keyword">bool</span> lr_result = is_symmetrical(pnode1-&gt;pleft, pnode2-&gt;pright);</span><br><span class="line">        <span class="keyword">bool</span> rl_result = is_symmetrical(pnode1-&gt;pright, pnode2-&gt;pleft);</span><br><span class="line">        <span class="keyword">return</span> lr_result &amp;&amp; rl_result;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">is_symmetrical</span><span class="params">(node* proot)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(proot == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> is_symmetrical(proot-&gt;pleft, proot-&gt;pright);</span><br><span class="line">    <span class="comment">// 或者可以写为 虽然会多一倍计算过程 但代码精简到一行，有点抽象</span></span><br><span class="line">    <span class="comment">// return is_symmetrical(proot, proot);</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    node* tree = init_tree();</span><br><span class="line">    <span class="keyword">if</span>(is_symmetrical(tree)) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Tree is symmetrical.\n&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Tree is not symmetrical.\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><blockquote><p>面试题29：顺时针打印矩阵。</p></blockquote><p>输入一个矩阵，按照从外向里以顺时针的顺序依次打印出每一个数字。例如，如果输入如下矩阵，则依次打印数字1、2、3、4、8、12、16、15、15、13、9、5、6、7、11、10。</p><div align="center"><p><img src="/images/s2o-c4-part1-f3.jpg"></p></div><p>完整实现代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print_matrix_clockwise</span><span class="params">(<span class="keyword">int</span>** matrix, <span class="keyword">int</span> rows, <span class="keyword">int</span> cols)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(matrix == <span class="literal">nullptr</span> || rows &lt;= <span class="number">0</span> || cols &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> up = <span class="number">0</span>, bottom = rows<span class="number">-1</span>, left = <span class="number">0</span>, right = cols<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">int</span> i, j;</span><br><span class="line">    <span class="keyword">while</span>(up &lt; bottom &amp;&amp; left &lt; right) &#123;</span><br><span class="line">        <span class="comment">// 从左到右打印</span></span><br><span class="line">        i = up;</span><br><span class="line">        <span class="keyword">for</span>(j = left; j &lt;= right; j++) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, matrix[i][j]);</span><br><span class="line">        &#125;</span><br><span class="line">        up++;</span><br><span class="line">        <span class="comment">// 从上到下打印</span></span><br><span class="line">        j = right;</span><br><span class="line">        <span class="keyword">for</span>(i = up; i &lt;= bottom; i++) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, matrix[i][j]);</span><br><span class="line">        &#125;</span><br><span class="line">        right--;</span><br><span class="line">        <span class="comment">// 从右到左打印</span></span><br><span class="line">        i = bottom;</span><br><span class="line">        <span class="keyword">for</span>(j = right; j &gt;= left; j--) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, matrix[i][j]);</span><br><span class="line">        &#125;</span><br><span class="line">        bottom--;</span><br><span class="line">        <span class="comment">// 从下到上打印</span></span><br><span class="line">        j = left;</span><br><span class="line">        <span class="keyword">for</span>(i = bottom; i &gt;= up; i--) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, matrix[i][j]);</span><br><span class="line">        &#125;</span><br><span class="line">        left++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 当列数或行数是奇数时</span></span><br><span class="line">    <span class="comment">// 会出现多余一列或者一行的情况</span></span><br><span class="line">    <span class="keyword">if</span>(rows &amp; <span class="number">0x1</span> == <span class="number">1</span> || cols &amp; <span class="number">0x1</span> == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">// 最后一列</span></span><br><span class="line">        <span class="keyword">if</span>(up &lt; bottom) &#123;</span><br><span class="line">            j = left;</span><br><span class="line">            <span class="keyword">for</span>(i = up; i &lt;= bottom; i++) &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, matrix[i][j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 最后一行</span></span><br><span class="line">        <span class="keyword">if</span>(left &lt; right) &#123;</span><br><span class="line">            i = up;</span><br><span class="line">            <span class="keyword">for</span>(j = left; j &lt;= right; j++) &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, matrix[i][j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> rows = <span class="number">4</span>, cols = <span class="number">4</span>;</span><br><span class="line">    <span class="keyword">int</span>** matrix = <span class="keyword">new</span> <span class="keyword">int</span>*[rows];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; rows; i++) &#123;</span><br><span class="line">        matrix[i] = <span class="keyword">new</span> <span class="keyword">int</span>[cols];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; cols; j++) &#123;</span><br><span class="line">            matrix[i][j] = i * <span class="number">4</span> + j + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    print_matrix_clockwise((<span class="keyword">int</span>**)matrix, rows, cols);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在实现完整代码的时候，其中需要注意的一个问题是，二维数组的传参问题，如果想像题目一样传指针的方式传参，就需要在主函数使用动态数组的申请方式，用普通的声明方式<code>int matrix[][]</code>再强转<code>(int**)matrix</code>虽说可以传入到函数中，但访问数组会发生错误（原因暂时没有去细究了，应该和内存段的访问相关）。</p><h2 id="3-举例让抽象问题具体化"><a href="#3-举例让抽象问题具体化" class="headerlink" title="3 举例让抽象问题具体化"></a>3 举例让抽象问题具体化</h2><p>包含面试题30-34。</p><p>请到《第4章笔记 高质量代码 P2》阅读这部分内容。</p><h2 id="4-分解让复杂问题简单化"><a href="#4-分解让复杂问题简单化" class="headerlink" title="4 分解让复杂问题简单化"></a>4 分解让复杂问题简单化</h2><p>包含面试题35-38。</p><p>请到《第4章笔记 高质量代码 P3》阅读这部分内容。</p>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;写代码之前理思路，举例子和画图都是很好的办法。&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="剑指Offer" scheme="https://yumi-cn.github.io/categories/%E5%89%91%E6%8C%87Offer/"/>
    
    
    <category term="笔记" scheme="https://yumi-cn.github.io/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>《剑指Offer》第3章笔记 高质量代码 P2</title>
    <link href="https://yumi-cn.github.io/2021/01/01/s2o-c3-part2/"/>
    <id>https://yumi-cn.github.io/2021/01/01/s2o-c3-part2/</id>
    <published>2021-01-01T04:26:35.000Z</published>
    <updated>2021-01-01T04:22:23.734Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>鲁棒是英文Robust的音译，有时也翻译成健壮性。</p></blockquote><a id="more"></a><div align="center"><p><img src="/images/s2o-c3-part2-f4.jpg"></p></div><h2 id="1、2、3-章节"><a href="#1、2、3-章节" class="headerlink" title="1、2、3 章节"></a>1、2、3 章节</h2><p>请到《第3章笔记 高质量代码 P1》阅读这部分内容。</p><h2 id="4-代码的鲁棒性"><a href="#4-代码的鲁棒性" class="headerlink" title="4 代码的鲁棒性"></a>4 代码的鲁棒性</h2><p>提高代码的鲁棒性的有效途径是进行防御性编程。防御性编程是一种编程习惯，是指预见在什么地方可能会出现问题，并为这些可能出现的问题制定处理方式。</p><p>在面试时，最简单也是最实用的防御性变成就是在函数入口添加代码以验证用户输入是否符合要求。通常面试要求的是写一两个函数，我们需要格外关注这些函数的输入参数。当然并不是所有与鲁棒性相关的问题都是检查输入的参数这么简单，有时候要关注稍微隐含一点的逻辑中，可能会发生的潜在问题。</p><h2 id="面试题22-26"><a href="#面试题22-26" class="headerlink" title="面试题22-26"></a>面试题22-26</h2><blockquote><p>面试题22：链表中倒数第K个节点</p></blockquote><p>输入一个链表，输出该链表中倒数第k个节点。这里的k从1开始计数，即链表的尾节点是倒数第1个节点。如，一个链表有6个节点，从头节点开始，他们的值依次是1、2、3、4、5、6，这个链表的倒数第3个节点是值为4的节点。链表节点定义如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> value;</span><br><span class="line">    node* pnext;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这里面需要考虑到的一个问题是，虽然输入的数据是<code>k</code>是正常的整数，但还要考虑链表中是否有大于等于<code>k</code>个的节点。思路就是简单的用两个间隔距离为<code>k-1</code>的指针来解决。</p><p>完整代码实现：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> value;</span><br><span class="line">    node* pnext;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">node* <span class="title">init_node</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123; ... &#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert_node</span><span class="params">(node** phead, node* pnode)</span> </span>&#123; ... &#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(node** phead)</span> </span>&#123; ... &#125;</span><br><span class="line"></span><br><span class="line"><span class="function">node* <span class="title">find_k_to_tail</span><span class="params">(node** phead, <span class="keyword">unsigned</span> <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(phead == <span class="literal">nullptr</span> || *phead == <span class="literal">nullptr</span> || k == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    node* left = *phead;</span><br><span class="line">    node* right = *phead;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k<span class="number">-1</span> &amp;&amp; right != <span class="literal">nullptr</span>; i++) &#123;</span><br><span class="line">        right = right-&gt;pnext;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(right == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(right-&gt;pnext != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        right = right-&gt;pnext;</span><br><span class="line">        left = left-&gt;pnext;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> left;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    node** phead = <span class="keyword">new</span> node*;</span><br><span class="line">    *phead = <span class="literal">nullptr</span>;</span><br><span class="line">    node** node_list = <span class="keyword">new</span> node*[<span class="number">10</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">        node* new_node = init_node(i);</span><br><span class="line">        node_list[i] = new_node;</span><br><span class="line">        insert_node(phead, new_node);</span><br><span class="line">    &#125;</span><br><span class="line">    print(phead); <span class="comment">// 0 1 2 3 4 5 6 7 8 9</span></span><br><span class="line">    node* first_node = find_k_to_tail(phead, <span class="number">10</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;first node: %d\n&quot;</span>, first_node-&gt;value);</span><br><span class="line">    <span class="comment">// first node: 0</span></span><br><span class="line">    node* last_second_node = find_k_to_tail(phead, <span class="number">2</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;last second node: %d\n&quot;</span>, last_second_node-&gt;value);</span><br><span class="line">    <span class="comment">// last second node: 8</span></span><br><span class="line">    node* last_node = find_k_to_tail(phead, <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;last node: %d\n&quot;</span>, last_node-&gt;value);</span><br><span class="line">    <span class="comment">// last node: 9</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><blockquote><p>面试题23：链表中环的入口节点</p></blockquote><p>如果一个链表包含环，如何找出环的入口节点？例如，在如下图所示的链表中，环的入口节点是节点3。</p><div align="center"><p><img src="/images/s2o-c3-part2-f1.jpg"></p></div><ol><li>如何确定链表有环？两个指针，一个1次1步，一个1次2步，如果1次2步的指针“追上了”1次1步的指针，则代表有环，如果指针遇到<code>nullptr</code>则无环；</li><li>如果有环，如何确定环的入口在哪？假设我们知道环里面节点的个数为<code>4</code>，则可以用两个指针，第一个指针先走4步（到达图中第5个节点），第二指针从1开始，同时开始移动，当两个指针相遇时（图中会相遇在第3个节点），即是环的入口节点；</li><li>问题从“<strong>判断环的入口在哪</strong>”转换成了“<strong>如何判断一个环里有多少个节点？</strong>”；判断环里有多少个节点可以用第一步中的结果，固定一个指针，移动一个指针，当两个指针又相遇时，则可以计数出环中的节点个数。</li></ol><p>完整代码实现：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> value;</span><br><span class="line">    node* pnext;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">node* <span class="title">init_node</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123; ... &#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert_node</span><span class="params">(node** phead, node* pnode)</span> </span>&#123; ... &#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(node** phead)</span> </span>&#123; ... &#125;</span><br><span class="line"></span><br><span class="line"><span class="function">node* <span class="title">meeting_node</span><span class="params">(node** phead)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(phead == <span class="literal">nullptr</span> || *phead == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    node* pslow = (*phead)-&gt;pnext;</span><br><span class="line">    node* pfast = pslow-&gt;pnext;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(pfast != <span class="literal">nullptr</span> &amp;&amp; pfast != pslow) &#123;</span><br><span class="line">        pslow = pslow-&gt;pnext;</span><br><span class="line">        pfast = pfast-&gt;pnext;</span><br><span class="line">        <span class="keyword">if</span>(pfast != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            pfast = pfast-&gt;pnext;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(pfast == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> pfast;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">node* <span class="title">find_loop_entry</span><span class="params">(node** phead)</span> </span>&#123;</span><br><span class="line">    node* mnode = meeting_node(phead);</span><br><span class="line">    <span class="keyword">if</span>(mnode == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="comment">// 无环或输入数据错误</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 得到环中的节点数目</span></span><br><span class="line">    <span class="keyword">int</span> nodes_in_loop = <span class="number">1</span>;</span><br><span class="line">    node* pnode1 = mnode;</span><br><span class="line">    <span class="keyword">while</span>(pnode1-&gt;pnext != mnode) &#123;</span><br><span class="line">        pnode1 = pnode1-&gt;pnext;</span><br><span class="line">        nodes_in_loop++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 移动pnode1，次数为欢中节点数目</span></span><br><span class="line">    pnode1 = *phead;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nodes_in_loop; i++) &#123;</span><br><span class="line">        pnode1 = pnode1-&gt;pnext;</span><br><span class="line">    &#125;</span><br><span class="line">    node* pnode2 = *phead;</span><br><span class="line">    <span class="comment">// 再同时移动pnode1和pnode2</span></span><br><span class="line">    <span class="keyword">while</span>(pnode1 != pnode2) &#123;</span><br><span class="line">        pnode1 = pnode1-&gt;pnext;</span><br><span class="line">        pnode2 = pnode2-&gt;pnext;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> pnode1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    node** phead = <span class="keyword">new</span> node*;</span><br><span class="line">    *phead = <span class="literal">nullptr</span>;</span><br><span class="line">    node** node_list = <span class="keyword">new</span> node*[<span class="number">6</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">6</span>; i++) &#123;</span><br><span class="line">        node* new_node = init_node(i+<span class="number">1</span>);</span><br><span class="line">        node_list[i] = new_node;</span><br><span class="line">        insert_node(phead, new_node);</span><br><span class="line">    &#125;</span><br><span class="line">    print(phead);</span><br><span class="line">    <span class="comment">// 1 2 3 4 5 6</span></span><br><span class="line">    <span class="keyword">if</span>(find_loop_entry(phead) == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;No loop yet.\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 尾节点指向第3个节点</span></span><br><span class="line">    node_list[<span class="number">5</span>]-&gt;pnext = node_list[<span class="number">2</span>];</span><br><span class="line">    node* loop_entry = find_loop_entry(phead);</span><br><span class="line">    <span class="keyword">if</span>(loop_entry == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;No loop, Error.\n&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Loop entry at %d.\n&quot;</span>, loop_entry-&gt;value);</span><br><span class="line">        <span class="comment">// Loop entry at 3.</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><blockquote><p>面试题24：反转链表</p></blockquote><p>定义一个函数，输入一个链表的头节点，反转该链表并输出反转后链表的头节点，链表节点定义如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> value;</span><br><span class="line">    node* pnext;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>思路就是新建一个头结点，在遍历链表的时候，不断的把节点插入到新链表的头节点，最后完成倒序。</p><p>完整实现代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> value;</span><br><span class="line">    node* pnext;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">node* <span class="title">init_node</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123; ... &#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert_node</span><span class="params">(node** phead, node* pnode)</span> </span>&#123; ... &#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(node** phead)</span> </span>&#123; ... &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">reverse</span><span class="params">(node** phead)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(phead == <span class="literal">nullptr</span> || *phead == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    node** new_phead = <span class="keyword">new</span> node*;</span><br><span class="line">    *new_phead = <span class="literal">nullptr</span>;</span><br><span class="line">    node* pnode = *phead;</span><br><span class="line">    <span class="keyword">while</span>(pnode != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        *phead = pnode-&gt;pnext;</span><br><span class="line">        <span class="keyword">if</span>(*new_phead == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            pnode-&gt;pnext = <span class="literal">nullptr</span>;</span><br><span class="line">            *new_phead = pnode;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            pnode-&gt;pnext = *new_phead;</span><br><span class="line">            *new_phead = pnode;</span><br><span class="line">        &#125;</span><br><span class="line">        pnode = *phead;</span><br><span class="line">    &#125;</span><br><span class="line">    *phead = *new_phead;</span><br><span class="line">    *new_phead = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">delete</span> new_phead;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    node** phead = <span class="keyword">new</span> node*;</span><br><span class="line">    *phead = <span class="literal">nullptr</span>;</span><br><span class="line">    node** node_list = <span class="keyword">new</span> node*[<span class="number">10</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">        node* new_node = init_node(i+<span class="number">1</span>);</span><br><span class="line">        node_list[i] = new_node;</span><br><span class="line">        insert_node(phead, new_node);</span><br><span class="line">    &#125;</span><br><span class="line">    print(phead);</span><br><span class="line">    <span class="comment">// 1 2 3 4 5 6 7 8 9 10</span></span><br><span class="line">    reverse(phead);</span><br><span class="line">    print(phead);</span><br><span class="line">    <span class="comment">// 10 9 8 7 6 5 4 3 2 1</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><blockquote><p>面试题25：合并两个排序的链表。</p></blockquote><p>输入两个递增排序的链表，合并这两个链表并使新链表中的节点仍然是递增排序的。</p><div align="center"><p><img src="/images/s2o-c3-part2-f2.jpg"></p></div><p>思路也没有很复杂，就是不断比较头结点大小，然后插入新链表的尾部，不过要注意一些实现细节，例如其中一个链表提前为空后的插入方法、算法结束判断、输入的各种可能性。</p><p>完整实现代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> value;</span><br><span class="line">    node* pnext;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">node* <span class="title">init_node</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123; ... &#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert_node</span><span class="params">(node** phead, node* pnode)</span> </span>&#123; ... &#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(node** phead)</span> </span>&#123; ... &#125;</span><br><span class="line"></span><br><span class="line"><span class="function">node** <span class="title">order_merge</span><span class="params">(node** phead1, node** phead2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(phead1 == <span class="literal">nullptr</span> || *phead1 == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> phead2;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(phead2 == <span class="literal">nullptr</span> || *phead2 == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> phead1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    node** phead;</span><br><span class="line">    *phead = <span class="literal">nullptr</span>;</span><br><span class="line">    node* pnode = <span class="literal">nullptr</span>;</span><br><span class="line">    node* temp = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(*phead1 != <span class="literal">nullptr</span> &amp;&amp; *phead2 != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span>((*phead1)-&gt;value &lt;= (*phead2)-&gt;value) &#123;</span><br><span class="line">            temp = *phead1;</span><br><span class="line">            *phead1 = temp-&gt;pnext;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            temp = *phead2;</span><br><span class="line">            *phead2 = temp-&gt;pnext;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(*phead == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            *phead = temp;</span><br><span class="line">            pnode = *phead;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            pnode-&gt;pnext = temp;</span><br><span class="line">            pnode = temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(*phead1 != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        pnode-&gt;pnext = *phead1;</span><br><span class="line">        pnode = pnode-&gt;pnext;</span><br><span class="line">        *phead1 = (*phead1)-&gt;pnext;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(*phead2 != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        pnode-&gt;pnext = *phead2;</span><br><span class="line">        pnode = pnode-&gt;pnext;</span><br><span class="line">        *phead2 = (*phead2)-&gt;pnext;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    pnode-&gt;pnext = <span class="literal">nullptr</span>;</span><br><span class="line">    pnode = <span class="literal">nullptr</span>;</span><br><span class="line">    temp = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">delete</span> pnode;</span><br><span class="line">    <span class="keyword">delete</span> temp;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> phead;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    node** phead1 = <span class="keyword">new</span> node*;</span><br><span class="line">    node** phead2 = <span class="keyword">new</span> node*;</span><br><span class="line">    *phead1 = <span class="literal">nullptr</span>;</span><br><span class="line">    *phead2 = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">        node* new_node1 = init_node(i * <span class="number">2</span>);</span><br><span class="line">        node* new_node2 = init_node(i * <span class="number">2</span> + <span class="number">1</span>);</span><br><span class="line">        insert_node(phead1, new_node1);</span><br><span class="line">        insert_node(phead2, new_node2);</span><br><span class="line">    &#125;</span><br><span class="line">    print(phead1); <span class="comment">// 0 2 4 6</span></span><br><span class="line">    print(phead2); <span class="comment">// 1 3 5 7</span></span><br><span class="line">    node** phead3 = order_merge(phead1, phead2);</span><br><span class="line">    print(phead3); <span class="comment">// 0 1 2 3 4 5 6 7</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>书上写的是递归版本，但是这里考虑到时间效率优化（其实是没想到），就写成循环实现了，会稍微长一点点。</p><hr><blockquote><p>面试题26：树的子结构</p></blockquote><p>输入两颗二叉树<code>A</code>和<code>B</code>，判断<code>B</code>是不是<code>A</code>的子结构。二叉树节点定义：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span></span><br><span class="line">    <span class="keyword">double</span> value;</span><br><span class="line">    node* pleft;</span><br><span class="line">    node* pright;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>关于<strong>子结构</strong>的定义，如下图中的两棵二叉树，A中有一部分子树的结构和B是一样的，所以B是A的子结构。</p><div align="center"><p><img src="/images/s2o-c3-part2-f3.jpg" alt="左A，右B"></p></div><ol><li>第一步在树A中查找与根节点的值一样的节点，实际上是树的遍历；</li><li>判断树A中以R为根节点的子树是不是和树B具有相同的结构。</li></ol><p>完整实现代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span></span><br><span class="line">    <span class="keyword">double</span> value;</span><br><span class="line">    node* pleft;</span><br><span class="line">    node* pright;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">node* <span class="title">init_node</span><span class="params">(<span class="keyword">double</span> value)</span> </span>&#123; ... &#125;</span><br><span class="line"><span class="function">node* <span class="title">init_a_tree</span><span class="params">()</span> </span>&#123; ... &#125;</span><br><span class="line"><span class="function">node* <span class="title">init_b_tree</span><span class="params">()</span> </span>&#123; ... &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> eps = <span class="number">1e-7</span>;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">equal</span><span class="params">(<span class="keyword">double</span> d1, <span class="keyword">double</span> d2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>((d1 - d2) &gt; -eps &amp;&amp; (d1 - d2) &lt; eps) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">does_tree1_have_tree2</span><span class="params">(node* proot1, node* proot2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(proot2 == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(proot1 == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(!equal(proot1-&gt;value, proot2-&gt;value)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 检查左子树</span></span><br><span class="line">    <span class="keyword">bool</span> left_result = does_tree1_have_tree2(proot1-&gt;pleft, proot2-&gt;pleft);</span><br><span class="line">    <span class="comment">// 检查右子树</span></span><br><span class="line">    <span class="keyword">bool</span> right_result = does_tree1_have_tree2(proot1-&gt;pright, proot2-&gt;pright);</span><br><span class="line">    <span class="keyword">return</span> left_result &amp;&amp; right_result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">is_sub_tree</span><span class="params">(node* proot1, node* proot2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">bool</span> result = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(proot1 != <span class="literal">nullptr</span> &amp;&amp; proot2 != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span>(equal(proot1-&gt;value, proot2-&gt;value)) &#123;</span><br><span class="line">            <span class="comment">// 检查根节点是否为B树子结构</span></span><br><span class="line">            result = does_tree1_have_tree2(proot1, proot2);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(!result) &#123;</span><br><span class="line">            <span class="comment">// 检查左子树是否为B树子结构</span></span><br><span class="line">            result = is_sub_tree(proot1-&gt;pleft, proot2);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(!result) &#123;</span><br><span class="line">            <span class="comment">// 检查右子树是否为B树子结构</span></span><br><span class="line">            result = is_sub_tree(proot1-&gt;pright, proot2);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    node* tree_a = init_a_tree();</span><br><span class="line">    node* tree_b = init_b_tree();</span><br><span class="line">    <span class="keyword">if</span>(is_sub_tree(tree_a, tree_b)) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Tree A has Tree B.\n&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Tree A does not have Tree B.\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>需要注意地方有两个，一个是在使用指针前一定要先对其进行判断，另一个是注意题目给的<code>value</code>类型是<code>double</code>，在判断相等时不能只是简单地使用<code>==</code>，要使用精度阈值的判断方法<code>fabs(n1 - n2) &lt; eps</code>。</p>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;鲁棒是英文Robust的音译，有时也翻译成健壮性。&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="剑指Offer" scheme="https://yumi-cn.github.io/categories/%E5%89%91%E6%8C%87Offer/"/>
    
    
    <category term="笔记" scheme="https://yumi-cn.github.io/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>《剑指Offer》第3章笔记 高质量代码 P1</title>
    <link href="https://yumi-cn.github.io/2020/12/30/s2o-c3-part1/"/>
    <id>https://yumi-cn.github.io/2020/12/30/s2o-c3-part1/</id>
    <published>2020-12-30T11:05:35.000Z</published>
    <updated>2020-12-30T11:14:58.937Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>除了程序代码的正确性，经常我们还要关注它的鲁棒性。</p></blockquote><a id="more"></a><h2 id="1-面试官谈代码质量"><a href="#1-面试官谈代码质量" class="headerlink" title="1 面试官谈代码质量"></a>1 面试官谈代码质量</h2><blockquote><p>“一般会考查应聘人员对代码的容错处理能力，对一些特别的输入会询问应聘人员是否考虑、如何处理。不能容忍代码只是针对一种假想的‘正常值’进行处理，不考虑异常状况，也不考虑资源的回收等问题。”</p><p>—— 殷焰（支付宝，高级安全测试工程师）</p></blockquote><blockquote><p>“如果是因为粗心犯错，则可以原谅，因为毕竟面试的时候会紧张；不能容忍的是，该掌握的知识点却没有掌握，而且提醒了还不知道。”</p><p>—— 马凌洲（Autodesk，软件开发经理）</p></blockquote><blockquote><p>“最不能容忍功能错误，忽略边界情况。”</p><p>—— 尹彦（英特尔，软件工程师）</p></blockquote><blockquote><p>“如果一个程序员连变量、函数命名都毫无章法，解决一个具体问题都找不到一个最合适的数据结构，那么这会让面试官对他的印象大打折扣，因为这只能说明他程序写得太少，不够熟悉。”</p><p>—— 吴斌（英伟达，图形设计师）</p></blockquote><blockquote><p>“我会从程序的正确性和鲁棒性两方面检验代码的质量。会关注对输入参数的检查、处理错误和异常的方式、命名方式等。对于没有工作经验的学生，程序正确性之外的错误基本都能容忍，但经过提示后希望能够很快解决。对于有工作经验的人，不能容忍考虑不周到，有明显的鲁棒性错误。”</p><p>—— 田超（微软，SDE ||）</p></blockquote><hr><h2 id="2-代码的规范性"><a href="#2-代码的规范性" class="headerlink" title="2 代码的规范性"></a>2 代码的规范性</h2><p>面试官会根据应聘者写出的代码来决定是否录用他，如果应聘者代码写的不够规范，影响面试官阅读代码的兴致，那么面试官就会默默地减去几分。<strong>书写、布局和命名</strong>都决定着代码的规范性。</p><div align="center"><p><img src="/images/s2o-c3-part1-f1.jpg" alt="影响代码规范性的因素"></p></div><p>首先，<strong>清晰的规范的代码书写</strong>。写的慢一点也可以，把字母、数字、符号写清楚。</p><p>其次，<strong>清晰的规范的代码布局</strong>。缩进、对齐的一些布局格式要注意统一。</p><p>最后，<strong>合理的规范的代码命名</strong>。建议在写代码时，用完整的英文单词组合命名变量和函数。比如函数传入一个二叉树的根节点作为参数，则可以把该参数命名为<code>BinaryTreeNode* pRoot</code>，不用觉得这样多写字母会麻烦，如果一眼能看出变量、函数的用途，应聘者就能避免搞混淆而犯一些低级错误（除了循环量<code>i,j,k</code>这种，其他都要注意），同时合理的命名也能让面试官一眼读懂代码的意图。</p><hr><h2 id="3-代码的完整性"><a href="#3-代码的完整性" class="headerlink" title="3 代码的完整性"></a>3 代码的完整性</h2><p>面试官会通过检查代码是否完整来考查应聘者的思维是否全面，一般会检查代码是否完成了基本功能、输入边界值是否能得到正确地输出、是否对各种不合规范的非法输入做出了合理的错误处理。</p><h3 id="3-1-3个方面确保完整性"><a href="#3-1-3个方面确保完整性" class="headerlink" title="3.1 3个方面确保完整性"></a>3.1 3个方面确保完整性</h3><p>咕咕待更。</p><h3 id="3-2-3种错误处理的方法"><a href="#3-2-3种错误处理的方法" class="headerlink" title="3.2 3种错误处理的方法"></a>3.2 3种错误处理的方法</h3><p>咕咕待更。</p><h3 id="3-3-面试题-16-21"><a href="#3-3-面试题-16-21" class="headerlink" title="3.3 面试题 16-21"></a>3.3 面试题 16-21</h3><blockquote><p>面试题16：数值的整数次方。</p></blockquote><p>实现函数<code>double Power(double base, int exponent)</code>，求<code>base</code>的<code>exponent</code>次方，不得使用库函数，不需要考虑大数问题（只考虑结果在double的表达范围）。</p><p>完整实现代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> g_invalid_input = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">double</span> eps = <span class="number">1e-8</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">equal</span><span class="params">(<span class="keyword">double</span> lhs, <span class="keyword">double</span> rhs)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">double</span> big = (lhs &gt; rhs)?lhs:rhs;</span><br><span class="line">    <span class="keyword">double</span> small = (big != lhs)?lhs:rhs;</span><br><span class="line">    <span class="keyword">return</span> (big - small) &lt;= eps;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">power_with_unsigned_exp</span><span class="params">(<span class="keyword">double</span> base, <span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="built_in">exp</span>)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// exp只为正数，内部只关心几次方的计算</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">exp</span> == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">exp</span> == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> base;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 考虑用递归数学公式来加速幂计算</span></span><br><span class="line">        <span class="comment">// exp &gt;&gt; 1，int右移1位，等价于除以2向下取整，优化计算速度</span></span><br><span class="line">        <span class="keyword">double</span> result = power_with_unsigned_exp(base, <span class="built_in">exp</span> &gt;&gt; <span class="number">1</span>);</span><br><span class="line">        result *= result;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">exp</span> &amp; <span class="number">0x1</span> == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="comment">// 判断是否为奇数，这种方式比 % 2 == 0，速度更快</span></span><br><span class="line">            result *= base;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">power</span><span class="params">(<span class="keyword">double</span> base, <span class="keyword">int</span> <span class="built_in">exp</span>)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 考虑exp 为正、为负、为0的情况</span></span><br><span class="line"></span><br><span class="line">    g_invalid_input = <span class="literal">false</span>; <span class="comment">// 初始化全局变量</span></span><br><span class="line">    <span class="keyword">if</span>(equal(base, <span class="number">0.0</span>) &amp;&amp; <span class="built_in">exp</span> &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        g_invalid_input = <span class="literal">true</span>; <span class="comment">// 也可以考虑其他错误处理方式</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0.0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> abs_exp = (<span class="keyword">unsigned</span> <span class="keyword">int</span>)((<span class="built_in">exp</span> &lt; <span class="number">0</span>)?-<span class="built_in">exp</span>:<span class="built_in">exp</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">double</span> result = power_with_unsigned_exp(base, abs_exp);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (<span class="built_in">exp</span> &lt; <span class="number">0</span>)?(<span class="number">1.0</span> / result):(result);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; power(<span class="number">2</span>, <span class="number">4</span>) &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 16</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; power(<span class="number">10</span>, <span class="number">5</span>) &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 100000</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; power(<span class="number">13</span>, <span class="number">-2</span>) &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 0.00591716</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; power(<span class="number">0</span>, <span class="number">0</span>) &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 1</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><blockquote><p>面试题17：打印从1到最大的n位数。</p></blockquote><p>输入数字<code>n</code>，按顺序打印出<code>1</code>到最大的<code>n</code>位十进制数。比如输入3，从1、2、3一直打印到最大的3位数999。</p><p>用字符串模拟大数加法进位的方式：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">char</span>* number)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 对于前面的空0，不再打印</span></span><br><span class="line">    <span class="keyword">int</span> len = <span class="built_in">strlen</span>(number);</span><br><span class="line">    <span class="keyword">bool</span> begin = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(!begin &amp;&amp; number[i] == <span class="string">&#x27;0&#x27;</span>) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(!begin &amp;&amp; number[i] != <span class="string">&#x27;0&#x27;</span>) &#123;</span><br><span class="line">            begin = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>, number[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">increment</span><span class="params">(<span class="keyword">char</span>* number)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">bool</span> is_overflow = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">int</span> carry = <span class="number">0</span>; <span class="comment">// 进位量</span></span><br><span class="line">    <span class="keyword">int</span> len = <span class="built_in">strlen</span>(number);</span><br><span class="line">    <span class="comment">// 模拟加法进位</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = len - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="keyword">int</span> sum = number[i] - <span class="string">&#x27;0&#x27;</span> + carry;</span><br><span class="line">        <span class="keyword">if</span>(i == len - <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="comment">// 末位加1 increment</span></span><br><span class="line">            sum++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(sum &gt;= <span class="number">10</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span>(i == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// 已经在最高位，进位就溢出了</span></span><br><span class="line">                is_overflow = <span class="literal">true</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                carry = <span class="number">1</span>;</span><br><span class="line">                sum -= <span class="number">10</span>;</span><br><span class="line">                number[i] = <span class="string">&#x27;0&#x27;</span> + sum;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            number[i] = <span class="string">&#x27;0&#x27;</span> + sum;</span><br><span class="line">            carry = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> is_overflow;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print_1_to_n_max</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span>* number = <span class="keyword">new</span> <span class="keyword">char</span>[n + <span class="number">1</span>]; <span class="comment">// 多一位给结尾符 \0</span></span><br><span class="line">    <span class="built_in">memset</span>(number, <span class="string">&#x27;0&#x27;</span>, n);</span><br><span class="line">    number[n] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(!increment(number)) &#123;</span><br><span class="line">        print(number);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">delete</span>[] number;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    print_1_to_n_max(<span class="number">3</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>还可以考虑用全排列的方式，就不用再考虑进位的问题，代码就简洁了很多：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">char</span>* number)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 对于前面的空0，不再打印</span></span><br><span class="line">    <span class="keyword">int</span> len = <span class="built_in">strlen</span>(number);</span><br><span class="line">    <span class="keyword">bool</span> begin = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(!begin &amp;&amp; number[i] == <span class="string">&#x27;0&#x27;</span>) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(!begin &amp;&amp; number[i] != <span class="string">&#x27;0&#x27;</span>) &#123;</span><br><span class="line">            begin = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>, number[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(begin == <span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>); <span class="comment">// 修正部分，不打印全0的情况</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print_1_to_n_max_rec</span><span class="params">(<span class="keyword">char</span>* number, <span class="keyword">int</span> len, <span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(index == len) &#123;</span><br><span class="line">        print(number);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">        number[index] = i + <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        print_1_to_n_max_rec(number, len, index + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print_1_to_n_max_permutation</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">char</span>* number = <span class="keyword">new</span> <span class="keyword">char</span>[n + <span class="number">1</span>];</span><br><span class="line">    <span class="built_in">memset</span>(number, <span class="string">&#x27;0&#x27;</span>, n);</span><br><span class="line">    number[n] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line"></span><br><span class="line">    print_1_to_n_max_rec(number, n, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">delete</span>[] number;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    print_1_to_n_max_permutation(<span class="number">3</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不过全排列的方法有一个容易忽略的漏洞，就算按照书上的代码运行，会出现一个多余的打印情况<code>print(&quot;000&quot;)</code>，这是因为这是全排列的起点，而想修改全排列的起点为<code>001</code>还稍微有点麻烦，这个时候你会发现其实<code>print</code>并不会把<code>000</code>打印出来，但是会多打印一个<code>\n</code>换行，所以只要简单修改一下<code>print</code>，让其只在非<code>000</code>的情况下才换行，这样看起来我们的输出起点就是<code>1</code>了。</p><hr><blockquote><p>面试题18：删除链表的节点。</p></blockquote><p><strong>题目一</strong>：在O(1)的时间内删除链表节点。</p><p>给定单向链表的头指针和一个节点指针，定义一个函数在<code>O(1)</code>时间内删除该节点。链表节点与函数的定义如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> value;</span><br><span class="line">    node* pnext;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">delete_node</span><span class="params">(node** phead, node* pdelete)</span></span>;</span><br></pre></td></tr></table></figure><p>完整实现代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> value;</span><br><span class="line">    node* pnext;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">node* <span class="title">init_node</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">    node* pnode = <span class="keyword">new</span> node;</span><br><span class="line">    pnode-&gt;value = value;</span><br><span class="line">    pnode-&gt;pnext = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">return</span> pnode;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert_node</span><span class="params">(node** phead, node* pnode)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(*phead == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        *phead = pnode;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    node* temp = *phead;</span><br><span class="line">    <span class="keyword">while</span>(temp-&gt;pnext != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        temp = temp-&gt;pnext;</span><br><span class="line">    &#125;</span><br><span class="line">    temp-&gt;pnext = pnode;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">delete_node</span><span class="params">(node** phead, node* pdelete)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!phead || !pdelete) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(pdelete-&gt;pnext != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="comment">// 删除非尾节点，拷贝节点</span></span><br><span class="line">        node* pnext = pdelete-&gt;pnext;</span><br><span class="line">        pdelete-&gt;value = pnext-&gt;value;</span><br><span class="line">        pdelete-&gt;pnext = pnext-&gt;pnext;</span><br><span class="line">        <span class="comment">// 删除节点</span></span><br><span class="line">        <span class="keyword">delete</span> pnext;</span><br><span class="line">        pnext = <span class="literal">nullptr</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(*phead == pdelete) &#123;</span><br><span class="line">        <span class="comment">// 删除尾节点，并且链表只有一个节点</span></span><br><span class="line">        <span class="keyword">delete</span> pdelete;</span><br><span class="line">        pdelete = <span class="literal">nullptr</span>;</span><br><span class="line">        *phead = <span class="literal">nullptr</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 删除尾节点，只能从头找起</span></span><br><span class="line">        node* pnode = *phead;</span><br><span class="line">        <span class="keyword">while</span>(pnode-&gt;pnext != pdelete) &#123;</span><br><span class="line">            pnode = pnode-&gt;pnext;</span><br><span class="line">        &#125;</span><br><span class="line">        pnode-&gt;pnext = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">delete</span> pdelete;</span><br><span class="line">        pdelete = <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(node** phead)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(*phead == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    node* pnode = *phead;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, pnode-&gt;value);</span><br><span class="line">    <span class="keyword">while</span>(pnode-&gt;pnext != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        pnode = pnode-&gt;pnext;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, pnode-&gt;value);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    node** phead = <span class="keyword">new</span> node*;</span><br><span class="line">    *phead = <span class="literal">nullptr</span>;</span><br><span class="line">    node** node_list = <span class="keyword">new</span> node*[<span class="number">10</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">        node* new_node = init_node(i);</span><br><span class="line">        node_list[i] = new_node;</span><br><span class="line">        insert_node(phead, new_node);</span><br><span class="line">    &#125;</span><br><span class="line">    print(phead); <span class="comment">// 0 1 2 3 4 5 6 7 8 9</span></span><br><span class="line">    <span class="comment">// 删除头节点</span></span><br><span class="line">    delete_node(phead, node_list[<span class="number">0</span>]);</span><br><span class="line">    <span class="comment">// 删除尾节点</span></span><br><span class="line">    delete_node(phead, node_list[<span class="number">9</span>]);</span><br><span class="line">    <span class="comment">// 删除中间节点</span></span><br><span class="line">    delete_node(phead, node_list[<span class="number">5</span>]);</span><br><span class="line">    print(phead); <span class="comment">// 1 2 3 4 6 7 8</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码有三个需要讨论的地方：</p><ol><li><strong>关于时间复杂度</strong>，如果是尾节点，则需要<code>O(n)</code>时间，如果是非尾节点，则需要<code>O(1)</code>时间，平均情况下<code>[(n-1)*O(1) + O(n)]/n = O(1)</code>，这也是书上说明的情况，<strong>但如果你真的要较真</strong>，你说：“我就是尾节点也想做到<code>O(1)</code>时间，可不可以？” 我说当然可以，再细想一下尾节点需要<code>O(n)</code>的原因，因为我们没有办法知道它的前一个节点是什么，那整个链表里面有没有什么地方是可以让我们保留一个额外的指针的地方呢？当然有，那就是尾节点没有利用起来的<code>pnext</code>，如果你将尾节点的<code>pnext</code>指向它的前一个节点，那自然删除也只需要<code>O(1)</code>时间了，当然这会影响到一些其他过程，例如判断达到尾节点的方式就和以往的<code>pnode-&gt;pnext == nullptr</code>不同了，但方法终归是可行的，尤其是如果面试官再进一步问是否还可以更优化时；</li><li><strong>上述代码仍然不是完美代码</strong>，主要是指的完整性上，因为它基于一个假设：<strong>要删除的节点的确在链表中</strong>，需要<code>O(n)</code>的时间才能判断链表中是否包含某一个节点（不借助其他数据结构情况下），受到题目的<code>O(1)</code>时间限制，所以这部分就没有再考虑了，可以和面试官进行说明；</li><li>代码中用来<strong>删除节点的部分</strong>，用了一个保存节点的<code>node_list</code>数组，但这个数组中的节点情况并不会一直地和链表的节点情况保持一致，因为方法中涉及到了节点的拷贝，取决于删除的情况，数组<code>i</code>位置保存节点的<code>value</code>很有可能并不是<code>i</code>，也有可能链表中<code>i</code>值的节点还在，而<code>node_list</code>中<code>i</code>位置的指针已经被设置为<code>nullptr</code>。</li></ol><p><strong>题目二</strong>：删除链表中重复的节点。</p><p>在一个<strong>排序的链表</strong>中，如何删除重复的节点？</p><p>PS：这道题在书上的图3.4应该是打印出错了，初始链表的几个节点都没有打全，总之就是链表中重复的节只保留一个。另外，注意题目中的<strong>已排序</strong>条件。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> value;</span><br><span class="line">    node* pnext;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">delete_duplication</span><span class="params">(node** phead)</span></span>;</span><br></pre></td></tr></table></figure><p>完整实现代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> value;</span><br><span class="line">    node* pnext;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">node* <span class="title">init_node</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123; ... &#125;; <span class="comment">// 和上面代码的相同</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert_node</span><span class="params">(node** phead, node* pnode)</span> </span>&#123; ... &#125;; <span class="comment">// 和上面代码的相同</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(node** phead)</span> </span>&#123; ... &#125;; <span class="comment">// 和上面代码的相同</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">delete_duplication</span><span class="params">(node** phead)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(phead == <span class="literal">nullptr</span> || *phead == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    node* pprenode = <span class="literal">nullptr</span>;</span><br><span class="line">    node* pnode = *phead;</span><br><span class="line">    <span class="keyword">while</span>(pnode != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        node* pnext = pnode-&gt;pnext;</span><br><span class="line">        <span class="keyword">bool</span> need_delete = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(pnext != <span class="literal">nullptr</span> &amp;&amp; pnext-&gt;value == pnode-&gt;value) &#123;</span><br><span class="line">            need_delete = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        pprenode = pnode; <span class="comment">// 修改的代码</span></span><br><span class="line">        <span class="keyword">if</span>(!need_delete) &#123;</span><br><span class="line">            <span class="comment">// pprenode = pnode; // 原代码</span></span><br><span class="line">            pnode = pnode-&gt;pnext;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">int</span> value = pnode-&gt;value;</span><br><span class="line">            node* ptobedel = pnext; <span class="comment">// 修改的代码</span></span><br><span class="line">            <span class="comment">// node* ptobedel = pnode; // 原代码</span></span><br><span class="line">            <span class="keyword">while</span>(ptobedel != <span class="literal">nullptr</span> &amp;&amp; ptobedel-&gt;value == value) &#123;</span><br><span class="line">                pnext = ptobedel-&gt;pnext;</span><br><span class="line">                <span class="keyword">delete</span> ptobedel;</span><br><span class="line">                ptobedel = <span class="literal">nullptr</span>;</span><br><span class="line">                ptobedel = pnext;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(pprenode == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">                *phead = pnext;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                pprenode-&gt;pnext = pnext;</span><br><span class="line">            &#125;</span><br><span class="line">            pnode = pnext;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    node** phead = <span class="keyword">new</span> node*;</span><br><span class="line">    *phead = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">        node* new_node = init_node(i / <span class="number">2</span>);</span><br><span class="line">        insert_node(phead, new_node);</span><br><span class="line">    &#125;</span><br><span class="line">    print(phead); <span class="comment">// 0 0 1 1 2 2 3 3 4 4</span></span><br><span class="line">    delete_duplication(phead);</span><br><span class="line">    print(phead); <span class="comment">// 0 1 2 3 4</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>init_node</code>、<code>insert_node</code>以及<code>print</code>函数均和18题题目一的代码相同，不再赘述。</p><p>PS：需要说明的一点是，书上的<code>delete_duplication</code>代码和我这里所写的代码有细微差别，原因是<strong>对原题目的理解偏差问题</strong>，如果原题目所说的<strong>删除重复的节点</strong>不需要留下一个被重复的节点（即一个都不留），则看上面代码的原代码部分，如果是需要保留一个节点，就看修改后的部分。</p><hr><blockquote><p>面试题19：正则表达式匹配</p></blockquote><p>题目：请实现一个函数用来匹配包含 <code>.</code> 和 <code>*</code> 的正则表达式。模式中的字符 <code>.</code> 表示任意一个字符，而 <code>*</code> 表示它前面的字符可以出现任意次（含0次），匹配是指<strong>字符串的所有字符匹配整个模式</strong>，例如，字符串 <code>&quot;aaa&quot;</code> 与模式 <code>a.a</code> 和 <code>ab*ac*a</code> 匹配，但与 <code>aa.a</code> 和 <code>ab*a</code> 均不匹配。</p><p>遇到字符时，和模式串的对应字符进行比较：</p><ul><li>如果是<strong>普通字符</strong>，则直接比较匹配，后移指针；</li><li>如果是 <code>.</code>，匹配任意字符，后移指针；</li><li>如果发现字符的下一位是 <code>*</code>，就有两种情况了：<ul><li>如果是<strong>再匹配一次</strong>的情况，先检验是否匹配，如果匹配，则字符串指针后移，匹配串指针不后移；如果不匹配，则只能考虑将匹配串指针后移两位(跳过<code>*</code>)；</li><li>如果是<strong>不再匹配一次</strong>的情况，匹配串指针后移两位（跳过<code>*</code>）；</li><li>两种情况都要考虑到，所以需要用到递归来判断其中一个分支是否可行。</li></ul></li></ul><p>完整实现代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">match_core</span><span class="params">(<span class="keyword">char</span>* str, <span class="keyword">char</span>* pattern)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%c %c \n&quot;</span>, *str, *pattern);</span><br><span class="line">    <span class="keyword">if</span>(*str == <span class="string">&#x27;\0&#x27;</span> &amp;&amp; *pattern == <span class="string">&#x27;\0&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(*str != <span class="string">&#x27;\0&#x27;</span> &amp;&amp; *pattern == <span class="string">&#x27;\0&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(*(pattern + <span class="number">1</span>) == <span class="string">&#x27;*&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span>((*pattern == <span class="string">&#x27;.&#x27;</span> &amp;&amp; *str != <span class="string">&#x27;\0&#x27;</span>) || *str == *pattern) &#123;</span><br><span class="line">            <span class="keyword">return</span> match_core(str + <span class="number">1</span>, pattern) || match_core(str, pattern + <span class="number">2</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> match_core(str, pattern + <span class="number">2</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>((*pattern == <span class="string">&#x27;.&#x27;</span> &amp;&amp; *str != <span class="string">&#x27;\0&#x27;</span>) || *str == *pattern) &#123;</span><br><span class="line">        <span class="keyword">return</span> match_core(str + <span class="number">1</span>, pattern + <span class="number">1</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">match</span><span class="params">(<span class="keyword">char</span>* str, <span class="keyword">char</span>* pattern)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(str == <span class="literal">nullptr</span> || pattern == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> match_core(str, pattern);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> str[<span class="number">100</span>] = <span class="string">&quot;aaa&quot;</span>;</span><br><span class="line">    <span class="keyword">char</span> pattern[<span class="number">100</span>] = <span class="string">&quot;ab*ac*a&quot;</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Match? %s \n&quot;</span>, match(str, pattern) ? <span class="string">&quot;true&quot;</span> : <span class="string">&quot;false&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码中，需要注意的一个点是，对于匹配串的字符是<code>.</code>时，不能只是简单的只看匹配串，还要看<strong>被匹配串是否有字符可以匹配</strong>，所以不能只是简单地写为<code>if(*pattern == &#39;.&#39; || ...)</code>，应该写为<code>if((*pattern == &#39;.&#39; &amp;&amp; *str != &#39;\0&#39;) || ...)</code>，如果忽略这个细节，你不会在题目提供的几个输入输出上发现问题，但如果你多尝试其他的输入输出，尤其是当匹配串为<code>.*</code>(匹配任意字符)，你会发现结果是错误的。</p><hr><blockquote><p>面试题20：表示数值的字符串</p></blockquote><p>实现一个函数用来判断字符串是否表示数值（包括整数和小数），例如字符串<code>&quot;+100&quot;</code>、<code>&quot;5e2&quot;</code>、<code>&quot;-123&quot;</code>、<code>&quot;3.1416&quot;</code>及<code>&quot;-1E-16&quot;</code>都表示数值，但<code>&quot;12e&quot;</code>、<code>&quot;1a3.14&quot;</code>、<code>&quot;1.2.3&quot;</code>、<code>&quot;+-5&quot;</code>及<code>&quot;12e+5.4&quot;</code>都不是。</p><p>表示数值的字符串遵循模式 <code>A[.[B]][e|EC]</code> 或者 <code>.B[e|EC]</code>，其中A为数值的整数部分，B紧跟小数点为数值的小数部分，C紧跟着<code>e</code>或者<code>E</code>为数值的指数部分。A和C都是可能以<code>+</code>或者<code>-</code>开头的<code>0~9</code>的数位串，B也是<code>0~9</code>的数位串，但前面不能有正负号。</p><p>完整实现代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">scan_unsigned_inter</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>** str)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>* before = *str;</span><br><span class="line">    <span class="keyword">while</span>(**str != <span class="string">&#x27;\0&#x27;</span> &amp;&amp; **str &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; **str &lt;= <span class="string">&#x27;9&#x27;</span>) &#123;</span><br><span class="line">        (*str)++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> *str &gt; before;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">scan_integer</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>** str)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(**str == <span class="string">&#x27;+&#x27;</span> || **str == <span class="string">&#x27;-&#x27;</span>) &#123;</span><br><span class="line">        (*str)++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> scan_unsigned_inter(str);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">is_numberic</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* str)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(str == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// A[.[B]][e|EC] 或者 .B[e|EC]</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查A部分</span></span><br><span class="line">    <span class="keyword">bool</span> a_is_numeric = scan_integer(&amp;str);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">bool</span> b_is_numeric = <span class="literal">true</span>;</span><br><span class="line">    <span class="comment">// 如果碰到小数点，检查B部分</span></span><br><span class="line">    <span class="keyword">if</span>(*str == <span class="string">&#x27;.&#x27;</span>) &#123;</span><br><span class="line">        str++;</span><br><span class="line">        b_is_numeric = scan_unsigned_inter(&amp;str);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">bool</span> c_is_numeric = <span class="literal">true</span>;</span><br><span class="line">    <span class="comment">// 如果碰到e或E，检查C部分</span></span><br><span class="line">    <span class="keyword">if</span>(*str == <span class="string">&#x27;e&#x27;</span> || *str == <span class="string">&#x27;E&#x27;</span>) &#123;</span><br><span class="line">        str++;</span><br><span class="line">        c_is_numeric = scan_integer(&amp;str);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">bool</span> all_scan = (*str == <span class="string">&#x27;\0&#x27;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// (A || B) &amp;&amp; C &amp;&amp; End</span></span><br><span class="line">    <span class="keyword">return</span> (a_is_numeric || b_is_numeric) &amp;&amp; c_is_numeric &amp;&amp; all_scan;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print_is_numberic</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* str)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s %s\n&quot;</span>, str, is_numberic(str)?<span class="string">&quot;yes&quot;</span>:<span class="string">&quot;no&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    print_is_numberic(<span class="string">&quot;+100&quot;</span>); <span class="comment">// +100 yes</span></span><br><span class="line">    print_is_numberic(<span class="string">&quot;5e2&quot;</span>); <span class="comment">// 5e2 yes</span></span><br><span class="line">    print_is_numberic(<span class="string">&quot;-123&quot;</span>); <span class="comment">// -123 yes</span></span><br><span class="line">    print_is_numberic(<span class="string">&quot;3.1416&quot;</span>); <span class="comment">// 3.1416 yes</span></span><br><span class="line">    print_is_numberic(<span class="string">&quot;-1E-16&quot;</span>); <span class="comment">// -1E-16 yes</span></span><br><span class="line">    print_is_numberic(<span class="string">&quot;12e&quot;</span>); <span class="comment">// 12e no</span></span><br><span class="line">    print_is_numberic(<span class="string">&quot;1a3.14&quot;</span>); <span class="comment">// 1a3.14 no</span></span><br><span class="line">    print_is_numberic(<span class="string">&quot;1.2.3&quot;</span>); <span class="comment">// 1.2.3 no</span></span><br><span class="line">    print_is_numberic(<span class="string">&quot;+-5&quot;</span>); <span class="comment">// +-5 no</span></span><br><span class="line">    print_is_numberic(<span class="string">&quot;12e+5.4&quot;</span>); <span class="comment">// 12e+5.4 no</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码中需要注意的一个点是，书上原代码中是把各部分判断拆开计算逻辑合并的，但是我为了更加直观地写出其中逻辑思路，将各部分的判断都留到了最后，最后我们如果稍微一疏忽，容易就写成<code>A || B &amp;&amp; C &amp;&amp; End</code>，在C++中，<strong>逻辑运算符的结合反向是从左到右的</strong>，所以有可能你会把这种写法理解成<code>(A || B) &amp;&amp; C &amp;&amp; End</code>，<strong>但是</strong>，<strong>逻辑运算符之间的优先级顺序是</strong>，<code>! &gt; &amp;&amp; &gt; ||</code>，这会导致计算结果等价于<code>A || (B &amp;&amp; C &amp;&amp; End)</code>，即只要<code>A==true</code>就会判定为数字，这当然不正确的，所以要得到正确的结果，应该显式的写为<code>(A || B) &amp;&amp; C &amp;&amp; End</code>，避免计算错误。</p><hr><blockquote><p>面试题21：调整数组顺序使奇数位于偶数前面</p></blockquote><p>输入一个整数数组，实现一个函数来调整该数组中数字的顺序，使得<strong>所有奇数位于数组的前半部分</strong>，<strong>所有偶数位于数组的后半部分</strong>。</p><p>针对这道题的最优解法，在数组头尾设置两个指针，依次开始向中间扫描，如果左指针遇到偶数则停下，右指针遇到奇数则停下，然后交换两个指针指向的内容，直到两个指针相遇，算法停止，最后结果满足题目要求。</p><p>完整实现代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">reorder_odd_even</span><span class="params">(<span class="keyword">int</span>* <span class="built_in">array</span>, <span class="keyword">unsigned</span> <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">array</span> == <span class="literal">nullptr</span> || len == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span>* pleft = <span class="built_in">array</span>;</span><br><span class="line">    <span class="keyword">int</span>* pright = <span class="built_in">array</span> + len - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(pleft &lt; pright) &#123;</span><br><span class="line">        <span class="comment">// 左指针遇到偶数停</span></span><br><span class="line">        <span class="keyword">while</span>(pleft &lt; pright &amp;&amp; (*pleft &amp; <span class="number">0x1</span>) != <span class="number">0</span>) &#123;</span><br><span class="line">            pleft++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 右指针遇到奇数停</span></span><br><span class="line">        <span class="keyword">while</span>(pleft &lt; pright &amp;&amp; (*pright &amp; <span class="number">0x1</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">            pright--;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> temp = *pleft;</span><br><span class="line">        *pleft = *pright;</span><br><span class="line">        *pright = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> <span class="built_in">array</span>[<span class="number">10</span>] = &#123;<span class="number">0</span>, <span class="number">2</span>, <span class="number">9</span>, <span class="number">1</span>, <span class="number">6</span>, <span class="number">5</span>, <span class="number">8</span>, <span class="number">7</span>, <span class="number">3</span>, <span class="number">4</span>&#125;;</span><br><span class="line">    reorder_odd_even(<span class="built_in">array</span>, <span class="number">10</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, <span class="built_in">array</span>[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 3 7 9 1 5 6 8 2 0 4</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可扩展的解法，不固定其中的判别逻辑，可以将<strong>任意两类定义的数据</strong>进行这样的前后分离：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 这里用到的是一个函数指针，将一个函数传给另一个函数内部使用</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">reorder</span><span class="params">(<span class="keyword">int</span>* <span class="built_in">array</span>, <span class="keyword">unsigned</span> <span class="keyword">int</span> len, <span class="keyword">bool</span> (*func)(<span class="keyword">int</span>))</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">array</span> == <span class="literal">nullptr</span> || len == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span>* pleft = <span class="built_in">array</span>;</span><br><span class="line">    <span class="keyword">int</span>* pright = <span class="built_in">array</span> + len - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(pleft &lt; pright) &#123;</span><br><span class="line">        <span class="comment">// 左指针遇到偶数停</span></span><br><span class="line">        <span class="keyword">while</span>(pleft &lt; pright &amp;&amp; !func(*pleft)) &#123;</span><br><span class="line">            pleft++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 右指针遇到奇数停</span></span><br><span class="line">        <span class="keyword">while</span>(pleft &lt; pright &amp;&amp; func(*pright)) &#123;</span><br><span class="line">            pright--;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> temp = *pleft;</span><br><span class="line">        *pleft = *pright;</span><br><span class="line">        *pright = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">is_even</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (n &amp; <span class="number">0x1</span>) == <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">is_odd</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (n &amp; <span class="number">0x1</span>) != <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> <span class="built_in">array</span>[<span class="number">10</span>] = &#123;<span class="number">0</span>, <span class="number">2</span>, <span class="number">9</span>, <span class="number">1</span>, <span class="number">6</span>, <span class="number">5</span>, <span class="number">8</span>, <span class="number">7</span>, <span class="number">3</span>, <span class="number">4</span>&#125;;</span><br><span class="line">    reorder(<span class="built_in">array</span>, <span class="number">10</span>, is_even);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, <span class="built_in">array</span>[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 3 7 9 1 5 6 8 2 0 4</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    reorder(<span class="built_in">array</span>, <span class="number">10</span>, is_odd);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, <span class="built_in">array</span>[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 4 0 2 8 6 5 1 9 7 3</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="4-代码的鲁棒性"><a href="#4-代码的鲁棒性" class="headerlink" title="4 代码的鲁棒性"></a>4 代码的鲁棒性</h2><p>请到《第3章笔记 高质量代码 P2》阅读这部分内容。</p>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;除了程序代码的正确性，经常我们还要关注它的鲁棒性。&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="剑指Offer" scheme="https://yumi-cn.github.io/categories/%E5%89%91%E6%8C%87Offer/"/>
    
    
    <category term="笔记" scheme="https://yumi-cn.github.io/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>1月的计划</title>
    <link href="https://yumi-cn.github.io/2020/12/23/plan-2021-01/"/>
    <id>https://yumi-cn.github.io/2020/12/23/plan-2021-01/</id>
    <published>2020-12-23T10:10:23.000Z</published>
    <updated>2020-12-26T02:44:55.040Z</updated>
    
    <content type="html"><![CDATA[<p>距离2021的春招实习只有2个半月了，要开始争分夺秒了（唉，好想给女儿做二创啊）。</p><p>感觉前两个月因为各种各样的情况，看书写笔记的效率还是有点低（投入的时间确实也不够多），还有同时要看几本难啃的书确实不容易，之后要分清一下多个任务的主次了。</p><a id="more"></a><p>12月剩下时间的规划：</p><ul><li><strong>《剑指Offer》</strong>第3、4章，暂时不再写完整的博客了，只贴部分题目的完整实现代码；</li><li><strong>《3D游戏与计算机图形学中的数学方法》</strong>第4、5、6章，暂时不再写完整博客，会先简单写一些重要知识点摘录（自己打公式太费时间了）；</li><li><strong>《Real Time Rendering 4th》</strong>第2、3、4章，不再写完整博客，翻译还是有点费时费力，先看一遍过一下好了，主要作为3D数学方法那本书的知识补充。</li></ul><p>1月的规划：</p><ul><li><strong>《剑指Offer》</strong>第5、6章，不写完整博客，只贴部分题目的完整实现代码；</li><li><strong>《3D游戏与计算机图形学中的数学方法》</strong>第6-9章，暂时不再写完整博客，会先简单写一些重要知识点摘录；</li><li><strong>《Real Time Rendering 4th》</strong>第5-11章，只读，不写博客；</li><li><strong>《Effective C++》</strong>的55个条款，尽量都写写代码尝试实践，每一个其实都涉及到不少原本C++中的知识点，应该都要同步学习或者复习一下。</li></ul><p>其实就算是真的完成了这么多阅读的任务，还是有很多<strong>知识盲区</strong>，比如Unity3D、UE4、OpenGL、DirectX、RTX系列技术这种。</p><p>2月的初步规划（除掉过年，可能只有大半月的时间）：</p><ul><li><strong>面试笔试题</strong>，稍微刷一点面试常见的算法题(尤其是mid和hard难度的)，数量控制在100题以内吧，找到用C++解题的手感；</li><li><strong>引擎面试题</strong>，只能去收集各大厂引擎、渲染方面的面经贴，然后总结各种各样的点，有必要的话拓展去了解；</li><li><strong>OpenGL</strong>，估计至少要走一遍指南吧，代码都敲一敲；</li><li><strong>Unity3D入门和《Unity Shader 入门精要》</strong>，主要是了解Unity方面的相关知识；</li><li><strong>各大厂的简历投递</strong>，别忘了投简历了，注意提前收集他们的时间。</li></ul><p>3月的初步规划（基本上到了冲刺阶段了，剩下半个月时间）：</p><ul><li><strong>面试笔试题</strong>，每日做题的任务照常安排着走；</li><li><strong>引擎面试题</strong>，继续看收集的那些面试问题，顺带复习一下以前的笔记；</li><li><strong>《游戏引擎架构》</strong>，半个月简单刷一下这本书的大致内容，做到都有一定了解即可，当作知识广度阅读资料。</li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;距离2021的春招实习只有2个半月了，要开始争分夺秒了（唉，好想给女儿做二创啊）。&lt;/p&gt;
&lt;p&gt;感觉前两个月因为各种各样的情况，看书写笔记的效率还是有点低（投入的时间确实也不够多），还有同时要看几本难啃的书确实不容易，之后要分清一下多个任务的主次了。&lt;/p&gt;</summary>
    
    
    
    <category term="计划-Flags" scheme="https://yumi-cn.github.io/categories/%E8%AE%A1%E5%88%92-Flags/"/>
    
    
  </entry>
  
  <entry>
    <title>《剑指Offer》第2章笔记 算法和数据操作</title>
    <link href="https://yumi-cn.github.io/2020/12/20/s2o-c2-algorithm/"/>
    <id>https://yumi-cn.github.io/2020/12/20/s2o-c2-algorithm/</id>
    <published>2020-12-20T05:57:08.000Z</published>
    <updated>2020-12-20T05:57:53.072Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>考算法的面试题也备受面试官青睐（老折磨人了）。</p></blockquote><a id="more"></a><p>通常<strong>排序和查找</strong>是面试时考查算法的重点，准备的时候要重点掌握二分查找、归并排序和快速排序，要做到随时正确、完整地写出它们地代码。</p><p>二维数组上搜索路径的一些题目可以尝试用回溯法，通常回溯法适合用递归代码实现，如果面试官不允许递归实现，再尝试用栈来模拟递归过程。</p><p>如果是求解某个问题的最优解，并且问题可以分为子问题解决，就可以尝试用动态规划，如果在分解子问题中，满足一些特定条件就可以找到最优解，可以考虑用贪婪最优法。</p><hr><h2 id="1-递归和循环"><a href="#1-递归和循环" class="headerlink" title="1 递归和循环"></a>1 递归和循环</h2><ul><li>递归的代码通常比循环更加简洁，但代价是效率不够高，并且还有递归栈层数限制；</li><li>在一些题目中简单的递归会增加不必要的重复计算；</li><li>应用动态规划解决问题时，大部分都是递归方法分析问题，有些问题会出现子问题重复计算，到时候会讨论如何用循环替换递归实现；</li></ul><blockquote><p>面试题10：斐波那契数列</p></blockquote><p>题目一：求斐波那契数列的第n项，<code>f(0) = 0, f(1) = 1, f(n) = f(n-1) + f(n-2)</code>。</p><p>最简单的递归法就不在说明了，这里直接写一下不用重复计算的思路，当需要求解第n项时，需要求解前n-1项，通过观察可以发现从第2项开始计算，可以避免重复计算的问题。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> max_n = <span class="number">1000</span>;</span><br><span class="line"><span class="comment">// 如果不需要缓存，使用两个变量求解即可</span></span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> store[max_n];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">fibonacci</span><span class="params">(<span class="keyword">unsigned</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n &gt;= max_n) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>; <span class="comment">// Throw Error</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (store[n] != <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> store[n];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            store[i] = store[i<span class="number">-1</span>] + store[i<span class="number">-2</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> store[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::fill(&amp;store[<span class="number">0</span>], &amp;store[max_n], <span class="number">-1</span>);</span><br><span class="line">    store[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    store[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; fibonacci(<span class="number">50</span>) &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>书上还有一个<code>O(logn)</code>的算法，要使用到一个数学公式：</p><div>$$\left[\begin{matrix}f(n) & f(n-1) \\f(n-1) & f(n-2)\end{matrix}\right]=\left[\begin{matrix}1 & 1 \\1 & 0\end{matrix}\right]^{n-1}$$</div><p>公式可以用数学归纳法证明，问题就转换为如何求矩阵乘方，如果只是简单地从0开始循环，n次方需要n次元素，时间复杂度仍然是<code>O(n)</code>，并不比前面的方法快，但是其中的乘方有如下性质：</p><div>$$a^{n}=\left\{\begin{array}{rcl}a^{n/2} \cdot a^{n/2}, & & n\ is\ even \\a^{(n-1)/2} \cdot a^{(n-1)/2} \cdot a, & & n\ is\ odd\end{array}\right.$$</div><p>从公式可以看出，如果想求得n次方，就要先求得n/2次方，再把n/2次方的结果平方一下即可，时间复杂度为<code>O(logn)</code>。</p><p>不过算法仅做了解，很少会这么去写，实现起来也比较复杂。</p><p>还有不少面试题可以看成是斐波那契数列的应用：</p><p>题目二：青蛙跳台阶问题。</p><p>一只青蛙一次可以跳上1级台阶，也可以跳上2级台阶，求该青蛙跳上一个n级的台阶总共有多少种跳法。</p><p>将问题看作是求解函数f(n)，当青蛙第1次跳1级，则下一次求解f(n-1)，如果青蛙第1次跳2级，则下一次求解f(n-2)，所以其实本质还是斐波那契数列<code>f(n)=f(n-1)+f(n-2)</code>。</p><hr><h2 id="2-查询和排序"><a href="#2-查询和排序" class="headerlink" title="2 查询和排序"></a>2 查询和排序</h2><p>查询相对于排序较为简单，不外乎顺序查找、二分查找、哈希表查找和二叉排序树查找。<br>在面试的时候，不管是用循环还是递归，面试官都期待应聘者能够信手拈来写出<strong>完整正确地二分查找代码</strong>，否则可能连继续面试的兴趣都没有。</p><p>排序比查找要复杂一点，面试官会经常要求应聘者比较 插入排序、冒泡排序、归并排序、快速排序等不同算法的优劣。</p><p>实现快速排序算法的关键在于先在数组中选择一个数字，接下来把数组中的数字分为两部分，比选择的数字小的数字移到数组左边，比选择的数字大的数字移到数组的右边（递增排序）。</p><p>（然后就是一段基本上在哪本书上都能看到的快速排序代码）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">partition</span><span class="params">(<span class="keyword">int</span> data[], <span class="keyword">int</span> len, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(data == <span class="literal">nullptr</span> || len &lt;=<span class="number">0</span> || start &lt; <span class="number">0</span> || end &gt;= len) &#123;</span><br><span class="line">        <span class="function"><span class="built_in">std</span>::logic_error <span class="title">ex</span><span class="params">(<span class="string">&quot;Invalid Parameters&quot;</span>)</span></span>;</span><br><span class="line">        <span class="keyword">throw</span> <span class="built_in">std</span>::exception(ex);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> index = random_in_range(start, end);</span><br><span class="line">    swap(&amp;data[index], &amp;data[end]); <span class="comment">// end位置存储比较元素</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> small = start - <span class="number">1</span>; <span class="comment">// small用来指向存放小于比较元素的位置</span></span><br><span class="line">    <span class="keyword">for</span>(index = start; index &lt; end; index++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(data[index] &lt; data[end]) &#123;</span><br><span class="line">            <span class="comment">// 比比较元素小的就交换到small的地方</span></span><br><span class="line">            small++;</span><br><span class="line">            <span class="keyword">if</span>(small != index) &#123;</span><br><span class="line">                <span class="comment">// 如果位置相同就没必要再交换了</span></span><br><span class="line">                swap(&amp;data[index], &amp;data[small]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    small++;</span><br><span class="line">    swap(&amp;data[small], &amp;data[end]); <span class="comment">// 比较元素也放回对应位置</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> small; <span class="comment">// 返回比较元素的位置，划分左右两个子数组</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面是<code>partition</code>部分的代码，快速排序的其中一步，选择锚元素(比较元素)，将数组start-end区域的元素划分为两部分，一部分小于锚元素，另一部分大于锚元素。</p><p>完整的运行代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ctime&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;exception&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">random_in_range</span><span class="params">(<span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">    srand((<span class="keyword">unsigned</span>)time(<span class="literal">NULL</span>));</span><br><span class="line">    <span class="keyword">return</span> rand() % (end - start + <span class="number">1</span>) + start;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>* lhs, <span class="keyword">int</span>* rhs)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> temp = *lhs;</span><br><span class="line">    *lhs = *rhs;</span><br><span class="line">    *rhs = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">partition</span><span class="params">(<span class="keyword">int</span> data[], <span class="keyword">int</span> len, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(data == <span class="literal">nullptr</span> || len &lt;=<span class="number">0</span> || start &lt; <span class="number">0</span> || end &gt;= len) &#123;</span><br><span class="line">        <span class="function"><span class="built_in">std</span>::logic_error <span class="title">ex</span><span class="params">(<span class="string">&quot;Invalid Parameters&quot;</span>)</span></span>;</span><br><span class="line">        <span class="keyword">throw</span> <span class="built_in">std</span>::exception(ex);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> index = random_in_range(start, end);</span><br><span class="line">    swap(&amp;data[index], &amp;data[end]); <span class="comment">// end位置存储比较元素</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> small = start - <span class="number">1</span>; <span class="comment">// small用来指向存放小于比较元素的位置</span></span><br><span class="line">    <span class="keyword">for</span>(index = start; index &lt; end; index++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(data[index] &lt; data[end]) &#123;</span><br><span class="line">            <span class="comment">// 比比较元素小的就交换到small的地方</span></span><br><span class="line">            small++;</span><br><span class="line">            <span class="keyword">if</span>(small != index) &#123;</span><br><span class="line">                <span class="comment">// 如果位置相同就没必要再交换了</span></span><br><span class="line">                swap(&amp;data[index], &amp;data[small]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    small++;</span><br><span class="line">    swap(&amp;data[small], &amp;data[end]); <span class="comment">// 比较元素也放回对应位置</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> small; <span class="comment">// 返回比较元素的位置，划分左右两个子数组</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">quick_sort</span><span class="params">(<span class="keyword">int</span> data[], <span class="keyword">int</span> len, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(start == end) &#123;</span><br><span class="line">        <span class="keyword">return</span>; <span class="comment">// 单个元素，不用排序</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> index = partition(data, len, start, end);</span><br><span class="line">    <span class="keyword">if</span>(index &gt; start) &#123;</span><br><span class="line">        quick_sort(data, len, start, index<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(index &lt; end) &#123;</span><br><span class="line">        quick_sort(data, len, start+<span class="number">1</span>, end);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> data[] = &#123;<span class="number">9</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">7</span>, <span class="number">5</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">6</span>&#125;;</span><br><span class="line">    quick_sort(data, <span class="number">10</span>, <span class="number">0</span>, <span class="number">9</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, data[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>partition</code>函数除了可以用在快速排序中，还可以用来实现在长度n数组中查找第k大的数字，面试题39“数组中出现次数超过一半的数字”和面试题40“最小的k个数”都可以用这个函数来解决。</p><p>不同排序的适用场合也不尽相同，快速排序虽然总体的平均效率最好，但不是任何时候都是最优的算法（只是在平均效率上满足O(nlogn)，可以找出一些最坏的情况），所以在面试的时候，如果面试官要求实现一个排序算法，可以先问清楚这个排序<strong>应用的环境是什么</strong>、<strong>有哪些约束条件</strong>等等，得到足够多的信息之后再选择合适的排序算法。</p><blockquote><p>面试题11：旋转数组的最小数字</p></blockquote><p>把一个数组最开始的若干的元素搬到数组的末尾，称之为数组的旋转，输入一个递增排序的数组的一个旋转，输出旋转数组的最小元素。例如{3, 4, 5, 1, 2}是{1, 2, 3, 4, 5}的一个旋转，数组的最小值是1。</p><ul><li>思路1：简单遍历数组求最小值（无论正序还是逆序），时间开销都是O(n)，大概率不是一个最优解；</li><li>思路2：递增排序的一个区间满足性质, <strong>首元素一定小于尾元素</strong>，如果考虑到元素可以重复，即如果<strong>首元素大于等于尾元素</strong>，则该区间可能并不是<strong>非递减的</strong>。</li><li>思路3：思路2通过二分区间判断实现起来还是有一点复杂，还可以进一步地简化思路，每一次判断<code>mid</code>和<code>start</code>、<code>end</code>位置上元素大小关系，如果<code>mid&gt;=start</code>，证明<code>mid</code>位于前面的递增区间，下一步在<code>mid-end</code>中找最小元素；如果<code>mid&lt;=end</code>，证明<code>mid</code>位于后面的递增区间，下一步在<code>start-mid</code>中找最小元素。</li></ul><p>按照思路3，<code>start</code>总是指向前面递增数组的元素、<code>end</code>总是指向后面递增数组的元素，当<code>start</code>和<code>end</code>中间没有其他元素时，<code>end</code>就指向后面递增元素的第一个，也就是最小的数字，这也是循环结束的条件。</p><div align="center"><p><img src="/images/s2o-c2-ag-cv-11.1.jpg" alt="在数组{3,4,5,1,2}中查找最小值的过程"></p></div><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">min</span><span class="params">(<span class="keyword">int</span>* numbers, <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(numbers == <span class="literal">nullptr</span> || len &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="function"><span class="built_in">std</span>::logic_error <span class="title">ex</span><span class="params">(<span class="string">&quot;Invalid parameters&quot;</span>)</span></span>;</span><br><span class="line">        <span class="keyword">throw</span> <span class="built_in">std</span>::exception(ex);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> index1 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> index2 = len - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> index_mid = index1;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(numbers[index1] &gt;= numbers[index2]) &#123;</span><br><span class="line">        <span class="keyword">if</span>(index2 - index1 == <span class="number">1</span>) &#123;</span><br><span class="line">            index_mid = index2;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        index_mid = (index1 + index2) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(numbers[index_mid] &gt;= numbers[index1]) &#123;</span><br><span class="line">            <span class="comment">// mid在前面的递增数组中，min在后面</span></span><br><span class="line">            index1 = index_mid;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(numbers[index_mid] &lt;= numbers[index2]) &#123;</span><br><span class="line">            <span class="comment">// mid在后面的递增数组中，min在前面</span></span><br><span class="line">            index2 = index_mid;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> numbers[index_mid];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但上面的方法还有一些特殊情况没有考虑到：</p><ul><li>如果只搬动了0个元素到后面，即排序数组本身，上面的方法就不再适用了，但因为此时数组中一个数字就是最小的数字，可以直接返回；</li><li>如果<code>index1</code>和<code>index2</code>指向的元素相等，甚至他们都和<code>index_mid</code>指向的元素想等时，应该如何处理呢？这个时候无法简单地判断出<code>min</code>在前面还是后面（参考下面图），所以只能采取简单的遍历法（如果是递归函数实现的话可以都向下计算然后比对最小值）。</li></ul><div align="center"><p><img src="/images/s2o-c2-ag-cv-11.2.jpg" alt="数组{0,1,1,1,1}的两个旋转数组"></p></div><p>完整代码实现：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;exception&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">min_in_order</span><span class="params">(<span class="keyword">int</span>* numbers, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> min = numbers[start];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = start + <span class="number">1</span>; i &lt;= end; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(min &gt; numbers[i]) &#123;</span><br><span class="line">            min = numbers[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> min;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">min</span><span class="params">(<span class="keyword">int</span>* numbers, <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(numbers == <span class="literal">nullptr</span> || len &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="function"><span class="built_in">std</span>::logic_error <span class="title">ex</span><span class="params">(<span class="string">&quot;Invalid parameters&quot;</span>)</span></span>;</span><br><span class="line">        <span class="keyword">throw</span> <span class="built_in">std</span>::exception(ex);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> index1 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> index2 = len - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> index_mid = index1;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(numbers[index1] &gt;= numbers[index2]) &#123;</span><br><span class="line">        <span class="keyword">if</span>(index2 - index1 == <span class="number">1</span>) &#123;</span><br><span class="line">            index_mid = index2;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        index_mid = (index1 + index2) / <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(numbers[index1] == numbers[index2]</span><br><span class="line">            &amp;&amp; numbers[index_mid] == numbers[index1]) &#123;</span><br><span class="line">            <span class="comment">// index1 mid index2 均相等，顺序查找</span></span><br><span class="line">                <span class="keyword">return</span> min_in_order(numbers, index1, index2);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(numbers[index_mid] &gt;= numbers[index1]) &#123;</span><br><span class="line">            <span class="comment">// mid在前面的递增数组中，min在后面</span></span><br><span class="line">            index1 = index_mid;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(numbers[index_mid] &lt;= numbers[index2]) &#123;</span><br><span class="line">            <span class="comment">// mid在后面的递增数组中，min在前面</span></span><br><span class="line">            index2 = index_mid;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> numbers[index_mid];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> numbers[] = &#123;<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">1</span>, <span class="number">2</span>&#125;;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, min(numbers, <span class="number">5</span>)); <span class="comment">// 1</span></span><br><span class="line">    <span class="keyword">int</span> onumbers[] = &#123;<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>&#125;;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, min(onumbers, <span class="number">5</span>)); <span class="comment">// 0</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="3-回溯法"><a href="#3-回溯法" class="headerlink" title="3 回溯法"></a>3 回溯法</h2><p>回溯法可以看成蛮力法的升级，它从解决问题的每一步可能选项理选出一个可行的解决方法。<br>回溯法非常适合由多个步骤组成的问题，并且每个步骤都有多个选项。</p><p>用回溯法解决的问题的所有选项可以形象地用树状结构表示。在某一步有<code>n</code>个可能的选项，该步骤可以看成是树状结构中的一个节点，每个选项看成树中节点连接线。树的叶节点对应对应着终结状态，如果在叶节点的状态满足题目的约束条件，则找到了一个可行的解决方案。</p><p>如果叶节点的状态不满足约束，则只好回溯到它的上一个节点再尝试其他的选项，如果上一个节点所有可能的选项都已经试过，找下一种可能选项时，需要再次回溯到上一个节点（依次类推）。如果所有节点的所有选项都已经尝试过仍然不能达到满足约束条件的终结状态，则该问题无解。</p><p>以面试题12来说明回溯法的应用方法。</p><blockquote><p>面试题12：矩阵中的路径</p></blockquote><p>设计一个函数，用来判断一个矩阵中是否存在一条包含某字符串所有字符的路径。路径可以从矩阵中的任意一格开始，每一步可以在矩阵中向左、右、上、下移动一格。如果一条路径经过了矩阵的某一格，那么该路径不能再次进入该格子。</p><div align="center"><p><img src="/images/s2o-c2-ag-cv-12.1.jpg" alt="一个字符矩阵的例子"></p></div><p>用回溯法解决的典型题，首先在矩阵中任选一个格子作为路径的起点，然后尝试匹配字符串，如果位置字符匹配，则在临近格子中寻找下一步格子，重复上述过程，直到路径上所有字符都在矩阵中找到相应的位置。</p><p>由于回溯法的递归特性，路径可以被看成一个栈，当在矩阵中定位了路径中前n个字符位置之后，在与第n个字符对应的格子的周围都没有找到第n+1字符，这时候只好在路径上回到第n-1字符，重新定位第n个字符。</p><p>由于路径不能重复进入矩阵的格子，所以要定义和字符矩阵大小一样的布尔值矩阵，用来标识路径已经进入了哪些格子。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt; // include memset()</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">has_path_core</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* matrix, <span class="keyword">int</span> rows, <span class="keyword">int</span> cols, <span class="keyword">int</span> row,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">int</span> col, <span class="keyword">const</span> <span class="keyword">char</span>* str, <span class="keyword">int</span>&amp; path_len, <span class="keyword">bool</span>* visited)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(str[path_len] == <span class="string">&#x27;\0&#x27;</span>) &#123;</span><br><span class="line">        <span class="comment">// 前面的字符都找到相应位置了</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">bool</span> has_path = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span>(row &gt;= <span class="number">0</span> &amp;&amp; row &lt; rows &amp;&amp; col &gt;= <span class="number">0</span> &amp;&amp; col &lt; cols</span><br><span class="line">        &amp;&amp; matrix[row * cols + col] == str[path_len]</span><br><span class="line">        &amp;&amp; !visited[row * cols + col]) &#123;</span><br><span class="line">        path_len++;</span><br><span class="line">        visited[row*col + col] = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">        has_path = has_path_core(matrix, rows, cols, row, col<span class="number">-1</span>, str, path_len, visited)</span><br><span class="line">                || has_path_core(matrix, rows, cols, row<span class="number">-1</span>, col, str, path_len, visited)</span><br><span class="line">                || has_path_core(matrix, rows, cols, row, col+<span class="number">1</span>, str, path_len, visited)</span><br><span class="line">                || has_path_core(matrix, rows, cols, row+<span class="number">1</span>, col, str, path_len, visited);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(!has_path) &#123;</span><br><span class="line">            path_len--;</span><br><span class="line">            visited[row * cols + col] = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> has_path;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">has_path</span><span class="params">(<span class="keyword">char</span>* matrix, <span class="keyword">int</span> rows, <span class="keyword">int</span> cols, <span class="keyword">char</span>* str)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(matrix == <span class="literal">nullptr</span> || rows &lt; <span class="number">1</span> || cols &lt; <span class="number">1</span> || str == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">bool</span>* visited = <span class="keyword">new</span> <span class="keyword">bool</span>[rows * cols];</span><br><span class="line">    <span class="built_in">memset</span>(visited, <span class="number">0</span>, rows * cols);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> path_len = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> row = <span class="number">0</span>; row &lt; rows; row++) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> col = <span class="number">0</span>; col &lt; cols; col++) &#123;</span><br><span class="line">            <span class="comment">// 从点(row, col)出发去寻找path</span></span><br><span class="line">            <span class="keyword">if</span>(has_path_core(matrix, rows, cols, row, col, str, path_len, visited)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">delete</span>[] visited;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> matrix[<span class="number">12</span>] = &#123; <span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;t&#x27;</span>,<span class="string">&#x27;g&#x27;</span>, <span class="string">&#x27;c&#x27;</span>,<span class="string">&#x27;f&#x27;</span>,<span class="string">&#x27;c&#x27;</span>,<span class="string">&#x27;s&#x27;</span>, <span class="string">&#x27;j&#x27;</span>,<span class="string">&#x27;d&#x27;</span>,<span class="string">&#x27;e&#x27;</span>,<span class="string">&#x27;h&#x27;</span> &#125;;</span><br><span class="line">    <span class="keyword">char</span> str1[<span class="number">10</span>] = <span class="string">&quot;bfce&quot;</span>;</span><br><span class="line">    <span class="keyword">if</span>(has_path(matrix, <span class="number">3</span>, <span class="number">4</span>, str1)) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; str1 &lt;&lt; <span class="string">&quot; in matrxi.&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; str1 &lt;&lt; <span class="string">&quot; not in matrxi.&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// bfce in matrxi.</span></span><br><span class="line">    <span class="keyword">char</span> str2[<span class="number">10</span>] = <span class="string">&quot;abfb&quot;</span>;</span><br><span class="line">    <span class="keyword">if</span>(has_path(matrix, <span class="number">3</span>, <span class="number">4</span>, str2)) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; str2 &lt;&lt; <span class="string">&quot; in matrxi.&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; str2 &lt;&lt; <span class="string">&quot; not in matrxi.&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// abfb not in matrxi.</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>面试题13：机器人的运动范围</p></blockquote><p>地上有一个<code>m</code>行<code>n</code>列的方格。一个机器人从<code>(0,0)</code>的格子开始移动，它每次可以向左、右、上、下移动一格，但不能进入<strong>行坐标和列坐标的数位之和</strong>大于<code>k</code>的格子。例如，当<code>k</code>为<code>18</code>时，机器人能进入方法<code>(35, 37)</code>，因为<code>3+5+3+7=18</code>，但不能进入方格<code>(35, 38)</code>，因为<code>3+5+3+8=19</code>，请问该机器人能够到达多少格子？</p><p>机器人从<code>(0,0)</code>开始移动，准备进入<code>(i,j)</code>时，要检查坐标的数位来判断是否能够进入，如果能进入，再判断是否能进入4个相邻的格子（不包含已走格子）。</p><p>完整代码实现：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">get_digit_sum</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(num &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        sum += num % <span class="number">10</span>;</span><br><span class="line">        num /= <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span> threshold, <span class="keyword">int</span> rows, <span class="keyword">int</span> cols, <span class="keyword">int</span> row, <span class="keyword">int</span> col, <span class="keyword">bool</span>* visited)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(row &gt;= <span class="number">0</span> &amp;&amp; row &lt; rows &amp;&amp; col &gt;= <span class="number">0</span> &amp;&amp; col &lt; cols</span><br><span class="line">        &amp;&amp; get_digit_sum(row) + get_digit_sum(col) &lt;= threshold</span><br><span class="line">        &amp;&amp; !visited[row * cols + col]) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">moving_count_core</span><span class="params">(<span class="keyword">int</span> threshold, <span class="keyword">int</span> rows, <span class="keyword">int</span> cols, <span class="keyword">int</span> row, <span class="keyword">int</span> col, <span class="keyword">bool</span>* visited)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 检查当前是否可达</span></span><br><span class="line">    <span class="keyword">if</span>(check(threshold, rows, cols, row, col, visited)) &#123;</span><br><span class="line">        visited[row * cols + col] = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">        count = <span class="number">1</span></span><br><span class="line">            + moving_count_core(threshold, rows, cols, row - <span class="number">1</span>, col, visited)</span><br><span class="line">            + moving_count_core(threshold, rows, cols, row, col - <span class="number">1</span>, visited)</span><br><span class="line">            + moving_count_core(threshold, rows, cols, row + <span class="number">1</span>, col, visited)</span><br><span class="line">            + moving_count_core(threshold, rows, cols, row, col + <span class="number">1</span>, visited);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回计数</span></span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">moving_count</span><span class="params">(<span class="keyword">int</span> threshold, <span class="keyword">int</span> rows, <span class="keyword">int</span> cols)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(threshold &lt; <span class="number">0</span> || rows &lt;= <span class="number">0</span> || cols &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">bool</span> *visited = <span class="keyword">new</span> <span class="keyword">bool</span>[rows * cols];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; rows * cols; i++) &#123;</span><br><span class="line">        visited[i] = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从(0, 0)出发，计数count</span></span><br><span class="line">    <span class="keyword">int</span> count = moving_count_core(threshold, rows, cols, <span class="number">0</span>, <span class="number">0</span>, visited);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">delete</span>[] visited;</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; moving_count(<span class="number">-1</span>, <span class="number">1</span>, <span class="number">1</span>) &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 0</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; moving_count(<span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>) &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 1</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; moving_count(<span class="number">12</span>, <span class="number">40</span>, <span class="number">40</span>) &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 770</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; moving_count(<span class="number">18</span>, <span class="number">40</span>, <span class="number">40</span>) &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 1484</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="4-动态规划与贪婪算法"><a href="#4-动态规划与贪婪算法" class="headerlink" title="4 动态规划与贪婪算法"></a>4 动态规划与贪婪算法</h2><p>如果面试题是求一个问题的最优解(通常是<strong>求最大值或者最小值</strong>)，而且该问题能够被分解成若干个子问题，子问题之间还有重叠的更小子问题，就可以考虑用动态规划来解决这个问题。</p><p>在应用动态规划之前，要先分析<strong>是否能把大问题分解成小问题</strong>，分解后的<strong>每个小问题也存在最优解</strong>，如果把<strong>小问题的最优解组合起来能够得到整个问题的最优解</strong>，则可以应用动态规划来解决这个问题。</p><p>在一些题目情况中，相同子问题在分解大问题的过程中重复出现，为了避免重复求解相同子问题，可以用从下往上的顺序先计算小问题的最优解并存储下来，再以此为基础求取大问题的最优解。在应用动态规划解决问题的时候，我们总是从解决最小问题开始，并把已经解决的子问题的最优解存储下来（大部分题目一般用一维或者二维数组里），并把子问题的最优解组合起来逐步解决大的问题。</p><p>在应用动态规划时，每一步都面临若干个选择，在求解时只能把所有的可能尝试一遍，然后比较得出最优的选择。</p><p>贪婪算法和动态规划不一样，贪婪算法每一步都可以根据规则做出一个最优的选择，基于这个找到最优解，但贪婪算法需要证明每一步的选择是可以保证最后获得最优结果，有时候不要想当然的应用贪婪算法。</p><blockquote><p>面试题14：剪绳子</p></blockquote><p>给你一根长度为<code>n</code>的绳子，请把绳子剪成<code>m</code>段(<code>m</code>、<code>n</code>都是整数，<code>n&gt;1</code>并且<code>m&gt;1</code>)，每段绳子的长度记为<code>k[0],k[1],...,k[m]</code>，请问 <code>k[0] x k[1] x ... x k[m]</code>可能的最大乘积是多少？例如，当绳子的长度是8时，我们把它剪成长度分为2、3、3的三段，此时得到的最大乘积是18。</p><p>Tips：这道题里面的一个比较含糊不清的地方是对<code>m</code>的界定，有些题目中可能<code>m</code>也是一个输入量，指计算在这个<code>m</code>段限定条件下<code>n</code>长度绳子的最大结果值（基本上就是另一类题了），而在本书的这道题目中并没有将<code>m</code>看作一个单独的输入量，只是说明后续的计算流程用，在面试遇到这样的情况可以向面试官询问对<code>m</code>的作用界定。</p><ul><li>思路1：暴力遍历，第一步有<code>n-1</code>种剪法，第二步有<code>n-2</code>种剪法，…，剪到底的话需要剪<code>n</code>步（每一步可以剪多个绳子），所以可以简单估算时间复杂度<code>O(n^2)</code>；</li><li>思路2：动态规划；</li><li>思路3：尝试用贪婪算法来解决。</li></ul><p>先讲一下<strong>动态规划的解法</strong>。</p><p>首先定义函数<code>f(n)</code>为把长度为<code>n</code>的绳子剪成若干段后各段长度乘积的最大值。在剪第一刀时，有<code>n-1</code>中可能的选择，因此有<code>f(n)=max(f(i) x f(n-i))</code>，其中<code>0&lt;i&lt;n</code>。</p><p>这是一个从上至下的递归公式，递归会产生很多重复计算，所以一个更好的办法是按照从下而上的顺序计算，也就是说我们先得到<code>f(2)</code>、<code>f(3)</code>，再得到<code>f(4)</code>、<code>f(5)</code>，直到得到<code>f(n)</code>。比较容易得知<code>f(1)=0</code>、<code>f(2)=1</code>以及<code>f(3)=2</code>，之后就按照迭代公式计算，得到<code>f(n)</code>。</p><p>Tips：书上这个题目的解析里面，个人觉得有一点疏漏，<code>f(k-1)</code>的定义应该是在<strong>剪后的乘积最大</strong>和<strong>不剪的自身长度</strong>中的最大值，即<code>f(k-1)=max(&#123;f(i) x f(k-i), k=1,2,...,n-1&#125;), </code>，因为只有在计算<code>f(n)</code>的时候是必须要剪断的(因为<code>m&gt;1</code>)，而剩下的子段不是一定要剪断，所以<code>f(k-1), k=1,2,...,n-1</code>的计算方式不能完全照搬<code>f(n)</code>的公式，例如<code>f(1)</code>作为一个长度为<code>1</code>的子段，因为并不是一定要剪，所以其本身可以返回的最大长度是<code>1</code>，而不是<code>0</code>，否则对于一个长度为<code>n</code>的绳子，在剪为<code>1</code>长度和<code>n-1</code>长度的两个子段时，使用<code>f(1)=0</code>，就会导致计算的结果错误，因为在这个情况下是有最后的值的，而并不是<code>0*f(n-1)=0</code>，所以按照修正后的定义，当是子段的时候，<code>f(1)=1</code>，<code>f(2)=2</code>，<code>f(3)=3</code>，<code>f(4)=4</code>，<code>f(5)=6</code>，…，可以发现虽然在<code>k&gt;3</code>这部分定义修正没有意义，但对于<code>k&lt;=3</code>部分是有意义的。</p><p>完整实现代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">max_product_after_cutting_dyprog</span><span class="params">(<span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(len &lt; <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(len == <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(len == <span class="number">3</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 循环替代递归，减少重复子任务，动态规划法</span></span><br><span class="line">    <span class="keyword">int</span>* products = <span class="keyword">new</span> <span class="keyword">int</span>[len + <span class="number">1</span>];</span><br><span class="line">    products[<span class="number">0</span>] = <span class="number">0</span>; <span class="comment">// f(0)=0</span></span><br><span class="line">    products[<span class="number">1</span>] = <span class="number">1</span>; <span class="comment">// 修正定义的f(1)=1</span></span><br><span class="line">    products[<span class="number">2</span>] = <span class="number">2</span>; <span class="comment">// 修正定义的f(2)=2</span></span><br><span class="line">    products[<span class="number">3</span>] = <span class="number">3</span>; <span class="comment">// 修正定义的f(3)=3</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> max = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">4</span>; i &lt;= len; i++) &#123;</span><br><span class="line">        max = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= i/<span class="number">2</span>; j++) &#123;</span><br><span class="line">            <span class="keyword">int</span> product = products[j] * products[i - j];</span><br><span class="line">            <span class="keyword">if</span>(max &lt; product) &#123;</span><br><span class="line">                max = product;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// products[i] = max; // 书上该行的位置，个人觉得没必要</span></span><br><span class="line">        &#125;</span><br><span class="line">        products[i] = max; <span class="comment">// 个人意见的修正，虽然不影响结果</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    max = products[len];</span><br><span class="line">    <span class="keyword">delete</span>[] products;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> max;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 结果是36</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; max_product_after_cutting_dyprog(<span class="number">10</span>) &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Tips：上面的代码除了调整过一行的位置以外，基本上没有修改，可以看到代码中对<code>f(1)</code>、<code>f(2)</code>和<code>f(3)</code>的定义都是符合我之前说的修正后的定义，而不是作者说明的什么<code>f(1)=0</code>、<code>f(2)=1</code>以及<code>f(3)=2</code>，所以也侧面证明之前我对定义的修正是正确的。</p><p>接着看一下<strong>贪婪算法的解法</strong>。</p><p>如果按照如下的策略来剪绳子，则得到的各段绳子的长度乘积最大，当<code>n&gt;=5</code>时，尽可能多地剪长度为<code>3</code>的绳子；当剩下的绳子长度为<code>4</code>时，把绳子剪成两段长度为<code>2</code>的绳子。</p><p>完整实现代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">max_product_after_cutting_greedy</span><span class="params">(<span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(len &lt; <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(len == <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(len == <span class="number">3</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 尽可能剪为长度为3的绳子段</span></span><br><span class="line">    <span class="keyword">int</span> times_of_3 = len / <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 剩余长度为4时，不再减去3</span></span><br><span class="line">    <span class="keyword">if</span>(len - times_of_3 * <span class="number">3</span> == <span class="number">1</span>) &#123;</span><br><span class="line">        times_of_3 -= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 代表有多少个2段</span></span><br><span class="line">    <span class="keyword">int</span> times_of_2 = (len - times_of_3 * <span class="number">3</span>) / <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">int</span>)(<span class="built_in">pow</span>(<span class="number">3</span>, times_of_3) * <span class="built_in">pow</span>(<span class="number">2</span>, times_of_2));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 结果是36，和动态规划法相同</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; max_product_after_cutting_greedy(<span class="number">10</span>) &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>证明一些这种思路的正确性：</p><ul><li>首先，当<code>n&gt;=5</code>时，我们可以证明<code>2(n-2)&gt;n</code>并且<code>3(n-3)&gt;n</code>（剪出一长度2子段或剪出一长度<code>3</code>子段），也就是说，当绳子剩下的长度大于等于<code>5</code>时，就把它剪成<code>3</code>或者<code>2</code>的子段，另外，<code>n&gt;=5</code>时，<code>3(n-3)&gt;=2(n-2)</code>，因此我们应该尽可能地多剪长度为<code>3</code>的绳子段（<strong>其实书上的这部分证明还并不够严谨，可以自行去严谨地证明</strong>）。</li><li>那么当长度为4时，可以简单推出最大的情况就是<code>2*2</code>或者不剪的<code>4</code>。</li></ul><hr><h2 id="5-位运算"><a href="#5-位运算" class="headerlink" title="5 位运算"></a>5 位运算</h2><p>位运算是把<strong>数字用二进制表示</strong>之后，对每一位上<code>0</code>或者<code>1</code>的运算，二进制及其位运算是现代计算机学科的基石，很多底层的技术都离不开位运算（都是基石了咋离得开嘛），因为与位运算相关的题目也经常出现在面试中。</p><p>在微软产品Excel中，用A表示第1列，B表示第2列，…，Z表示第26列，AA表示第27列，AB表示第28列，…，以此类推，写出一个函数，输入用字母表示的列号，输出第几列，这就是一个典型的进制转换题目。</p><p>位运算总共只有5种运算：与 <code>&amp;</code>、或 <code>||</code>、异或 <code>^</code>、左移<code>&lt;&lt;</code>和右移<code>&gt;&gt;</code>。</p><p>与、或和异或运算规律可以用下表进行总结：</p><div align="center"><p><img src="/images/s2o-c2-ag-t-2.1.jpg"></p></div><p>左移运算法<code>m &lt;&lt; n</code>表示把<code>m</code>左移<code>n</code>位，在左移<code>n</code>位时，最左边的<code>n</code>位将被丢弃，同时在最右边补上<code>n</code>个<code>0</code>，比如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">00001010</span> &lt;&lt; <span class="number">2</span> = <span class="number">00101000</span></span><br><span class="line"><span class="number">10001010</span> &lt;&lt; <span class="number">3</span> = <span class="number">01010000</span></span><br></pre></td></tr></table></figure><p>右移运算符<code>m &gt;&gt; n</code>表示把<code>m</code>右移<code>n</code>位，在右移<code>n</code>位时，最右边的<code>n</code>位将被丢弃，但是在右移时处理最左边位的情形要稍微复杂一点：</p><ul><li>如果数字是一个无符号数值，则用0填补最左边的n位；</li><li>如果数字是一个有符号数值，则用数字的符号位填补最左边的n位；<ul><li>数字是正数，右移补0；</li><li>数字是负数，左移补1。</li></ul></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">00001010</span> &gt;&gt; <span class="number">2</span> = <span class="number">00000010</span></span><br><span class="line"><span class="number">10001010</span> &gt;&gt; <span class="number">3</span> = <span class="number">11110001</span></span><br></pre></td></tr></table></figure><p>面试题15“二进制中1的个数”就是直接考查位运算的例子，而面试56“数组中数字出现的次数”、面试题65“不用加减乘除做加法”等都是根据位运算的特点来解决问题。</p><blockquote><p>面试题15：二进制中1的个数</p></blockquote><p>实现一个函数，输入一个整数，输出该数二进制表示中1的个数，例如，把9表示成二进制是1001，有2个1，所以输出2。</p><ul><li><strong>可能会引起死循环</strong>的解法：判断整数二进制最右边是否为<code>1</code>，然后进行右移一位再进行判断，直到整个整数变为<code>0</code>为止，至于如何判断一个整数的最右边是不是<code>1</code>，只要把整数和<code>1</code>做位与(<code>&amp;</code>)运算看结果是不是<code>1</code>就只知道了，这个方法的问题在于对于负数的处理会导致死循环，如果是负数，则右移会在首位补<code>1</code>，数字永远不会变为<code>0</code>，最后变为<code>0xffffffff</code>导致死循环；</li><li><strong>常规解法</strong>：为了避免死循环，可以<strong>不右移</strong>输入的数字<code>n</code>，而转为<strong>左移</strong>用来校验的数字<code>1</code>，依次校验数字<code>n</code>的每一位是否为<code>1</code>；</li></ul><p>常规解法的代码实现：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">number_of_1</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> flag = <span class="number">1</span>; <span class="comment">// unsigned int 才能采集到符号位</span></span><br><span class="line">    <span class="comment">// 循环次数取决于操作系统中int的存储位数，一般是4字节，32位</span></span><br><span class="line">    <span class="keyword">while</span>(flag) &#123; <span class="comment">// 1从左边溢出后，flag会变成0</span></span><br><span class="line">        <span class="keyword">if</span>(num &amp; flag) &#123; <span class="comment">// 非0 即 该位有1</span></span><br><span class="line">            count++;</span><br><span class="line">        &#125;</span><br><span class="line">        flag = flag &lt;&lt; <span class="number">1</span>; <span class="comment">// 赋值更新</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; number_of_1(<span class="number">255</span>) &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 8</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; number_of_1(<span class="number">-1</span>) &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 32</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>令人惊喜的解法</strong>：先分析一下把一个数减去1的情况，如果一个整数不等于0，则二进制中<strong>至少有一位是1</strong>，假设这个数最右边为1，则减1导致最后一位为0，其余位保持不变；假设最后一位是0，如果最右边的1位于第m位，则减一时，第m位由1变0，m位之后的所有0都变成1，m之前的所有位保持不变。根据这两种情况，可以发现把一个整数减1，都是把最右边的1变成0，如果右边有0，则所有0变成1，如果把一个<strong>整数</strong>和<strong>它减去1的结果</strong>做<strong>位与运算</strong>，相当于把最右边的1变成0。以1100为例，减1结果是1011，1100和1011做位运算，结果是1000，即相比于1100把最右边的1变成0。所以最后的思路是，把一个整数减1，再和原整数做与运算，就把最右边1变为0，那么一个二进制中有多少1就可以进行多少次这样的操作。</li></ul><p>完整代码实现：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">number_of_1_sp</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(num) &#123;</span><br><span class="line">        count++;</span><br><span class="line">        num = (num - <span class="number">1</span>) &amp; num;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; number_of_1_sp(<span class="number">255</span>) &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 8</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; number_of_1_sp(<span class="number">-1</span>) &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 32</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;考算法的面试题也备受面试官青睐（老折磨人了）。&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="剑指Offer" scheme="https://yumi-cn.github.io/categories/%E5%89%91%E6%8C%87Offer/"/>
    
    
    <category term="笔记" scheme="https://yumi-cn.github.io/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>《3D图形的数学》第3章笔记 变换</title>
    <link href="https://yumi-cn.github.io/2020/12/12/3dmath-c3/"/>
    <id>https://yumi-cn.github.io/2020/12/12/3dmath-c3/</id>
    <published>2020-12-12T12:52:19.000Z</published>
    <updated>2020-12-12T15:18:18.379Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>3D游戏开发过程中，通常需要以某种方式对向量进行变换。</p></blockquote><a id="more"></a><p>通常用到的变换包括<strong>平移、缩放和旋转</strong>。</p><h2 id="1-通用变换"><a href="#1-通用变换" class="headerlink" title="1 通用变换"></a>1 通用变换</h2><p>通常把 \(n \times n\) 可逆矩阵M看成是一个从坐标系到另一个坐标系的变换矩阵。</p><p>M的列给出了坐标轴从原坐标系到新坐标系的映射；\(M^{-1}\)的列给出了坐标轴从新坐标系到原坐标系的映射。</p><p>PS：书上的上面两句话，可以尝试从M乘以一个坐标轴单位向量的结果角度来考量，也就理解M的列是如何对一个向量或者坐标的各个轴的处理的。</p><p>多个变换可以串联起来，也可以将多个变换矩阵的乘积用一个矩阵来表示，例如 \(G(MP)=(GM)P\)，其中G/M是变换矩阵，P是坐标或向量，先做M变换再做G变换的结果可以用一个(GM)矩阵来存储，这样可以对顶点做无数次的变换，不需要额外的存储空间和计算开销。</p><h3 id="1-1-正交矩阵"><a href="#1-1-正交矩阵" class="headerlink" title="1.1 正交矩阵"></a>1.1 正交矩阵</h3><p><strong>正交矩阵的转置等于其逆矩阵</strong>。</p><p><strong>【定义3.1】</strong> 一个n阶可逆方阵M，当且仅当 \(M^{-1}=M^{T}\)时，M为正交矩阵。</p><p><strong>【定理3.2】</strong> 如果向量组 \(V_{1}, V_{2}, \cdots, V_{n}\)构成的一个正交向量集合，则以 \(V_{j}, (1 \leq j \leq n)\)作为第j列的n阶方阵是正交矩阵。</p><p>正交矩阵还有另外一个性质，用于变换向量时，<strong>正交矩阵不改变向量的长度和角度</strong>（一般指的是两个同样变换的向量夹角）。</p><p><strong>【定理3.3】</strong> 如果n阶方阵M正交，则M具有保证长度和角度不变的特性。</p><p>Tips：证明可以先从不改变两个向量的内积入手，然后再说明对单个向量不改变长度，再推出不改变角度。</p><p>由于这样的特性，使用正交矩阵变换可以保持坐标系的整体结构，所以正交矩阵只能用于表示旋转和反射（在某一方向上将点镜像的运算）的组合。</p><h3 id="1-2-手向性"><a href="#1-2-手向性" class="headerlink" title="1.2 手向性"></a>1.2 手向性</h3><p>在三维空间中，由3D向量 \(V_{1}, V_{2}, V_{3}\) 构成的坐标系的基具有手向性。对于<strong>右手基</strong>，有 \((V_{1} \times V_{2}) \cdot V_{3} &gt; 0\)，即在右手坐标系中， \(V_{1}, V_{2}\)的叉积(右手法则下)的方向与 \(V_{3}\)的方向形成一个锐角，如果是一个<strong>正交规范的右手基</strong>，则有 \(V_{1} \times V_{2} = V_{3}\)；若\((V_{1} \times V_{2}) \cdot V_{3} &lt; 0\)，那么是<strong>左手基</strong>。</p><p>进行<strong>奇数次的反射操作</strong>，会改变手向性，<strong>偶数次的反射</strong>相当与一次旋转。通过考查变换矩阵的行列式可以判定矩阵是否存在反射，若<strong>行列式为负</strong>，则存在反射，用其对任意基的向量进行变换操作后，基的手向性发生改变。如果行列式是正的，则不改变手向性。</p><p>另外，正交矩阵的行列式值只可能是1或-1，如果为1，则矩阵只有旋转；如果为-1，则表示旋转操作后再进行一次反射。</p><hr><h2 id="2-缩放变换"><a href="#2-缩放变换" class="headerlink" title="2 缩放变换"></a>2 缩放变换</h2><p>用a作为系数缩放向量P，只需要计算 \(P^{‘}=aP\)，在三维空间中，运算也可以表示为和矩阵的乘积：</p><div>$$P^{'}=\left[\begin{matrix}a & 0 & 0 \\0 & a & 0 \\0 & 0 & a\end{matrix}\right]\left[\begin{matrix}P_{x} \\P_{y} \\P_{z}\end{matrix}\right]\tag{3.8}$$</div><p>这种缩放成为<strong>统一缩放</strong>（各个轴相同缩放系数），如果希望在x,y,z轴以不同的值缩放向量，可以改变对角线上的元素（不再是相同的一个a），这种缩放称为<strong>非统一缩放</strong>。</p><div>$$P^{'}=\left[\begin{matrix}a & 0 & 0 \\0 & b & 0 \\0 & 0 & c\end{matrix}\right]\left[\begin{matrix}P_{x} \\P_{y} \\P_{z}\end{matrix}\right]\tag{3.9}$$</div><p>如果想在<strong>3个任意轴上进行非统一缩放</strong>，就要用到稍微复杂的缩放过程。假设以a,b,c为系数，在U,V,W轴方向上进行缩放，就需要先从坐标系(U,V,W)变换到坐标系(i,j,k) （这一步乘以[U V W]的逆矩阵变换到UVW为ijk坐标轴的空间中），然后在(i,j,k)坐标系中计算缩放（乘以缩放矩阵），最后再还原到(U,V,W)坐标系（乘以[U V W]矩阵变换到原本的ijk坐标轴空间中）。</p><div>$$P^{'}=\left[\begin{matrix}U_{x} & V_{x} & W_{x} \\U_{y} & V_{y} & W_{y} \\U_{z} & V_{z} & W_{z}\end{matrix}\right]\left[\begin{matrix}a & 0 & 0 \\0 & b & 0 \\0 & 0 & c\end{matrix}\right]\left[\begin{matrix}U_{x} & V_{x} & W_{x} \\U_{y} & V_{y} & W_{y} \\U_{z} & V_{z} & W_{z}\end{matrix}\right]^{-1}\left[\begin{matrix}P_{x} \\P_{y} \\P_{z}\end{matrix}\right]\tag{3.10}$$</div><p>Tips：这一段其实说的有点绕，但其实理解第一步就可以理解后面了，关于为什么是乘以逆矩阵，是因为(U,V,W)中的目标 \(P^{uvw}\) 有以下的表示方法：</p><div>$$P^{uvw}_{x}\left[\begin{matrix}U_{x} \\U_{y} \\U_{z}\end{matrix}\right]+P^{uvw}_{y}\left[\begin{matrix}W_{x} \\W_{y} \\W_{z}\end{matrix}\right]+P^{uvw}_{z}\left[\begin{matrix}V_{x} \\V_{y} \\V_{z}\end{matrix}\right]\\ =\left[\begin{matrix}U_{x} & V_{x} & W_{x} \\U_{y} & V_{y} & W_{y} \\U_{z} & V_{z} & W_{z}\end{matrix}\right]\left[\begin{matrix}P^{uvw}_{x} \\P^{uvw}_{y} \\P^{uvw}_{z}\end{matrix}\right]=\left[\begin{matrix}P_{x} \\P_{y} \\P_{z}\end{matrix}\right]$$</div><p>所以要求得(U,V,W)坐标系下的坐标 \(P^{uvw}\) 就要用原坐标乘以矩阵[U V W]的逆矩阵：</p><div>$$\left[\begin{matrix}P^{uvw}_{x} \\P^{uvw}_{y} \\P^{uvw}_{z}\end{matrix}\right]=\left[\begin{matrix}U_{x} & V_{x} & W_{x} \\U_{y} & V_{y} & W_{y} \\U_{z} & V_{z} & W_{z}\end{matrix}\right]^{-1}\left[\begin{matrix}P_{x} \\P_{y} \\P_{z}\end{matrix}\right]$$</div><p>这也就解释了第一步为什么乘以的是逆矩阵，后面也就相同的方法来解释了。</p><hr><h2 id="3-旋转变换"><a href="#3-旋转变换" class="headerlink" title="3 旋转变换"></a>3 旋转变换</h2><p>得到将坐标系绕x,y或z轴旋转 \(\theta\)角的矩阵并不难，当A轴指向我们时，所看到的旋转时逆时针方向。</p><p>首先看一下二维空间旋转的通用公式，如图3.2所示，通过交换x和y坐标，并将新的x坐标取负，得到(-y,x)，就能够将位于xy平面线上的二维向量P进行90°的逆时针旋转。设旋转向量为Q，则有 \( Q=&lt;-P_{y}, P_{x}&gt;\)。向量P和Q组成了xy平面的一个正交基，因此xy平面的任意向量都可以用这两个向量的线性组合来表示。</p><div align="center"><p><img src="/images/3d-math-c3-3-1.jpg"></p></div><p>如图3.3所示，任意向量P以 \(\theta\)角旋转后所形成的二维向量 \(P^{‘}\)，都可以用分别平行于P和Q的分量来表示。</p><div>$$P^{'} = Pcos\theta + Qsin\theta \tag{3.11}$$</div><p>带入Q的坐标计算，可以有：</p><div>$$\begin{aligned}P^{'}_{x} &= P_{x}cos\theta - P_{y}sin\theta \\P^{'}_{y} &= P_{y}cos\theta + P_{x}sin\theta\end{aligned}\tag{3.12}$$</div><p>用矩阵改写则有：</p><div>$$P^{'} =\left[\begin{matrix}cos\theta & -sin\theta \\sin\theta & cos\theta\end{matrix}\right]P\tag{3.13}$$</div><p>将单位矩阵的第3行和第3列加入到等式3.13中的2D旋转矩阵，就可以扩展成3D空间中绕z轴的三维旋转，在旋转过程中z坐标保持不变，绕z轴旋转 \(\theta\) 角度的旋转矩阵 \(R_{z}(\theta)\)可以表示为：</p><div>$$R_{z}(\theta) =\left[\begin{matrix}cos\theta & -sin\theta & 0 \\sin\theta & cos\theta & 0 \\0 & 0 & 1\end{matrix}\right]\tag{3.14}$$</div><p>同样，可以分别得到绕x轴和绕y轴旋转\theta角度的旋转矩阵 \(R_{x}(\theta)\) 和 \(R_{y}(\theta)\)：</p><div>$$\begin{aligned}R_{x}(\theta) =\left[\begin{matrix}1 & 0 & 0 \\0 & cos\theta & -sin\theta \\0 & sin\theta & cos\theta\end{matrix}\right]\\R_{y}(\theta) =\left[\begin{matrix}cos\theta & 0 & sin\theta \\0 & 1 & 0 \\-sin\theta & 0 & cos\theta\end{matrix}\right]\end{aligned}\tag{3.15}$$</div><h3 id="3-1-绕任意轴旋转"><a href="#3-1-绕任意轴旋转" class="headerlink" title="3.1 绕任意轴旋转"></a>3.1 绕任意轴旋转</h3><p>如果如果希望将向量P绕一个<strong>任意轴旋转</strong> \(\theta\) 角，选定的任意轴以单位向量A表示，那么可以先将向量P分解为平行于A和垂直于A的分量。<br>如图3.4所示，由于平行分量在旋转过程中保持不变，所以只需要计算垂直于A的分量的旋转。</p><div align="center"><p><img src="/images/3d-math-c3-3-2.jpg"></p></div><p>A是一个单位向量，P在A上地投影为（公式1.18）：</p><div>$$proj_{A}P = \frac{P \cdot A}{A^{2}} A = (P \cdot A)A\tag{3.16}$$</div><p>P垂直于A的分量为（公式1.19）：</p><div>$$perp_{A} P = P - proj_{A} P = P - (P \cdot A)A\tag{3.17}$$</div><p>将垂直于A的分量进行旋转，再加上平行分量，就得到最终的旋转结果。</p><p>垂直分量的旋转实在垂直于A轴的平面内进行的，平面中可以用垂直分量和垂直分量旋转90°所形成的向量组成一组正交基，就可以表达该平面内的任意向量，垂直分量旋转90°的向量可以用 \(A \times P\) 得到。</p><p>用下面的公式表示 \(perp_{A}P\)旋转 \(\theta\)角，即：</p><div>$$[P - (P \cdot A)A]cos\theta + (A \times P)sin\theta\tag{3.18}$$</div><p>再加上平行分量 \(proj_{A}P\)，就可以得到P绕A轴旋转的公式：</p><div>$$P^{'} = [P - (P \cdot A)A]cos\theta + (A \times P)sin\theta + (P \cdot A)A \\= Pcos\theta + (A \times P)sin\theta + (P \cdot A)A(1 - cos\theta)\tag{3.19}$$</div><p>将其中的 \(A \times P\)和 \((P \cdot A)A\)替换为等价矩阵形式，就可以更加具体的表示出旋转矩阵 \(R_{A}(\theta)\)，公式过于繁杂就不再赘述。</p><h2 id="4-齐次坐标"><a href="#4-齐次坐标" class="headerlink" title="4 齐次坐标"></a>4 齐次坐标</h2><p>还有一个重要的变换是平移操作，在空间中平移坐标系，只需要简单地添加偏移向量，并不会影响坐标轴的方向和尺度，但这种矩阵无法用 \(3 \times 3\)的矩阵来直接表示，需要加一个平移分量：</p><div>$$P^{'} = MP + T \tag{3.22}$$</div><p>M为可逆变换矩阵，T是平移向量。</p><h3 id="4-1-四维变换"><a href="#4-1-四维变换" class="headerlink" title="4.1 四维变换"></a>4.1 四维变换</h3><p>可以用一种统一的数学形式来简洁而优雅地表示这些变换（包含平移操作），为了做到这一点，需要将向量从三维扩展到四维，使用 \(4 \times 4\)矩阵来表示变换操作，给3D点P增加一个坐标，并将这个扩展的第四坐标(称为w坐标)的值设为1。</p><p>构造一个  \(4 \times 4\)变换矩阵F，F对应于变换矩阵M和3D平移变换T：</p><div>$$F =\left[\begin{matrix}M & T \\0 & 1\end{matrix}\right]=\left[\begin{matrix}M_{11} & M_{12} & M_{13} & T_{x} \\M_{21} & M_{22} & M_{23} & T_{y} \\M_{31} & M_{32} & M_{33} & T_{z} \\0 & 0 & 0 & 1\end{matrix}\right]\tag{3.24}$$</div><p>这个矩阵乘以向量 \(P=&lt;P_{x}, P_{y}, P_{z}, 1&gt;\) 就等效于公式3.22，同时结果w坐标保持为1.</p><h3 id="4-2-点向量和方向向量"><a href="#4-2-点向量和方向向量" class="headerlink" title="4.2 点向量和方向向量"></a>4.2 点向量和方向向量</h3><p>Tips：书上把点坐标叫做点向量还是蛮奇怪的，就理解成点坐标就行了。</p><p>由于方向向量不会受平移变换的影响，所以在其扩展四维时，其w坐标设置为0（其实也可以从两个点坐标相减的角度理解，两个w相减就是0了），这个时候F矩阵中只有左上的 \(3 \times 3\) 部分可以影响方向向量。</p><h3 id="4-3-坐标的几何解释"><a href="#4-3-坐标的几何解释" class="headerlink" title="4.3 坐标的几何解释"></a>4.3 坐标的几何解释</h3><p>假设有一个四维点 \(P=&lt;x, y, z, w&gt;\)，其中坐标不为0，这里定义P在三维空间的映像，<br>如果用 \(\widetilde{P}\)表示P在 \(w=1\)的三维空间中的投影，\(\widetilde{P}\)可以用下面的公式来表示：</p><div>$$\widetilde{P} = <\frac{x}{w}, \frac{y}{w}, \frac{z}{w}>\tag{3.28}$$</div><div align="center"><p><img src="/images/3dmath-c3-3.6.jpg" alt="图3.6 四维点P在三维空间的投影"></p></div><p>如图3.6所示（图中省略z轴为了方便表示），三维点 \(\widetilde{P}\) 对应于连接点P与原点的直线和 \(w=1\)的平面的交点，从这一点可以知道，对四维向量P作任意系数乘积，其结果都对应于三维空间中一个相同的点，在第4章5节中详细讨论这种投影在三维图形中的重要性。</p><h2 id="5-法向量的变换"><a href="#5-法向量的变换" class="headerlink" title="5 法向量的变换"></a>5 法向量的变换</h2><p>一个多边形模型的顶点除了需要表示空间位置外，还要包含一些附加信息，这些信息用来表示<strong>该顶点是如何融合到周围的曲面中的</strong>。一般情况下，顶点可能有<strong>切线向量</strong>和<strong>法线向量</strong>与之关联。<strong>当变换一个模型时，不但要变换顶点，同时还要对与顶点有关的向量进行变换</strong>。</p><p>可通过求两个顶点之间的差来计算<strong>切线向量</strong>，所以经过<strong>变换的切线向量</strong>可以表示为<strong>两个变换点的差</strong>。如果使用一个矩阵来变换顶点位置，也可以用这个矩阵来变换顶点的切向量。图3.7所示所示为用一个<strong>非正交矩阵M变换法向量N</strong>时发生的情况，变换后的法向量最终不垂直于变换后的表面。</p><div align="center"><p><img src="/images/3dmath-c3-3.7.jpg" alt="图3.7 用非正交矩阵M变换法向量"></p></div><p>因为切线方向和法线方向是垂直的，所以同一顶点的切向量T和法向量N必须满足等式 \(N \cdot T = 0\)，并且必须保证变换后的切向量 \(T^{‘}\)和法向量 \(N^{‘}\)仍然满足等式，设变换矩阵为M，有 \(T^{‘}=MT\)，设变换N所需的矩阵为G，有：</p><div>$$N^{'} \cdot T^{'} = (GN) \cdot (MT) = 0\tag{3.29}$$</div><p>经过简单的运算，可以得到：</p><div>$$(GN) \cdot (MT) = (GN)^{T}(MT) = N^{T}G^{T}MT\tag{3.30}$$</div><p>由于 \(N^{T}T=0\)，如果 \(G^{T}M=I\)，则等式 \(N^{T}G^{T}MT\) 肯定成立。<br>因此可以得出 \(G=(M^{-1})^{T}\)。可以看出，用变换点的矩阵的逆转置矩阵，就能正确地变换法向量，<strong>必须通过这种方式变换的向量称为协变向量</strong>，用矩阵M以通常方式变换的向量（点或切向量）称为<strong>逆变向量</strong>。</p><p><strong>如果矩阵M是正交的</strong>，那么 \(M^{-1}=M^{T}\)，因此 \((M^{-1})^{T}=M\)，所以当M是正交矩阵时，<strong>法向量变换过程的求逆转置运算就可以避免</strong>，这一点适用于本章前面提到的当M等于旋转矩阵的情况。</p><h2 id="6-四元数"><a href="#6-四元数" class="headerlink" title="6 四元数"></a>6 四元数</h2><p>四元数是三维图像编程人员用来表示旋转的另一种数学形式。</p><p>在许多情况下，用四元数代替旋转矩阵会有很多的好处，因为四元数需要的存储空间更少，四元数之间的<strong>连接运算</strong>需要的算术运算更少，在产生平滑的三维动画时，用四元数更容易进行修改。</p><h3 id="6-1-四元数数学"><a href="#6-1-四元数数学" class="headerlink" title="6.1 四元数数学"></a>6.1 四元数数学</h3><p>四元数集合，被数学家们称为哈密顿四元数环(ring of Hamiltonian quaternions)，用H表示，可以理解为四维向量空间，空间中的元素q具有以下形式：</p><div>$$q = [w, x, y, z] = w + xi + yj + zk\tag{3.31}$$</div><p>四元数经常写为 \(q=s+v\)的形式，其中s表示数量部分，对应于q中的w分量，v表示向量部分，对应于q中的x,y,z分量。</p><p>四元数集合是复数集合的自然扩展，四元数的乘法服从分配率，并且虚部i,j,k之间的乘法服从下面的规则：</p><div>$$\begin{aligned}i^{2} &= j^{2} = k^{2} = -1 \\ij &= -ji = k \\jk &= -kj = i \\ki &= -ik = j\end{aligned}\tag{3.32}$$</div><p>四元数式的乘法是不可交换的，因此运算要注意顺序。</p><p>两个四元数 \(q_{1}=w_{1}+x_{1}i+y_{1}j+z_{1}k\) 和 \(q_{2}=w_{2}+x_{2}i+y_{2}j+z_{2}k\) 的乘积 \(q_{1}q_{2}\) 为：</p><div>$$q_{1}q_{2} = \\(w_{1}w_{2} - x_{1}x_{2} - y_{1}y_{2} - z_{1}z_{2}) + \\(w_{1}x_{2} + x_{1}w_{2} + y_{1}z_{2} - z_{1}y_{1})i + \\(w_{1}y_{2} - x_{1}z_{2} + y_{1}w_{2} + z_{1}x_{2})j + \\(w_{1}z_{2} + x_{1}y_{2} - y_{1}x_{2} + z_{1}w_{2})k\tag{3.33}$$</div><p>如果写成数量-向量形式，则 \(q_{1}=s_{1}+v_{1}\) 和 \(q_{2}=s_{2}+v_{2}\) 的乘积可以写成如下形式：</p><div>$$q_{1}q_{2} = s_{1}s_{2} - v_{1} \cdot v_{2} + s_{1}v_{2} + s_{2}v_{1} + v_{1} \times v_{2}\tag{3.34}$$</div><p>和复数一样，四元数有共轭。</p><p><strong>【定义3.4】</strong> 四元数 \(q=s+v\)的共轭，记为 \(\bar{q}\)，定义为 \(\bar{q}=s-v\)。</p><p>通过简单的运算，就可以发现q与其共轭 \(\bar{q}\)的乘积等于q自身的点积，也就是等于q模的平方。</p><div>$$q \bar{q} = \bar{q} q = q \cdot q = ||q||^{2} = q^{2}\tag{3.35}$$</div><p><strong>【定理3.5】</strong> 非零的四元数的逆，记为 \(q^{-1}\)，则有：</p><div>$$q^{-1} = \frac{\bar{q}}{q^{2}}\tag{3.36}$$</div><h3 id="6-2-四元数的旋转"><a href="#6-2-四元数的旋转" class="headerlink" title="6.2 四元数的旋转"></a>6.2 四元数的旋转</h3><p>三维空间的旋转可以理解为 \(R^{3}\) 到自身 的映射函数 \(\varphi\)。由于\(\varphi\)代表旋转，所以它必须包含长度、角度、旋转方向等信息。如果有：</p><div>$$||\varphi(P)||=||P||\tag{3.39}$$</div><p>则<strong>长度保持不变</strong>。</p><p>如果对任意两个点 \(P_{1}\) 和 \(P_{2}\)有：</p><div>$$\varphi(P_{1}) \cdot \varphi(P_{2}) = P_{1} \cdot P_{2}\tag{3.40}$$</div><p>则从原点到两个点 \(P_{1}\) 和 \(P_{2}\)的连线所形成的<strong>夹角保持不变</strong>。</p><p>最后，如果：</p><div>$$\varphi(P_{1}) \times \varphi(P_{2}) = \varphi(P_{1} \times P_{2})\tag{3.41}$$</div><p>则<strong>手向性也保持</strong>不变。</p><p>如果满足条件 \(\varphi(s+v)=s+\varphi(v)\)，则函数 \(\varphi\)可以扩展为H到自身的映射，这样就允许将公式(3.40)重写为：</p><div>$$\varphi(P_{1}) \cdot \varphi(P_{2}) = \varphi(P_{1} \cdot P_{2})\tag{3.42}$$</div><p>如果将 \(P_{1}\)和 \(P_{2}\)看成是数量部分为0的四元数，根据 \(P_{1}P_{2} = -P_{1} \cdot P_{2} + P_{1} \times P_{2}\)，就可以将等式(3.41)和(3.42)合并成一个等式，在该等式中可以<strong>保持角度不变和手向性不变</strong>，公式如下：</p><div>$$\varphi(P_{1})\varphi(P_{2}) = \varphi(P_{1}P_{2})\tag{3.43}$$</div><p>满足这种等式的函数 \(\varphi\) 称为是<strong>同态</strong>的。</p><p>这一类函数可以用下面的公式给出：</p><div>$$\varphi_{q}(P) = qPq^{-1}\tag{3.44}$$</div><p>其中q是一个非0的四元数，且满足等式(3.39)（长度不变）和(3.43)（角度不变、手向性不变），因此可以表示旋转的集合。</p><p>现在需要找到一个关于四元数q的公式，q对应于 \(\theta\)角绕A轴的旋转。<br>简单的计算表明 \(\varphi_{aq}=\varphi_{q}\) 适用于任何非零数量a，为了简单起见，只涉及单位四元数。设 \(q=s+v\) 是<strong>单位四元数</strong>，则 \(q^{-1}=s-v\)，对于给定的点P，有：</p><div>$$\begin{aligned}qPq^{-1} &= (s + v)P(s - v) \\&= (-v \cdot P + sP + v \times P)(s - v) \\&= -sv \cdot P + s^{2}P + sv \times P + (v \cdot P)v - sPv - (v \times P)v \\&= s^{2}P + 2sv \times P + (v \cdot P)v - v \times P \times v\end{aligned}\tag{3.47}$$</div><p>对叉积 \(v \times P \times v\) 使用定理1.9(6)，这个等式就变为：</p><div>$$\begin{aligned}v \times (P \times v) = v \times P \times v = v^{2}P - (v \cdot P) v \\qP^{-1}q = (s^{2}-v^{2})P + 2sv \times P + 2(v \cdot P)v\end{aligned}\tag{3.48}$$</div><p>设 \(v=tA\)，其中A为单位向量，则上式可改写为：</p><div>$$qP^{-1}q = (s^{2}-v^{2})P + 2stA \times P + 2t^{2}(A \cdot P)A\tag{3.49}$$</div><p>比较等式(3.19)给出的绕任意轴旋转的公式，可以推出下面的等式：</p><div>$$P^{'} = [P - (P \cdot A)A]cos\theta + (A \times P)sin\theta + (P \cdot A)A \\= Pcos\theta + (A \times P)sin\theta + (P \cdot A)A(1 - cos\theta)\tag{3.19}$$</div><div>$$\begin{aligned}s^{2} - t^{2} &= cos\theta \\2st &= sin\theta \\2t^{2} &= 1 - cos\theta\end{aligned}\tag{3.50}$$</div><p>由第三个等式可以得出：</p><div>$$t = \sqrt{\frac{1-cos\theta}{2}} = sin\frac{\theta}{2}\tag{3.51}$$</div><p>结合式(3.50)中第一和第三个等式，可以得出 \(s^{2}+t^{2}=1\)，因此可以肯定 \(s=cos\frac{\theta}{2}\)。</p><p>现在可以用下面的等式给出对应于 \(\theta\)角绕A轴旋转的单位四元数q为：</p><div>$$q = cos\frac{\theta}{2} + Asin\frac{\theta}{2}\tag{3.52}$$</div><p>这里应注意：四元数q的<strong>任意数量乘积</strong>(特别是-q)表示的是相同的旋转，这是因为之前说的\(\varphi_{aq}=\varphi_{q}\) 适用于任何非零数量a。</p><div>$$(aq)P(aq)^{-1} = aqP \frac{q^{-1}}{a} = qP^{-1}q\tag{3.53}$$</div><p>两个四元数的乘积也可以表示一个旋转，乘积 \(q_{1}q_{2}\) 表示<strong>先以</strong> \(q_{2}\)，<strong>后以</strong> \(q_{1}\)进行旋转：</p><div>$$q_{1}(q_{2}Pq_{2}^{-1})q_{1}^{-1} = (q_{1}q_{2})P(q_{1}q_{2})^{-1}\tag{3.54}$$</div><p>可以将任意多的四元数结合起来，形成表示一系列旋转的一个四元数，<br>将两个四元数相乘需要做16次乘法和加法运算，而两个 \(3 \times 3\) 矩阵相乘需要27次这样的操作，因此当对物体进行多次旋转时，应用四元数可以获得较高的计算效率。</p><p>经常需要将一个四元数变成等价的 \(3 \times 3\)旋转矩阵的形式。<br>利用等式(1.25)和(1.20)，可以确定对应于四元数 \(q = s + tA\)的矩阵公式。</p><div>$$P \times Q =\left[\begin{matrix}0 & -P_{z} & P_{y} \\P_{z} & 0 & -P_{x} \\-P_{y} & P_{x} & 0\end{matrix}\right]\left[\begin{matrix}Q_{x} \\Q_{y} \\Q_{z}\end{matrix}\right]\tag{1.25}$$</div><div>$$proj_{Q} P = \frac{1}{Q^{2}}\left[\begin{matrix}Q_{x}^{2} & Q_{x}Q_{y} & Q_{x}Q_{z} \\Q_{x}Q_{y} & Q_{y}^{2} & Q_{y}Q_{z} \\Q_{x}Q_{z} & Q_{y}Q_{z} & Q_{z}^{2}\end{matrix}\right]\left[\begin{matrix}P_{x} \\P_{y} \\P_{z}\end{matrix}\right]\tag{1.20}$$</div><p>然后将等式(3.49)改写成矩阵形式(和3.1节中用的技巧类似），由此可得：</p><div>$$qPq_{-1} =\left[\begin{matrix}s^{2}-t^{2} & 0 & 0 \\0 & s^{2}-t^{2} & 0 \\0 & 0 & s^{2}-t^{2}\end{matrix}\right]P + \\2st\left[\begin{matrix}0 & -A_{z} & A_{y} \\A_{z} & 0 & -A_{x} \\-A_{y} & A_{x} & 0\end{matrix}\right]P + \\2t^{2}\left[\begin{matrix}A_{x}^{2} & A_{x}A_{y} & A_{x}A_{z} \\A_{x}A_{y} & A_{y}^{2} & A_{y}A_{z} \\A_{x}A_{z} & A_{y}A_{z} & A_{z}^{2}\end{matrix}\right]P\tag{3.55}$$</div><p>将四元数p写成四维向量 \(q=&lt;w,x,y,z&gt;\)，那么 \(w=s, x=tA_{x}, y=tA_{y}, z=tA_{z}\)，因此A是单位向量，所以 \(x^{2}+y^{2}+z^{2} = t^{2}A^{2} = t^{2}\)，以 \(w,x,y,z\)为分量，则公式(3.55)可以改写为：</p><div>$$qPq_{-1} =\left[\begin{matrix}w^{2}-x^{2}-y^{2}-z^{2} & 0 & 0 \\0 & w^{2}-x^{2}-y^{2}-z^{2} & 0 \\0 & 0 & w^{2}-x^{2}-y^{2}-z^{2}\end{matrix}\right]P + \\2w\left[\begin{matrix}0 & -z & y \\z & 0 & -x \\-y & x & 0\end{matrix}\right]P + \\2\left[\begin{matrix}x^{2} & xy & xz \\xy & y^{2} & yz \\xz & yz & z^{2}\end{matrix}\right]P\tag{3.56}$$</div><p>因为q是单位四元数，满足 \(w^{2} + x^{2} + y^{2} + z^{2} = 1\)，所以有：</p><div>$$w^{2} - x^{2} - y^{2} - z^{2} = 1 - 2x^{2} - 2y^{2} - 2z^{2}\tag{3.57}$$</div><p>根据该等式，并结合前面的三个矩阵，可以得到用来计算矩阵 \(R_{q}\) 的公式，这里的 \(R_{q}\) 表示对应于四元数q的旋转矩阵，公式为：</p><div>$$R_{q} = \left[\begin{matrix}1-2y^{2}-2z^{2} & 2xy-2wz & 2xz+2wy \\2xy+2wz & 1-2x^{2}-2z^{2} & 2yz-2wx \\2xz-2wy & 2yz+2wx & 1-2x^{2}-2y^{2}\end{matrix}\right]\tag{3.58}$$</div><h3 id="6-3-球形线性插值"><a href="#6-3-球形线性插值" class="headerlink" title="6.3 球形线性插值"></a>6.3 球形线性插值</h3><p>因为四元数是用向量表示的，所以很适合于插值运算。<br>在产生一个物理动画的过程中，在产生位于两个预先计算的关键帧之间的中间过渡定位时，插值非常有用。</p><p>最简单的插值类型是<strong>线性插值</strong>，对于两个四元数 \(q_{1}\)和 \(q_{2}\)，线性插值后所得的四元数 \(q_{t}\)为：</p><div>$$q(t) = (1-t)q_{1} + tq_{2} \tag{3.59}$$</div><p>当t在0和1之间变化时，函数 \(q(t)\)在连接 \(q_{1}\)和 \(q_{2}\)的线段上平滑变化。</p><div align="center"><p><img src="/images/3d-math-c3-6-3.jpg" alt="四元数的线性插值"></p></div><p>如上图所示，\(q(t)\)并不保持 \(q_{1}\)和 \(q_{2}\)的单位长度，但可以使用下面的函数在任意点位置对 \(q(t)\)进行重新规格化：</p><div>$$q(t)=\frac{(1-t)q_{1} + tq_{2}}{||(1-t)q_{1} + tq_{2}||}\tag{3.60}$$</div><p>尽管线性插值是很有效的，但由等式(3.60)得出的函数 \(q(t)\)并没有以恒定的速率描绘 \(q_{1}\)和 \(q_{2}\)间的过渡弧线，这是线性插值的弊端。如下图所示，\(q_{1},q_{2}\)之间的角度变化速率在端点时相对较慢，在中间的地方最快。</p><div align="center"><p><img src="/images/3d-math-c3-6-4.jpg" alt="arccos(q(t)·q1)的曲线"></p></div><p>我们希望找到一个函数 \(q(t)\)，用它对四元数 \(q_{1}\)和 \(q_{2}\)进行插值时，<br>会保持其单位长度不变并且以恒定的速率扫过位于 \(q_{1}\)和 \(q_{2}\)之间的夹角。</p><p>如果 \(q_{1}\)和 \(q_{2}\)的夹角为 \(\theta\)，那么这个函数将会产生一个四元数，该四元数在 \(q(t)\)和 \(q_{1}\)之间形成一个夹角 \(\theta t\)，这里t在0在1之间取值。</p><p>如下图所示，四元数 \(q(t)\)位于连接 \(q_{1}\)和 \(q_{2}\)的弧上，与 \(q_{1}\)构成夹角 \(\theta t\)，与 \(q_{2}\)构成夹角 \(\theta(1-t)\)，可以将 \(q(t)\)写成：</p><div>$$q(t) = a(t)q_{1} + b(t)q_{2} \tag{3.61}$$</div><div align="center"><p><img src="/images/3d-math-c3-6-5.jpg" alt="图(a)和图(b) 用相似三角形得到分量长度"></p></div><p>如图(a)所示，可以构造相似三角形来确定长度 \(a(t)\)，\(q_{1}\)到以原点和 \(q_{2}\)为端点的线段的垂直距离为 \(||q_{1}||sin\theta\)，而 \(q(t)\)到该线段的垂直距离为 \(||q(t)||sin(\theta(1-t))\)，根据相似三角形，可以由：</p><p>Tips：书上说的这个相似三角形在图(a)中并不明显，是以角 \(\theta\)为共同角，将边 \(||q(t)||sin(\theta(1-t))\) 平移到左边，构成的一个小三角形。</p><div>$$\frac{a(t)}{||q(t)||sin(\theta(1-t))} =\frac{||q_{1}||}{||q||sin\theta}$$</div><p>所以有：</p><div>$$\frac{a(t)}{||q_{1}||} =\frac{||q(t)||sin(\theta(1-t))}{||q||sin\theta}\tag{3.62}$$</div><p>由于 \(||q_{1}||=1\)，\(||q(t)||=1\)，可以将上式简化为：</p><div>$$a(t) = \frac{sin(\theta(1-t))}{sin\theta}\tag{3.63}$$</div><p>图(b)表示了求长度 \(b(t)\)的相同过程，有结果：</p><div>$$b(t) = \frac{sin(\theta t)}{sin\theta}\tag{3.64}$$</div><p>可以将球型线性插值函数 \(q(t)\)定义如下：</p><div>$$q(t)= \frac{sin(\theta(1-t))}{sin\theta}q_{1} + \frac{sin(\theta t)}{sin\theta}q_{2}\tag{3.65}$$</div><p>这里的角 \(\theta\) 为：</p><div>$$\theta = arccos(q_{1} \cdot q_{2})\tag{3.66}$$</div><p>\(sin\theta\)计算：</p><div>$$sin\theta = \sqrt{1-(q_{1} \cdot q_{2})^{2}}\tag{3.67}$$</div><p>因为四元数 \(q\) 和\(-q\)表示<strong>相同的旋转</strong>，所以选择四元数 \(q_{1}\)和 \(q_{2}\)的正负号时一般要满足 \(q_{1} \cdot q_{2} \geq 0\)，这样可以保证以最短路径的方式进行插值。</p>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;3D游戏开发过程中，通常需要以某种方式对向量进行变换。&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="3D游戏与图形学的数学" scheme="https://yumi-cn.github.io/categories/3D%E6%B8%B8%E6%88%8F%E4%B8%8E%E5%9B%BE%E5%BD%A2%E5%AD%A6%E7%9A%84%E6%95%B0%E5%AD%A6/"/>
    
    
    <category term="笔记" scheme="https://yumi-cn.github.io/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>《实时渲染 4th》第1章笔记 导论</title>
    <link href="https://yumi-cn.github.io/2020/12/09/rtr-c1/"/>
    <id>https://yumi-cn.github.io/2020/12/09/rtr-c1/</id>
    <published>2020-12-09T11:12:14.000Z</published>
    <updated>2020-12-09T14:01:50.228Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>实时渲染一般指计算机里的快速图像生成。</p></blockquote><a id="more"></a><p>PS：原书《Real Time Rendering 4th》全英文，有些词翻译如果不够好还请见谅。</p><p>Tips：屏幕刷新率(refresh rate)和显示频率(display rate)在现在是有区别的；</p><blockquote><p>We will not be able to cover every topic in depth, so our goal is to present key concepts and terminology, explain the most robust and practical algorithms in the field, and provide pointers to the best places to go for more information.</p></blockquote><p>虽然这本书没有覆盖到实时渲染涉及到的每一个主题，但本书的目的是呈现关键概念和术语、解释最鲁邦和实用的算法、提供深入了解这些内容的方向指引。</p><h2 id="1-内容概览"><a href="#1-内容概览" class="headerlink" title="1 内容概览"></a>1 内容概览</h2><ul><li><strong>第2章 图形渲染管线</strong>：<code>The Graphics Rendering Pipeline</code>，实时渲染的核心是通过什么样的步骤来将场景传达到显示上；</li><li><strong>第3章 图形处理单元</strong>：<code>The Graphics Processing Unit</code>，现代GPU中一般通过一组计算单元(fixed-function and programmable units)来实现渲染管线；</li><li><strong>第4章 变换</strong>：<code>Transforms</code>，变换是操作物体位置、方向、大小以及形状、控制摄像机位置和视角的基本工具；</li><li><strong>第5章 着色基础</strong>：<code>Shading Basics</code>，着色一般指的是通过材质(Material)和光源(Light)来表现物体，还有一些相关的主题，例如抗锯齿（反走样 antialiasing）、透明处理以及Gamma矫正；</li><li><strong>第6章 纹理</strong>：<code>Texturing</code>，纹理贴图用于在物体表面呈现纹理；</li><li><strong>第7章 光影</strong>：<code>Shadows</code>，光影让场景更有真实情感，会介绍一些快速计算光影的流行算法；</li><li><strong>第8章 光和颜色</strong>：<code>Light and Color</code>，讲解计算机是如何如何量化光和颜色，以及把这些量化转换成显示量纲的方法；</li><li><strong>第9章 基于物理的着色</strong>：<code>Physically Based Shading</code>，基于物理的着色会更加接近真实；</li><li><strong>第10章 局部光照</strong>：<code>Local Illumination</code>，主要介绍一些渲染复杂光源的算法，例如光源本身具有物理形状；</li><li><strong>第11章 全局光照</strong>：<code>Global Illumination</code>，模拟光源和场景之间的交互的算法，进一步增加场景的真实度；</li><li><strong>第12章 图像效果</strong>：<code>Image-Space Effects</code>，GPU擅长快速处理图像，首先介绍图像滤波(image filtering)和重投影(reprojection)技术，然后介绍一些流行的后期效果，例如镜头光晕(lens flares)、动态模糊(motion blur)以及景深(depth of field)；</li><li><strong>第13章 几何之外</strong>：<code>Beyond Polygons</code>，三角形不一定总是最快或最真实地描述物体的方式，还有其他方式，例如图片(images)、点云(point clouds)、体素(voxels)等；</li><li><strong>第14章 体渲染和透光渲染</strong>：<code>Volumetric and Translucency Rendering</code>，介绍体积材质(volumetric material)（例如云、烟、雾）的表达方式以及和光的交互，大到气象效果，小到头发渲染；</li><li><strong>第15章 非真实渲染</strong>：<code>Non-Photorealistic Rendering</code>，主要介绍一些风格渲染，例如卡通渲染(cartoon shading)、水彩效果(watercolor<br>effects)；</li><li><strong>第16章 几何技术</strong>：<code>Polygonal Techniques</code>，几何体数据的来源各种各样，如果需要又快又好地渲染，就需要进行一定处理，涉及到几何数据表达和压缩方法；</li><li><strong>第17章 曲线和曲面</strong>：<code>Curves and Curved Surfaces</code>，复杂的表面表达提供的优势在于更好的在质量和速度中进行取舍，表达越简洁，曲面就越光滑；</li><li><strong>第18章 管线优化</strong>：<code>Pipeline Optimization</code>，寻找渲染瓶颈来优化速度，涉及到一些多线程技术；</li><li><strong>第19章 加速算法</strong>：<code>Acceleration Algorithms</code>，比快更快，Various<br>forms of culling and level of detail rendering are covered；</li><li><strong>第20章 高效着色</strong>：<code>Efficient Shading</code>，越多的光源，渲染就越慢，在渲染前无法知道是否需要渲染会造成资源浪费，使用一些方法可以解决这些问题；</li><li><strong>第21章 虚拟现实和增强现实</strong>：<code>Virtual and Augmented Reality</code>，这些领域有很多特定的技术难题，也有一些相应方法来高效快速的生成图像；</li><li><strong>第22章 相交检测</strong>：<code>Intersection Test Methods</code>，深入介绍一些几何相交检测的高效算法；</li><li><strong>第23章 图形硬件</strong>：<code>Graphics Hardware</code>，图形硬件的一些细节，例如色彩深度(color depth)、帧缓冲(framebuffers)和基础架构类型；</li><li><strong>第24章 面向未来</strong>：<code>The Future</code>，Take a guess (we do)。</li></ul><p>还有一些没有收录在实体书中，在<a href="http://www.realtimerendering.com/">realtimerendering.com</a>上更新的章节：</p><ul><li><strong>碰撞检测</strong>：<code>Collision Detection</code>，The 3rd edition’s chapter on this subject has been fully updated, but could not fit in the bounds of the physical book；</li><li><strong>实时光线追踪</strong>：<code>Real-Time Ray Tracing</code>，API support for this area was announced in March 2018, too late for inclusion in the book, so we wrote an additional chapter about the subject as a whole.</li><li><strong>附录</strong>：<code>Appendices</code>，The two appendices, Some Linear Algebra and Trigonometry, also had to be cut from the physical book.</li></ul><h2 id="2-标记和定义"><a href="#2-标记和定义" class="headerlink" title="2 标记和定义"></a>2 标记和定义</h2><h3 id="2-1-数学标记"><a href="#2-1-数学标记" class="headerlink" title="2.1 数学标记"></a>2.1 数学标记</h3><div align="center"><p><img src="/images/rtr-c1-t1.1.jpg" alt="表1.1 本书中的大部分标记"></p></div><p><strong>向量或者点</strong>通常用粗体小写字母表示，并且其内部组成一般写为：</p><div>$$\textbf{v} =\left(\begin{matrix}v_{x} \\v_{y} \\v_{z}\end{matrix}\right)$$</div><p>在图形学领域中一般用列向量的表达方式，有时候为了书面方便也会写成行向量。</p><p>书中使用到<strong>矩阵</strong>大多是 \(2 \times 2\)，\(3 \times 3\) 和\(4 \times 4\)，以\(3 \times 3\)矩阵为例，说明矩阵的表示方式：</p><div>$$\textbf{M} =\left(\begin{matrix}m_{00} & m_{01} & m_{02} \\m_{10} & m_{11} & m_{12} \\m_{20} & m_{21} & m_{22}\end{matrix}\right)\tag{1.1}$$</div><p>有时候为了表达需求，会只关注行向量或者列向量的内容，矩阵也可以写为：</p><div>$$\textbf{M} =\left(\begin{matrix}\textbf{m}_{,0} & \textbf{m}_{,1} & \textbf{m}_{,2}\end{matrix}\right)=\left(\begin{matrix}\textbf{m}_{0,}^{T} \\\textbf{m}_{1,}^{T} \\\textbf{m}_{2,}^{T}\end{matrix}\right)\tag{1.2}$$</div><p>其中 \(\textbf{m}_{,j}\) 代表第j列向量，\(\textbf{m}_{i,}\) 代表第i行向量。</p><p><strong>平面</strong>的数学表示是 \(\pi:\textbf{n}\cdot\textbf{x} + d = 0\)，其中 \(\textbf{n}\)是平面的法向量，\(d\)是标量，平面将空间分为两个子空间，正子空间是 \(\textbf{n}\cdot\textbf{x} + d &gt; 0\)，相应的负子空间是 \(\textbf{n}\cdot\textbf{x} + d &lt; 0\)</p><p>三角形通常用三个点来表示，例如有不共线的三点 \(\textbf{v}_{0}, \textbf{v}_{1}, \textbf{v}_{2}\)，构成的三角形是 \(\bigtriangleup\textbf{v}_{0}\textbf{v}_{1}\textbf{v}_{2}\)。</p><div align="center"><p><img src="/images/rtr-c1-t1.2.jpg" alt="表1.2 数学运算的标记"></p></div><p>大部分都应该是比较常见的，需要稍微特殊说明的几个：</p><ol start="4"><li>主要用于二维向量，求二维向量的垂直向量，例如有 \(\textbf{v}=(v_{x}, v_{y})\)，\(\textbf{v}^{\perp}=(-v_{y}, v_{x})\)；</li><li>将x映射为非负空间数，当其为负值时会变为0；</li><li>和8较为类似，映射到0-1空间中，大于1变为1，小于0变为0；</li><li><code>binomial coefficients</code>，二项式系数，\(\left(\begin{matrix}n \\ k\end{matrix}\right) = \frac{n!}{k!(n-k)!}\)。</li></ol><p>一般把 \(x=0, y=0, z=0\) 叫做 坐标平面(coordinate<br>planes)或者轴对齐平面(axis-aligned planes)，将轴 \(\textbf{e}_{x}=(1, 0, 0), \textbf{e}_{y}=(0, 1, 0), \textbf{e}_{z}=(0, 0, 1)\)叫做主轴(main axes)或者主方向(main directions)，也分别叫做x轴(x-axis)，y轴(y-axis)和z轴(z-axis)。</p><div align="center"><p><img src="/images/rtr-c1-t1.3.jpg" alt="表1.3 其他需要说明的数学函数"></p></div><p>C语言数学函数 <code>atan2(y,x)</code> 有时候被经常提及到，它是<code>arctan(x)</code>的一个拓展，主要区别在于 \(-\frac{\pi}{2} &lt; arctan(x) &lt; \frac{\pi}{2}\)，\(0 \lep atan2(y, x) &lt; 2\pi\)，一种常用操作是计算<code>arctan(y/x)</code>，但是当<code>x=0</code>时会出现除0问题（尽管可能本意是表达一个无穷大数，但C语言会报除0错误），而这时候使用<code>atan2(y,x)</code>可以避免这样的问题。</p><p><code>log(n)</code>函数一般指的是自然数<code>e</code>为底数，而不是以<code>10</code>为底数。</p><p>默认情况下均使用右手坐标系。</p><p>颜色一般用一个三元向量表示，<code>(red, green, blue)</code>，各项的值都在[0,1]。</p><h3 id="2-2-几何定义"><a href="#2-2-几何定义" class="headerlink" title="2.2 几何定义"></a>2.2 几何定义</h3><p>最原石的一些基础渲染元(basic rendering primitives, also called drawing primitives)，最常用的是点、线和三角形。</p><p>在本书中，一组几何体(a collection of geometric entities)通常叫做一个<strong>模型</strong>(model)或者<strong>对象</strong>(object)；<strong>场景</strong>(scene)指的是环境中一组需要渲染模型，场景一般也包括材质描述、光线以及视角定义。</p><p>也有些不是使用点、线和三角形这种基础渲染元表达的模型，例如点云、函数表达（贝塞尔曲线）。</p><h3 id="2-3-Shading和Shader？"><a href="#2-3-Shading和Shader？" class="headerlink" title="2.3 Shading和Shader？"></a>2.3 Shading和Shader？</h3><p>本书中的 <strong>Shading</strong> 和 <strong>Shader</strong> 是两个截然不同但是又有关联的概念：</p><ul><li>前者指的是计算机生成的视觉表达(computer-generated visual appearance)，例如shading model、shading equation以及toon shading这些概念原理；</li><li>后者指的是渲染系统中的一个可编程单元，例如vertex shader、shading language。</li></ul><p>尽管他们用词形式上有一些混淆，但是要通过语境上下文来判断其指的是哪个概念（在书本以外可能会单独开一页来讲一些概念的区分）。</p>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;实时渲染一般指计算机里的快速图像生成。&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="Real Time Rendering 4th" scheme="https://yumi-cn.github.io/categories/Real-Time-Rendering-4th/"/>
    
    
    <category term="笔记" scheme="https://yumi-cn.github.io/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>《剑指Offer》第2章笔记 树</title>
    <link href="https://yumi-cn.github.io/2020/12/07/s2o-c2-tree/"/>
    <id>https://yumi-cn.github.io/2020/12/07/s2o-c2-tree/</id>
    <published>2020-12-07T12:18:45.000Z</published>
    <updated>2020-12-07T12:17:45.992Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>树的操作会涉及大量指针，因此与树相关的面试题都不太容易。</p></blockquote><a id="more"></a><p>树的逻辑很简单：</p><ul><li>除根节点之外，每个节点只有一个父节点，根节点没有父节点；</li><li>除叶节点之外，每个节点都有一个或多个子节点，叶节点没有子节点；</li><li>父节点和子节点之间用指针链接。</li></ul><p>面试中大部分都是<strong>二叉树</strong>，在二叉树中每个节点最多只能有两个子节点。</p><p>二叉树中最重要的操作是如何遍历数结构，按照某种顺序访问树的所有节点，通常有几种遍历方式：</p><ul><li>前序：父-&gt;左子-&gt;右子；</li><li>中序：左子-&gt;父-&gt;右子；</li><li>后序：左子-&gt;右子-&gt;父；</li><li>层序：从根节点层到叶节点层，按层输出，每一层按照从左到右输出。</li></ul><p>二叉树中又有一些特例：</p><ul><li><strong>二叉搜索树</strong>：在二叉搜索树中，左子节点总是小于或等于父节点，右子节点总是大于或等于父节点，可以平均在<code>O(logn)</code>的时间内根据值在二叉树中查找节点；</li><li><strong>堆</strong>：堆分为最大堆和最小堆，在最大堆中，根节点的值最大，最小堆中的根节点值最小（其他节点按子树递推），有很多需要快速找到最大值或最小值的问题都可以用堆来解决；</li><li><strong>红黑树</strong>：把树中的节点定义为红、黑两种颜色，并通过规则确保<strong>从根节点到叶节点的最长路径</strong>的长度<strong>不超过</strong>最短路径的两倍；在C++的STL中，<code>set</code>、<code>multiset</code>、<code>map</code>、<code>multimap</code>等都是基于红黑树实现的。</li></ul><blockquote><p>面试题7：重建二叉树</p></blockquote><p>输入二叉树的前序和中序遍历结果，重建该二叉树，假设输入的前序中序结构中都不含有重复的数字。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 二叉树节点定义</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">  <span class="keyword">int</span> value;</span><br><span class="line">  Node* left;</span><br><span class="line">  Node* right;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><div align="center"><p><img src="/images/s2o-c2-tree-cv-7.jpg"></p></div><p>在前序遍历中，第一个数字总是树的根节点；但在中序遍历中，根节点的值在序列中间，左子树的值位于根节点左边，右子树的值位于根节点右边；所以<strong>对于一个子树</strong>，我们在<strong>前序中寻找其根节点</strong>（第一个出现的值），然后在<strong>中序中根据根节点的位置</strong>，把<strong>剩下的点</strong>分为<strong>左子树和右子树</strong>。</p><p>完整代码实现：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;exception&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> value;</span><br><span class="line">    Node* left;</span><br><span class="line">    Node* right;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Node* construct_core</span><br><span class="line">(</span><br><span class="line">    <span class="keyword">int</span>* po_start, <span class="keyword">int</span>* po_end,</span><br><span class="line">    <span class="keyword">int</span>* io_start, <span class="keyword">int</span>* io_end</span><br><span class="line">) &#123;</span><br><span class="line">    <span class="keyword">int</span> root_value = po_start[<span class="number">0</span>];</span><br><span class="line">    Node* root = <span class="keyword">new</span> Node();</span><br><span class="line">    root-&gt;value = root_value;</span><br><span class="line">    root-&gt;left = root-&gt;right = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">if</span>(po_start == po_end) &#123;</span><br><span class="line">        <span class="keyword">if</span>(io_start == io_end &amp;&amp; *po_start == *io_start) &#123;</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// Windows Ver Error</span></span><br><span class="line">            <span class="built_in">std</span>::logic_error ex(<span class="string">&quot;Invalid input&quot;</span>);</span><br><span class="line">            <span class="keyword">throw</span> <span class="built_in">std</span>::exception(ex);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span>* io_root = io_start;</span><br><span class="line">    <span class="keyword">while</span>(io_root &lt;= io_end &amp;&amp; *io_root != root_value) &#123;</span><br><span class="line">        io_root++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(io_root == io_end &amp;&amp; *io_root != root_value) &#123;</span><br><span class="line">        <span class="comment">// Windows Ver Error</span></span><br><span class="line">        <span class="function"><span class="built_in">std</span>::logic_error <span class="title">ex</span><span class="params">(<span class="string">&quot;Invalid input&quot;</span>)</span></span>;</span><br><span class="line">        <span class="keyword">throw</span> <span class="built_in">std</span>::exception(ex);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> left_len = io_root - io_start;</span><br><span class="line">    <span class="keyword">int</span>* left_po_end = po_start + left_len;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(left_len &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        root-&gt;left = construct_core(po_start+<span class="number">1</span>, left_po_end, io_start, io_root<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(left_len &lt; po_end - po_start) &#123;</span><br><span class="line">        root-&gt;right = construct_core(left_po_end + <span class="number">1</span>, po_end, io_root+<span class="number">1</span>, io_end);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Node* <span class="title">construct</span><span class="params">(<span class="keyword">int</span>* preodr, <span class="keyword">int</span>* inodr, <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(preodr == <span class="literal">nullptr</span> || inodr == <span class="literal">nullptr</span> || len &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> construct_core(preodr, preodr + len - <span class="number">1</span>,</span><br><span class="line">            inodr, inodr + len - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">post_order_print</span><span class="params">(Node* node)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(node != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        post_order_print(node-&gt;left);</span><br><span class="line">        post_order_print(node-&gt;right);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, node-&gt;value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> preodr[<span class="number">8</span>] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">7</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">8</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> inodr[<span class="number">8</span>] = &#123;<span class="number">4</span>, <span class="number">7</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">3</span>, <span class="number">8</span>, <span class="number">6</span>&#125;;</span><br><span class="line">    Node* root = construct(preodr, inodr, <span class="number">8</span>);</span><br><span class="line">    post_order_print(root); <span class="comment">// 7 4 2 5 8 6 3 1</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>面试题8：二叉树的下一个节点</p></blockquote><p>给定二叉树和其中的一个节点，如何<strong>找出中序遍历序列的下一个节点</strong>？树节点除了有左右子节点指针，还有一个指向父节点的指针。</p><p>这类题目一般从各类情况具体分析入手：</p><ul><li>如果<strong>节点有右子树</strong>，则下一个节点就是<strong>右子树中的最左子节点</strong>；</li><li>如果<strong>节点没有右子树</strong>：<ul><li>如果该节点是<strong>父节点的左子节点</strong>，<strong>父节点</strong>就是下一个节点；</li><li>并且该节点是<strong>父节点的右子节点</strong>，按照中序遍历的逻辑，需要继续往上寻找，<strong>直到找到某一个节点A，这个节点A是A父节点的左子节点</strong>，如果不存在这样的节点，那就代表原节点为最后一个遍历节点了，没有下一个节点。</li></ul></li></ul><p>面试中遇到这种题，大概率只需要编写指定功能的函数部分，不需要编写完整的代码，所以需要对面试官询问具体的输入输出情况。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> value;</span><br><span class="line">    Node* left;</span><br><span class="line">    Node* right;</span><br><span class="line">    Node* parent;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">Node* <span class="title">find_next</span><span class="params">(Node* node)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(node == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Node* next = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">if</span>(node-&gt;right != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="comment">// 右子树的最左子节点（不一定需要是叶节点）</span></span><br><span class="line">        Node* temp = node-&gt;right;</span><br><span class="line">        <span class="keyword">while</span>(temp-&gt;left != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            temp = temp-&gt;left;</span><br><span class="line">        &#125;</span><br><span class="line">        next = temp;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (node-&gt;parent != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="comment">// 寻找满足条件的祖先节点</span></span><br><span class="line">        <span class="comment">// 某个节点是其父节点的左子节点</span></span><br><span class="line">        Node* temp = node;</span><br><span class="line">        Node* parent = node-&gt;parent;</span><br><span class="line">        <span class="keyword">while</span>(parent != <span class="literal">nullptr</span> &amp;&amp; temp == parent-&gt;right) &#123;</span><br><span class="line">            temp = parent;</span><br><span class="line">            parent = parent-&gt;parent;</span><br><span class="line">        &#125;</span><br><span class="line">        next = parent;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;树的操作会涉及大量指针，因此与树相关的面试题都不太容易。&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="剑指Offer" scheme="https://yumi-cn.github.io/categories/%E5%89%91%E6%8C%87Offer/"/>
    
    
    <category term="笔记" scheme="https://yumi-cn.github.io/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>《剑指Offer》第2章笔记 栈和队列</title>
    <link href="https://yumi-cn.github.io/2020/12/07/s2o-c2-stk-queue/"/>
    <id>https://yumi-cn.github.io/2020/12/07/s2o-c2-stk-queue/</id>
    <published>2020-12-07T12:17:27.000Z</published>
    <updated>2020-12-07T14:14:52.856Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>栈：先进后出，队列：先进先出。</p></blockquote><a id="more"></a><p>栈是一个非常常见的数据结构，在计算机领域被广泛应用，比如操作系统会给每个线程创建一个栈用来存储函数调用时各个函数的参数、返回地址以及临时变量等。栈的特点是<strong>后进先出</strong>。</p><p>在栈中通常需要<code>O(n)</code>时间才能找到栈最大或者最小的元素，如果想<code>O(1)</code>时间内找到则需要做特殊的设计。</p><p>队列是另一种很重要的数据结构，队列的特点是<strong>先进先出</strong>。</p><blockquote><p>面试题9：用两个栈实现队列</p></blockquote><p>使用栈实现队列的两个函数<code>appendTail</code>和<code>deleteHead</code>，分别完成在队列尾部插入节点和在队列头部删除节点的功能。</p><p>一个典型的队列定义：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="class"><span class="keyword">class</span> <span class="title">CQueue</span> &#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        CQueue(<span class="keyword">void</span>);</span><br><span class="line">        ~CQueue(<span class="keyword">void</span>);</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">appendTail</span><span class="params">(<span class="keyword">const</span> T&amp; node)</span></span>;</span><br><span class="line">        <span class="function">T <span class="title">deleteHead</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="built_in">stack</span>&lt;T&gt; stack1;</span><br><span class="line">        <span class="built_in">stack</span>&lt;T&gt; stack2;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>至于这道题的解法，基于一个简单的原理，将一组数先进行依次进栈、再依次出栈入栈到另一个栈里，再全部进行出栈，就完成了一个简单的队列先进先出。但如果只是单纯的依赖这样的过程，无法极大程度地利用栈的空间（例如用于出栈<code>deleteHead</code>的栈满时，用于进栈<code>appendTail</code>其实还可以继续利用起来）。</p><p>定义stack1为入队栈，stack2为出队栈。</p><ul><li>入队操作：<ul><li>当stack1不满时，直接入栈；</li><li>当stack1满时：<ul><li>如果stack2为空，将stack1中的元素依次出栈入栈stack2；</li><li>如果stack2中有元素，则无法入队；</li></ul></li></ul></li><li>出队操作：<ul><li>当stack2中有元素是，直接出栈；</li><li>当stack2为空时：<ul><li>如果stack1不为空，将stack1所有元素依次出栈入栈stack2，再出栈栈顶元素；</li><li>如果stack1为空，则队列为空，无法出队；</li></ul></li></ul></li></ul><p>完整实现代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;exception&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="class"><span class="keyword">class</span> <span class="title">CQueue</span> &#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="comment">// CQueue(void);</span></span><br><span class="line">        <span class="comment">// ~CQueue(void);</span></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">appendTail</span><span class="params">(<span class="keyword">const</span> T&amp; node)</span></span>;</span><br><span class="line">        <span class="function">T <span class="title">deleteHead</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">stack</span>&lt;T&gt; stack1;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">stack</span>&lt;T&gt; stack2;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="keyword">void</span> CQueue&lt;T&gt;::appendTail(<span class="keyword">const</span> T&amp; element) &#123;</span><br><span class="line">    <span class="comment">// 不限制栈容量时，直接入栈</span></span><br><span class="line">    stack1.push(element);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; T CQueue&lt;T&gt;::deleteHead() &#123;</span><br><span class="line">    <span class="keyword">if</span>(stack2.size() &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">while</span>(stack1.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            T&amp; data = stack1.top(); <span class="comment">// Why use T&amp;</span></span><br><span class="line">            stack1.pop();</span><br><span class="line">            stack2.push(data);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(stack2.size() == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// Throw Empty Error</span></span><br><span class="line">        <span class="function"><span class="built_in">std</span>::logic_error <span class="title">ex</span><span class="params">(<span class="string">&quot;queue is empty&quot;</span>)</span></span>;</span><br><span class="line">        <span class="keyword">throw</span> <span class="built_in">std</span>::exception(ex);</span><br><span class="line">    &#125;</span><br><span class="line">    T head = stack2.top();</span><br><span class="line">    stack2.pop();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    CQueue&lt;<span class="keyword">int</span>&gt; cqueue;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">        cqueue.appendTail(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; cqueue.deleteHead() &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">5</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">        cqueue.appendTail(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">7</span>; i++) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; cqueue.deleteHead() &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>相关题目：用两个队列实现一个栈。</p><p>简单分析一下思路，模仿入栈操作时，只能用使用入队操作，当需要出栈时，元素在队列尾部，只能将前面所有元素进行出队才能获取到，而出队剩下的元素就继续进入到第二个队列中。</p>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;栈：先进后出，队列：先进先出。&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="剑指Offer" scheme="https://yumi-cn.github.io/categories/%E5%89%91%E6%8C%87Offer/"/>
    
    
    <category term="笔记" scheme="https://yumi-cn.github.io/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>《3D图形的数学》第2章笔记 矩阵</title>
    <link href="https://yumi-cn.github.io/2020/12/01/3dmath-c2/"/>
    <id>https://yumi-cn.github.io/2020/12/01/3dmath-c2/</id>
    <published>2020-12-01T09:19:10.000Z</published>
    <updated>2020-12-01T12:51:52.499Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>在三维变换中，矩阵运算是最常用的表达方式。</p></blockquote><a id="more"></a><h2 id="1-矩阵的性质"><a href="#1-矩阵的性质" class="headerlink" title="1 矩阵的性质"></a>1 矩阵的性质</h2><p>一个 \(n \times m\) 的矩阵M就是一个有n行和m列的数组，如果 \(n = m\) 则矩阵M是方阵，把矩阵M第j列的第i行元素（或者第i行第j列）记作 \(M_{ij}\)。</p><p><strong>矩阵M的转置</strong>，记作 \(\textbf{M}^{T}\)，是一个\(m \times n\)矩阵，其中 \(M_{ij}^{T} = M_{ji}\)。</p><p><strong>矩阵的数乘</strong>，或者叫标量乘积，和向量类似，是乘以矩阵的每个元素。</p><p><strong>矩阵的加法</strong>，两个相同大小的矩阵，对应行列的元素相加。</p><p><strong>矩阵的乘法</strong>，如果矩阵F的行数和矩阵G的列数相等，则矩阵F和G可以相乘，假设F是\(n \times m\)的矩阵，G是\(m \times p\)的矩阵，FG就是\(n \times p\)的矩阵，FG在(i, j)位置上的元素可以表示为：</p><div>$$(\textbf{F}\textbf{G})_{ij} = \sum_{k=1}^{m}F_{ik}G_{kj} = \textbf{F}_{i*} \cdot \textbf{G}_{*j} \tag{2.5}$$</div><p>其实也可以看作是矩阵F的第i行和矩阵G的第j列元素之间的点积。</p><p><strong>单位阵</strong>是\(n \times n\)的矩阵，记作\(\textbf{I}_{n}\)，对于\(n \times n\)的矩阵M，有 \( \textbf{M} \textbf{I}_{n}\) = \(\textbf{I}_{n} \textbf{M}\) = \(\textbf{M}\)。</p><div>$$\textbf{I}_{n} =\left[\begin{matrix}1 & 0 & \cdots & 0 \\0 & 1 & \cdots & 0 \\\vdots & \vdots & \ddots & \vdots \\0 & 0 & \cdots & 1\end{matrix}\right]\tag{2.6}$$</div><p>因为单位阵尺寸由情况而定，所以通常把下标n去掉，记作 \(\textbf{I}\)。</p><p><strong>【定理2.1】</strong> 矩阵有以下性质：</p><ul><li>矩阵加法满足交换律和结合律；</li><li>系数加法乘矩阵、系数乘矩阵加法，均满足分配率；</li></ul><p><strong>【定理2.2】</strong> 还具有以下性质：</p><ul><li>系数乘矩阵先后不影响结果；</li><li>矩阵连乘，先后不影响结果；</li><li>\((\textbf{F}\textbf{G})^{T}=\textbf{G}^{T}\textbf{F}^{T}\)。</li></ul><h2 id="2-线性方程组"><a href="#2-线性方程组" class="headerlink" title="2 线性方程组"></a>2 线性方程组</h2><p>矩阵提供了一种有效并且简便的线性方程组表示法，例如线性方程组：</p><div>$$\begin{aligned}3x + 2y - 3z &= 5 \\4x - 3y + 6z &= 1 \\x - z &= 3\end{aligned}\tag{2.10}$$</div><p>可以用以下矩阵形式表示：</p><div>$$\left[\begin{matrix}3 & 2 & -3 \\4 & -3 & 6 \\1 & 0 & -1\end{matrix}\right]\left[\begin{matrix}x \\y \\z\end{matrix}\right]= \left[\begin{matrix}5 \\1 \\3\end{matrix}\right]\tag{2.11}$$</div><p>在未知向量&lt;x,y,z&gt;前面的矩阵叫做<strong>系数矩阵</strong>，在等号右边的列向量叫做<strong>常数向量</strong>。常数向量不为0的线性方程组叫做<strong>非齐次方程组</strong>，常数向量为0叫做<strong>齐次方程组</strong>。</p><p>把系数矩阵和常数向量并置一起（称为增广矩阵），执行基本行变换，就可以得到线性方程组的解。</p><p><strong>【定义2.3】</strong> 所谓<strong>基本行变换</strong>就是对一个矩阵执行以下三种变换之一：</p><ul><li>两行相互交换；</li><li>一行和不为0的系数相乘；</li><li>一行与一个不为0的系数乘后加到另一行上。</li></ul><p>方程(2.11)为例，写出增广矩阵：</p><div>$$\left[\begin{array}{ccc|c}3 & 2 & -3 & 5 \\4 & -3 & 6 & 1 \\1 & 0 & -1 & 3\end{array}\right]\tag{2.12}$$</div><p>对线性方程组的增广矩阵进行的行变换不会影响线性方程组的解，只是使线性方程组更加容易计算（可以同步理解成，一般求方程组解的步骤，使用方程组互相带入化简，使得方程组最后较容易解出值）。</p><p><strong>当用行变换求解一个线性方程组时，目标是把系数矩阵变换为它的最简形式</strong>。</p><p><strong>【定义2.4】</strong> 当且仅当一个矩阵满足一下条件，称为最简形式：</p><ul><li>每一个非0行，最左边的非0元素，即前导元素，必须为1；</li><li>每一个非0行均在全0行前面，或者说，全0行在矩阵底部；</li><li>如果一行前导元素在第j列，则其他行第j列的元素均为0；</li><li>对任意两个非0行 \(i_{2}\) 和 \(i_{1}\)，如果满足\(i_{2} &gt; i_{1}\)，并且相应的前导元素分别位于\(j_{2}\)和\(j_{1}\)列，则必然存在\(j_{2} &gt; j_{1}\)。</li></ul><p>或者简单来说，对于最简形式的矩阵，前导元素是向下向右的趋势的，并且，包含前导元素的列只有一个1，其他元素都为0。</p><p>一个最简形式矩阵例子：</p><div>$$\left[\begin{matrix}1 & 0 & -3 & 0 \\0 & 1 & 2 & 0 \\0 & 0 & 0 & 1 \\0 & 0 & 0 & 0 \end{matrix}\right]\tag{2.14}$$</div><p><strong>【算法2.6】</strong> 把一个线性方程组的 \(n \times (n+1)\) 增广矩阵M变换为最简形式，以下每一步的M在逐渐更新，而不是保持原始状态：</p><ol><li>下标i=1；</li><li>下标j=1，从第1列到第n列开始循环；</li><li>找到一个满足行号 \(k \geq i\)，并且 \(\textbf{M}_{kj} \neq 0\) 的行，如果不存在，跳到步骤8；</li><li>如果 \(k \neq i\)，交换第k行和第i行；</li><li>使矩阵M的元素(i, j)变为1：将第i行乘以 \(1 / \textbf{M}_{ij}\)；</li><li>把第j列中除第i行之外的元素变为0：对于每一行r，\(1 \leq r \leq n\) 且 \(r \neq i\)，将第i行乘 \(-\textbf{M}_{rj}\)加到第r行上；</li><li>i加1；</li><li>如果\(j \leq n\)，j加1，跳到步骤3。</li></ol><p>简单来说，就是每次找到第j列上的前导元素在哪一行，然后把这一行放在对应的位置上，让前导元素变1，再清除第j列上的其它元素，直到再找不到有前导元素的行，算法停止。</p><p>对于化简到最简形式后，如何判断方程组解的情况，有以下规律：</p><ul><li>如果系数矩阵的最简形式是一个单位阵，<strong>方程组有唯一解</strong>；</li><li>如果有一行或多行全为0，方程组要么无解，要么有无穷多解；</li><li>如果某一行系数矩阵为0而常数向量不为0，<strong>则方程组无解</strong>。</li></ul><h2 id="3-逆矩阵"><a href="#3-逆矩阵" class="headerlink" title="3 逆矩阵"></a>3 逆矩阵</h2><p>对一个\(n \times n\)的矩阵M而言，如果存在一个矩阵\(M^{-1}\)，使得 \(\textbf{M}\textbf{M}^{-1}=\textbf{M}^{-1}\textbf{M}=\textbf{I}\)，则称矩阵M是可逆的，矩阵\(M^{-1}\)叫做M的逆矩阵。</p><p>并不是每个矩阵都可逆，没有逆矩阵的矩阵叫做奇异矩阵，例如任何一行或一列为0的矩阵就是奇异矩阵。</p><p><strong>【定理2.9】</strong> 有一行或一列全为0的矩阵是不可逆的。</p><p><strong>【定理2.10】</strong> 一个矩阵M是可逆的，当且仅当\(M^{T}\)是可逆的。</p><p><strong>证明：</strong></p><p>假设M是可逆的，则\(M^{-1}\)存在，所以有：</p><div>$$\textbf{M}^{T}(\textbf{M}^{-1})^{T} =(\textbf{M}^{-1}\textbf{M})^{T} = \textbf{I}^{T} = \textbf{I}\tag{2.29}$$</div><p>并且</p><div>$$(\textbf{M}^{-1})^{T}\textbf{M}^{T} =(\textbf{M}\textbf{M}^{-1})^{T} = \textbf{I}^{T} = \textbf{I}\tag{2.30}$$</div><p>因此，\((\textbf{M}^{-1})^{T}\)是 \(\textbf{M}^{T}\)的逆矩阵。</p><p>类似，如果假设\(\textbf{M}^{T}\)是可逆的，则\((\textbf{M}{T})^{-1}\)存在：</p><div>$$\textbf{M}[(\textbf{M}^{T})^{-1}]^{T} =[(\textbf{M}^{T})^{-1}\textbf{M}^{T})]^{T} =\textbf{I}^{T} = \textbf{I}\tag{2.31}$$</div><p>而且</p><div>$$[(\textbf{M}^{T})^{-1}]^{T}\textbf{M} =[(\textbf{M}^{T}(\textbf{M}^{T})^{-1})]^{T} =\textbf{I}^{T} = \textbf{I}\tag{2.32}$$</div><p>因此，\([(\textbf{M}^{T})^{-1}]^{T}\)是M的逆矩阵。</p><p><strong>【定理2.11】</strong> 如果F和G都是\(n \times n\)的可逆矩阵，那么FG也是可逆的，并且 \((\textbf{F}\textbf{G})^{-1}\) = \(\textbf{G}^{-1}\textbf{F}^{-1}\)。</p><p>求矩阵最简形式的方法（算法2.6）也可以用来计算矩阵逆矩阵，为了计算\(n \times n\)矩阵的逆矩阵，在矩阵的右边并接一个单位阵，以形成一个\(n \times 2n\)的矩阵。</p><div>$$\left[\begin{array}{cccc|cccc}M_{11} & M_{12} & \cdots & M_{1n} & 1 & 0 & \cdots & 0 \\M_{21} & M_{22} & \cdots & M_{2n} & 0 & 1 & \cdots & 0 \\\vdots & \vdots & \ddots & \vdots & \vdots & \vdots & \ddots & \vdots \\M_{n1} & M_{n2} & \cdots & M_{nn} & 0 & 0 & \cdots & 1\end{array}\right]\tag{2.34}$$</div><p>对整个矩阵执行基本行变换操作，直到其左边的\(n \times n\)矩阵变为单位阵，这时右边的\(n \times n\)部分就是M的逆矩阵，如果左边无法化为单位矩阵，则该矩阵不可逆。</p><p><strong>【定理2.14】</strong> 假设(n \times n\)矩阵 \(M^{‘}\)是(n \times n\)矩阵M进行基本变换后得到的矩阵，则有 \(M^{‘}=EM\)，其中E是对单位阵进行相同的基本变换的最终矩阵。</p><p>把<strong>单位阵</strong>经过<strong>行变换</strong>后得到的矩阵称为<strong>初等矩阵</strong>，如果为了把矩阵M变为单位阵而必须经过k次基本行变换，那么：</p><div>$$\textbf{I} = \textbf{E}_{k}\textbf{E}_{k-1} \cdots \textbf{E}_{1}\textbf{M}\tag{2.47}$$</div><p>其中矩阵 \(\textbf{E}_{1}, \textbf{E}_{2}, \cdots, \textbf{E}_{k}\)是单位阵对应的k次行变换的初等矩阵，也就是说，矩阵 \(\textbf{E}_{k}\textbf{E}_{k-1} \cdots \textbf{E}_{1}\)之间的积即为M的逆矩阵。</p><p><strong>【定理2.15】</strong> 当且仅当矩阵M的<strong>行是一个线性无关向量集</strong>时，(n \times n\)矩阵M是可逆的。</p><h2 id="4-行列式"><a href="#4-行列式" class="headerlink" title="4 行列式"></a>4 行列式</h2><p>方阵的行列式得到的是一个标量，矩阵M的行列式记作\(det \textbf{M}\)，行列式使用垂直线取代矩阵两侧的括号。</p><div>$$det \textbf{M} =\left|\begin{matrix}M_{11} & M_{12} & M_{13} \\M_{21} & M_{22} & M_{23} \\M_{31} & M_{32} & M_{33}\end{matrix}\right|\tag{2.50}$$</div><p>\(n \times n\)矩阵M的行列式的值由一个递推公式给出，用符号 \(M^{|i, j|}\)表示原始矩阵M中第i行和第j列删除后行程的 \((n-1) \times (n-1)\)矩阵，用这种方法，行列式值可用以下方法计算：</p><div>$$det \textbf{M} = \sum_{i=1}^{n}(-1)^{i+k}M_{ik} det \textbf{M}^{|i,k|}\tag{2.53}$$</div><div>$$det \textbf{M} = \sum_{i=1}^{n}(-1)^{k+j}M_{kj} det \textbf{M}^{|k,j|}\tag{2.54}$$</div><p>其中k是满足条件 \(1 \leq k \leq n\)的任意常数。</p><p>二阶矩阵的行列式公式：</p><div>$$\left|\begin{matrix}a & b \\c & d\end{matrix}\right|= ad - bc\tag{2.55}$$</div><p>三阶矩阵的行列式公式：</p><div>$$\begin{aligned}\left|\begin{matrix}a_{11} & a_{12} & a_{13} \\a_{21} & a_{22} & a_{23} \\a_{31} & a_{32} & a_{33}\end{matrix}\right|= a_{11}det\textbf{M}^{|1,1|} - a_{12}det\textbf{M}^{|1,2|} + a_{13}det\textbf{M}^{|1,3|} \\= a_{11}(a_{22}a_{33}-a_{23}a_{32}) -a_{12}(a_{21}a_{33}-a_{23}a_{31}) +a_{13}(a_{21}a_{32}-a_{22}a_{31})\end{aligned}\tag{2.56}$$</div><p><strong>【定理2.16】</strong> 执行基本变换对一个矩阵的行列式有以下性质：</p><ul><li>两行交换，行列式取反；</li><li>矩阵一行乘比例系数a则行列式变为原来的a倍；</li><li>把一行的若干倍加到另一行对行列式没有影响。</li></ul><p><strong>【推论2.17】</strong> 如果矩阵有相同行，则行列式为0。</p><p><strong>【定理2.18】</strong> \(n \times n\)矩阵M当且仅当 \(det \textbf{M} \neq 0\)时是可逆的。</p><p><strong>【定理2.19】</strong> 对任意两个 \(n \times n\)的矩阵F和G，有 \(det\textbf{F}\textbf{G}=det\textbf{F}det\textbf{G}\)。</p><p>Tips：初等矩阵乘积的行列式等于行列式的乘积。</p><p><strong>【定理2.20】</strong> 假设F是 \(n \times n\)矩阵，如果另一 \(n \times n\)矩阵G的元素为：</p><div>$$G_{ij} = (-1)^{i + j} \frac{det \textbf{F}^{|j, i|}}{det \textbf{F}}\tag{2.62}$$</div><p>那么 \(\textbf{G}=\textbf{F}^{-1}\)。</p><p>通过定理2.20可以推出图形学中经常用的几个逆矩阵计算公式主要是2阶和3阶的。</p><p>2阶方阵逆矩阵公式：</p><div>$$\textbf{A}^{-1} = \frac{1}{det \textbf{A}}\left[\begin{matrix}A_{22} & -A_{12}\\-A_{21} & A_{11}\end{matrix}\right]\tag{2.63}$$</div><p>3阶方阵逆矩阵公式：</p><div>$$\textbf{B}^{-1} = \frac{1}{det \textbf{B}}\left[\begin{matrix}B_{22}B_{33}-B_{23}B_{32} & B_{13}B_{32}-B_{12}B_{33} & B_{12}B_{23}-B_{13}B_{22} \\B_{23}B_{31}-B_{21}B_{33} & B_{11}B_{33}-B_{13}B_{31} & B_{13}B_{21}-B_{11}B_{23} \\B_{21}B_{32}-B_{22}B_{31} & B_{12}B_{31}-B_{11}B_{32} & B_{11}B_{22}-B_{12}B_{21}\end{matrix}\right]$$</div><h2 id="5-特征值与特征向量"><a href="#5-特征值与特征向量" class="headerlink" title="5 特征值与特征向量"></a>5 特征值与特征向量</h2><p>对于<strong>可逆方阵</strong>，<strong>必然</strong>存在一个<strong>向量</strong>，当该<strong>向量与可逆方阵相乘</strong>时，<strong>向量只会发生大小变换而方向不变</strong>，即，对于n阶方阵M，存在着非0的n维向量 \(\textbf{V}_{1}, \textbf{V}_{2}, \cdots, \textbf{V}_{n}\)满足：</p><div>$$\textbf{M}\textbf{V}_{i} = \lambda_{i}\textbf{V}_{i}\tag{2.65}$$</div><p>其中比例系数 \(\lambda_{i}\) 称为矩阵M的特征值，而向量 \(\textbf{V}_{i}\)是对应特征值的特征向量。</p><p>对式（2.65）进行变换可得到矩阵的特征值：</p><div>$$(\textbf{M}-\lambda_{i}\textbf{I})\textbf{V}_{i} = \textbf{0}\tag{2.66}$$</div><p>对于非0向量 \(\textbf{V}_{i}\)，如果上式成立，矩阵 \(\textbf{M}-\lambda_{i}\textbf{I}\)一定是奇异矩阵（不可逆），否则就可以对其求逆，得到:</p><div>$$\textbf{V}_{i} = (\textbf{M}-\lambda_{i}\textbf{I})^{-1}\textbf{0} = \textbf{0}\tag{2.67}$$</div><p>这个非0向量矛盾，所以矩阵 \(\textbf{M}-\lambda_{i}\textbf{I}\)的行列式为0，因此可以通过：</p><div>$$det(\textbf{M}-\lambda\textbf{I}) = 0\tag{2.68}$$</div><p>计算出矩阵的特征值解，由2.68式得出的关于 \(\lambda\)的n阶多项式叫做矩阵M的特征多项式，多项式的根就是矩阵M的特征值。</p><p>一旦矩阵的特征值求得，就可以代入式(2.66)，计算出相应的特征向量，因为矩阵 \(\textbf{M}-\lambda_{i}\textbf{I}\) 是奇异的，所以简化形式至少有一行全为0，所以有无穷多解（比如特征向量的系数倍数向量也是特征向量），因此特征向量可以表示成任意常数的形式，如果有必要也可以取特征向量的长度为1。</p><p>通常，<strong>如果矩阵特征值是复数，则相应的特征向量也含有复数元素</strong>；确保有实数特征值以及相应的实数特征向量的矩阵是<strong>对称矩阵</strong>。</p><p><strong>【定义2.23】</strong> 一个n阶方阵，当且仅当 对任意i和j均有 \(M_{ij}=M_{ji}\) 时是对称矩阵，也就是说如果矩阵元素关于主对角线对称，则该矩阵就成为<strong>对称矩阵</strong>。</p><p><strong>【定理2.24】</strong> 矩阵<strong>元素为实数</strong>的对称矩阵的特征值也是实数。</p><p><strong>【定理2.25】</strong> 对应于<strong>对称矩阵</strong>M的<strong>不同特征值的特征向量</strong>是<strong>正交</strong>的。</p><h2 id="6-对角化"><a href="#6-对角化" class="headerlink" title="6 对角化"></a>6 对角化</h2><p>对角矩阵（对称矩阵的特例），只在主对角线上有非0元素的矩阵。</p><p>给定方阵M，如果能找到一个矩阵A使得 \(\textbf{A}^{-1}\textbf{M}\textbf{A}\) 是对角矩阵，那么就说矩阵A将矩阵M对角化了。</p><p><strong>【定理2.26】</strong> 假设M是特征值为 \(\lambda_{1}, \lambda_{2}, \cdots, \lambda_{n}\)的n阶方阵，且与特征值对应的特征向量 \(\textbf{V}_{1}, \textbf{V}_{2}, \cdots, \textbf{V}_{n}\) 是一个<strong>线性无关集</strong>，则矩阵A：</p><div>$$A = [ \textbf{V}_{1} \textbf{V}_{2} \cdots \textbf{V}_{n} ]\tag{2.82}$$</div><p>可以将矩阵M对角化，而且 \(\textbf{A}^{-1}\textbf{M}\textbf{A}\) 的主对角元素是矩阵M的特征值，即：</p><div>$$\textbf{A}^{-1}\textbf{M}\textbf{A} =\left[\begin{matrix}\lambda_{1} & 0 & \cdots & 0 \\0 & \lambda_{2} & \cdots & 0\\\vdots & \vdots & \ddots & \vdots\\0 & 0 & \cdots & \lambda_{n}\end{matrix}\right]\tag{2.83}$$</div><p>相反，如果存在一个可逆矩阵A使得 \(\textbf{A}^{-1}\textbf{M}\textbf{A}\) 是一个对角阵，则矩阵A的列必然是矩阵M的特征向量，而 \(\textbf{A}^{-1}\textbf{M}\textbf{A}\) 的对角线元素则是矩阵M的特征值。</p>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;在三维变换中，矩阵运算是最常用的表达方式。&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="3D游戏与图形学的数学" scheme="https://yumi-cn.github.io/categories/3D%E6%B8%B8%E6%88%8F%E4%B8%8E%E5%9B%BE%E5%BD%A2%E5%AD%A6%E7%9A%84%E6%95%B0%E5%AD%A6/"/>
    
    
    <category term="笔记" scheme="https://yumi-cn.github.io/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>《剑指Offer》第2章笔记 链表</title>
    <link href="https://yumi-cn.github.io/2020/11/30/s2o-c2-linked/"/>
    <id>https://yumi-cn.github.io/2020/11/30/s2o-c2-linked/</id>
    <published>2020-11-30T11:09:59.000Z</published>
    <updated>2020-11-30T12:17:30.456Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>链表应该是面试时被提及最频繁的数据结构。</p></blockquote><a id="more"></a><p>链表的结构很简单，它由指针把若干个节点连接成链状结构，链表的创建、插入节点、删除节点等操作都只需要20行左右的代码就能实现，代码量比较适合面试（哈希表、有向图等复杂的一个操作可能就需要很多代码）。</p><p>链表是一种动态数据结构，创建链表时，无须知道链表长度，插入节点时，只需要为新节点分配内存，然后调整指针的指向来确保新节点被链接到链表中；内存分配不是在创建链表时一次性完成的，而是每添加一个节点分配一次内存。</p><p>典型的单向链表节点定义：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> value;</span><br><span class="line">    Node* next;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>往链表末尾添加一个节点：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add_to_tail</span><span class="params">(Node** phead, <span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 头结点是一个指针的指针</span></span><br><span class="line">    Node* pnew = <span class="keyword">new</span> Node();</span><br><span class="line">    pnew-&gt;value = value;</span><br><span class="line">    pnew-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">if</span>(*phead == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="comment">// 创建头节点</span></span><br><span class="line">        *phead = pnew;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 添加节点到尾部</span></span><br><span class="line">        Node* pnode = *phead;</span><br><span class="line">        <span class="keyword">while</span>(pnode-&gt;next != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            pnode = pnode-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        pnode-&gt;next = pnew;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>想要在链表中找到第i个节点，那我们只能从头结点开始遍历链表，时间效率为<code>O(n)</code>，而在数组中只需要<code>O(1)</code>的时间。</p><p>找到第一个含有某值节点并删除该节点的代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">remove_node</span><span class="params">(Node** phead, <span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(phead==<span class="literal">nullptr</span> || *phead==<span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Node* p_delete = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">if</span>((*phead)-&gt;value == value) &#123;</span><br><span class="line">        <span class="comment">// 头结点删除需要单独考虑操作</span></span><br><span class="line">        p_delete = *phead;</span><br><span class="line">        *phead = (*phead)-&gt;next;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        Node* pnode = *phead;</span><br><span class="line">        <span class="comment">// 寻找删除节点的前一个节点</span></span><br><span class="line">        <span class="keyword">while</span>(pnode-&gt;next != <span class="literal">nullptr</span></span><br><span class="line">            &amp;&amp; pnode-&gt;next-&gt;value != value) &#123;</span><br><span class="line">                pnode = pnode-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(pnode-&gt;next != <span class="literal">nullptr</span> &amp;&amp; pnode-&gt;next-&gt;value == value) &#123;</span><br><span class="line">            <span class="comment">// 调整删除节点前一个节点的链接</span></span><br><span class="line">            p_delete = pnode-&gt;next;</span><br><span class="line">            pnode-&gt;next = pnode-&gt;next-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(p_delete != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="keyword">delete</span> p_delete;</span><br><span class="line">        p_delete = <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一些特殊形式的链表也会被经常考到：</p><ul><li>环形链表：链表末尾节点指向头结点（面试题62）；</li><li>双向链表：节点还有一个指向前一个节点的指针（面试题36）；</li><li>复杂链表：节点还有拥有指向任意节点的指针（面试题35）。</li></ul><blockquote><p>面试题6：从尾到头打印链表</p></blockquote><p>输入一个链表的头节点，从尾到头反过来打印每个节点的值。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> value;</span><br><span class="line">    Node* next;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>Tips：如果打算修改输入数据，最好先问面试官是不是允许修改，这里假设面试官不能改变链表的结构。</p><p>这道题目需要先访问的节点后输出，可以想到使用栈这种数据结构，每次访问到节点，就压到栈中，输出的时候只需要循环出栈即可。</p><p>完整代码实现：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> value;</span><br><span class="line">    Node* next;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add_to_tail</span><span class="params">(Node** phead, <span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 头结点是一个指针的指针</span></span><br><span class="line">    Node* pnew = <span class="keyword">new</span> Node();</span><br><span class="line">    pnew-&gt;value = value;</span><br><span class="line">    pnew-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">if</span>(*phead == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="comment">// 创建头节点</span></span><br><span class="line">        *phead = pnew;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 添加节点到尾部</span></span><br><span class="line">        Node* pnode = *phead;</span><br><span class="line">        <span class="keyword">while</span>(pnode-&gt;next != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            pnode = pnode-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        pnode-&gt;next = pnew;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">reverse_print</span><span class="params">(Node** phead)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(phead==<span class="literal">nullptr</span> || *phead==<span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">stack</span>&lt;Node*&gt; pstack;</span><br><span class="line">    Node* pnode = *phead;</span><br><span class="line">    <span class="keyword">while</span>(pnode != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        pstack.push(pnode);</span><br><span class="line">        pnode = pnode-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(!pstack.empty()) &#123;</span><br><span class="line">        pnode = pstack.top();</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\t&quot;</span>, pnode-&gt;value);</span><br><span class="line">        pstack.pop();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> values[] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line">    Node** phead = <span class="keyword">new</span> Node*;</span><br><span class="line">    *phead = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">        add_to_tail(phead, values[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    reverse_print(phead);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>具体的实现中需要注意到的一个点是头节点的初始化，因为是指针的指针，所以需要先申请一个<strong>Node指针类型的指针</strong>，<code>new Node*</code>，然后再将头结点指向的节点设置为<code>nullptr</code>，这样才不会在访问时出错。</p><p>如果可以使用栈结构来实现，也可以考虑使用递归的方式实现，通过递归访问，只有在返回函数的时候再输出节点，就可以实现逆序输出。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 调用的时候要使用 *phead</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">reverse_print_rec</span><span class="params">(Node* node)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(node == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    reverse_print_rec(node-&gt;next);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\t&quot;</span>, node-&gt;value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>递归的代码相比于使用栈会简洁很多，但是使用递归是有代价的，函数递归使用的栈空间通常会有限制（比自己建立栈的空间要小），所以如果链表过于长可能会导致函数调用栈溢出。</p>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;链表应该是面试时被提及最频繁的数据结构。&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="剑指Offer" scheme="https://yumi-cn.github.io/categories/%E5%89%91%E6%8C%87Offer/"/>
    
    
    <category term="笔记" scheme="https://yumi-cn.github.io/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>《剑指Offer》第2章笔记 字符串</title>
    <link href="https://yumi-cn.github.io/2020/11/28/s2o-c2-string/"/>
    <id>https://yumi-cn.github.io/2020/11/28/s2o-c2-string/</id>
    <published>2020-11-28T14:06:05.000Z</published>
    <updated>2020-11-30T11:09:14.812Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>字符串的使用频率非常高，为了优化，很多语言都对字符串做了特殊的规定。</p></blockquote><a id="more"></a><p>C/C++中每个字符串都以字符 <code>\0</code> 做为结尾，这样便于运行时判断字符数组的尾部，由于这个特点，字符串数组的长度比真实字符串长度要多1才可以，这样容易导致一些错误：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> str[<span class="number">10</span>];</span><br><span class="line"><span class="built_in">strcpy</span>(str, <span class="string">&quot;0123456789&quot;</span>); <span class="comment">// Error</span></span><br></pre></td></tr></table></figure><p>为了节省内存，C/C++把常量字符串放到一个单独的内存区域，当几个指针赋值给相同的常量字符串时，实际上会指向相同的内存地址。但用常量内存来初始化字符数组时，情况又有所不同了，看下面的例子：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> str1[] = <span class="string">&quot;hello world&quot;</span>;</span><br><span class="line">    <span class="keyword">char</span> str2[] = <span class="string">&quot;hello world&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span>* str3 = <span class="string">&quot;hello world&quot;</span>;</span><br><span class="line">    <span class="keyword">char</span>* str4 = <span class="string">&quot;hello world&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;str1 =%p\n&quot;</span>, str1); <span class="comment">// 0061fe04</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;str2 =%p\n&quot;</span>, str2); <span class="comment">// 0061fdf8</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;str3 =%p\n&quot;</span>, str3); <span class="comment">// 00409001</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;str4 =%p\n&quot;</span>, str4); <span class="comment">// 00409001</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>str1</code>和<code>str2</code>是两个字符数组，在初始化赋值时，运行时为为他们分配两个长度为12字节的内存空间，并把字符串赋值到数组中去（而不是直接拷贝字符串常量地址），所以他们的初始地址是不同的。</p><p><code>str3</code>和<code>str4</code>是两个指针，不需要再分配内存来存储内容，只需要传递地址，所以他们就拷贝了同一个地址。</p><blockquote><p>面试题5：替换空格</p></blockquote><p>实现一个函数，把字符串的每个空格替换成<code>%20</code>，例如输入<code>We are happy.</code>，则输出<code>We%20are%20happy.</code>。</p><p>题目来自于网络编程中的URL特殊字符编码，有时候服务器不一定支持一些特殊字符URL，所以需要先将特殊转换成ASCII码的两位十六进制表示，比如空格的ASCII码是<code>32</code>，即十六进制的<code>0x20</code>，空格被替换成<code>%20</code>，比如<code>#</code>的ASCII码为35，十六进制<code>0x23</code>，在URL中被替换成<code>%23</code>。</p><p>一般有两种解决方向：</p><ul><li>在原字符数组上进行处理；</li><li>申请新字符数组，将新内容写进去；</li></ul><p>在面试过程中遇到这样的问题，如果确定题目中没有限定说明，可以向面试官进一步地问清楚应该考虑什么样的限定条件。</p><p>在这里我们假设（作者假设）面试官需要在原字符数组上替换，输入的字符串后面有足够多的内存空间。</p><p>我们仍然从最简思路入手：</p><ul><li><strong>思路1</strong>：在字符串中进行遍历，当碰到空格时，将空格替换为<code>%20</code>，由于替换的字符串比空格多2个字符，为了放入<code>%20</code>，所以要将后续的字符串后移两位，重复该操作直到字符串没有空格。</li></ul><p>假设字符串长度<code>n</code>，对于每个空格字符，需要移动后面<code>O(n)</code>个字符，所以时间开销是<code>O(n^2)</code>。</p><p>显然这个方法过于简单，还不是最优解，观察可以发现，有些字符串被反复后移，但其实对于一个固定空格个数的字符串，这些字符串所应该处的最终位置我们是可以计算出来的，比如<code>We are happy.</code>中<code>We</code>前面没有空格，不需要向后移动，<code>are</code>前面有1个空格，所以字符串会被后移2位，<code>happy.</code>前面有2个空格，需要移动4位。</p><p>所以对于某些字符串其最终的位置反而是通过计算得到的，不需要反复的重复移动（拷贝字符串时间开销大）。</p><ul><li><strong>思路2</strong>：使用一个空格计数器，在移动字符串时，根据当前空格计数器来判断当前字符需要后移多少位，然后直接将字符移动到目标位置上，遇到空格时，根据计算的后移位置，直接顺序写入<code>%20</code>。时间开销因为只需要遍历一次字符串，所以是<code>O(n)</code>。</li></ul><p>这样的思路还是有亿点点问题需要考虑，如果从头开始移动字符串，则后面的字符串还没有空出来时，就需要先移动后面的字符串，这样就导致问题变得稍微有点复杂，所以我们可以反过来，从尾部开始处理移动操作。</p><ul><li><strong>思路3</strong>：先遍历一次字符串，统计空格出现次数，计算最终字符串的长度，然后从尾部开始处理移动，申请两个指针，一个指向原字符位置，一个指向移动目标位置，当遇到普通字符时，直接转移，遇到空格时，在目标位置写入替换字符串。时间开销仍然是<code>O(n)</code>。</li></ul><p>完整实现代码:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">replace</span><span class="params">(<span class="keyword">char</span>* str, <span class="keyword">char</span>* ori, <span class="keyword">char</span>* rep)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(str != <span class="literal">nullptr</span> &amp;&amp; ori != <span class="literal">nullptr</span> &amp;&amp; rep != <span class="literal">nullptr</span></span><br><span class="line">       &amp;&amp; <span class="built_in">strlen</span>(str) &gt; <span class="number">0</span> &amp;&amp; <span class="built_in">strlen</span>(ori) &gt; <span class="number">0</span> &amp;&amp; <span class="built_in">strlen</span>(rep) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> ori_len = <span class="built_in">strlen</span>(ori);</span><br><span class="line">        <span class="keyword">int</span> rep_len = <span class="built_in">strlen</span>(rep);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">strlen</span>(str); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">strncmp</span>((str+i), ori, ori_len) == <span class="number">0</span>) &#123;</span><br><span class="line">                count++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(count == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">char</span>* po = str + <span class="built_in">strlen</span>(str) + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">char</span>* pr = po + count * (rep_len - ori_len);</span><br><span class="line">        <span class="keyword">while</span>(po &gt;= str) &#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">strncmp</span>(po, ori, ori_len) == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">char</span>* tmp = rep + (rep_len - <span class="number">1</span>); tmp &gt;= rep; tmp--) &#123;</span><br><span class="line">                    *pr = *tmp;</span><br><span class="line">                    pr--;</span><br><span class="line">                &#125;</span><br><span class="line">                po--;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                *pr = *po;</span><br><span class="line">                po--;</span><br><span class="line">                pr--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> str[<span class="number">100</span>] = <span class="string">&quot;We are happy.&quot;</span>;</span><br><span class="line">    <span class="keyword">char</span> ori[<span class="number">10</span>] = <span class="string">&quot; &quot;</span>;</span><br><span class="line">    <span class="keyword">char</span> rep[<span class="number">10</span>] = <span class="string">&quot;%20&quot;</span>;</span><br><span class="line">    <span class="keyword">if</span>(replace(str, ori, rep)) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, str);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Error\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Tips：代码和原作者的实现有出入，实现了相对来说比较通用的字符串替换，但是方法以及代码仅仅只针对这道题目而言是有效的，还有非常多该题目以外的问题其实是没有考虑到的，例如需要被替换不是单个的空格而是多个空格甚至是任意字符、替换的字符串如果长度小于被替换字符串该怎么处理，等等（修改上述代码中的初始字符串即可看到结果会出现问题）；不过不在这里继续讨论，可以自行尝试思考。</p><blockquote><p>拓展题练习题： 已排序的两个数组A1和A2，A1尾部有足够多的空间容纳A2，将A2的所有数组插入A1中，并且最终A1中所有数字是有序的。</p></blockquote>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;字符串的使用频率非常高，为了优化，很多语言都对字符串做了特殊的规定。&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="剑指Offer" scheme="https://yumi-cn.github.io/categories/%E5%89%91%E6%8C%87Offer/"/>
    
    
    <category term="笔记" scheme="https://yumi-cn.github.io/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>《3D图形的数学》第1章笔记 向量</title>
    <link href="https://yumi-cn.github.io/2020/11/27/3dmath-c1/"/>
    <id>https://yumi-cn.github.io/2020/11/27/3dmath-c1/</id>
    <published>2020-11-27T12:14:23.000Z</published>
    <updated>2020-11-28T09:18:55.646Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>对于成功的3D程序猿，掌握如何进行向量运算是一种基本的技能要求。</p></blockquote><a id="more"></a><blockquote><p>原书：《3D游戏与计算机图形学中的数学方法》 by Eric.Lengyel</p></blockquote><h2 id="1-向量的形式"><a href="#1-向量的形式" class="headerlink" title="1 向量的形式"></a>1 向量的形式</h2><p>一个n维向量<strong>V</strong>可以表示为：</p><div>$$\textbf{V} = < V_{1}, V_{2}, ... , V_{n} > \tag{1.1}$$</div><p>系数a和向量<strong>V</strong>的乘积可以定义为：</p><div>$$a\textbf{V} = < aV_{1}, aV_{2}, ... , aV_{n} > \tag{1.4}$$</div><p>向量加减运算：</p><div>$$\textbf{P} + \textbf{Q}= < P_{1} + Q_{1}, P_{2} + Q_{2}, ... , P_{n} + Q_{n} > \tag{1.5}$$</div><p><strong>【定理1.1】</strong>对于给定的任何两个系数a和b，以及任何三个向量<strong>P</strong>、<strong>Q</strong>和<strong>R</strong>，有以下运算规律：</p><ul><li>\(\textbf{P} + \textbf{Q} = \textbf{Q} + \textbf{P}\)</li><li>\((\textbf{P} + \textbf{Q}) + \textbf{R} = \textbf{P} + (\textbf{Q} + \textbf{R})\)</li><li>\((ab)\textbf{P} = a(b\textbf{P})\)</li><li>\(a(\textbf{P} + \textbf{Q}) = a\textbf{P} + a\textbf{Q}\)</li><li>\((a + b)\textbf{P} = a\textbf{P} + b\textbf{P}\)</li></ul><p>n维向量<strong>V</strong>的模，||<strong>V</strong>||：</p><div>$$\textbf{||V||} = \sqrt{\sum_{i=1}^{n} V_{i}^{2}} \tag{1.6}$$</div><p>模也称为向量的范数或者长度，模为1的向量称为单位向量。</p><p>设向量<strong>V</strong>表示一个三维点或方向，则公式(1.6)可以展开为：</p><div>$$\textbf{||V||} = \sqrt{V_{x}^{2} + V_{y}^{2} + V_{z}^{2}} \tag{1.7}$$</div><p>如果向量V至少有至少有一个非零分量，可以通过乘 \(1/\textbf{||V||}\) 得到V方向上的一个单位向量，也叫做单位化、规格化。</p><p><strong>【定理1.2】</strong> 对于任意给定系数a，任意的两个向量<strong>P</strong>和<strong>Q</strong>，有以下性质：</p><ul><li>\( \textbf{||P||} \geq 0 \)</li><li>当且仅当 \( \textbf{||P||}=&lt;0, 0, …, 0&gt; \)时，\( \textbf{||P||}=0 \)</li><li>\( \textbf{||aP||}=|a|\textbf{||P||} \)</li><li>\( \textbf{||P + Q||} \leq \textbf{||P||} + \textbf{||Q||} \)</li></ul><p>其中的第4条，可以由三角不等式得到。</p><h2 id="2-点积"><a href="#2-点积" class="headerlink" title="2 点积"></a>2 点积</h2><p><strong>向量间</strong>的<strong>点积</strong>，也叫做<strong>数量积</strong>或<strong>内积</strong>，3D图形中经常用点积来度量两个向量指向的差异。</p><p><strong>【定理1.3】</strong> 两个n维向量P和Q的点积，记作P·Q，即：</p><div>$$\textbf{P} \cdot \textbf{Q}= \sum_{i=1}^{n} P_{i}Q_{i} \tag{1.9}$$</div><p>向量的点积等于两个向量的对应分量乘积之和。</p><p>在三维空间中，有：</p><div>$$\textbf{P} \cdot \textbf{Q}= P_{x}Q_{x} + P_{y}Q_{y} + P_{z}Q_{z} \tag{1.10}$$</div><p><strong>【定理1.4】</strong> 对于给定的两个向量P和Q，点积满足公式：</p><div>$$\textbf{P} \cdot \textbf{Q}= \textbf{||P||}\textbf{||Q||} cos \alpha \tag{1.12}$$</div><p>\(\alpha\)是向量P和Q之间的夹角（详细的说是P和Q的起点、终点决定的平面夹角）。</p><p>Tips：定理1.4的证明要用到余弦定理，一个三角形有三条边\(a,b,c\)，\(a,b\)夹角是\(\alpha\)时，三边满足等式关系\(c^{2} = a^{2} + b^{2} - 2abcos\alpha\)。</p><p>定理1.4可以得出两个结论：</p><ul><li>当且仅当 \(\textbf{P} \cdot \textbf{Q} = 0\) 时， 向量P和向量Q相互垂直。点积为0的向量称为正交向量，零向量和任意向量正交；</li><li>点积正负号说明两个向量的方向情况，例如在看平面法线和平面外一点，可以查看点相对于平面的位置，是在法线同侧（点积为正）还是在不同侧（点积为负）。</li></ul><p><strong>【定理1.5】</strong> 对于任意给定系数a，任意的两个向量<strong>P</strong>和<strong>Q</strong>，有以下性质：</p><ul><li>\( \textbf{P} \cdot \textbf{Q} = \textbf{Q} \cdot \textbf{P} \)</li><li>\( (a\textbf{P}) \cdot \textbf{Q} = a(\textbf{P} \cdot \textbf{Q}) \)</li><li>\( \textbf{P} \cdot (\textbf{Q} + \textbf{R}) = \textbf{P} \cdot \textbf{Q} + \textbf{P} \cdot \textbf{R} \)</li><li>\( \textbf{P} \cdot \textbf{P} = \textbf{||P||}^{2} \)</li><li>\( | \textbf{P} \cdot \textbf{Q} | \leq \textbf{||P||} \cdot \textbf{||Q||} \)</li></ul><p>向量P在向量Q上的投影长度：</p><div>$$\textbf{||P||}cos\alpha= \frac{\textbf{P}\cdot\textbf{Q}}{\textbf{||Q||}} \tag{1.17}$$</div><p>如果再乘以单位向量 \( \frac{\textbf{Q}}{\textbf{||Q||}} \)，就可以得到具有该长度并且平行于Q的一个向量，即表示向量P到向量Q的投影，记作\( proj_{\textbf{Q}} \textbf{P} \)：</p><div>$$proj_{\textbf{Q}}\textbf{P} = \frac{\textbf{P} \cdot \textbf{Q}}{\textbf{||Q||}^{2}} \textbf{Q} \tag{1.18}$$</div><p>P到Q的投影也可以看作是一个线性变换过程，所以可以表示为矩阵和向量乘积，三维情况下，\( proj_{\textbf{Q}} \textbf{P} \) 也可以用下面的公式计算：</p><div>$$proj_{\textbf{Q}} \textbf{P} = \frac{1}{\textbf{Q}^{2}}\left[\begin{matrix}Q_{x}^{2} & Q_{x}Q_{y} & Q_{x}Q_{z} \\Q_{x}Q_{y} & Q_{y}^{2} & Q_{y}Q_{z} \\Q_{x}Q_{z} & Q_{y}Q_{z} & Q_{z}^{2}\end{matrix}\right]\left[\begin{matrix}P_{x} \\P_{y} \\P_{z}\end{matrix}\right]\tag{1.20}$$</div><p>向量P相对于向量Q的垂直分量记作\( perp_{\textbf{Q}} \textbf{P} \)，可以用向量P减去投影分量得到垂直分量：</p><div>$$perp_{\textbf{Q}} \textbf{P} = \textbf{P} - proj_{\textbf{Q}} \textbf{P} \tag{1.19}$$</div><h2 id="3-叉积"><a href="#3-叉积" class="headerlink" title="3 叉积"></a>3 叉积</h2><p>两个三维向量的叉积又称为向量积，结果是一个新的向量，这个向量垂直于原来的两个向量。</p><p>在3D图形学中，已知曲面上一点的两个不同方向的切向量，就可以通过求叉积得到曲面在该点的法向量。</p><p><strong>【定义1.6】</strong> 两个3D向量P和Q的叉积记作 \(\textbf{P} \times \textbf{Q}\)，结果向量为：</p><div>$$\textbf{P} \times \textbf{Q}= <P_{y}Q_{z} - P_{z}Q_{y},P_{z}Q_{x} - P_{x}Q_{z},P_{x}Q_{y} - P_{y}Q_{x} > \tag{1.21}$$</div><p>便于记忆的一个工具是伪行列式：</p><div>$$\textbf{P} \times \textbf{Q} =\left|\begin{matrix}i & j & k \\P_{x} & P_{y} & P_{z} \\Q_{x} & Q_{y} & Q_{z}\end{matrix}\right|\tag{1.22}$$</div><p>这里i,j,k是x,y,z轴的单位向量：</p><div>$$\begin{aligned}\textbf{i} &= <1, 0, 0> \\\textbf{j} &= <0, 1, 0> \\\textbf{k} &= <0, 0, 1>\end{aligned}\tag{1.23}$$</div><p>叉积\(\textbf{P} \times \textbf{Q}\)也可以用线性变换的形式表示，变换矩阵派生于P，作用于Q：</p><div>$$\textbf{P} \times \textbf{Q} =\left[\begin{matrix}0 & -P_{z} & P_{y} \\P_{z} & 0 & -P_{x} \\-P_{y} & P_{x} & 0\end{matrix}\right]\left[\begin{matrix}Q_{x} \\Q_{y} \\Q_{z}\end{matrix}\right]\tag{1.25}$$</div><p>Tips：原书P7的公式(1.25)有疏漏，变换矩阵中出现了Q的分量。</p><p>对于任意给定的三个3D向量P、Q和R，等式 \((\textbf{P} \times \textbf{Q}) \cdot \textbf{R}\) 的值可以通过伪行列式乘以R得到：</p><div>$$(\textbf{P} \times \textbf{Q}) \cdot \textbf{R} =\left|\begin{matrix}R_{x} & R_{y} & R_{z} \\P_{x} & P_{y} & P_{z} \\Q_{x} & Q_{y} & Q_{z}\end{matrix}\right|=\left|\begin{matrix}P_{x} & P_{y} & P_{z} \\Q_{x} & Q_{y} & Q_{z} \\R_{x} & R_{y} & R_{z}\end{matrix}\right|\tag{1.27}$$</div><p>Tips：行列式表达我在这里书写了两种表达形式，第一种是延续之前伪行列式的写法，只是将R替代了ijk的位置，第二种写法来自于书上，遵循PQR的出现次序的记忆法，两者的值根据初等变化法则是相等的。</p><p>如果P、Q和R中任何一个可以表示为其他两个向量的线性组合，则行列式的值为0（根据垂直法则和点积定理推导）。</p><p><strong>【定理1.8】</strong> 对于给定的两个3D向量P和Q，叉积\(\textbf{P} \times \textbf{Q}\)满足下面公式：</p><div>$$||\textbf{P} \times \textbf{Q}|| = \textbf{||P||}\textbf{||Q||}sin\alpha \tag{1.28}$$</div><p>\(\alpha\)为P和Q的夹角。</p><p>由定理1.8可知，叉积\(\textbf{P} \times \textbf{Q}\)的模等于由向量P和Q组成的平行四边形的面积。因此，一个三角形的顶点\(V_{1}, V_{2}, V_{3}\)，可以计算其面积A:</p><div>$$A = \frac{1}{2} || (V_{2} - V_{1}) \times (V_{3} - V_{1}) || \tag{1.32}$$</div><p>叉积得到的非零向量一定垂直于原本的两个向量，但满足要求的有两种方向，为了确定叉积方向，引入叉积遵循的<strong>右手法则</strong>。例如，使用右手手指指向P方向，手心朝向Q反向，则大拇指就是叉积\(\textbf{P} \times \textbf{Q}\)的方向。</p><p>空间轴的单位向量ijk，按照圆形循环的方式排序，i在j之前，j在k之前，k在i之前，则这样的顺序叉积乘等于第三个向量：</p><div>$$\begin{aligned} \textbf{i} \times \textbf{j} &= \textbf{k} \\ \textbf{j} \times \textbf{k} &= \textbf{i} \\ \textbf{k} \times \textbf{i} &= \textbf{j}\end{aligned}\tag{1.33}$$</div><p>反之，按照相反的顺序相接的叉乘等于第三个向量的负值。</p><p><strong>【定理1.9】</strong> 对于给定系数a，b和任意三个3D向量P、Q和R，有以下性质：</p><ul><li>\( \textbf{P} \times \textbf{Q} = - (\textbf{Q} \times \textbf{P}) \)</li><li>\( (a\textbf{P}) \times \textbf{Q} = a(\textbf{P} \times \textbf{Q}) \)</li><li>\( \textbf{P} \times (\textbf{Q} + \textbf{R}) = \textbf{P} \times \textbf{Q} + \textbf{P} \times \textbf{R} \)</li><li>\( \textbf{P} \times \textbf{P} = \textbf{0} = &lt;0, 0, 0&gt; \)</li><li>\( (\textbf{P} \times \textbf{Q}) \cdot \textbf{R} = (\textbf{R} \times \textbf{P}) \cdot \textbf{Q} = (\textbf{Q} \times \textbf{R}) \cdot \textbf{P} \) （注意顺序，满足圆形循环）</li><li>\( \textbf{P} \times (\textbf{Q} \times \textbf{P}) = \textbf{P} \times \textbf{Q} \times \textbf{P} = \textbf{P}^{2}\textbf{Q} - (\textbf{P} \cdot \textbf{Q}) \textbf{P} \)</li></ul><p>前五条都比较容易证明，稍微说一下最后一条的证明方式：</p><div>$$\begin{aligned}\textbf{P} \times (\textbf{Q} \times \textbf{P}) &= \textbf{P} \times [-(\textbf{P} \times \textbf{Q})] \\ &= [\textbf{P} \times -(\textbf{P} \times \textbf{Q})] \\ &= -[-(\textbf{P} \times \textbf{Q}) \times \textbf{P}] \\ &= (\textbf{P} \times \textbf{Q}) \times \textbf{P} \\ &= \textbf{P} \times \textbf{Q} \times \textbf{P}\end{aligned}\tag{1.35}$$</div><p>后面的具体计算式，是通过对三个分量分别求值得到的结果，不再赘述。</p><p>由定理1.9可以得到 <strong>叉积不满足交换律和结合律</strong>。</p><h2 id="4-向量空间"><a href="#4-向量空间" class="headerlink" title="4 向量空间"></a>4 向量空间</h2><p><strong>【定理1.10】</strong> 向量空间是一个集合V，元素成为向量，下面定义向量空间中的加法和乘数，并介绍一些性质：</p><ul><li>V对于加法运算封闭；</li><li>V对于乘数运算封闭；</li><li>V中存在一个零元素 \(\textbf{0}\)；</li><li>V中任意向量P存在向量Q使其 \( \textbf{P} + \textbf{Q} = \textbf{0}\)；</li><li>加法满足结合律；</li><li>乘数满足结合律；</li><li>乘数对于加法满足分配率，\( a(\textbf{P} + \textbf{Q}) = a\textbf{P} + a\textbf{Q}\)；</li><li>系数加法对于乘数满足分配率，\( (a + b)\textbf{P} = a\textbf{P} + b\textbf{P}\)。</li></ul><p>将由n元组组成的向量空间记作 \(R^{n}\)，比如三维的向量空间记作\(R^{3}\)。</p><p>每一个向量空间都可以由一组向量的线性组合来生成，生成向量空间的向量组成为基。</p><p><strong>【定义1.11】</strong> 对于一组向量 {\( \textbf{e}_{1}, \textbf{e}_{2}, …, \textbf{e}_{n} \)}，<strong>如果不存在</strong>这样一组实数 {\(a_{1}, a_{2}, …, a_{n}\)}，其中<strong>至少有一个</strong> \(a_{i}\) 不为0，使得下式成立：</p><div>$$a_{1}\textbf{e}_{1} + a_{2}\textbf{e}_{2} + \cdots + a_{n}\textbf{e}_{n} = 0 \tag{1.40}$$</div><p><strong>则称这组向量线性无关，否则称向量组线性相关</strong>。</p><p>一个n维向量空间可以由n个线性无关的向量组成的向量集合生成，这个向量组成为基。</p><p><strong>【定义1.12】</strong> 向量空间V的基B是一个由n个线性无关的向量组成的集合，即 \(\textbf{B}\)={\(\textbf{e}_{1}, \textbf{e}_{2}, …, \textbf{e}_{n} \)}，对于向量空间V中的任意一个元素P，都存在一组实数使得：</p><div>$$\textbf{P} = a_{1}\textbf{e}_{1} + a_{2}\textbf{e}_{2} + \cdots + a_{n}\textbf{e}_{n} \tag{1.41}$$</div><p>任意空间向量\(R^{n}\)都具有无限个基，对基的形式进行一些限定后，可以使基具有特定的性质。</p><p><strong>【定义1.13】</strong> 对于向量空间的基\(\textbf{B}\)={\(\textbf{e}_{1}, \textbf{e}_{2}, …, \textbf{e}_{n} \)}，如果对于任意 \(i \neq j\) 都有 \(\textbf{e}_{i} \cdot \textbf{e}_{j} = 0\)，则该基为正交基。</p><p><strong>【定理1.14】</strong> 对于给定的两个向量 \(\textbf{e}_{1}\) 和 \(\textbf{e}_{2}\)， 如果\(\textbf{e}_{1} \cdot \textbf{e}_{2} = 0\)，则\(\textbf{e}_{1}\) 和 \(\textbf{e}_{2}\)线性无关。</p><p>对基的另一个形式限定就是基的所有向量都具有单位长度（更简单化了），引入Kronecker delta符号 \(\delta_{ij}\)，定义如下：</p><div>$$\delta_{ij} =\left\{\begin{aligned} 1, i&=j  \\ 0, i&\neq j\end{aligned}\right.\tag{1.42}$$</div><p><strong>【定理1.15】</strong> 如果对于每一对 \((i, j)\) 有 \(\textbf{e}_{i} \cdot \textbf{e}_{j} = \delta_{ij}\)，则基 \(\beta\)={\(\textbf{e}_{1}, \textbf{e}_{2}, …, \textbf{e}_{n} \)}称为向量空间的正交规范基。</p><p>显然向量组{\(\textbf{i}, \textbf{j}, \textbf{k}\)}是\(R^{3}\)的一个正交规范基。</p><p>有一个方法可以将具有n个线性无关向量的向量组转换为向量空间\(R^{n}\)的正交基，基本思想是减去向量在前面每个向量上的投影，结果肯定和前面所有的向量正交。</p><p><strong>【定理1.16】</strong> <strong>Gram-Schmidt 正交规范化：</strong> 对于由n个线性无关想了组成的向量组\(\textbf{B}\)={\(\textbf{e}_{1}, \textbf{e}_{2}, …, \textbf{e}_{n} \)}，算法可以产生向量组\(\beta\)={\(\textbf{e}_{1}^{‘}, \textbf{e}_{2}^{‘}, …, \textbf{e}_{n}^{‘} \)}，当 \(i \neq j\)时，\(\textbf{e}_{i}^{i} \cdot \textbf{e}_{j}^{i} = 0\)。</p><ol><li>设 \(\textbf{e}_{1}^{‘} = \textbf{e}_{1}\)；</li><li>从i=2开始；</li><li>从\(\textbf{e}_{i}\)中减去\(\textbf{e}_{i}\)在向量\(\textbf{e}_{1}^{‘}, \textbf{e}_{2}^{‘}, …, \textbf{e}_{i-1}^{‘} \)上地投影，结果为\(\textbf{e}_{i}^{‘}\)，即</li></ol><div>$$\textbf{e}_{i}^{'} =\textbf{e}_{i} - \sum_{k=1}^{i-1} proj_{\textbf{e}_{k}} \textbf{e}_{i} =\textbf{e}_{i} - \sum_{k=1}^{i-1} \frac{\textbf{e}_{i} \cdot \textbf{e}_{k}}{\textbf{e}_{k}^{2}} \textbf{e}_{k} \tag{1.43}$$</div><ol start="4"><li>如果i &lt; n，i加1，重复步骤3。</li><li>如果需要进一步生成正交规范基，就对每个\(\textbf{e}_{i}^{‘}\)进行规范化。</li></ol>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;对于成功的3D程序猿，掌握如何进行向量运算是一种基本的技能要求。&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="3D游戏与图形学的数学" scheme="https://yumi-cn.github.io/categories/3D%E6%B8%B8%E6%88%8F%E4%B8%8E%E5%9B%BE%E5%BD%A2%E5%AD%A6%E7%9A%84%E6%95%B0%E5%AD%A6/"/>
    
    
    <category term="笔记" scheme="https://yumi-cn.github.io/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>《剑指Offer》第2章笔记 数组</title>
    <link href="https://yumi-cn.github.io/2020/11/26/s2o-c2-array/"/>
    <id>https://yumi-cn.github.io/2020/11/26/s2o-c2-array/</id>
    <published>2020-11-26T13:57:25.000Z</published>
    <updated>2020-11-28T14:12:10.637Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>数据结构是技术面的重点，主要围绕数组、字符串、链表、树、栈以及队列这几种常见的数据结构展开。</p></blockquote><a id="more"></a><p>嗯，除了语言和算法以外的最重要的（废话）。</p><hr><p>数组的一些特点（主要是指C/C++中的基础数组类型）：</p><ul><li>连续的内存，按照顺序存储；</li><li>创建时需要指定数组的容量大小；</li><li><code>O(1)</code>时间读/写任何位置元素；</li></ul><p>为了解决基础数组空间效率不高的问题，人们设计了动态数组，比如 <code>C++ STL</code> 中的 <code>vector</code> ，其中为了避免空间浪费，先为数组开辟小空间，当数据数目超过容量时，再重新分配一块更大的空间，把之间的数据复制到新的数组中，再把之前的内存释放（一般没有延续之前地址往后申请内存的操作，所以只能整块申请，然后再释放掉新的），但是这样就会带来内存空间申请和数据迁移的时间开销，因此使用动态数组要尽量减少改变数组容量大小的操作。</p><blockquote><p>在C/C++中，数组和指针既相互关联又有区别。</p></blockquote><p>声明一个数组时，数组的名字也是一个指针（不可修改的指针变量），该指针指向数组的第一个元素。需要注意的是，C/C++不会主动记录数组的大小，所以在访问数组元素时，程序要确保不会超过边界。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">get_size</span><span class="params">(<span class="keyword">int</span> data[])</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">sizeof</span>(data);</span><br><span class="line">&#125;Error: Cannot find module &#x27;gulplog&#x27;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> data1[] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line">  <span class="keyword">int</span> size1 = <span class="keyword">sizeof</span>(data1);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span>* data2 = data1;</span><br><span class="line">  <span class="keyword">int</span> size2 = <span class="keyword">sizeof</span>(data2);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span> size3 = get_size(data1);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%d, %d, %d&quot;</span>, size1, size2, size3);</span><br><span class="line">  <span class="comment">// 20, 4, 4</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>在上面的代码中：</p><ul><li><code>sizeof(data1) == 20</code>：<code>sizeof(data1)</code>求数组的大小（字节数），<code>data1</code>包含5个整数，每个整数4字节，所以20字节；</li><li><code>sizeof(data2) == 4</code>：<code>data2</code>声明是指针，尽管指向了数组指针，但本质仍然是指针，在32位系统上，对任意指针求<code>sizeof</code>都是4(32位系统是4个字节的地址)；</li><li><code>get_size(data1) == 4</code>：在C/C++中，数组作为函数参数传递时，会退化为同类型的指针，尽管函数声明的是数组参数，但还是会退化为指针（语言概念特色），所以结果仍然是4。</li></ul><hr><blockquote><p>面试题3 题目一：找出数组中重复的数字。</p></blockquote><p>数组长度n，数字都在 <code>0</code> - <code>n-1</code> 的范围内，数组中某些数字重复，但不知道有几个数字重复，请找出数组中任意一个重复数字；例如<code>&#123;2, 3, 1, 0, 2, 5, 3&#125;</code>，重复数字2或者3。</p><ul><li><strong>思路1</strong>：简单的排序再搜索就可以，但需要 <code>O(nlogn)</code> 的时间开销；</li><li><strong>改进思路2</strong>：常用的一种优化思路是使用哈希表，从头到尾记录所有数字的出现次数，如果次数大于2就是重复的数字，时间开销降低到了 <code>O(n)</code> ，但凭空多了哈希表的 <code>O(n)</code> 开销；</li></ul><p>大部分的人都能想到第二种方法，然后书的作者会介绍第三种方法：</p><blockquote><p>数字都在0~n-1的范围内，如果数组不重复，则数字i出现在下标i的位置，如果重复，则某些位置有多个数字，同时有些位置没有数字。</p></blockquote><p>但我觉得对这种方法的阐述，<strong>稍微有点凭空跳脱</strong>，没有和之前提到的前两种思路有任何延续，所以一时可能较于难以理解这里的思路，尤其是之后的算法流程。</p><p>我们可以延续之前的<strong>改进思路2</strong>，使用哈希表的优点是时间开销少，缺点是多了空间开销，那么进一步的优化思路是：<strong>如何减少空间上的开销？</strong></p><p>在已知数字出现在 <code>0</code> ~ <code>n-1</code> 范围内时，哈希表的一种简单实现是位置<code>i</code>存储数字<code>i</code>的出现频率：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> <span class="built_in">array</span>[<span class="number">5</span>] = &#123;<span class="number">1</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">0</span>, <span class="number">2</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> hash[<span class="number">5</span>] = &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>&#125;;</span><br><span class="line">... <span class="comment">// for num in array to finish hash</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; hash &lt;&lt; <span class="built_in">endl</span>; <span class="comment">// [1, 1, 1, 2, 0]</span></span><br></pre></td></tr></table></figure><p>那么，你可以想到的一种优化思路是：原数组存储的数字在读取过一次后其实就没有作用了，所以在数字<code>i</code>被读取了之后，<strong>将它“自己的位置”作为哈希表的存储位</strong>，<strong>不就不需要额外的空间了么</strong>？</p><p>更加细节地，在数字<code>i</code>被读取了过后，尽管它本身可能不在位置<code>i</code>上，可以把原本位置<code>i</code>的数字替换到当前的位置，最后我们使用位置<code>i</code>作为数字<code>i</code>的哈希表存储位，就完成了一步操作；对全数组的数字都执行这样的操作，就可以找出重复的数字了。</p><p>这个方法本质上是延续哈希表的思路，并且具体实现的方式你就会发现和作者提出的方法是一致的，所以我猜测作者的实质本意是将改进思路2的一种延续优化，但并没有在书中进行说明这种思路转变，稍微有点儿可惜。</p><p>PS：这样的改进思路在延续了简单哈希表实现的同时，也延续了这样的哈希表缺点，即无法处理<code>0</code> ~ <code>n-1</code> 范围以外的数字情况。</p><p>从头到尾依次扫描数组中的每个数字，当扫描到位置<code>i</code>的数字<code>m</code>时，判断<code>m==i</code>：</p><ul><li>如果相等，说明数字<code>i</code>在位置<code>i</code>上，继续执行；</li><li>如果不相等，将位置<code>m</code>上的数字交换到位置<code>i</code>上，位置<code>m</code>上放置了数字<code>m</code>，从位置<code>i</code>继续下一步判断；如果在交换之前发现，位置<code>m</code>上已经是数字<code>m</code>了，那么就说明数字<code>m</code>重复了，程序结束。</li></ul><p>一个栗子：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">1</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">0</span>, <span class="number">2</span>] <span class="comment">// i=0</span></span><br><span class="line">[<span class="number">3</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">0</span>, <span class="number">2</span>] <span class="comment">// i=0 1 on 1</span></span><br><span class="line">[<span class="number">0</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">2</span>] <span class="comment">// i=0 3 on 3</span></span><br><span class="line">[<span class="number">0</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">2</span>] <span class="comment">// i=0 0 on 0</span></span><br><span class="line">[<span class="number">0</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">2</span>] <span class="comment">// i=1 1 on 1</span></span><br><span class="line">[<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">3</span>] <span class="comment">// i=2 2 on 2</span></span><br><span class="line">[<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">3</span>] <span class="comment">// i=3 3 on 3</span></span><br><span class="line">[<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">3</span>] <span class="comment">// i=4 3 already on 3, 3 repeat</span></span><br></pre></td></tr></table></figure><p>完整代码实现：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find_repeat</span><span class="params">(<span class="keyword">int</span> <span class="built_in">array</span>[], <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(i &lt; len) &#123;</span><br><span class="line">        <span class="keyword">int</span> m = <span class="built_in">array</span>[i];</span><br><span class="line">        <span class="keyword">if</span>(m != i) &#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">array</span>[m] != m) &#123;</span><br><span class="line">                <span class="comment">// swap</span></span><br><span class="line">                <span class="keyword">int</span> temp = <span class="built_in">array</span>[m];</span><br><span class="line">                <span class="built_in">array</span>[m] = m;</span><br><span class="line">                <span class="built_in">array</span>[i] = temp;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> m;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> len;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> <span class="built_in">array</span>[] = &#123;<span class="number">1</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">0</span>, <span class="number">2</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> len = <span class="keyword">sizeof</span>(<span class="built_in">array</span>) / <span class="keyword">sizeof</span>(<span class="built_in">array</span>[<span class="number">0</span>]);</span><br><span class="line">    <span class="keyword">int</span> dup = find_repeat(<span class="built_in">array</span>, len);</span><br><span class="line">    <span class="keyword">if</span>(dup == len) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;No Repeat Number\n&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Repeat Number: %d\n&quot;</span>, dup);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在其中还可以加上前一节提到的安全、边界等问题的考虑，在下面贴的作者的实现里面可以看到：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">duplicate</span><span class="params">(<span class="keyword">int</span> <span class="built_in">array</span>[], <span class="keyword">int</span> len, <span class="keyword">int</span>* dup)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 考虑参数失效</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">array</span> == <span class="literal">nullptr</span> || len &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 考虑超过边界</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">array</span>[i] &lt; <span class="number">0</span> || <span class="built_in">array</span>[i] &gt; len - <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 实现比较优雅 流程相同</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="built_in">array</span>[i] != i) &#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">array</span>[i] == <span class="built_in">array</span>[<span class="built_in">array</span>[i]]) &#123;</span><br><span class="line">                *dup = <span class="built_in">array</span>[i];</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// swap</span></span><br><span class="line">                <span class="keyword">int</span> temp = <span class="built_in">array</span>[i];</span><br><span class="line">                <span class="built_in">array</span>[i] = <span class="built_in">array</span>[temp];</span><br><span class="line">                <span class="built_in">array</span>[temp] = temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><blockquote><p>面试题3 题目二：不修改数组找出重复的数字。</p></blockquote><p>在长度n+1的数组里的所有数字都在1~n的范围内，所以数组至少有一个数字是重复的。请找出数组中任意一个重复的数字，但不能修改输入的数组。</p><p>这一题虽然可以像题目一那样，只需要多开辟一个n+1长度的辅助数组，用来解决问题，但是这样就多了O(n)的空间开销。</p><p>一般在这种限定情况下，很难再和题目一一样做到时间、空间开销非常小的情况下完成任务，所以可以退一步，不需要缩减到O(n)时间，比如维持和快排复杂度O(nlogn)相同情况下，达成O(1)的空间开销也是一种优化的思路。</p><p>因为出发点不同，我们再次退回到最简单的方法：</p><ul><li>没有额外的空间帮助记录时，就只能每次判断一个数字是否有重复，即判断n次，每次有n长度的遍历开销，也就是O(n^2)；</li></ul><p>所以有<strong>两个优化的方向</strong>：（1）减少判断的次数n；（2）减少遍历长度n。</p><p>在没有额外信息辅助的情况下，优化（2）一般是很难做的（因为每个数只有遍历了全部才知道是否有重复），所以我们可以尝试优化（1）的部分。</p><p>最简单思路下，只有遍历了1~n的n个数在数组中的情况，才能知道谁重复了，我们可以用一些技巧来减少需要判断的次数。</p><p>其实非常巧妙，这条技巧就在题目中：“1~n范围内的数，在长度n+1的数组中必然存在一个重复”，这个命题成立的原因是，如果你遍历一次数组，统计1~n范围内数字的出现次数(n+1)，出现情况是大于n的（这里的n指1~n的这个范围长度），进一步地推广到一个普适命题“i~j范围内的数，在长度n+1的数组中，如果出现次数大于(j-i+1)，那必然存在重复”；</p><p>也就是意味着我们只用使用一次O(n)的遍历时间，就可以确定一个范围的数字是否存在重复。这样的性质可以让我们不断地缩小所需要判断的数字范围，这也就是时间开销上的优化。</p><p>具体地，我们可以联想到二分法：</p><ul><li>一开始将范围1~n分为两部分，一半是1~m，另一半是m+1~n；</li><li>如果范围1~m的数字的统计次数大于m，则这个范围内有重复的数字；否则另一半m+1~n的区间里一定有包含重复的数字；</li><li>继续二分存在重复数字的范围，重复步骤；</li><li>直到确定到某个重复数字。</li></ul><p>比如说题目给的例子{ 2, 3, 5, 4, 3, 2, 6, 7 }：</p><ul><li>[1-4]范围的数字出现5次，[5-7]范围的数字出现3次，重复在[1-4];</li><li>[1-2]范围的数字出现2次，[3-4]范围的数字出现3次，重复在[3-4]；</li><li>[3]数字出现2次，[4]数字出现1次，重复数字是3。</li></ul><p>然后简单分析一下时间复杂度，每次遍历统计的时间开销不变O(n)，因为数字范围二分，一共需要走O(logn)步，所以在O(nlogn)时间中可以找出重复数字。</p><p>完整代码实现：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">is_repeat</span><span class="params">(<span class="keyword">int</span> <span class="built_in">array</span>[], <span class="keyword">int</span> len, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">array</span>[i] &lt;= end &amp;&amp; <span class="built_in">array</span>[i] &gt;= start) &#123;</span><br><span class="line">            count += <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count &gt; (end - start + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find_repeat</span><span class="params">(<span class="keyword">int</span> <span class="built_in">array</span>[], <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> start = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> end = len<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">while</span>(end != start) &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = (end + start) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(is_repeat(<span class="built_in">array</span>, len, start, mid)) &#123;</span><br><span class="line">            end = mid;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            start = mid+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> start;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> <span class="built_in">array</span>[] = &#123;<span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">6</span>, <span class="number">7</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> len = <span class="keyword">sizeof</span>(<span class="built_in">array</span>) / <span class="keyword">sizeof</span>(<span class="built_in">array</span>[<span class="number">0</span>]);</span><br><span class="line">    <span class="keyword">int</span> dup = find_repeat(<span class="built_in">array</span>, len);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Repeat Number: %d\n&quot;</span>, dup); <span class="comment">// 3</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Tips：上述代码没有考虑一些安全、边界问题，所以比较简短。</p><p>需要指出的一点是，上面的使用的这种方法不能保证找出所有重复的数字，例如其中的2也是重复数字，但是算法只找出了3，一个原因是因为只会检查其中一半范围，例如检查到前一半有重复的时候，就不会再检查后一半范围了，另一个原因是算法无法确定是其中一个数字出现2次还是几次。</p><hr><blockquote><p>面试题4：二维数组中的查找</p></blockquote><p>在一个二维整数数组中，每一行从左到右递增，每一列从上到下递增，判断数组中是否含有指定数字。</p><p>例如：</p><div>$$\begin{matrix}1 & 2 & 8 & 9 \\2 & 4 & 9 & 12 \\4 & 7 & 10 & 13 \\6 & 8 & 11 & 15\end{matrix}$$</div><p>当一个数和矩阵中间的一个数比较时，除了相等，还有两种情况：</p><ul><li>(a)当查询数字<strong>小于</strong>目标数字时，说明目标数字<strong>一定不会出现在左上角</strong>，剩下需要判断的区域在其右边和下边；</li><li>(b)当查询数字<strong>大于</strong>目标数字时，说明目标数字<strong>一定不会出现在右下角</strong>，剩下需要判断的区域在其左边和上边。</li></ul><div align="center"><p><img src="/images/s2o-c2-array-cv4.jpg" alt="比较的两种情况"></p></div><p>当我们按照常规思路，尝试从<code>(0,0)</code>出发，向右下角进行搜索时，我们跳转到下一格只有通过2种方式，从上转移到下，和从左转移到右，如果我们把已遍历的位置称为“已知信息”，我们可以看到这种搜索方式，<strong>大部分“已知信息”都集中在左上部</strong>，这在比较出现的两种情况中，要么无法提供任何信息，要么只能提供重叠区域的信息，<strong>无法让转移确定下一次的方向</strong>。</p><p>所以为了<strong>避免“已知信息”的浪费</strong>，我们可以尝试从右上角<code>(0, n-1)</code>出发，向左下角进行搜索，这样会提供更多的信息，如果发生向下转移，代表上边没有比目标数更大的，如果发生向左转移，代表右边的数比目标数更大，所以导致更加明确的在左下角区域中搜索目标数。</p><div align="center"><p><img src="/images/s2o-c2-array-cv4-2.jpg" alt="例子"></p></div><p>完整代码实现：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> matrix[][<span class="number">4</span>], <span class="keyword">int</span> rows, <span class="keyword">int</span> cols, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> j = cols - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(i &lt; rows &amp;&amp; j &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span>(matrix[i][j] &lt; target) &#123;</span><br><span class="line">            i++;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(matrix[i][j] &gt; target) &#123;</span><br><span class="line">            j--;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> matrix[][<span class="number">4</span>] = &#123;</span><br><span class="line">        &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">8</span>, <span class="number">9</span>&#125;,</span><br><span class="line">        &#123;<span class="number">2</span>, <span class="number">4</span>, <span class="number">9</span>, <span class="number">12</span>&#125;,</span><br><span class="line">        &#123;<span class="number">4</span>, <span class="number">7</span>, <span class="number">10</span>, <span class="number">13</span>&#125;,</span><br><span class="line">        &#123;<span class="number">6</span>, <span class="number">8</span>, <span class="number">11</span>, <span class="number">15</span>&#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">int</span> target = <span class="number">7</span>;</span><br><span class="line">    <span class="keyword">if</span>(find(matrix, <span class="number">4</span>, <span class="number">4</span>, target)) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Found!\n&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Not Found!\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;数据结构是技术面的重点，主要围绕数组、字符串、链表、树、栈以及队列这几种常见的数据结构展开。&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="剑指Offer" scheme="https://yumi-cn.github.io/categories/%E5%89%91%E6%8C%87Offer/"/>
    
    
    <category term="笔记" scheme="https://yumi-cn.github.io/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>《剑指Offer》第2章笔记 编程语言</title>
    <link href="https://yumi-cn.github.io/2020/11/25/s2o-c2-lg/"/>
    <id>https://yumi-cn.github.io/2020/11/25/s2o-c2-lg/</id>
    <published>2020-11-25T12:57:25.000Z</published>
    <updated>2020-11-28T09:20:58.171Z</updated>
    
    <content type="html"><![CDATA[<p>第2章主要围绕<strong>编程语言</strong>、<strong>数据结构</strong>和<strong>算法</strong>，介绍技术面所需要的“基础知识”。</p><a id="more"></a><h2 id="编程语言"><a href="#编程语言" class="headerlink" title="编程语言"></a>编程语言</h2><p>书里代码都是用 <code>C/C++/C#</code> 实现的，后面分别从 <code>C++</code> 和 <code>C#</code> 语言的角度来讲述其中一些被问道的细节点，这样的细节点因为篇幅限制，不可能都写进书里，所以还需要通过阅读对应编程语言的书籍来进阶了解，同时其他语言的使用者也可以从其中窥探到面试官在针对语言掌握的考量时，都是从什么样的角度出发的。</p><h3 id="C"><a href="#C" class="headerlink" title="C++"></a>C++</h3><p>通常语言面试的问题有3种类型：</p><ol><li>对于语言中概念的理解程度；</li><li>面对代码，分析运行结果（或错误）；</li><li>在上下文环境中，定义类型或实现函数。</li></ol><p>作者推荐的几本C++书，根据自己的情况选择阅读顺序：</p><ul><li><strong>《Effective C++》</strong>：书中列举了C++经常出现的问题以及解决这些问题的技巧（大多是面试官比较喜欢问的方向），适合面试之前突击C++；</li><li><strong>《C++ Primer》</strong>：人称C++全书，适合全面了解的时候阅读，也可以当作宝典查询；</li><li><strong>《深度探索C++对象模型》</strong>：深度了解C++对象的内部机制，介绍很多较为底层的知识点；</li><li><strong>《The C++ Programming Language》</strong>：C++圣经（大概），适合全面深入掌握C++。</li></ul><p>下面通过一道面试题（第3种类型）来表现一下这类题目是如何考查语言知识点的。</p><blockquote><p>面试题1：赋值运算符函数，如下为类型CMyString的声明，请为该类型添加赋值运算符函数。</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CMyString</span> &#123;</span></span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    CMyString(<span class="keyword">char</span>* pData=<span class="literal">nullptr</span>);</span><br><span class="line">    CMyString(<span class="keyword">const</span> CMyString&amp; str);</span><br><span class="line">    ~CMyString(<span class="keyword">void</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">char</span>* m_pData;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>Tips：赋值运算符主要负责变量在进行赋值 <code>=</code> 运算时，如何处理变量对象内部成员变化。</p><p>定义C++中的<strong>赋值运算符</strong>函数时，需要关注点有：</p><ul><li><strong>返回值类型声明为引用，函数结束前返回实例自身的引用</strong>，因为返回引用才允许连续赋值的情况，例如 <code>str1 = str2 = str3</code>，否则无法通过编译；</li><li>把<strong>传入的参数类型声明为常量引用</strong>，如果不是引用，形参到实参传递会调用一次复制构造函数（函数的传值引用），引用可以避免这样的开销；同时因为赋值运算并不会修改传入的实例的状态，所以应进一步加上 <code>const</code> 关键字；</li><li><strong>释放实例自身已有的内存</strong>，主要在对象有动态分配内存情况下考虑，如果忘记在分配新内存前释放旧内存空间，程序旧出现了内存泄漏(memory leakge)，这块内存无法被回收使用（资源浪费、占用空间导致空间不够用）；</li><li><strong>判断传入参数和当前实例</strong>(*this)是不是同一个实例，是则不进行赋值，如果不判断就直接赋值，在同一个实例情况下，会导致在还没有拷贝到传入参数（自己）的内存时，就释放自己的内存，这也就导致传入参数的内存被释放了（因为函数是传引用），最后找不到待赋值的内容。</li></ul><p>经典解法：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line">CMyString&amp; CMyString::<span class="keyword">operator</span>=(<span class="keyword">const</span> CMyString&amp; str) &#123;</span><br><span class="line">  <span class="keyword">if</span>(<span class="keyword">this</span> == &amp;str) &#123;  <span class="comment">// 对象的 this 是一个地址</span></span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;     <span class="comment">// 传对象 而不是地址</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">delete</span> []m_pData;   <span class="comment">// 数组的释放方式</span></span><br><span class="line">  m_pData = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">  m_pData = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="built_in">strlen</span>(str.m_pData) + <span class="number">1</span>]; <span class="comment">// 申请新空间，多的1位给&#x27;\0&#x27;</span></span><br><span class="line">  <span class="built_in">strcpy</span>(m_pData, str.m_pData); <span class="comment">// 复制 赋值</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果对自己有更高的要求，应该再进一步地考虑其中涉及到的问题。</p><p>前面的函数中，<strong>分配内存之前先释放了内存</strong>，如果在分配内存时，内存不足就会导致 <code>new char</code> 排除异常，<code>m_pData</code>将是一个空指针，并且无法回退到之前的结果，也就是说一旦赋值运算符内部抛出了异常，实例不再保持有效的状态（并不是原有的状态），这违背了异常安全性（Exception Safety）原则（正常情况下，如果抛出异常也不应该导致内容被错误操作）。</p><ul><li>简单的方法是先用 <code>new</code> 分配新内容，再 <code>delete</code> 释放已有的；</li><li>更好的办法是<strong>创建一个临时实例</strong>，再交换临时实例和原来的实例。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line">CMyString&amp; CMyString::<span class="keyword">operator</span>=(<span class="keyword">const</span> CMyString&amp; str) &#123;</span><br><span class="line">  <span class="keyword">if</span>(<span class="keyword">this</span> == &amp;str) &#123;</span><br><span class="line">    CMyString tmp(str); <span class="comment">// 复制构造函数</span></span><br><span class="line">    <span class="built_in">std</span>::swap(m_pData, tmp.m_pData); <span class="comment">// 交换地址</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当 <code>tmp</code> 局部变量遇到 <code>if</code> 结束时，会自动调用它的析构函数，会把交换下来的 <code>this</code> 的 <code>m_pData</code> 所指向的内存释放掉；在新的代码中，在复制构造函数中分配内存，如果由于内存不足抛出异常时，由于此时还没有修改原来的实例状态，实例的状态依旧是有效的（原有的），也就保证了异常安全性。</p><p>完整代码（包含所有实现和测试）：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CMyString</span> &#123;</span></span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    CMyString(<span class="keyword">char</span>* pData); <span class="comment">// 第一个参数设定默认值会导致无法通过编译</span></span><br><span class="line">    CMyString(<span class="keyword">const</span> CMyString&amp; str);</span><br><span class="line">    ~CMyString(<span class="keyword">void</span>);</span><br><span class="line">    CMyString&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> CMyString&amp; str); <span class="comment">// 赋值运算符函数声明</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">void</span>)</span></span>; <span class="comment">// 标准输出函数</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">char</span>* m_pData;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 构造函数</span></span><br><span class="line">CMyString::CMyString(<span class="keyword">char</span>* pData) &#123;</span><br><span class="line">    <span class="keyword">if</span>(pData != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        m_pData = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="built_in">strlen</span>(pData) + <span class="number">1</span>];</span><br><span class="line">        <span class="built_in">strcpy</span>(m_pData, pData);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 复制构造函数</span></span><br><span class="line">CMyString::CMyString(<span class="keyword">const</span> CMyString&amp; str) &#123;</span><br><span class="line">    <span class="keyword">if</span>(str.m_pData != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        m_pData = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="built_in">strlen</span>(str.m_pData) + <span class="number">1</span>];</span><br><span class="line">        <span class="built_in">strcpy</span>(m_pData, str.m_pData);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 析构函数</span></span><br><span class="line">CMyString::~CMyString(<span class="keyword">void</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span>(m_pData != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="keyword">delete</span> []m_pData;</span><br><span class="line">        m_pData = <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CMyString::print</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; m_pData &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 赋值运算符函数</span></span><br><span class="line">CMyString&amp; CMyString::<span class="keyword">operator</span>=(<span class="keyword">const</span> CMyString&amp; str) &#123;</span><br><span class="line">  <span class="keyword">if</span>(<span class="keyword">this</span> != &amp;str) &#123;</span><br><span class="line">    CMyString tmp(str); <span class="comment">// 复制构造函数</span></span><br><span class="line">    <span class="built_in">std</span>::swap(m_pData, tmp.m_pData); <span class="comment">// 交换地址</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 测试CMyString</span></span><br><span class="line">    <span class="function">CMyString <span class="title">str1</span><span class="params">(<span class="string">&quot;Sword&quot;</span>)</span></span>;</span><br><span class="line">    <span class="function">CMyString <span class="title">str2</span><span class="params">(<span class="string">&quot;2&quot;</span>)</span></span>;</span><br><span class="line">    <span class="function">CMyString <span class="title">str3</span><span class="params">(<span class="string">&quot;Offer&quot;</span>)</span></span>;</span><br><span class="line">    str1 = str2 = str3;</span><br><span class="line">    str1.print(); <span class="comment">// Offer</span></span><br><span class="line">    str2.print(); <span class="comment">// Offer</span></span><br><span class="line">    str3.print(); <span class="comment">// Offer</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果完整的去实现上面这个题目，会引出一些非常容易忽略的细节问题（并且会导致严重错误），例如在初始化变量 <code>str1</code> 时，<code>CMyString str1(&quot;Sword&quot;);</code>，其中所传入的参数一般都是程序声明的<strong>字符串常量</strong>，如果在构造函数中简单地实现为：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Mem Error</span></span><br><span class="line">CMyString::CMyString(<span class="keyword">char</span>* pData) &#123;</span><br><span class="line">    m_pData = pData;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>就会导致赋值运算符函数中的析构函数调用过程发生错误，因为析构函数中的 <code>delete []m_pData</code> 的delete操作符只负责操作堆(Heap)中的内存区域(因为new只在堆里申请内存区域)，如果使用delete操作符去释放一个字符串常量指针所指向的区域，就会发生错误（大概是访问越界）。</p><p>所以在初始化时应该使用和delete对应的new操作，在堆中申请内存，再把传入参数的内容复制到其中。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">CMyString::CMyString(<span class="keyword">char</span>* pData) &#123;</span><br><span class="line">    <span class="keyword">if</span>(pData != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        m_pData = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="built_in">strlen</span>(pData) + <span class="number">1</span>];</span><br><span class="line">        <span class="built_in">strcpy</span>(m_pData, pData);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="C-1"><a href="#C-1" class="headerlink" title="C#"></a>C#</h3><p>因为还没怎么学C#的东西，C#的部分暂时跳过，记录一下推荐的书：</p><ul><li>《Professional C#》：特点是附录中有描述C#和其他语言的区别；</li><li>《CLR Via C#》：深入介绍C#，对CLR和.NET进行剖析，可以方便理解装箱卸箱、垃圾回收、反射等概念。</li></ul><blockquote><p>面试题2：实现Singleton模式（单例模式）</p></blockquote><p>暂时跳过。</p><p>涉及到设计模式的部分，列举一些可以参考阅读的资料：</p><ul><li>《设计模式：C++常用设计模式》：<a href="https://refactoringguru.cn/design-patterns/cpp">https://refactoringguru.cn/design-patterns/cpp</a> ；</li><li>《Head First 设计模式》：感觉是一本比较老的书，可能之后看看吧；</li><li>《Game Programming Patterns》：<a href="http://gameprogrammingpatterns.com/contents.html">http://gameprogrammingpatterns.com/contents.html</a> 。</li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;第2章主要围绕&lt;strong&gt;编程语言&lt;/strong&gt;、&lt;strong&gt;数据结构&lt;/strong&gt;和&lt;strong&gt;算法&lt;/strong&gt;，介绍技术面所需要的“基础知识”。&lt;/p&gt;</summary>
    
    
    
    <category term="剑指Offer" scheme="https://yumi-cn.github.io/categories/%E5%89%91%E6%8C%87Offer/"/>
    
    
    <category term="笔记" scheme="https://yumi-cn.github.io/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>《剑指Offer》第1章笔记</title>
    <link href="https://yumi-cn.github.io/2020/11/24/s2o-c1/"/>
    <id>https://yumi-cn.github.io/2020/11/24/s2o-c1/</id>
    <published>2020-11-24T04:57:25.000Z</published>
    <updated>2020-11-28T09:20:54.477Z</updated>
    
    <content type="html"><![CDATA[<p>第1章主要介绍的是几种面试方式的不同流程以及注意事项。</p><blockquote><p>“…技术面试中的5个要素，是全书的大纲,…”</p></blockquote><a id="more"></a><h2 id="远程桌面面试"><a href="#远程桌面面试" class="headerlink" title="远程桌面面试"></a>远程桌面面试</h2><ul><li>思考清楚再开始编码；</li><li>良好的代码命名和缩进对齐；</li><li>单元测试、断点调试。</li></ul><h2 id="面试的3个环节"><a href="#面试的3个环节" class="headerlink" title="面试的3个环节"></a>面试的3个环节</h2><p>行为面试、技术面试、应聘者提问。</p><h3 id="行为面试"><a href="#行为面试" class="headerlink" title="行为面试"></a>行为面试</h3><ol start="0"><li>自我介绍：30s-1min，介绍主要学习和工作经历；</li><li>项目经验：STAR模型描述项目经历；<ul><li>Situation：简短的项目背景；</li><li>Task：自己完成的任务，注意区分“参与”和“负责”；</li><li>Action：如何完成任务的，详细介绍自己完成任务的方式方法；</li><li>Result：自己的贡献，尝试量化自己的产出，让人直接接收到你的成果。</li></ul></li><li>掌握技能：注意区分“了解”、“熟悉”和“精通”；<ul><li>了解：上过课、看过书，但没有做过实际项目，通常只建议有用的时候再写；</li><li>熟悉：通常的情况，指能够独立解决大部分问题；</li><li>精通：得心应手，能够轻松回答领域内的绝大多数问题。</li></ul></li><li>为什么跳槽：尽量不说抱怨层面的原因，多从自我发展的角度阐述选择的理由。</li></ol><h3 id="技术面试"><a href="#技术面试" class="headerlink" title="技术面试"></a>技术面试</h3><p>平均1个小时的面试，技术面试会占据40-50分钟的时间。</p><p>总的来说面试官关注应聘者的5种素质：</p><ul><li>扎实的基础知识：编程语言、数据结构和算法；</li><li>能写高质量的代码：代码鲁棒性，边界考虑（另外还需要注意代码规范或者风格）；</li><li>分析问题的思路清晰：从简单完备的思路出发，用各种方法来尝试优化，例如画图形象化，举例具象化，分解简单化；</li><li>能够优化时间、空间效率：熟知数据结构优缺点，熟练掌握常用算法；</li><li>学习、沟通、综合能力。</li></ul><p>PS：5个要素分别对应本书的第2、3、4、5、6章节内容。</p><h3 id="应聘者提问"><a href="#应聘者提问" class="headerlink" title="应聘者提问"></a>应聘者提问</h3><p>如果觉得面试后临时想比较困难，可以在面试前提前准备一些问题。</p><p>主要围绕公司、职位、项目等工作上的事情，不太适合问较远较模糊或者和工薪相关的问题（之后再和HR聊也可以）。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;第1章主要介绍的是几种面试方式的不同流程以及注意事项。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;“…技术面试中的5个要素，是全书的大纲,…”&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="剑指Offer" scheme="https://yumi-cn.github.io/categories/%E5%89%91%E6%8C%87Offer/"/>
    
    
    <category term="笔记" scheme="https://yumi-cn.github.io/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>11月的计划</title>
    <link href="https://yumi-cn.github.io/2020/11/19/plan-2020-11/"/>
    <id>https://yumi-cn.github.io/2020/11/19/plan-2020-11/</id>
    <published>2020-11-18T16:00:00.000Z</published>
    <updated>2020-12-12T07:42:20.623Z</updated>
    
    <content type="html"><![CDATA[<p>11月大概还剩下一周的时间，主要是在尝试起步学一些东西：</p><ul><li>《剑指Offer》：大概前几章，简单过一下摸一下这本书的安排规律，每章尽量写一点浓缩知识点；</li><li>《3D游戏与计算机图形学中的数学方法》：之前把Games101课程简单过了一下，再通过刷这本书巩固一下基础的数学。</li></ul><a id="more"></a><p>12月的初步规划：</p><ul><li>《剑指Offer》；</li><li>《3D游戏与计算机图形学中的数学方法》；</li><li>《Fundamentals of Computer Graphics》 。</li></ul><p>1月的初步规划：</p><ul><li>《Effictive C++》；</li><li>《Real Time Rendering 4th》；</li><li>《游戏引擎架构》。</li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;11月大概还剩下一周的时间，主要是在尝试起步学一些东西：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;《剑指Offer》：大概前几章，简单过一下摸一下这本书的安排规律，每章尽量写一点浓缩知识点；&lt;/li&gt;
&lt;li&gt;《3D游戏与计算机图形学中的数学方法》：之前把Games101课程简单过了一下，再通过刷这本书巩固一下基础的数学。&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="计划-Flags" scheme="https://yumi-cn.github.io/categories/%E8%AE%A1%E5%88%92-Flags/"/>
    
    
  </entry>
  
</feed>
