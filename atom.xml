<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>画码余生</title>
  
  <subtitle>副标题</subtitle>
  <link href="https://yumi-cn.github.io/atom.xml" rel="self"/>
  
  <link href="https://yumi-cn.github.io/"/>
  <updated>2020-12-12T15:18:18.379Z</updated>
  <id>https://yumi-cn.github.io/</id>
  
  <author>
    <name>Yumiko</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>《3D图形的数学》第3章笔记 变换</title>
    <link href="https://yumi-cn.github.io/2020/12/12/3dmath-c3/"/>
    <id>https://yumi-cn.github.io/2020/12/12/3dmath-c3/</id>
    <published>2020-12-12T12:52:19.000Z</published>
    <updated>2020-12-12T15:18:18.379Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>3D游戏开发过程中，通常需要以某种方式对向量进行变换。</p></blockquote><a id="more"></a><p>通常用到的变换包括<strong>平移、缩放和旋转</strong>。</p><h2 id="1-通用变换"><a href="#1-通用变换" class="headerlink" title="1 通用变换"></a>1 通用变换</h2><p>通常把 \(n \times n\) 可逆矩阵M看成是一个从坐标系到另一个坐标系的变换矩阵。</p><p>M的列给出了坐标轴从原坐标系到新坐标系的映射；\(M^{-1}\)的列给出了坐标轴从新坐标系到原坐标系的映射。</p><p>PS：书上的上面两句话，可以尝试从M乘以一个坐标轴单位向量的结果角度来考量，也就理解M的列是如何对一个向量或者坐标的各个轴的处理的。</p><p>多个变换可以串联起来，也可以将多个变换矩阵的乘积用一个矩阵来表示，例如 \(G(MP)=(GM)P\)，其中G/M是变换矩阵，P是坐标或向量，先做M变换再做G变换的结果可以用一个(GM)矩阵来存储，这样可以对顶点做无数次的变换，不需要额外的存储空间和计算开销。</p><h3 id="1-1-正交矩阵"><a href="#1-1-正交矩阵" class="headerlink" title="1.1 正交矩阵"></a>1.1 正交矩阵</h3><p><strong>正交矩阵的转置等于其逆矩阵</strong>。</p><p><strong>【定义3.1】</strong> 一个n阶可逆方阵M，当且仅当 \(M^{-1}=M^{T}\)时，M为正交矩阵。</p><p><strong>【定理3.2】</strong> 如果向量组 \(V_{1}, V_{2}, \cdots, V_{n}\)构成的一个正交向量集合，则以 \(V_{j}, (1 \leq j \leq n)\)作为第j列的n阶方阵是正交矩阵。</p><p>正交矩阵还有另外一个性质，用于变换向量时，<strong>正交矩阵不改变向量的长度和角度</strong>（一般指的是两个同样变换的向量夹角）。</p><p><strong>【定理3.3】</strong> 如果n阶方阵M正交，则M具有保证长度和角度不变的特性。</p><p>Tips：证明可以先从不改变两个向量的内积入手，然后再说明对单个向量不改变长度，再推出不改变角度。</p><p>由于这样的特性，使用正交矩阵变换可以保持坐标系的整体结构，所以正交矩阵只能用于表示旋转和反射（在某一方向上将点镜像的运算）的组合。</p><h3 id="1-2-手向性"><a href="#1-2-手向性" class="headerlink" title="1.2 手向性"></a>1.2 手向性</h3><p>在三维空间中，由3D向量 \(V_{1}, V_{2}, V_{3}\) 构成的坐标系的基具有手向性。对于<strong>右手基</strong>，有 \((V_{1} \times V_{2}) \cdot V_{3} &gt; 0\)，即在右手坐标系中， \(V_{1}, V_{2}\)的叉积(右手法则下)的方向与 \(V_{3}\)的方向形成一个锐角，如果是一个<strong>正交规范的右手基</strong>，则有 \(V_{1} \times V_{2} = V_{3}\)；若\((V_{1} \times V_{2}) \cdot V_{3} &lt; 0\)，那么是<strong>左手基</strong>。</p><p>进行<strong>奇数次的反射操作</strong>，会改变手向性，<strong>偶数次的反射</strong>相当与一次旋转。通过考查变换矩阵的行列式可以判定矩阵是否存在反射，若<strong>行列式为负</strong>，则存在反射，用其对任意基的向量进行变换操作后，基的手向性发生改变。如果行列式是正的，则不改变手向性。</p><p>另外，正交矩阵的行列式值只可能是1或-1，如果为1，则矩阵只有旋转；如果为-1，则表示旋转操作后再进行一次反射。</p><hr><h2 id="2-缩放变换"><a href="#2-缩放变换" class="headerlink" title="2 缩放变换"></a>2 缩放变换</h2><p>用a作为系数缩放向量P，只需要计算 \(P^{‘}=aP\)，在三维空间中，运算也可以表示为和矩阵的乘积：</p><div>$$P^{'}=\left[\begin{matrix}a & 0 & 0 \\0 & a & 0 \\0 & 0 & a\end{matrix}\right]\left[\begin{matrix}P_{x} \\P_{y} \\P_{z}\end{matrix}\right]\tag{3.8}$$</div><p>这种缩放成为<strong>统一缩放</strong>（各个轴相同缩放系数），如果希望在x,y,z轴以不同的值缩放向量，可以改变对角线上的元素（不再是相同的一个a），这种缩放称为<strong>非统一缩放</strong>。</p><div>$$P^{'}=\left[\begin{matrix}a & 0 & 0 \\0 & b & 0 \\0 & 0 & c\end{matrix}\right]\left[\begin{matrix}P_{x} \\P_{y} \\P_{z}\end{matrix}\right]\tag{3.9}$$</div><p>如果想在<strong>3个任意轴上进行非统一缩放</strong>，就要用到稍微复杂的缩放过程。假设以a,b,c为系数，在U,V,W轴方向上进行缩放，就需要先从坐标系(U,V,W)变换到坐标系(i,j,k) （这一步乘以[U V W]的逆矩阵变换到UVW为ijk坐标轴的空间中），然后在(i,j,k)坐标系中计算缩放（乘以缩放矩阵），最后再还原到(U,V,W)坐标系（乘以[U V W]矩阵变换到原本的ijk坐标轴空间中）。</p><div>$$P^{'}=\left[\begin{matrix}U_{x} & V_{x} & W_{x} \\U_{y} & V_{y} & W_{y} \\U_{z} & V_{z} & W_{z}\end{matrix}\right]\left[\begin{matrix}a & 0 & 0 \\0 & b & 0 \\0 & 0 & c\end{matrix}\right]\left[\begin{matrix}U_{x} & V_{x} & W_{x} \\U_{y} & V_{y} & W_{y} \\U_{z} & V_{z} & W_{z}\end{matrix}\right]^{-1}\left[\begin{matrix}P_{x} \\P_{y} \\P_{z}\end{matrix}\right]\tag{3.10}$$</div><p>Tips：这一段其实说的有点绕，但其实理解第一步就可以理解后面了，关于为什么是乘以逆矩阵，是因为(U,V,W)中的目标 \(P^{uvw}\) 有以下的表示方法：</p><div>$$P^{uvw}_{x}\left[\begin{matrix}U_{x} \\U_{y} \\U_{z}\end{matrix}\right]+P^{uvw}_{y}\left[\begin{matrix}W_{x} \\W_{y} \\W_{z}\end{matrix}\right]+P^{uvw}_{z}\left[\begin{matrix}V_{x} \\V_{y} \\V_{z}\end{matrix}\right]\\ =\left[\begin{matrix}U_{x} & V_{x} & W_{x} \\U_{y} & V_{y} & W_{y} \\U_{z} & V_{z} & W_{z}\end{matrix}\right]\left[\begin{matrix}P^{uvw}_{x} \\P^{uvw}_{y} \\P^{uvw}_{z}\end{matrix}\right]=\left[\begin{matrix}P_{x} \\P_{y} \\P_{z}\end{matrix}\right]$$</div><p>所以要求得(U,V,W)坐标系下的坐标 \(P^{uvw}\) 就要用原坐标乘以矩阵[U V W]的逆矩阵：</p><div>$$\left[\begin{matrix}P^{uvw}_{x} \\P^{uvw}_{y} \\P^{uvw}_{z}\end{matrix}\right]=\left[\begin{matrix}U_{x} & V_{x} & W_{x} \\U_{y} & V_{y} & W_{y} \\U_{z} & V_{z} & W_{z}\end{matrix}\right]^{-1}\left[\begin{matrix}P_{x} \\P_{y} \\P_{z}\end{matrix}\right]$$</div><p>这也就解释了第一步为什么乘以的是逆矩阵，后面也就相同的方法来解释了。</p><hr><h2 id="3-旋转变换"><a href="#3-旋转变换" class="headerlink" title="3 旋转变换"></a>3 旋转变换</h2><p>得到将坐标系绕x,y或z轴旋转 \(\theta\)角的矩阵并不难，当A轴指向我们时，所看到的旋转时逆时针方向。</p><p>首先看一下二维空间旋转的通用公式，如图3.2所示，通过交换x和y坐标，并将新的x坐标取负，得到(-y,x)，就能够将位于xy平面线上的二维向量P进行90°的逆时针旋转。设旋转向量为Q，则有 \( Q=&lt;-P_{y}, P_{x}&gt;\)。向量P和Q组成了xy平面的一个正交基，因此xy平面的任意向量都可以用这两个向量的线性组合来表示。</p><div align="center"><p><img src="/images/3d-math-c3-3-1.jpg"></p></div><p>如图3.3所示，任意向量P以 \(\theta\)角旋转后所形成的二维向量 \(P^{‘}\)，都可以用分别平行于P和Q的分量来表示。</p><div>$$P^{'} = Pcos\theta + Qsin\theta \tag{3.11}$$</div><p>带入Q的坐标计算，可以有：</p><div>$$\begin{aligned}P^{'}_{x} &= P_{x}cos\theta - P_{y}sin\theta \\P^{'}_{y} &= P_{y}cos\theta + P_{x}sin\theta\end{aligned}\tag{3.12}$$</div><p>用矩阵改写则有：</p><div>$$P^{'} =\left[\begin{matrix}cos\theta & -sin\theta \\sin\theta & cos\theta\end{matrix}\right]P\tag{3.13}$$</div><p>将单位矩阵的第3行和第3列加入到等式3.13中的2D旋转矩阵，就可以扩展成3D空间中绕z轴的三维旋转，在旋转过程中z坐标保持不变，绕z轴旋转 \(\theta\) 角度的旋转矩阵 \(R_{z}(\theta)\)可以表示为：</p><div>$$R_{z}(\theta) =\left[\begin{matrix}cos\theta & -sin\theta & 0 \\sin\theta & cos\theta & 0 \\0 & 0 & 1\end{matrix}\right]\tag{3.14}$$</div><p>同样，可以分别得到绕x轴和绕y轴旋转\theta角度的旋转矩阵 \(R_{x}(\theta)\) 和 \(R_{y}(\theta)\)：</p><div>$$\begin{aligned}R_{x}(\theta) =\left[\begin{matrix}1 & 0 & 0 \\0 & cos\theta & -sin\theta \\0 & sin\theta & cos\theta\end{matrix}\right]\\R_{y}(\theta) =\left[\begin{matrix}cos\theta & 0 & sin\theta \\0 & 1 & 0 \\-sin\theta & 0 & cos\theta\end{matrix}\right]\end{aligned}\tag{3.15}$$</div><h3 id="3-1-绕任意轴旋转"><a href="#3-1-绕任意轴旋转" class="headerlink" title="3.1 绕任意轴旋转"></a>3.1 绕任意轴旋转</h3><p>如果如果希望将向量P绕一个<strong>任意轴旋转</strong> \(\theta\) 角，选定的任意轴以单位向量A表示，那么可以先将向量P分解为平行于A和垂直于A的分量。<br>如图3.4所示，由于平行分量在旋转过程中保持不变，所以只需要计算垂直于A的分量的旋转。</p><div align="center"><p><img src="/images/3d-math-c3-3-2.jpg"></p></div><p>A是一个单位向量，P在A上地投影为（公式1.18）：</p><div>$$proj_{A}P = \frac{P \cdot A}{A^{2}} A = (P \cdot A)A\tag{3.16}$$</div><p>P垂直于A的分量为（公式1.19）：</p><div>$$perp_{A} P = P - proj_{A} P = P - (P \cdot A)A\tag{3.17}$$</div><p>将垂直于A的分量进行旋转，再加上平行分量，就得到最终的旋转结果。</p><p>垂直分量的旋转实在垂直于A轴的平面内进行的，平面中可以用垂直分量和垂直分量旋转90°所形成的向量组成一组正交基，就可以表达该平面内的任意向量，垂直分量旋转90°的向量可以用 \(A \times P\) 得到。</p><p>用下面的公式表示 \(perp_{A}P\)旋转 \(\theta\)角，即：</p><div>$$[P - (P \cdot A)A]cos\theta + (A \times P)sin\theta\tag{3.18}$$</div><p>再加上平行分量 \(proj_{A}P\)，就可以得到P绕A轴旋转的公式：</p><div>$$P^{'} = [P - (P \cdot A)A]cos\theta + (A \times P)sin\theta + (P \cdot A)A \\= Pcos\theta + (A \times P)sin\theta + (P \cdot A)A(1 - cos\theta)\tag{3.19}$$</div><p>将其中的 \(A \times P\)和 \((P \cdot A)A\)替换为等价矩阵形式，就可以更加具体的表示出旋转矩阵 \(R_{A}(\theta)\)，公式过于繁杂就不再赘述。</p><h2 id="4-齐次坐标"><a href="#4-齐次坐标" class="headerlink" title="4 齐次坐标"></a>4 齐次坐标</h2><p>还有一个重要的变换是平移操作，在空间中平移坐标系，只需要简单地添加偏移向量，并不会影响坐标轴的方向和尺度，但这种矩阵无法用 \(3 \times 3\)的矩阵来直接表示，需要加一个平移分量：</p><div>$$P^{'} = MP + T \tag{3.22}$$</div><p>M为可逆变换矩阵，T是平移向量。</p><h3 id="4-1-四维变换"><a href="#4-1-四维变换" class="headerlink" title="4.1 四维变换"></a>4.1 四维变换</h3><p>可以用一种统一的数学形式来简洁而优雅地表示这些变换（包含平移操作），为了做到这一点，需要将向量从三维扩展到四维，使用 \(4 \times 4\)矩阵来表示变换操作，给3D点P增加一个坐标，并将这个扩展的第四坐标(称为w坐标)的值设为1。</p><p>构造一个  \(4 \times 4\)变换矩阵F，F对应于变换矩阵M和3D平移变换T：</p><div>$$F =\left[\begin{matrix}M & T \\0 & 1\end{matrix}\right]=\left[\begin{matrix}M_{11} & M_{12} & M_{13} & T_{x} \\M_{21} & M_{22} & M_{23} & T_{y} \\M_{31} & M_{32} & M_{33} & T_{z} \\0 & 0 & 0 & 1\end{matrix}\right]\tag{3.24}$$</div><p>这个矩阵乘以向量 \(P=&lt;P_{x}, P_{y}, P_{z}, 1&gt;\) 就等效于公式3.22，同时结果w坐标保持为1.</p><h3 id="4-2-点向量和方向向量"><a href="#4-2-点向量和方向向量" class="headerlink" title="4.2 点向量和方向向量"></a>4.2 点向量和方向向量</h3><p>Tips：书上把点坐标叫做点向量还是蛮奇怪的，就理解成点坐标就行了。</p><p>由于方向向量不会受平移变换的影响，所以在其扩展四维时，其w坐标设置为0（其实也可以从两个点坐标相减的角度理解，两个w相减就是0了），这个时候F矩阵中只有左上的 \(3 \times 3\) 部分可以影响方向向量。</p><h3 id="4-3-坐标的几何解释"><a href="#4-3-坐标的几何解释" class="headerlink" title="4.3 坐标的几何解释"></a>4.3 坐标的几何解释</h3><p>假设有一个四维点 \(P=&lt;x, y, z, w&gt;\)，其中坐标不为0，这里定义P在三维空间的映像，<br>如果用 \(\widetilde{P}\)表示P在 \(w=1\)的三维空间中的投影，\(\widetilde{P}\)可以用下面的公式来表示：</p><div>$$\widetilde{P} = <\frac{x}{w}, \frac{y}{w}, \frac{z}{w}>\tag{3.28}$$</div><div align="center"><p><img src="/images/3dmath-c3-3.6.jpg" alt="图3.6 四维点P在三维空间的投影"></p></div><p>如图3.6所示（图中省略z轴为了方便表示），三维点 \(\widetilde{P}\) 对应于连接点P与原点的直线和 \(w=1\)的平面的交点，从这一点可以知道，对四维向量P作任意系数乘积，其结果都对应于三维空间中一个相同的点，在第4章5节中详细讨论这种投影在三维图形中的重要性。</p><h2 id="5-法向量的变换"><a href="#5-法向量的变换" class="headerlink" title="5 法向量的变换"></a>5 法向量的变换</h2><p>一个多边形模型的顶点除了需要表示空间位置外，还要包含一些附加信息，这些信息用来表示<strong>该顶点是如何融合到周围的曲面中的</strong>。一般情况下，顶点可能有<strong>切线向量</strong>和<strong>法线向量</strong>与之关联。<strong>当变换一个模型时，不但要变换顶点，同时还要对与顶点有关的向量进行变换</strong>。</p><p>可通过求两个顶点之间的差来计算<strong>切线向量</strong>，所以经过<strong>变换的切线向量</strong>可以表示为<strong>两个变换点的差</strong>。如果使用一个矩阵来变换顶点位置，也可以用这个矩阵来变换顶点的切向量。图3.7所示所示为用一个<strong>非正交矩阵M变换法向量N</strong>时发生的情况，变换后的法向量最终不垂直于变换后的表面。</p><div align="center"><p><img src="/images/3dmath-c3-3.7.jpg" alt="图3.7 用非正交矩阵M变换法向量"></p></div><p>因为切线方向和法线方向是垂直的，所以同一顶点的切向量T和法向量N必须满足等式 \(N \cdot T = 0\)，并且必须保证变换后的切向量 \(T^{‘}\)和法向量 \(N^{‘}\)仍然满足等式，设变换矩阵为M，有 \(T^{‘}=MT\)，设变换N所需的矩阵为G，有：</p><div>$$N^{'} \cdot T^{'} = (GN) \cdot (MT) = 0\tag{3.29}$$</div><p>经过简单的运算，可以得到：</p><div>$$(GN) \cdot (MT) = (GN)^{T}(MT) = N^{T}G^{T}MT\tag{3.30}$$</div><p>由于 \(N^{T}T=0\)，如果 \(G^{T}M=I\)，则等式 \(N^{T}G^{T}MT\) 肯定成立。<br>因此可以得出 \(G=(M^{-1})^{T}\)。可以看出，用变换点的矩阵的逆转置矩阵，就能正确地变换法向量，<strong>必须通过这种方式变换的向量称为协变向量</strong>，用矩阵M以通常方式变换的向量（点或切向量）称为<strong>逆变向量</strong>。</p><p><strong>如果矩阵M是正交的</strong>，那么 \(M^{-1}=M^{T}\)，因此 \((M^{-1})^{T}=M\)，所以当M是正交矩阵时，<strong>法向量变换过程的求逆转置运算就可以避免</strong>，这一点适用于本章前面提到的当M等于旋转矩阵的情况。</p><h2 id="6-四元数"><a href="#6-四元数" class="headerlink" title="6 四元数"></a>6 四元数</h2><p>四元数是三维图像编程人员用来表示旋转的另一种数学形式。</p><p>在许多情况下，用四元数代替旋转矩阵会有很多的好处，因为四元数需要的存储空间更少，四元数之间的<strong>连接运算</strong>需要的算术运算更少，在产生平滑的三维动画时，用四元数更容易进行修改。</p><h3 id="6-1-四元数数学"><a href="#6-1-四元数数学" class="headerlink" title="6.1 四元数数学"></a>6.1 四元数数学</h3><p>四元数集合，被数学家们称为哈密顿四元数环(ring of Hamiltonian quaternions)，用H表示，可以理解为四维向量空间，空间中的元素q具有以下形式：</p><div>$$q = [w, x, y, z] = w + xi + yj + zk\tag{3.31}$$</div><p>四元数经常写为 \(q=s+v\)的形式，其中s表示数量部分，对应于q中的w分量，v表示向量部分，对应于q中的x,y,z分量。</p><p>四元数集合是复数集合的自然扩展，四元数的乘法服从分配率，并且虚部i,j,k之间的乘法服从下面的规则：</p><div>$$\begin{aligned}i^{2} &= j^{2} = k^{2} = -1 \\ij &= -ji = k \\jk &= -kj = i \\ki &= -ik = j\end{aligned}\tag{3.32}$$</div><p>四元数式的乘法是不可交换的，因此运算要注意顺序。</p><p>两个四元数 \(q_{1}=w_{1}+x_{1}i+y_{1}j+z_{1}k\) 和 \(q_{2}=w_{2}+x_{2}i+y_{2}j+z_{2}k\) 的乘积 \(q_{1}q_{2}\) 为：</p><div>$$q_{1}q_{2} = \\(w_{1}w_{2} - x_{1}x_{2} - y_{1}y_{2} - z_{1}z_{2}) + \\(w_{1}x_{2} + x_{1}w_{2} + y_{1}z_{2} - z_{1}y_{1})i + \\(w_{1}y_{2} - x_{1}z_{2} + y_{1}w_{2} + z_{1}x_{2})j + \\(w_{1}z_{2} + x_{1}y_{2} - y_{1}x_{2} + z_{1}w_{2})k\tag{3.33}$$</div><p>如果写成数量-向量形式，则 \(q_{1}=s_{1}+v_{1}\) 和 \(q_{2}=s_{2}+v_{2}\) 的乘积可以写成如下形式：</p><div>$$q_{1}q_{2} = s_{1}s_{2} - v_{1} \cdot v_{2} + s_{1}v_{2} + s_{2}v_{1} + v_{1} \times v_{2}\tag{3.34}$$</div><p>和复数一样，四元数有共轭。</p><p><strong>【定义3.4】</strong> 四元数 \(q=s+v\)的共轭，记为 \(\bar{q}\)，定义为 \(\bar{q}=s-v\)。</p><p>通过简单的运算，就可以发现q与其共轭 \(\bar{q}\)的乘积等于q自身的点积，也就是等于q模的平方。</p><div>$$q \bar{q} = \bar{q} q = q \cdot q = ||q||^{2} = q^{2}\tag{3.35}$$</div><p><strong>【定理3.5】</strong> 非零的四元数的逆，记为 \(q^{-1}\)，则有：</p><div>$$q^{-1} = \frac{\bar{q}}{q^{2}}\tag{3.36}$$</div><h3 id="6-2-四元数的旋转"><a href="#6-2-四元数的旋转" class="headerlink" title="6.2 四元数的旋转"></a>6.2 四元数的旋转</h3><p>三维空间的旋转可以理解为 \(R^{3}\) 到自身 的映射函数 \(\varphi\)。由于\(\varphi\)代表旋转，所以它必须包含长度、角度、旋转方向等信息。如果有：</p><div>$$||\varphi(P)||=||P||\tag{3.39}$$</div><p>则<strong>长度保持不变</strong>。</p><p>如果对任意两个点 \(P_{1}\) 和 \(P_{2}\)有：</p><div>$$\varphi(P_{1}) \cdot \varphi(P_{2}) = P_{1} \cdot P_{2}\tag{3.40}$$</div><p>则从原点到两个点 \(P_{1}\) 和 \(P_{2}\)的连线所形成的<strong>夹角保持不变</strong>。</p><p>最后，如果：</p><div>$$\varphi(P_{1}) \times \varphi(P_{2}) = \varphi(P_{1} \times P_{2})\tag{3.41}$$</div><p>则<strong>手向性也保持</strong>不变。</p><p>如果满足条件 \(\varphi(s+v)=s+\varphi(v)\)，则函数 \(\varphi\)可以扩展为H到自身的映射，这样就允许将公式(3.40)重写为：</p><div>$$\varphi(P_{1}) \cdot \varphi(P_{2}) = \varphi(P_{1} \cdot P_{2})\tag{3.42}$$</div><p>如果将 \(P_{1}\)和 \(P_{2}\)看成是数量部分为0的四元数，根据 \(P_{1}P_{2} = -P_{1} \cdot P_{2} + P_{1} \times P_{2}\)，就可以将等式(3.41)和(3.42)合并成一个等式，在该等式中可以<strong>保持角度不变和手向性不变</strong>，公式如下：</p><div>$$\varphi(P_{1})\varphi(P_{2}) = \varphi(P_{1}P_{2})\tag{3.43}$$</div><p>满足这种等式的函数 \(\varphi\) 称为是<strong>同态</strong>的。</p><p>这一类函数可以用下面的公式给出：</p><div>$$\varphi_{q}(P) = qPq^{-1}\tag{3.44}$$</div><p>其中q是一个非0的四元数，且满足等式(3.39)（长度不变）和(3.43)（角度不变、手向性不变），因此可以表示旋转的集合。</p><p>现在需要找到一个关于四元数q的公式，q对应于 \(\theta\)角绕A轴的旋转。<br>简单的计算表明 \(\varphi_{aq}=\varphi_{q}\) 适用于任何非零数量a，为了简单起见，只涉及单位四元数。设 \(q=s+v\) 是<strong>单位四元数</strong>，则 \(q^{-1}=s-v\)，对于给定的点P，有：</p><div>$$\begin{aligned}qPq^{-1} &= (s + v)P(s - v) \\&= (-v \cdot P + sP + v \times P)(s - v) \\&= -sv \cdot P + s^{2}P + sv \times P + (v \cdot P)v - sPv - (v \times P)v \\&= s^{2}P + 2sv \times P + (v \cdot P)v - v \times P \times v\end{aligned}\tag{3.47}$$</div><p>对叉积 \(v \times P \times v\) 使用定理1.9(6)，这个等式就变为：</p><div>$$\begin{aligned}v \times (P \times v) = v \times P \times v = v^{2}P - (v \cdot P) v \\qP^{-1}q = (s^{2}-v^{2})P + 2sv \times P + 2(v \cdot P)v\end{aligned}\tag{3.48}$$</div><p>设 \(v=tA\)，其中A为单位向量，则上式可改写为：</p><div>$$qP^{-1}q = (s^{2}-v^{2})P + 2stA \times P + 2t^{2}(A \cdot P)A\tag{3.49}$$</div><p>比较等式(3.19)给出的绕任意轴旋转的公式，可以推出下面的等式：</p><div>$$P^{'} = [P - (P \cdot A)A]cos\theta + (A \times P)sin\theta + (P \cdot A)A \\= Pcos\theta + (A \times P)sin\theta + (P \cdot A)A(1 - cos\theta)\tag{3.19}$$</div><div>$$\begin{aligned}s^{2} - t^{2} &= cos\theta \\2st &= sin\theta \\2t^{2} &= 1 - cos\theta\end{aligned}\tag{3.50}$$</div><p>由第三个等式可以得出：</p><div>$$t = \sqrt{\frac{1-cos\theta}{2}} = sin\frac{\theta}{2}\tag{3.51}$$</div><p>结合式(3.50)中第一和第三个等式，可以得出 \(s^{2}+t^{2}=1\)，因此可以肯定 \(s=cos\frac{\theta}{2}\)。</p><p>现在可以用下面的等式给出对应于 \(\theta\)角绕A轴旋转的单位四元数q为：</p><div>$$q = cos\frac{\theta}{2} + Asin\frac{\theta}{2}\tag{3.52}$$</div><p>这里应注意：四元数q的<strong>任意数量乘积</strong>(特别是-q)表示的是相同的旋转，这是因为之前说的\(\varphi_{aq}=\varphi_{q}\) 适用于任何非零数量a。</p><div>$$(aq)P(aq)^{-1} = aqP \frac{q^{-1}}{a} = qP^{-1}q\tag{3.53}$$</div><p>两个四元数的乘积也可以表示一个旋转，乘积 \(q_{1}q_{2}\) 表示<strong>先以</strong> \(q_{2}\)，<strong>后以</strong> \(q_{1}\)进行旋转：</p><div>$$q_{1}(q_{2}Pq_{2}^{-1})q_{1}^{-1} = (q_{1}q_{2})P(q_{1}q_{2})^{-1}\tag{3.54}$$</div><p>可以将任意多的四元数结合起来，形成表示一系列旋转的一个四元数，<br>将两个四元数相乘需要做16次乘法和加法运算，而两个 \(3 \times 3\) 矩阵相乘需要27次这样的操作，因此当对物体进行多次旋转时，应用四元数可以获得较高的计算效率。</p><p>经常需要将一个四元数变成等价的 \(3 \times 3\)旋转矩阵的形式。<br>利用等式(1.25)和(1.20)，可以确定对应于四元数 \(q = s + tA\)的矩阵公式。</p><div>$$P \times Q =\left[\begin{matrix}0 & -P_{z} & P_{y} \\P_{z} & 0 & -P_{x} \\-P_{y} & P_{x} & 0\end{matrix}\right]\left[\begin{matrix}Q_{x} \\Q_{y} \\Q_{z}\end{matrix}\right]\tag{1.25}$$</div><div>$$proj_{Q} P = \frac{1}{Q^{2}}\left[\begin{matrix}Q_{x}^{2} & Q_{x}Q_{y} & Q_{x}Q_{z} \\Q_{x}Q_{y} & Q_{y}^{2} & Q_{y}Q_{z} \\Q_{x}Q_{z} & Q_{y}Q_{z} & Q_{z}^{2}\end{matrix}\right]\left[\begin{matrix}P_{x} \\P_{y} \\P_{z}\end{matrix}\right]\tag{1.20}$$</div><p>然后将等式(3.49)改写成矩阵形式(和3.1节中用的技巧类似），由此可得：</p><div>$$qPq_{-1} =\left[\begin{matrix}s^{2}-t^{2} & 0 & 0 \\0 & s^{2}-t^{2} & 0 \\0 & 0 & s^{2}-t^{2}\end{matrix}\right]P + \\2st\left[\begin{matrix}0 & -A_{z} & A_{y} \\A_{z} & 0 & -A_{x} \\-A_{y} & A_{x} & 0\end{matrix}\right]P + \\2t^{2}\left[\begin{matrix}A_{x}^{2} & A_{x}A_{y} & A_{x}A_{z} \\A_{x}A_{y} & A_{y}^{2} & A_{y}A_{z} \\A_{x}A_{z} & A_{y}A_{z} & A_{z}^{2}\end{matrix}\right]P\tag{3.55}$$</div><p>将四元数p写成四维向量 \(q=&lt;w,x,y,z&gt;\)，那么 \(w=s, x=tA_{x}, y=tA_{y}, z=tA_{z}\)，因此A是单位向量，所以 \(x^{2}+y^{2}+z^{2} = t^{2}A^{2} = t^{2}\)，以 \(w,x,y,z\)为分量，则公式(3.55)可以改写为：</p><div>$$qPq_{-1} =\left[\begin{matrix}w^{2}-x^{2}-y^{2}-z^{2} & 0 & 0 \\0 & w^{2}-x^{2}-y^{2}-z^{2} & 0 \\0 & 0 & w^{2}-x^{2}-y^{2}-z^{2}\end{matrix}\right]P + \\2w\left[\begin{matrix}0 & -z & y \\z & 0 & -x \\-y & x & 0\end{matrix}\right]P + \\2\left[\begin{matrix}x^{2} & xy & xz \\xy & y^{2} & yz \\xz & yz & z^{2}\end{matrix}\right]P\tag{3.56}$$</div><p>因为q是单位四元数，满足 \(w^{2} + x^{2} + y^{2} + z^{2} = 1\)，所以有：</p><div>$$w^{2} - x^{2} - y^{2} - z^{2} = 1 - 2x^{2} - 2y^{2} - 2z^{2}\tag{3.57}$$</div><p>根据该等式，并结合前面的三个矩阵，可以得到用来计算矩阵 \(R_{q}\) 的公式，这里的 \(R_{q}\) 表示对应于四元数q的旋转矩阵，公式为：</p><div>$$R_{q} = \left[\begin{matrix}1-2y^{2}-2z^{2} & 2xy-2wz & 2xz+2wy \\2xy+2wz & 1-2x^{2}-2z^{2} & 2yz-2wx \\2xz-2wy & 2yz+2wx & 1-2x^{2}-2y^{2}\end{matrix}\right]\tag{3.58}$$</div><h3 id="6-3-球形线性插值"><a href="#6-3-球形线性插值" class="headerlink" title="6.3 球形线性插值"></a>6.3 球形线性插值</h3><p>因为四元数是用向量表示的，所以很适合于插值运算。<br>在产生一个物理动画的过程中，在产生位于两个预先计算的关键帧之间的中间过渡定位时，插值非常有用。</p><p>最简单的插值类型是<strong>线性插值</strong>，对于两个四元数 \(q_{1}\)和 \(q_{2}\)，线性插值后所得的四元数 \(q_{t}\)为：</p><div>$$q(t) = (1-t)q_{1} + tq_{2} \tag{3.59}$$</div><p>当t在0和1之间变化时，函数 \(q(t)\)在连接 \(q_{1}\)和 \(q_{2}\)的线段上平滑变化。</p><div align="center"><p><img src="/images/3d-math-c3-6-3.jpg" alt="四元数的线性插值"></p></div><p>如上图所示，\(q(t)\)并不保持 \(q_{1}\)和 \(q_{2}\)的单位长度，但可以使用下面的函数在任意点位置对 \(q(t)\)进行重新规格化：</p><div>$$q(t)=\frac{(1-t)q_{1} + tq_{2}}{||(1-t)q_{1} + tq_{2}||}\tag{3.60}$$</div><p>尽管线性插值是很有效的，但由等式(3.60)得出的函数 \(q(t)\)并没有以恒定的速率描绘 \(q_{1}\)和 \(q_{2}\)间的过渡弧线，这是线性插值的弊端。如下图所示，\(q_{1},q_{2}\)之间的角度变化速率在端点时相对较慢，在中间的地方最快。</p><div align="center"><p><img src="/images/3d-math-c3-6-4.jpg" alt="arccos(q(t)·q1)的曲线"></p></div><p>我们希望找到一个函数 \(q(t)\)，用它对四元数 \(q_{1}\)和 \(q_{2}\)进行插值时，<br>会保持其单位长度不变并且以恒定的速率扫过位于 \(q_{1}\)和 \(q_{2}\)之间的夹角。</p><p>如果 \(q_{1}\)和 \(q_{2}\)的夹角为 \(\theta\)，那么这个函数将会产生一个四元数，该四元数在 \(q(t)\)和 \(q_{1}\)之间形成一个夹角 \(\theta t\)，这里t在0在1之间取值。</p><p>如下图所示，四元数 \(q(t)\)位于连接 \(q_{1}\)和 \(q_{2}\)的弧上，与 \(q_{1}\)构成夹角 \(\theta t\)，与 \(q_{2}\)构成夹角 \(\theta(1-t)\)，可以将 \(q(t)\)写成：</p><div>$$q(t) = a(t)q_{1} + b(t)q_{2} \tag{3.61}$$</div><div align="center"><p><img src="/images/3d-math-c3-6-5.jpg" alt="图(a)和图(b) 用相似三角形得到分量长度"></p></div><p>如图(a)所示，可以构造相似三角形来确定长度 \(a(t)\)，\(q_{1}\)到以原点和 \(q_{2}\)为端点的线段的垂直距离为 \(||q_{1}||sin\theta\)，而 \(q(t)\)到该线段的垂直距离为 \(||q(t)||sin(\theta(1-t))\)，根据相似三角形，可以由：</p><p>Tips：书上说的这个相似三角形在图(a)中并不明显，是以角 \(\theta\)为共同角，将边 \(||q(t)||sin(\theta(1-t))\) 平移到左边，构成的一个小三角形。</p><div>$$\frac{a(t)}{||q(t)||sin(\theta(1-t))} =\frac{||q_{1}||}{||q||sin\theta}$$</div><p>所以有：</p><div>$$\frac{a(t)}{||q_{1}||} =\frac{||q(t)||sin(\theta(1-t))}{||q||sin\theta}\tag{3.62}$$</div><p>由于 \(||q_{1}||=1\)，\(||q(t)||=1\)，可以将上式简化为：</p><div>$$a(t) = \frac{sin(\theta(1-t))}{sin\theta}\tag{3.63}$$</div><p>图(b)表示了求长度 \(b(t)\)的相同过程，有结果：</p><div>$$b(t) = \frac{sin(\theta t)}{sin\theta}\tag{3.64}$$</div><p>可以将球型线性插值函数 \(q(t)\)定义如下：</p><div>$$q(t)= \frac{sin(\theta(1-t))}{sin\theta}q_{1} + \frac{sin(\theta t)}{sin\theta}q_{2}\tag{3.65}$$</div><p>这里的角 \(\theta\) 为：</p><div>$$\theta = arccos(q_{1} \cdot q_{2})\tag{3.66}$$</div><p>\(sin\theta\)计算：</p><div>$$sin\theta = \sqrt{1-(q_{1} \cdot q_{2})^{2}}\tag{3.67}$$</div><p>因为四元数 \(q\) 和\(-q\)表示<strong>相同的旋转</strong>，所以选择四元数 \(q_{1}\)和 \(q_{2}\)的正负号时一般要满足 \(q_{1} \cdot q_{2} \geq 0\)，这样可以保证以最短路径的方式进行插值。</p>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;3D游戏开发过程中，通常需要以某种方式对向量进行变换。&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="3D游戏与图形学的数学" scheme="https://yumi-cn.github.io/categories/3D%E6%B8%B8%E6%88%8F%E4%B8%8E%E5%9B%BE%E5%BD%A2%E5%AD%A6%E7%9A%84%E6%95%B0%E5%AD%A6/"/>
    
    
    <category term="笔记" scheme="https://yumi-cn.github.io/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>《实时渲染 4th》第1章笔记 导论</title>
    <link href="https://yumi-cn.github.io/2020/12/09/rtr-c1/"/>
    <id>https://yumi-cn.github.io/2020/12/09/rtr-c1/</id>
    <published>2020-12-09T11:12:14.000Z</published>
    <updated>2020-12-09T14:01:50.228Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>实时渲染一般指计算机里的快速图像生成。</p></blockquote><a id="more"></a><p>PS：原书《Real Time Rendering 4th》全英文，有些词翻译如果不够好还请见谅。</p><p>Tips：屏幕刷新率(refresh rate)和显示频率(display rate)在现在是有区别的；</p><blockquote><p>We will not be able to cover every topic in depth, so our goal is to present key concepts and terminology, explain the most robust and practical algorithms in the field, and provide pointers to the best places to go for more information.</p></blockquote><p>虽然这本书没有覆盖到实时渲染涉及到的每一个主题，但本书的目的是呈现关键概念和术语、解释最鲁邦和实用的算法、提供深入了解这些内容的方向指引。</p><h2 id="1-内容概览"><a href="#1-内容概览" class="headerlink" title="1 内容概览"></a>1 内容概览</h2><ul><li><strong>第2章 图形渲染管线</strong>：<code>The Graphics Rendering Pipeline</code>，实时渲染的核心是通过什么样的步骤来将场景传达到显示上；</li><li><strong>第3章 图形处理单元</strong>：<code>The Graphics Processing Unit</code>，现代GPU中一般通过一组计算单元(fixed-function and programmable units)来实现渲染管线；</li><li><strong>第4章 变换</strong>：<code>Transforms</code>，变换是操作物体位置、方向、大小以及形状、控制摄像机位置和视角的基本工具；</li><li><strong>第5章 着色基础</strong>：<code>Shading Basics</code>，着色一般指的是通过材质(Material)和光源(Light)来表现物体，还有一些相关的主题，例如抗锯齿（反走样 antialiasing）、透明处理以及Gamma矫正；</li><li><strong>第6章 纹理</strong>：<code>Texturing</code>，纹理贴图用于在物体表面呈现纹理；</li><li><strong>第7章 光影</strong>：<code>Shadows</code>，光影让场景更有真实情感，会介绍一些快速计算光影的流行算法；</li><li><strong>第8章 光和颜色</strong>：<code>Light and Color</code>，讲解计算机是如何如何量化光和颜色，以及把这些量化转换成显示量纲的方法；</li><li><strong>第9章 基于物理的着色</strong>：<code>Physically Based Shading</code>，基于物理的着色会更加接近真实；</li><li><strong>第10章 局部光照</strong>：<code>Local Illumination</code>，主要介绍一些渲染复杂光源的算法，例如光源本身具有物理形状；</li><li><strong>第11章 全局光照</strong>：<code>Global Illumination</code>，模拟光源和场景之间的交互的算法，进一步增加场景的真实度；</li><li><strong>第12章 图像效果</strong>：<code>Image-Space Effects</code>，GPU擅长快速处理图像，首先介绍图像滤波(image filtering)和重投影(reprojection)技术，然后介绍一些流行的后期效果，例如镜头光晕(lens flares)、动态模糊(motion blur)以及景深(depth of field)；</li><li><strong>第13章 几何之外</strong>：<code>Beyond Polygons</code>，三角形不一定总是最快或最真实地描述物体的方式，还有其他方式，例如图片(images)、点云(point clouds)、体素(voxels)等；</li><li><strong>第14章 体渲染和透光渲染</strong>：<code>Volumetric and Translucency Rendering</code>，介绍体积材质(volumetric material)（例如云、烟、雾）的表达方式以及和光的交互，大到气象效果，小到头发渲染；</li><li><strong>第15章 非真实渲染</strong>：<code>Non-Photorealistic Rendering</code>，主要介绍一些风格渲染，例如卡通渲染(cartoon shading)、水彩效果(watercolor<br>effects)；</li><li><strong>第16章 几何技术</strong>：<code>Polygonal Techniques</code>，几何体数据的来源各种各样，如果需要又快又好地渲染，就需要进行一定处理，涉及到几何数据表达和压缩方法；</li><li><strong>第17章 曲线和曲面</strong>：<code>Curves and Curved Surfaces</code>，复杂的表面表达提供的优势在于更好的在质量和速度中进行取舍，表达越简洁，曲面就越光滑；</li><li><strong>第18章 管线优化</strong>：<code>Pipeline Optimization</code>，寻找渲染瓶颈来优化速度，涉及到一些多线程技术；</li><li><strong>第19章 加速算法</strong>：<code>Acceleration Algorithms</code>，比快更快，Various<br>forms of culling and level of detail rendering are covered；</li><li><strong>第20章 高效着色</strong>：<code>Efficient Shading</code>，越多的光源，渲染就越慢，在渲染前无法知道是否需要渲染会造成资源浪费，使用一些方法可以解决这些问题；</li><li><strong>第21章 虚拟现实和增强现实</strong>：<code>Virtual and Augmented Reality</code>，这些领域有很多特定的技术难题，也有一些相应方法来高效快速的生成图像；</li><li><strong>第22章 相交检测</strong>：<code>Intersection Test Methods</code>，深入介绍一些几何相交检测的高效算法；</li><li><strong>第23章 图形硬件</strong>：<code>Graphics Hardware</code>，图形硬件的一些细节，例如色彩深度(color depth)、帧缓冲(framebuffers)和基础架构类型；</li><li><strong>第24章 面向未来</strong>：<code>The Future</code>，Take a guess (we do)。</li></ul><p>还有一些没有收录在实体书中，在<a href="http://www.realtimerendering.com/">realtimerendering.com</a>上更新的章节：</p><ul><li><strong>碰撞检测</strong>：<code>Collision Detection</code>，The 3rd edition’s chapter on this subject has been fully updated, but could not fit in the bounds of the physical book；</li><li><strong>实时光线追踪</strong>：<code>Real-Time Ray Tracing</code>，API support for this area was announced in March 2018, too late for inclusion in the book, so we wrote an additional chapter about the subject as a whole.</li><li><strong>附录</strong>：<code>Appendices</code>，The two appendices, Some Linear Algebra and Trigonometry, also had to be cut from the physical book.</li></ul><h2 id="2-标记和定义"><a href="#2-标记和定义" class="headerlink" title="2 标记和定义"></a>2 标记和定义</h2><h3 id="2-1-数学标记"><a href="#2-1-数学标记" class="headerlink" title="2.1 数学标记"></a>2.1 数学标记</h3><div align="center"><p><img src="/images/rtr-c1-t1.1.jpg" alt="表1.1 本书中的大部分标记"></p></div><p><strong>向量或者点</strong>通常用粗体小写字母表示，并且其内部组成一般写为：</p><div>$$\textbf{v} =\left(\begin{matrix}v_{x} \\v_{y} \\v_{z}\end{matrix}\right)$$</div><p>在图形学领域中一般用列向量的表达方式，有时候为了书面方便也会写成行向量。</p><p>书中使用到<strong>矩阵</strong>大多是 \(2 \times 2\)，\(3 \times 3\) 和\(4 \times 4\)，以\(3 \times 3\)矩阵为例，说明矩阵的表示方式：</p><div>$$\textbf{M} =\left(\begin{matrix}m_{00} & m_{01} & m_{02} \\m_{10} & m_{11} & m_{12} \\m_{20} & m_{21} & m_{22}\end{matrix}\right)\tag{1.1}$$</div><p>有时候为了表达需求，会只关注行向量或者列向量的内容，矩阵也可以写为：</p><div>$$\textbf{M} =\left(\begin{matrix}\textbf{m}_{,0} & \textbf{m}_{,1} & \textbf{m}_{,2}\end{matrix}\right)=\left(\begin{matrix}\textbf{m}_{0,}^{T} \\\textbf{m}_{1,}^{T} \\\textbf{m}_{2,}^{T}\end{matrix}\right)\tag{1.2}$$</div><p>其中 \(\textbf{m}_{,j}\) 代表第j列向量，\(\textbf{m}_{i,}\) 代表第i行向量。</p><p><strong>平面</strong>的数学表示是 \(\pi:\textbf{n}\cdot\textbf{x} + d = 0\)，其中 \(\textbf{n}\)是平面的法向量，\(d\)是标量，平面将空间分为两个子空间，正子空间是 \(\textbf{n}\cdot\textbf{x} + d &gt; 0\)，相应的负子空间是 \(\textbf{n}\cdot\textbf{x} + d &lt; 0\)</p><p>三角形通常用三个点来表示，例如有不共线的三点 \(\textbf{v}_{0}, \textbf{v}_{1}, \textbf{v}_{2}\)，构成的三角形是 \(\bigtriangleup\textbf{v}_{0}\textbf{v}_{1}\textbf{v}_{2}\)。</p><div align="center"><p><img src="/images/rtr-c1-t1.2.jpg" alt="表1.2 数学运算的标记"></p></div><p>大部分都应该是比较常见的，需要稍微特殊说明的几个：</p><ol start="4"><li>主要用于二维向量，求二维向量的垂直向量，例如有 \(\textbf{v}=(v_{x}, v_{y})\)，\(\textbf{v}^{\perp}=(-v_{y}, v_{x})\)；</li><li>将x映射为非负空间数，当其为负值时会变为0；</li><li>和8较为类似，映射到0-1空间中，大于1变为1，小于0变为0；</li><li><code>binomial coefficients</code>，二项式系数，\(\left(\begin{matrix}n \\ k\end{matrix}\right) = \frac{n!}{k!(n-k)!}\)。</li></ol><p>一般把 \(x=0, y=0, z=0\) 叫做 坐标平面(coordinate<br>planes)或者轴对齐平面(axis-aligned planes)，将轴 \(\textbf{e}_{x}=(1, 0, 0), \textbf{e}_{y}=(0, 1, 0), \textbf{e}_{z}=(0, 0, 1)\)叫做主轴(main axes)或者主方向(main directions)，也分别叫做x轴(x-axis)，y轴(y-axis)和z轴(z-axis)。</p><div align="center"><p><img src="/images/rtr-c1-t1.3.jpg" alt="表1.3 其他需要说明的数学函数"></p></div><p>C语言数学函数 <code>atan2(y,x)</code> 有时候被经常提及到，它是<code>arctan(x)</code>的一个拓展，主要区别在于 \(-\frac{\pi}{2} &lt; arctan(x) &lt; \frac{\pi}{2}\)，\(0 \lep atan2(y, x) &lt; 2\pi\)，一种常用操作是计算<code>arctan(y/x)</code>，但是当<code>x=0</code>时会出现除0问题（尽管可能本意是表达一个无穷大数，但C语言会报除0错误），而这时候使用<code>atan2(y,x)</code>可以避免这样的问题。</p><p><code>log(n)</code>函数一般指的是自然数<code>e</code>为底数，而不是以<code>10</code>为底数。</p><p>默认情况下均使用右手坐标系。</p><p>颜色一般用一个三元向量表示，<code>(red, green, blue)</code>，各项的值都在[0,1]。</p><h3 id="2-2-几何定义"><a href="#2-2-几何定义" class="headerlink" title="2.2 几何定义"></a>2.2 几何定义</h3><p>最原石的一些基础渲染元(basic rendering primitives, also called drawing primitives)，最常用的是点、线和三角形。</p><p>在本书中，一组几何体(a collection of geometric entities)通常叫做一个<strong>模型</strong>(model)或者<strong>对象</strong>(object)；<strong>场景</strong>(scene)指的是环境中一组需要渲染模型，场景一般也包括材质描述、光线以及视角定义。</p><p>也有些不是使用点、线和三角形这种基础渲染元表达的模型，例如点云、函数表达（贝塞尔曲线）。</p><h3 id="2-3-Shading和Shader？"><a href="#2-3-Shading和Shader？" class="headerlink" title="2.3 Shading和Shader？"></a>2.3 Shading和Shader？</h3><p>本书中的 <strong>Shading</strong> 和 <strong>Shader</strong> 是两个截然不同但是又有关联的概念：</p><ul><li>前者指的是计算机生成的视觉表达(computer-generated visual appearance)，例如shading model、shading equation以及toon shading这些概念原理；</li><li>后者指的是渲染系统中的一个可编程单元，例如vertex shader、shading language。</li></ul><p>尽管他们用词形式上有一些混淆，但是要通过语境上下文来判断其指的是哪个概念（在书本以外可能会单独开一页来讲一些概念的区分）。</p>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;实时渲染一般指计算机里的快速图像生成。&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="Real Time Rendering 4th" scheme="https://yumi-cn.github.io/categories/Real-Time-Rendering-4th/"/>
    
    
    <category term="笔记" scheme="https://yumi-cn.github.io/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>《剑指Offer》第2章笔记 树</title>
    <link href="https://yumi-cn.github.io/2020/12/07/s2o-c2-tree/"/>
    <id>https://yumi-cn.github.io/2020/12/07/s2o-c2-tree/</id>
    <published>2020-12-07T12:18:45.000Z</published>
    <updated>2020-12-07T12:17:45.992Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>树的操作会涉及大量指针，因此与树相关的面试题都不太容易。</p></blockquote><a id="more"></a><p>树的逻辑很简单：</p><ul><li>除根节点之外，每个节点只有一个父节点，根节点没有父节点；</li><li>除叶节点之外，每个节点都有一个或多个子节点，叶节点没有子节点；</li><li>父节点和子节点之间用指针链接。</li></ul><p>面试中大部分都是<strong>二叉树</strong>，在二叉树中每个节点最多只能有两个子节点。</p><p>二叉树中最重要的操作是如何遍历数结构，按照某种顺序访问树的所有节点，通常有几种遍历方式：</p><ul><li>前序：父-&gt;左子-&gt;右子；</li><li>中序：左子-&gt;父-&gt;右子；</li><li>后序：左子-&gt;右子-&gt;父；</li><li>层序：从根节点层到叶节点层，按层输出，每一层按照从左到右输出。</li></ul><p>二叉树中又有一些特例：</p><ul><li><strong>二叉搜索树</strong>：在二叉搜索树中，左子节点总是小于或等于父节点，右子节点总是大于或等于父节点，可以平均在<code>O(logn)</code>的时间内根据值在二叉树中查找节点；</li><li><strong>堆</strong>：堆分为最大堆和最小堆，在最大堆中，根节点的值最大，最小堆中的根节点值最小（其他节点按子树递推），有很多需要快速找到最大值或最小值的问题都可以用堆来解决；</li><li><strong>红黑树</strong>：把树中的节点定义为红、黑两种颜色，并通过规则确保<strong>从根节点到叶节点的最长路径</strong>的长度<strong>不超过</strong>最短路径的两倍；在C++的STL中，<code>set</code>、<code>multiset</code>、<code>map</code>、<code>multimap</code>等都是基于红黑树实现的。</li></ul><blockquote><p>面试题7：重建二叉树</p></blockquote><p>输入二叉树的前序和中序遍历结果，重建该二叉树，假设输入的前序中序结构中都不含有重复的数字。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 二叉树节点定义</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">  <span class="keyword">int</span> value;</span><br><span class="line">  Node* left;</span><br><span class="line">  Node* right;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><div align="center"><p><img src="/images/s2o-c2-tree-cv-7.jpg"></p></div><p>在前序遍历中，第一个数字总是树的根节点；但在中序遍历中，根节点的值在序列中间，左子树的值位于根节点左边，右子树的值位于根节点右边；所以<strong>对于一个子树</strong>，我们在<strong>前序中寻找其根节点</strong>（第一个出现的值），然后在<strong>中序中根据根节点的位置</strong>，把<strong>剩下的点</strong>分为<strong>左子树和右子树</strong>。</p><p>完整代码实现：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;exception&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> value;</span><br><span class="line">    Node* left;</span><br><span class="line">    Node* right;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Node* construct_core</span><br><span class="line">(</span><br><span class="line">    <span class="keyword">int</span>* po_start, <span class="keyword">int</span>* po_end,</span><br><span class="line">    <span class="keyword">int</span>* io_start, <span class="keyword">int</span>* io_end</span><br><span class="line">) &#123;</span><br><span class="line">    <span class="keyword">int</span> root_value = po_start[<span class="number">0</span>];</span><br><span class="line">    Node* root = <span class="keyword">new</span> Node();</span><br><span class="line">    root-&gt;value = root_value;</span><br><span class="line">    root-&gt;left = root-&gt;right = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">if</span>(po_start == po_end) &#123;</span><br><span class="line">        <span class="keyword">if</span>(io_start == io_end &amp;&amp; *po_start == *io_start) &#123;</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// Windows Ver Error</span></span><br><span class="line">            <span class="built_in">std</span>::logic_error ex(<span class="string">&quot;Invalid input&quot;</span>);</span><br><span class="line">            <span class="keyword">throw</span> <span class="built_in">std</span>::exception(ex);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span>* io_root = io_start;</span><br><span class="line">    <span class="keyword">while</span>(io_root &lt;= io_end &amp;&amp; *io_root != root_value) &#123;</span><br><span class="line">        io_root++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(io_root == io_end &amp;&amp; *io_root != root_value) &#123;</span><br><span class="line">        <span class="comment">// Windows Ver Error</span></span><br><span class="line">        <span class="function"><span class="built_in">std</span>::logic_error <span class="title">ex</span><span class="params">(<span class="string">&quot;Invalid input&quot;</span>)</span></span>;</span><br><span class="line">        <span class="keyword">throw</span> <span class="built_in">std</span>::exception(ex);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> left_len = io_root - io_start;</span><br><span class="line">    <span class="keyword">int</span>* left_po_end = po_start + left_len;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(left_len &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        root-&gt;left = construct_core(po_start+<span class="number">1</span>, left_po_end, io_start, io_root<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(left_len &lt; po_end - po_start) &#123;</span><br><span class="line">        root-&gt;right = construct_core(left_po_end + <span class="number">1</span>, po_end, io_root+<span class="number">1</span>, io_end);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Node* <span class="title">construct</span><span class="params">(<span class="keyword">int</span>* preodr, <span class="keyword">int</span>* inodr, <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(preodr == <span class="literal">nullptr</span> || inodr == <span class="literal">nullptr</span> || len &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> construct_core(preodr, preodr + len - <span class="number">1</span>,</span><br><span class="line">            inodr, inodr + len - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">post_order_print</span><span class="params">(Node* node)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(node != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        post_order_print(node-&gt;left);</span><br><span class="line">        post_order_print(node-&gt;right);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, node-&gt;value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> preodr[<span class="number">8</span>] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">7</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">8</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> inodr[<span class="number">8</span>] = &#123;<span class="number">4</span>, <span class="number">7</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">3</span>, <span class="number">8</span>, <span class="number">6</span>&#125;;</span><br><span class="line">    Node* root = construct(preodr, inodr, <span class="number">8</span>);</span><br><span class="line">    post_order_print(root); <span class="comment">// 7 4 2 5 8 6 3 1</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>面试题8：二叉树的下一个节点</p></blockquote><p>给定二叉树和其中的一个节点，如何<strong>找出中序遍历序列的下一个节点</strong>？树节点除了有左右子节点指针，还有一个指向父节点的指针。</p><p>这类题目一般从各类情况具体分析入手：</p><ul><li>如果<strong>节点有右子树</strong>，则下一个节点就是<strong>右子树中的最左子节点</strong>；</li><li>如果<strong>节点没有右子树</strong>：<ul><li>如果该节点是<strong>父节点的左子节点</strong>，<strong>父节点</strong>就是下一个节点；</li><li>并且该节点是<strong>父节点的右子节点</strong>，按照中序遍历的逻辑，需要继续往上寻找，<strong>直到找到某一个节点A，这个节点A是A父节点的左子节点</strong>，如果不存在这样的节点，那就代表原节点为最后一个遍历节点了，没有下一个节点。</li></ul></li></ul><p>面试中遇到这种题，大概率只需要编写指定功能的函数部分，不需要编写完整的代码，所以需要对面试官询问具体的输入输出情况。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> value;</span><br><span class="line">    Node* left;</span><br><span class="line">    Node* right;</span><br><span class="line">    Node* parent;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">Node* <span class="title">find_next</span><span class="params">(Node* node)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(node == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Node* next = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">if</span>(node-&gt;right != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="comment">// 右子树的最左子节点（不一定需要是叶节点）</span></span><br><span class="line">        Node* temp = node-&gt;right;</span><br><span class="line">        <span class="keyword">while</span>(temp-&gt;left != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            temp = temp-&gt;left;</span><br><span class="line">        &#125;</span><br><span class="line">        next = temp;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (node-&gt;parent != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="comment">// 寻找满足条件的祖先节点</span></span><br><span class="line">        <span class="comment">// 某个节点是其父节点的左子节点</span></span><br><span class="line">        Node* temp = node;</span><br><span class="line">        Node* parent = node-&gt;parent;</span><br><span class="line">        <span class="keyword">while</span>(parent != <span class="literal">nullptr</span> &amp;&amp; temp == parent-&gt;right) &#123;</span><br><span class="line">            temp = parent;</span><br><span class="line">            parent = parent-&gt;parent;</span><br><span class="line">        &#125;</span><br><span class="line">        next = parent;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;树的操作会涉及大量指针，因此与树相关的面试题都不太容易。&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="剑指Offer" scheme="https://yumi-cn.github.io/categories/%E5%89%91%E6%8C%87Offer/"/>
    
    
    <category term="笔记" scheme="https://yumi-cn.github.io/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>《剑指Offer》第2章笔记 栈和队列</title>
    <link href="https://yumi-cn.github.io/2020/12/07/s2o-c2-stk-queue/"/>
    <id>https://yumi-cn.github.io/2020/12/07/s2o-c2-stk-queue/</id>
    <published>2020-12-07T12:17:27.000Z</published>
    <updated>2020-12-07T14:14:52.856Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>栈：先进后出，队列：先进先出。</p></blockquote><a id="more"></a><p>栈是一个非常常见的数据结构，在计算机领域被广泛应用，比如操作系统会给每个线程创建一个栈用来存储函数调用时各个函数的参数、返回地址以及临时变量等。栈的特点是<strong>后进先出</strong>。</p><p>在栈中通常需要<code>O(n)</code>时间才能找到栈最大或者最小的元素，如果想<code>O(1)</code>时间内找到则需要做特殊的设计。</p><p>队列是另一种很重要的数据结构，队列的特点是<strong>先进先出</strong>。</p><blockquote><p>面试题9：用两个栈实现队列</p></blockquote><p>使用栈实现队列的两个函数<code>appendTail</code>和<code>deleteHead</code>，分别完成在队列尾部插入节点和在队列头部删除节点的功能。</p><p>一个典型的队列定义：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="class"><span class="keyword">class</span> <span class="title">CQueue</span> &#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        CQueue(<span class="keyword">void</span>);</span><br><span class="line">        ~CQueue(<span class="keyword">void</span>);</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">appendTail</span><span class="params">(<span class="keyword">const</span> T&amp; node)</span></span>;</span><br><span class="line">        <span class="function">T <span class="title">deleteHead</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="built_in">stack</span>&lt;T&gt; stack1;</span><br><span class="line">        <span class="built_in">stack</span>&lt;T&gt; stack2;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>至于这道题的解法，基于一个简单的原理，将一组数先进行依次进栈、再依次出栈入栈到另一个栈里，再全部进行出栈，就完成了一个简单的队列先进先出。但如果只是单纯的依赖这样的过程，无法极大程度地利用栈的空间（例如用于出栈<code>deleteHead</code>的栈满时，用于进栈<code>appendTail</code>其实还可以继续利用起来）。</p><p>定义stack1为入队栈，stack2为出队栈。</p><ul><li>入队操作：<ul><li>当stack1不满时，直接入栈；</li><li>当stack1满时：<ul><li>如果stack2为空，将stack1中的元素依次出栈入栈stack2；</li><li>如果stack2中有元素，则无法入队；</li></ul></li></ul></li><li>出队操作：<ul><li>当stack2中有元素是，直接出栈；</li><li>当stack2为空时：<ul><li>如果stack1不为空，将stack1所有元素依次出栈入栈stack2，再出栈栈顶元素；</li><li>如果stack1为空，则队列为空，无法出队；</li></ul></li></ul></li></ul><p>完整实现代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;exception&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="class"><span class="keyword">class</span> <span class="title">CQueue</span> &#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="comment">// CQueue(void);</span></span><br><span class="line">        <span class="comment">// ~CQueue(void);</span></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">appendTail</span><span class="params">(<span class="keyword">const</span> T&amp; node)</span></span>;</span><br><span class="line">        <span class="function">T <span class="title">deleteHead</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">stack</span>&lt;T&gt; stack1;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">stack</span>&lt;T&gt; stack2;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="keyword">void</span> CQueue&lt;T&gt;::appendTail(<span class="keyword">const</span> T&amp; element) &#123;</span><br><span class="line">    <span class="comment">// 不限制栈容量时，直接入栈</span></span><br><span class="line">    stack1.push(element);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; T CQueue&lt;T&gt;::deleteHead() &#123;</span><br><span class="line">    <span class="keyword">if</span>(stack2.size() &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">while</span>(stack1.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            T&amp; data = stack1.top(); <span class="comment">// Why use T&amp;</span></span><br><span class="line">            stack1.pop();</span><br><span class="line">            stack2.push(data);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(stack2.size() == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// Throw Empty Error</span></span><br><span class="line">        <span class="function"><span class="built_in">std</span>::logic_error <span class="title">ex</span><span class="params">(<span class="string">&quot;queue is empty&quot;</span>)</span></span>;</span><br><span class="line">        <span class="keyword">throw</span> <span class="built_in">std</span>::exception(ex);</span><br><span class="line">    &#125;</span><br><span class="line">    T head = stack2.top();</span><br><span class="line">    stack2.pop();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    CQueue&lt;<span class="keyword">int</span>&gt; cqueue;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">        cqueue.appendTail(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; cqueue.deleteHead() &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">5</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">        cqueue.appendTail(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">7</span>; i++) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; cqueue.deleteHead() &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>相关题目：用两个队列实现一个栈。</p><p>简单分析一下思路，模仿入栈操作时，只能用使用入队操作，当需要出栈时，元素在队列尾部，只能将前面所有元素进行出队才能获取到，而出队剩下的元素就继续进入到第二个队列中。</p>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;栈：先进后出，队列：先进先出。&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="剑指Offer" scheme="https://yumi-cn.github.io/categories/%E5%89%91%E6%8C%87Offer/"/>
    
    
    <category term="笔记" scheme="https://yumi-cn.github.io/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>《3D图形的数学》第2章笔记 矩阵</title>
    <link href="https://yumi-cn.github.io/2020/12/01/3dmath-c2/"/>
    <id>https://yumi-cn.github.io/2020/12/01/3dmath-c2/</id>
    <published>2020-12-01T09:19:10.000Z</published>
    <updated>2020-12-01T12:51:52.499Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>在三维变换中，矩阵运算是最常用的表达方式。</p></blockquote><a id="more"></a><h2 id="1-矩阵的性质"><a href="#1-矩阵的性质" class="headerlink" title="1 矩阵的性质"></a>1 矩阵的性质</h2><p>一个 \(n \times m\) 的矩阵M就是一个有n行和m列的数组，如果 \(n = m\) 则矩阵M是方阵，把矩阵M第j列的第i行元素（或者第i行第j列）记作 \(M_{ij}\)。</p><p><strong>矩阵M的转置</strong>，记作 \(\textbf{M}^{T}\)，是一个\(m \times n\)矩阵，其中 \(M_{ij}^{T} = M_{ji}\)。</p><p><strong>矩阵的数乘</strong>，或者叫标量乘积，和向量类似，是乘以矩阵的每个元素。</p><p><strong>矩阵的加法</strong>，两个相同大小的矩阵，对应行列的元素相加。</p><p><strong>矩阵的乘法</strong>，如果矩阵F的行数和矩阵G的列数相等，则矩阵F和G可以相乘，假设F是\(n \times m\)的矩阵，G是\(m \times p\)的矩阵，FG就是\(n \times p\)的矩阵，FG在(i, j)位置上的元素可以表示为：</p><div>$$(\textbf{F}\textbf{G})_{ij} = \sum_{k=1}^{m}F_{ik}G_{kj} = \textbf{F}_{i*} \cdot \textbf{G}_{*j} \tag{2.5}$$</div><p>其实也可以看作是矩阵F的第i行和矩阵G的第j列元素之间的点积。</p><p><strong>单位阵</strong>是\(n \times n\)的矩阵，记作\(\textbf{I}_{n}\)，对于\(n \times n\)的矩阵M，有 \( \textbf{M} \textbf{I}_{n}\) = \(\textbf{I}_{n} \textbf{M}\) = \(\textbf{M}\)。</p><div>$$\textbf{I}_{n} =\left[\begin{matrix}1 & 0 & \cdots & 0 \\0 & 1 & \cdots & 0 \\\vdots & \vdots & \ddots & \vdots \\0 & 0 & \cdots & 1\end{matrix}\right]\tag{2.6}$$</div><p>因为单位阵尺寸由情况而定，所以通常把下标n去掉，记作 \(\textbf{I}\)。</p><p><strong>【定理2.1】</strong> 矩阵有以下性质：</p><ul><li>矩阵加法满足交换律和结合律；</li><li>系数加法乘矩阵、系数乘矩阵加法，均满足分配率；</li></ul><p><strong>【定理2.2】</strong> 还具有以下性质：</p><ul><li>系数乘矩阵先后不影响结果；</li><li>矩阵连乘，先后不影响结果；</li><li>\((\textbf{F}\textbf{G})^{T}=\textbf{G}^{T}\textbf{F}^{T}\)。</li></ul><h2 id="2-线性方程组"><a href="#2-线性方程组" class="headerlink" title="2 线性方程组"></a>2 线性方程组</h2><p>矩阵提供了一种有效并且简便的线性方程组表示法，例如线性方程组：</p><div>$$\begin{aligned}3x + 2y - 3z &= 5 \\4x - 3y + 6z &= 1 \\x - z &= 3\end{aligned}\tag{2.10}$$</div><p>可以用以下矩阵形式表示：</p><div>$$\left[\begin{matrix}3 & 2 & -3 \\4 & -3 & 6 \\1 & 0 & -1\end{matrix}\right]\left[\begin{matrix}x \\y \\z\end{matrix}\right]= \left[\begin{matrix}5 \\1 \\3\end{matrix}\right]\tag{2.11}$$</div><p>在未知向量&lt;x,y,z&gt;前面的矩阵叫做<strong>系数矩阵</strong>，在等号右边的列向量叫做<strong>常数向量</strong>。常数向量不为0的线性方程组叫做<strong>非齐次方程组</strong>，常数向量为0叫做<strong>齐次方程组</strong>。</p><p>把系数矩阵和常数向量并置一起（称为增广矩阵），执行基本行变换，就可以得到线性方程组的解。</p><p><strong>【定义2.3】</strong> 所谓<strong>基本行变换</strong>就是对一个矩阵执行以下三种变换之一：</p><ul><li>两行相互交换；</li><li>一行和不为0的系数相乘；</li><li>一行与一个不为0的系数乘后加到另一行上。</li></ul><p>方程(2.11)为例，写出增广矩阵：</p><div>$$\left[\begin{array}{ccc|c}3 & 2 & -3 & 5 \\4 & -3 & 6 & 1 \\1 & 0 & -1 & 3\end{array}\right]\tag{2.12}$$</div><p>对线性方程组的增广矩阵进行的行变换不会影响线性方程组的解，只是使线性方程组更加容易计算（可以同步理解成，一般求方程组解的步骤，使用方程组互相带入化简，使得方程组最后较容易解出值）。</p><p><strong>当用行变换求解一个线性方程组时，目标是把系数矩阵变换为它的最简形式</strong>。</p><p><strong>【定义2.4】</strong> 当且仅当一个矩阵满足一下条件，称为最简形式：</p><ul><li>每一个非0行，最左边的非0元素，即前导元素，必须为1；</li><li>每一个非0行均在全0行前面，或者说，全0行在矩阵底部；</li><li>如果一行前导元素在第j列，则其他行第j列的元素均为0；</li><li>对任意两个非0行 \(i_{2}\) 和 \(i_{1}\)，如果满足\(i_{2} &gt; i_{1}\)，并且相应的前导元素分别位于\(j_{2}\)和\(j_{1}\)列，则必然存在\(j_{2} &gt; j_{1}\)。</li></ul><p>或者简单来说，对于最简形式的矩阵，前导元素是向下向右的趋势的，并且，包含前导元素的列只有一个1，其他元素都为0。</p><p>一个最简形式矩阵例子：</p><div>$$\left[\begin{matrix}1 & 0 & -3 & 0 \\0 & 1 & 2 & 0 \\0 & 0 & 0 & 1 \\0 & 0 & 0 & 0 \end{matrix}\right]\tag{2.14}$$</div><p><strong>【算法2.6】</strong> 把一个线性方程组的 \(n \times (n+1)\) 增广矩阵M变换为最简形式，以下每一步的M在逐渐更新，而不是保持原始状态：</p><ol><li>下标i=1；</li><li>下标j=1，从第1列到第n列开始循环；</li><li>找到一个满足行号 \(k \geq i\)，并且 \(\textbf{M}_{kj} \neq 0\) 的行，如果不存在，跳到步骤8；</li><li>如果 \(k \neq i\)，交换第k行和第i行；</li><li>使矩阵M的元素(i, j)变为1：将第i行乘以 \(1 / \textbf{M}_{ij}\)；</li><li>把第j列中除第i行之外的元素变为0：对于每一行r，\(1 \leq r \leq n\) 且 \(r \neq i\)，将第i行乘 \(-\textbf{M}_{rj}\)加到第r行上；</li><li>i加1；</li><li>如果\(j \leq n\)，j加1，跳到步骤3。</li></ol><p>简单来说，就是每次找到第j列上的前导元素在哪一行，然后把这一行放在对应的位置上，让前导元素变1，再清除第j列上的其它元素，直到再找不到有前导元素的行，算法停止。</p><p>对于化简到最简形式后，如何判断方程组解的情况，有以下规律：</p><ul><li>如果系数矩阵的最简形式是一个单位阵，<strong>方程组有唯一解</strong>；</li><li>如果有一行或多行全为0，方程组要么无解，要么有无穷多解；</li><li>如果某一行系数矩阵为0而常数向量不为0，<strong>则方程组无解</strong>。</li></ul><h2 id="3-逆矩阵"><a href="#3-逆矩阵" class="headerlink" title="3 逆矩阵"></a>3 逆矩阵</h2><p>对一个\(n \times n\)的矩阵M而言，如果存在一个矩阵\(M^{-1}\)，使得 \(\textbf{M}\textbf{M}^{-1}=\textbf{M}^{-1}\textbf{M}=\textbf{I}\)，则称矩阵M是可逆的，矩阵\(M^{-1}\)叫做M的逆矩阵。</p><p>并不是每个矩阵都可逆，没有逆矩阵的矩阵叫做奇异矩阵，例如任何一行或一列为0的矩阵就是奇异矩阵。</p><p><strong>【定理2.9】</strong> 有一行或一列全为0的矩阵是不可逆的。</p><p><strong>【定理2.10】</strong> 一个矩阵M是可逆的，当且仅当\(M^{T}\)是可逆的。</p><p><strong>证明：</strong></p><p>假设M是可逆的，则\(M^{-1}\)存在，所以有：</p><div>$$\textbf{M}^{T}(\textbf{M}^{-1})^{T} =(\textbf{M}^{-1}\textbf{M})^{T} = \textbf{I}^{T} = \textbf{I}\tag{2.29}$$</div><p>并且</p><div>$$(\textbf{M}^{-1})^{T}\textbf{M}^{T} =(\textbf{M}\textbf{M}^{-1})^{T} = \textbf{I}^{T} = \textbf{I}\tag{2.30}$$</div><p>因此，\((\textbf{M}^{-1})^{T}\)是 \(\textbf{M}^{T}\)的逆矩阵。</p><p>类似，如果假设\(\textbf{M}^{T}\)是可逆的，则\((\textbf{M}{T})^{-1}\)存在：</p><div>$$\textbf{M}[(\textbf{M}^{T})^{-1}]^{T} =[(\textbf{M}^{T})^{-1}\textbf{M}^{T})]^{T} =\textbf{I}^{T} = \textbf{I}\tag{2.31}$$</div><p>而且</p><div>$$[(\textbf{M}^{T})^{-1}]^{T}\textbf{M} =[(\textbf{M}^{T}(\textbf{M}^{T})^{-1})]^{T} =\textbf{I}^{T} = \textbf{I}\tag{2.32}$$</div><p>因此，\([(\textbf{M}^{T})^{-1}]^{T}\)是M的逆矩阵。</p><p><strong>【定理2.11】</strong> 如果F和G都是\(n \times n\)的可逆矩阵，那么FG也是可逆的，并且 \((\textbf{F}\textbf{G})^{-1}\) = \(\textbf{G}^{-1}\textbf{F}^{-1}\)。</p><p>求矩阵最简形式的方法（算法2.6）也可以用来计算矩阵逆矩阵，为了计算\(n \times n\)矩阵的逆矩阵，在矩阵的右边并接一个单位阵，以形成一个\(n \times 2n\)的矩阵。</p><div>$$\left[\begin{array}{cccc|cccc}M_{11} & M_{12} & \cdots & M_{1n} & 1 & 0 & \cdots & 0 \\M_{21} & M_{22} & \cdots & M_{2n} & 0 & 1 & \cdots & 0 \\\vdots & \vdots & \ddots & \vdots & \vdots & \vdots & \ddots & \vdots \\M_{n1} & M_{n2} & \cdots & M_{nn} & 0 & 0 & \cdots & 1\end{array}\right]\tag{2.34}$$</div><p>对整个矩阵执行基本行变换操作，直到其左边的\(n \times n\)矩阵变为单位阵，这时右边的\(n \times n\)部分就是M的逆矩阵，如果左边无法化为单位矩阵，则该矩阵不可逆。</p><p><strong>【定理2.14】</strong> 假设(n \times n\)矩阵 \(M^{‘}\)是(n \times n\)矩阵M进行基本变换后得到的矩阵，则有 \(M^{‘}=EM\)，其中E是对单位阵进行相同的基本变换的最终矩阵。</p><p>把<strong>单位阵</strong>经过<strong>行变换</strong>后得到的矩阵称为<strong>初等矩阵</strong>，如果为了把矩阵M变为单位阵而必须经过k次基本行变换，那么：</p><div>$$\textbf{I} = \textbf{E}_{k}\textbf{E}_{k-1} \cdots \textbf{E}_{1}\textbf{M}\tag{2.47}$$</div><p>其中矩阵 \(\textbf{E}_{1}, \textbf{E}_{2}, \cdots, \textbf{E}_{k}\)是单位阵对应的k次行变换的初等矩阵，也就是说，矩阵 \(\textbf{E}_{k}\textbf{E}_{k-1} \cdots \textbf{E}_{1}\)之间的积即为M的逆矩阵。</p><p><strong>【定理2.15】</strong> 当且仅当矩阵M的<strong>行是一个线性无关向量集</strong>时，(n \times n\)矩阵M是可逆的。</p><h2 id="4-行列式"><a href="#4-行列式" class="headerlink" title="4 行列式"></a>4 行列式</h2><p>方阵的行列式得到的是一个标量，矩阵M的行列式记作\(det \textbf{M}\)，行列式使用垂直线取代矩阵两侧的括号。</p><div>$$det \textbf{M} =\left|\begin{matrix}M_{11} & M_{12} & M_{13} \\M_{21} & M_{22} & M_{23} \\M_{31} & M_{32} & M_{33}\end{matrix}\right|\tag{2.50}$$</div><p>\(n \times n\)矩阵M的行列式的值由一个递推公式给出，用符号 \(M^{|i, j|}\)表示原始矩阵M中第i行和第j列删除后行程的 \((n-1) \times (n-1)\)矩阵，用这种方法，行列式值可用以下方法计算：</p><div>$$det \textbf{M} = \sum_{i=1}^{n}(-1)^{i+k}M_{ik} det \textbf{M}^{|i,k|}\tag{2.53}$$</div><div>$$det \textbf{M} = \sum_{i=1}^{n}(-1)^{k+j}M_{kj} det \textbf{M}^{|k,j|}\tag{2.54}$$</div><p>其中k是满足条件 \(1 \leq k \leq n\)的任意常数。</p><p>二阶矩阵的行列式公式：</p><div>$$\left|\begin{matrix}a & b \\c & d\end{matrix}\right|= ad - bc\tag{2.55}$$</div><p>三阶矩阵的行列式公式：</p><div>$$\begin{aligned}\left|\begin{matrix}a_{11} & a_{12} & a_{13} \\a_{21} & a_{22} & a_{23} \\a_{31} & a_{32} & a_{33}\end{matrix}\right|= a_{11}det\textbf{M}^{|1,1|} - a_{12}det\textbf{M}^{|1,2|} + a_{13}det\textbf{M}^{|1,3|} \\= a_{11}(a_{22}a_{33}-a_{23}a_{32}) -a_{12}(a_{21}a_{33}-a_{23}a_{31}) +a_{13}(a_{21}a_{32}-a_{22}a_{31})\end{aligned}\tag{2.56}$$</div><p><strong>【定理2.16】</strong> 执行基本变换对一个矩阵的行列式有以下性质：</p><ul><li>两行交换，行列式取反；</li><li>矩阵一行乘比例系数a则行列式变为原来的a倍；</li><li>把一行的若干倍加到另一行对行列式没有影响。</li></ul><p><strong>【推论2.17】</strong> 如果矩阵有相同行，则行列式为0。</p><p><strong>【定理2.18】</strong> \(n \times n\)矩阵M当且仅当 \(det \textbf{M} \neq 0\)时是可逆的。</p><p><strong>【定理2.19】</strong> 对任意两个 \(n \times n\)的矩阵F和G，有 \(det\textbf{F}\textbf{G}=det\textbf{F}det\textbf{G}\)。</p><p>Tips：初等矩阵乘积的行列式等于行列式的乘积。</p><p><strong>【定理2.20】</strong> 假设F是 \(n \times n\)矩阵，如果另一 \(n \times n\)矩阵G的元素为：</p><div>$$G_{ij} = (-1)^{i + j} \frac{det \textbf{F}^{|j, i|}}{det \textbf{F}}\tag{2.62}$$</div><p>那么 \(\textbf{G}=\textbf{F}^{-1}\)。</p><p>通过定理2.20可以推出图形学中经常用的几个逆矩阵计算公式主要是2阶和3阶的。</p><p>2阶方阵逆矩阵公式：</p><div>$$\textbf{A}^{-1} = \frac{1}{det \textbf{A}}\left[\begin{matrix}A_{22} & -A_{12}\\-A_{21} & A_{11}\end{matrix}\right]\tag{2.63}$$</div><p>3阶方阵逆矩阵公式：</p><div>$$\textbf{B}^{-1} = \frac{1}{det \textbf{B}}\left[\begin{matrix}B_{22}B_{33}-B_{23}B_{32} & B_{13}B_{32}-B_{12}B_{33} & B_{12}B_{23}-B_{13}B_{22} \\B_{23}B_{31}-B_{21}B_{33} & B_{11}B_{33}-B_{13}B_{31} & B_{13}B_{21}-B_{11}B_{23} \\B_{21}B_{32}-B_{22}B_{31} & B_{12}B_{31}-B_{11}B_{32} & B_{11}B_{22}-B_{12}B_{21}\end{matrix}\right]$$</div><h2 id="5-特征值与特征向量"><a href="#5-特征值与特征向量" class="headerlink" title="5 特征值与特征向量"></a>5 特征值与特征向量</h2><p>对于<strong>可逆方阵</strong>，<strong>必然</strong>存在一个<strong>向量</strong>，当该<strong>向量与可逆方阵相乘</strong>时，<strong>向量只会发生大小变换而方向不变</strong>，即，对于n阶方阵M，存在着非0的n维向量 \(\textbf{V}_{1}, \textbf{V}_{2}, \cdots, \textbf{V}_{n}\)满足：</p><div>$$\textbf{M}\textbf{V}_{i} = \lambda_{i}\textbf{V}_{i}\tag{2.65}$$</div><p>其中比例系数 \(\lambda_{i}\) 称为矩阵M的特征值，而向量 \(\textbf{V}_{i}\)是对应特征值的特征向量。</p><p>对式（2.65）进行变换可得到矩阵的特征值：</p><div>$$(\textbf{M}-\lambda_{i}\textbf{I})\textbf{V}_{i} = \textbf{0}\tag{2.66}$$</div><p>对于非0向量 \(\textbf{V}_{i}\)，如果上式成立，矩阵 \(\textbf{M}-\lambda_{i}\textbf{I}\)一定是奇异矩阵（不可逆），否则就可以对其求逆，得到:</p><div>$$\textbf{V}_{i} = (\textbf{M}-\lambda_{i}\textbf{I})^{-1}\textbf{0} = \textbf{0}\tag{2.67}$$</div><p>这个非0向量矛盾，所以矩阵 \(\textbf{M}-\lambda_{i}\textbf{I}\)的行列式为0，因此可以通过：</p><div>$$det(\textbf{M}-\lambda\textbf{I}) = 0\tag{2.68}$$</div><p>计算出矩阵的特征值解，由2.68式得出的关于 \(\lambda\)的n阶多项式叫做矩阵M的特征多项式，多项式的根就是矩阵M的特征值。</p><p>一旦矩阵的特征值求得，就可以代入式(2.66)，计算出相应的特征向量，因为矩阵 \(\textbf{M}-\lambda_{i}\textbf{I}\) 是奇异的，所以简化形式至少有一行全为0，所以有无穷多解（比如特征向量的系数倍数向量也是特征向量），因此特征向量可以表示成任意常数的形式，如果有必要也可以取特征向量的长度为1。</p><p>通常，<strong>如果矩阵特征值是复数，则相应的特征向量也含有复数元素</strong>；确保有实数特征值以及相应的实数特征向量的矩阵是<strong>对称矩阵</strong>。</p><p><strong>【定义2.23】</strong> 一个n阶方阵，当且仅当 对任意i和j均有 \(M_{ij}=M_{ji}\) 时是对称矩阵，也就是说如果矩阵元素关于主对角线对称，则该矩阵就成为<strong>对称矩阵</strong>。</p><p><strong>【定理2.24】</strong> 矩阵<strong>元素为实数</strong>的对称矩阵的特征值也是实数。</p><p><strong>【定理2.25】</strong> 对应于<strong>对称矩阵</strong>M的<strong>不同特征值的特征向量</strong>是<strong>正交</strong>的。</p><h2 id="6-对角化"><a href="#6-对角化" class="headerlink" title="6 对角化"></a>6 对角化</h2><p>对角矩阵（对称矩阵的特例），只在主对角线上有非0元素的矩阵。</p><p>给定方阵M，如果能找到一个矩阵A使得 \(\textbf{A}^{-1}\textbf{M}\textbf{A}\) 是对角矩阵，那么就说矩阵A将矩阵M对角化了。</p><p><strong>【定理2.26】</strong> 假设M是特征值为 \(\lambda_{1}, \lambda_{2}, \cdots, \lambda_{n}\)的n阶方阵，且与特征值对应的特征向量 \(\textbf{V}_{1}, \textbf{V}_{2}, \cdots, \textbf{V}_{n}\) 是一个<strong>线性无关集</strong>，则矩阵A：</p><div>$$A = [ \textbf{V}_{1} \textbf{V}_{2} \cdots \textbf{V}_{n} ]\tag{2.82}$$</div><p>可以将矩阵M对角化，而且 \(\textbf{A}^{-1}\textbf{M}\textbf{A}\) 的主对角元素是矩阵M的特征值，即：</p><div>$$\textbf{A}^{-1}\textbf{M}\textbf{A} =\left[\begin{matrix}\lambda_{1} & 0 & \cdots & 0 \\0 & \lambda_{2} & \cdots & 0\\\vdots & \vdots & \ddots & \vdots\\0 & 0 & \cdots & \lambda_{n}\end{matrix}\right]\tag{2.83}$$</div><p>相反，如果存在一个可逆矩阵A使得 \(\textbf{A}^{-1}\textbf{M}\textbf{A}\) 是一个对角阵，则矩阵A的列必然是矩阵M的特征向量，而 \(\textbf{A}^{-1}\textbf{M}\textbf{A}\) 的对角线元素则是矩阵M的特征值。</p>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;在三维变换中，矩阵运算是最常用的表达方式。&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="3D游戏与图形学的数学" scheme="https://yumi-cn.github.io/categories/3D%E6%B8%B8%E6%88%8F%E4%B8%8E%E5%9B%BE%E5%BD%A2%E5%AD%A6%E7%9A%84%E6%95%B0%E5%AD%A6/"/>
    
    
    <category term="笔记" scheme="https://yumi-cn.github.io/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>《剑指Offer》第2章笔记 链表</title>
    <link href="https://yumi-cn.github.io/2020/11/30/s2o-c2-linked/"/>
    <id>https://yumi-cn.github.io/2020/11/30/s2o-c2-linked/</id>
    <published>2020-11-30T11:09:59.000Z</published>
    <updated>2020-11-30T12:17:30.456Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>链表应该是面试时被提及最频繁的数据结构。</p></blockquote><a id="more"></a><p>链表的结构很简单，它由指针把若干个节点连接成链状结构，链表的创建、插入节点、删除节点等操作都只需要20行左右的代码就能实现，代码量比较适合面试（哈希表、有向图等复杂的一个操作可能就需要很多代码）。</p><p>链表是一种动态数据结构，创建链表时，无须知道链表长度，插入节点时，只需要为新节点分配内存，然后调整指针的指向来确保新节点被链接到链表中；内存分配不是在创建链表时一次性完成的，而是每添加一个节点分配一次内存。</p><p>典型的单向链表节点定义：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> value;</span><br><span class="line">    Node* next;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>往链表末尾添加一个节点：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add_to_tail</span><span class="params">(Node** phead, <span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 头结点是一个指针的指针</span></span><br><span class="line">    Node* pnew = <span class="keyword">new</span> Node();</span><br><span class="line">    pnew-&gt;value = value;</span><br><span class="line">    pnew-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">if</span>(*phead == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="comment">// 创建头节点</span></span><br><span class="line">        *phead = pnew;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 添加节点到尾部</span></span><br><span class="line">        Node* pnode = *phead;</span><br><span class="line">        <span class="keyword">while</span>(pnode-&gt;next != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            pnode = pnode-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        pnode-&gt;next = pnew;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>想要在链表中找到第i个节点，那我们只能从头结点开始遍历链表，时间效率为<code>O(n)</code>，而在数组中只需要<code>O(1)</code>的时间。</p><p>找到第一个含有某值节点并删除该节点的代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">remove_node</span><span class="params">(Node** phead, <span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(phead==<span class="literal">nullptr</span> || *phead==<span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Node* p_delete = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">if</span>((*phead)-&gt;value == value) &#123;</span><br><span class="line">        <span class="comment">// 头结点删除需要单独考虑操作</span></span><br><span class="line">        p_delete = *phead;</span><br><span class="line">        *phead = (*phead)-&gt;next;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        Node* pnode = *phead;</span><br><span class="line">        <span class="comment">// 寻找删除节点的前一个节点</span></span><br><span class="line">        <span class="keyword">while</span>(pnode-&gt;next != <span class="literal">nullptr</span></span><br><span class="line">            &amp;&amp; pnode-&gt;next-&gt;value != value) &#123;</span><br><span class="line">                pnode = pnode-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(pnode-&gt;next != <span class="literal">nullptr</span> &amp;&amp; pnode-&gt;next-&gt;value == value) &#123;</span><br><span class="line">            <span class="comment">// 调整删除节点前一个节点的链接</span></span><br><span class="line">            p_delete = pnode-&gt;next;</span><br><span class="line">            pnode-&gt;next = pnode-&gt;next-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(p_delete != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="keyword">delete</span> p_delete;</span><br><span class="line">        p_delete = <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一些特殊形式的链表也会被经常考到：</p><ul><li>环形链表：链表末尾节点指向头结点（面试题62）；</li><li>双向链表：节点还有一个指向前一个节点的指针（面试题36）；</li><li>复杂链表：节点还有拥有指向任意节点的指针（面试题35）。</li></ul><blockquote><p>面试题6：从尾到头打印链表</p></blockquote><p>输入一个链表的头节点，从尾到头反过来打印每个节点的值。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> value;</span><br><span class="line">    Node* next;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>Tips：如果打算修改输入数据，最好先问面试官是不是允许修改，这里假设面试官不能改变链表的结构。</p><p>这道题目需要先访问的节点后输出，可以想到使用栈这种数据结构，每次访问到节点，就压到栈中，输出的时候只需要循环出栈即可。</p><p>完整代码实现：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> value;</span><br><span class="line">    Node* next;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add_to_tail</span><span class="params">(Node** phead, <span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 头结点是一个指针的指针</span></span><br><span class="line">    Node* pnew = <span class="keyword">new</span> Node();</span><br><span class="line">    pnew-&gt;value = value;</span><br><span class="line">    pnew-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">if</span>(*phead == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="comment">// 创建头节点</span></span><br><span class="line">        *phead = pnew;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 添加节点到尾部</span></span><br><span class="line">        Node* pnode = *phead;</span><br><span class="line">        <span class="keyword">while</span>(pnode-&gt;next != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            pnode = pnode-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        pnode-&gt;next = pnew;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">reverse_print</span><span class="params">(Node** phead)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(phead==<span class="literal">nullptr</span> || *phead==<span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">stack</span>&lt;Node*&gt; pstack;</span><br><span class="line">    Node* pnode = *phead;</span><br><span class="line">    <span class="keyword">while</span>(pnode != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        pstack.push(pnode);</span><br><span class="line">        pnode = pnode-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(!pstack.empty()) &#123;</span><br><span class="line">        pnode = pstack.top();</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\t&quot;</span>, pnode-&gt;value);</span><br><span class="line">        pstack.pop();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> values[] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line">    Node** phead = <span class="keyword">new</span> Node*;</span><br><span class="line">    *phead = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">        add_to_tail(phead, values[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    reverse_print(phead);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>具体的实现中需要注意到的一个点是头节点的初始化，因为是指针的指针，所以需要先申请一个<strong>Node指针类型的指针</strong>，<code>new Node*</code>，然后再将头结点指向的节点设置为<code>nullptr</code>，这样才不会在访问时出错。</p><p>如果可以使用栈结构来实现，也可以考虑使用递归的方式实现，通过递归访问，只有在返回函数的时候再输出节点，就可以实现逆序输出。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 调用的时候要使用 *phead</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">reverse_print_rec</span><span class="params">(Node* node)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(node == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    reverse_print_rec(node-&gt;next);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\t&quot;</span>, node-&gt;value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>递归的代码相比于使用栈会简洁很多，但是使用递归是有代价的，函数递归使用的栈空间通常会有限制（比自己建立栈的空间要小），所以如果链表过于长可能会导致函数调用栈溢出。</p>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;链表应该是面试时被提及最频繁的数据结构。&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="剑指Offer" scheme="https://yumi-cn.github.io/categories/%E5%89%91%E6%8C%87Offer/"/>
    
    
    <category term="笔记" scheme="https://yumi-cn.github.io/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>《剑指Offer》第2章笔记 字符串</title>
    <link href="https://yumi-cn.github.io/2020/11/28/s2o-c2-string/"/>
    <id>https://yumi-cn.github.io/2020/11/28/s2o-c2-string/</id>
    <published>2020-11-28T14:06:05.000Z</published>
    <updated>2020-11-30T11:09:14.812Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>字符串的使用频率非常高，为了优化，很多语言都对字符串做了特殊的规定。</p></blockquote><a id="more"></a><p>C/C++中每个字符串都以字符 <code>\0</code> 做为结尾，这样便于运行时判断字符数组的尾部，由于这个特点，字符串数组的长度比真实字符串长度要多1才可以，这样容易导致一些错误：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> str[<span class="number">10</span>];</span><br><span class="line"><span class="built_in">strcpy</span>(str, <span class="string">&quot;0123456789&quot;</span>); <span class="comment">// Error</span></span><br></pre></td></tr></table></figure><p>为了节省内存，C/C++把常量字符串放到一个单独的内存区域，当几个指针赋值给相同的常量字符串时，实际上会指向相同的内存地址。但用常量内存来初始化字符数组时，情况又有所不同了，看下面的例子：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> str1[] = <span class="string">&quot;hello world&quot;</span>;</span><br><span class="line">    <span class="keyword">char</span> str2[] = <span class="string">&quot;hello world&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span>* str3 = <span class="string">&quot;hello world&quot;</span>;</span><br><span class="line">    <span class="keyword">char</span>* str4 = <span class="string">&quot;hello world&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;str1 =%p\n&quot;</span>, str1); <span class="comment">// 0061fe04</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;str2 =%p\n&quot;</span>, str2); <span class="comment">// 0061fdf8</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;str3 =%p\n&quot;</span>, str3); <span class="comment">// 00409001</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;str4 =%p\n&quot;</span>, str4); <span class="comment">// 00409001</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>str1</code>和<code>str2</code>是两个字符数组，在初始化赋值时，运行时为为他们分配两个长度为12字节的内存空间，并把字符串赋值到数组中去（而不是直接拷贝字符串常量地址），所以他们的初始地址是不同的。</p><p><code>str3</code>和<code>str4</code>是两个指针，不需要再分配内存来存储内容，只需要传递地址，所以他们就拷贝了同一个地址。</p><blockquote><p>面试题5：替换空格</p></blockquote><p>实现一个函数，把字符串的每个空格替换成<code>%20</code>，例如输入<code>We are happy.</code>，则输出<code>We%20are%20happy.</code>。</p><p>题目来自于网络编程中的URL特殊字符编码，有时候服务器不一定支持一些特殊字符URL，所以需要先将特殊转换成ASCII码的两位十六进制表示，比如空格的ASCII码是<code>32</code>，即十六进制的<code>0x20</code>，空格被替换成<code>%20</code>，比如<code>#</code>的ASCII码为35，十六进制<code>0x23</code>，在URL中被替换成<code>%23</code>。</p><p>一般有两种解决方向：</p><ul><li>在原字符数组上进行处理；</li><li>申请新字符数组，将新内容写进去；</li></ul><p>在面试过程中遇到这样的问题，如果确定题目中没有限定说明，可以向面试官进一步地问清楚应该考虑什么样的限定条件。</p><p>在这里我们假设（作者假设）面试官需要在原字符数组上替换，输入的字符串后面有足够多的内存空间。</p><p>我们仍然从最简思路入手：</p><ul><li><strong>思路1</strong>：在字符串中进行遍历，当碰到空格时，将空格替换为<code>%20</code>，由于替换的字符串比空格多2个字符，为了放入<code>%20</code>，所以要将后续的字符串后移两位，重复该操作直到字符串没有空格。</li></ul><p>假设字符串长度<code>n</code>，对于每个空格字符，需要移动后面<code>O(n)</code>个字符，所以时间开销是<code>O(n^2)</code>。</p><p>显然这个方法过于简单，还不是最优解，观察可以发现，有些字符串被反复后移，但其实对于一个固定空格个数的字符串，这些字符串所应该处的最终位置我们是可以计算出来的，比如<code>We are happy.</code>中<code>We</code>前面没有空格，不需要向后移动，<code>are</code>前面有1个空格，所以字符串会被后移2位，<code>happy.</code>前面有2个空格，需要移动4位。</p><p>所以对于某些字符串其最终的位置反而是通过计算得到的，不需要反复的重复移动（拷贝字符串时间开销大）。</p><ul><li><strong>思路2</strong>：使用一个空格计数器，在移动字符串时，根据当前空格计数器来判断当前字符需要后移多少位，然后直接将字符移动到目标位置上，遇到空格时，根据计算的后移位置，直接顺序写入<code>%20</code>。时间开销因为只需要遍历一次字符串，所以是<code>O(n)</code>。</li></ul><p>这样的思路还是有亿点点问题需要考虑，如果从头开始移动字符串，则后面的字符串还没有空出来时，就需要先移动后面的字符串，这样就导致问题变得稍微有点复杂，所以我们可以反过来，从尾部开始处理移动操作。</p><ul><li><strong>思路3</strong>：先遍历一次字符串，统计空格出现次数，计算最终字符串的长度，然后从尾部开始处理移动，申请两个指针，一个指向原字符位置，一个指向移动目标位置，当遇到普通字符时，直接转移，遇到空格时，在目标位置写入替换字符串。时间开销仍然是<code>O(n)</code>。</li></ul><p>完整实现代码:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">replace</span><span class="params">(<span class="keyword">char</span>* str, <span class="keyword">char</span>* ori, <span class="keyword">char</span>* rep)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(str != <span class="literal">nullptr</span> &amp;&amp; ori != <span class="literal">nullptr</span> &amp;&amp; rep != <span class="literal">nullptr</span></span><br><span class="line">       &amp;&amp; <span class="built_in">strlen</span>(str) &gt; <span class="number">0</span> &amp;&amp; <span class="built_in">strlen</span>(ori) &gt; <span class="number">0</span> &amp;&amp; <span class="built_in">strlen</span>(rep) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> ori_len = <span class="built_in">strlen</span>(ori);</span><br><span class="line">        <span class="keyword">int</span> rep_len = <span class="built_in">strlen</span>(rep);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">strlen</span>(str); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">strncmp</span>((str+i), ori, ori_len) == <span class="number">0</span>) &#123;</span><br><span class="line">                count++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(count == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">char</span>* po = str + <span class="built_in">strlen</span>(str) + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">char</span>* pr = po + count * (rep_len - ori_len);</span><br><span class="line">        <span class="keyword">while</span>(po &gt;= str) &#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">strncmp</span>(po, ori, ori_len) == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">char</span>* tmp = rep + (rep_len - <span class="number">1</span>); tmp &gt;= rep; tmp--) &#123;</span><br><span class="line">                    *pr = *tmp;</span><br><span class="line">                    pr--;</span><br><span class="line">                &#125;</span><br><span class="line">                po--;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                *pr = *po;</span><br><span class="line">                po--;</span><br><span class="line">                pr--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> str[<span class="number">100</span>] = <span class="string">&quot;We are happy.&quot;</span>;</span><br><span class="line">    <span class="keyword">char</span> ori[<span class="number">10</span>] = <span class="string">&quot; &quot;</span>;</span><br><span class="line">    <span class="keyword">char</span> rep[<span class="number">10</span>] = <span class="string">&quot;%20&quot;</span>;</span><br><span class="line">    <span class="keyword">if</span>(replace(str, ori, rep)) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, str);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Error\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Tips：代码和原作者的实现有出入，实现了相对来说比较通用的字符串替换，但是方法以及代码仅仅只针对这道题目而言是有效的，还有非常多该题目以外的问题其实是没有考虑到的，例如需要被替换不是单个的空格而是多个空格甚至是任意字符、替换的字符串如果长度小于被替换字符串该怎么处理，等等（修改上述代码中的初始字符串即可看到结果会出现问题）；不过不在这里继续讨论，可以自行尝试思考。</p><blockquote><p>拓展题练习题： 已排序的两个数组A1和A2，A1尾部有足够多的空间容纳A2，将A2的所有数组插入A1中，并且最终A1中所有数字是有序的。</p></blockquote>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;字符串的使用频率非常高，为了优化，很多语言都对字符串做了特殊的规定。&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="剑指Offer" scheme="https://yumi-cn.github.io/categories/%E5%89%91%E6%8C%87Offer/"/>
    
    
    <category term="笔记" scheme="https://yumi-cn.github.io/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>《3D图形的数学》第1章笔记 向量</title>
    <link href="https://yumi-cn.github.io/2020/11/27/3dmath-c1/"/>
    <id>https://yumi-cn.github.io/2020/11/27/3dmath-c1/</id>
    <published>2020-11-27T12:14:23.000Z</published>
    <updated>2020-11-28T09:18:55.646Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>对于成功的3D程序猿，掌握如何进行向量运算是一种基本的技能要求。</p></blockquote><a id="more"></a><blockquote><p>原书：《3D游戏与计算机图形学中的数学方法》 by Eric.Lengyel</p></blockquote><h2 id="1-向量的形式"><a href="#1-向量的形式" class="headerlink" title="1 向量的形式"></a>1 向量的形式</h2><p>一个n维向量<strong>V</strong>可以表示为：</p><div>$$\textbf{V} = < V_{1}, V_{2}, ... , V_{n} > \tag{1.1}$$</div><p>系数a和向量<strong>V</strong>的乘积可以定义为：</p><div>$$a\textbf{V} = < aV_{1}, aV_{2}, ... , aV_{n} > \tag{1.4}$$</div><p>向量加减运算：</p><div>$$\textbf{P} + \textbf{Q}= < P_{1} + Q_{1}, P_{2} + Q_{2}, ... , P_{n} + Q_{n} > \tag{1.5}$$</div><p><strong>【定理1.1】</strong>对于给定的任何两个系数a和b，以及任何三个向量<strong>P</strong>、<strong>Q</strong>和<strong>R</strong>，有以下运算规律：</p><ul><li>\(\textbf{P} + \textbf{Q} = \textbf{Q} + \textbf{P}\)</li><li>\((\textbf{P} + \textbf{Q}) + \textbf{R} = \textbf{P} + (\textbf{Q} + \textbf{R})\)</li><li>\((ab)\textbf{P} = a(b\textbf{P})\)</li><li>\(a(\textbf{P} + \textbf{Q}) = a\textbf{P} + a\textbf{Q}\)</li><li>\((a + b)\textbf{P} = a\textbf{P} + b\textbf{P}\)</li></ul><p>n维向量<strong>V</strong>的模，||<strong>V</strong>||：</p><div>$$\textbf{||V||} = \sqrt{\sum_{i=1}^{n} V_{i}^{2}} \tag{1.6}$$</div><p>模也称为向量的范数或者长度，模为1的向量称为单位向量。</p><p>设向量<strong>V</strong>表示一个三维点或方向，则公式(1.6)可以展开为：</p><div>$$\textbf{||V||} = \sqrt{V_{x}^{2} + V_{y}^{2} + V_{z}^{2}} \tag{1.7}$$</div><p>如果向量V至少有至少有一个非零分量，可以通过乘 \(1/\textbf{||V||}\) 得到V方向上的一个单位向量，也叫做单位化、规格化。</p><p><strong>【定理1.2】</strong> 对于任意给定系数a，任意的两个向量<strong>P</strong>和<strong>Q</strong>，有以下性质：</p><ul><li>\( \textbf{||P||} \geq 0 \)</li><li>当且仅当 \( \textbf{||P||}=&lt;0, 0, …, 0&gt; \)时，\( \textbf{||P||}=0 \)</li><li>\( \textbf{||aP||}=|a|\textbf{||P||} \)</li><li>\( \textbf{||P + Q||} \leq \textbf{||P||} + \textbf{||Q||} \)</li></ul><p>其中的第4条，可以由三角不等式得到。</p><h2 id="2-点积"><a href="#2-点积" class="headerlink" title="2 点积"></a>2 点积</h2><p><strong>向量间</strong>的<strong>点积</strong>，也叫做<strong>数量积</strong>或<strong>内积</strong>，3D图形中经常用点积来度量两个向量指向的差异。</p><p><strong>【定理1.3】</strong> 两个n维向量P和Q的点积，记作P·Q，即：</p><div>$$\textbf{P} \cdot \textbf{Q}= \sum_{i=1}^{n} P_{i}Q_{i} \tag{1.9}$$</div><p>向量的点积等于两个向量的对应分量乘积之和。</p><p>在三维空间中，有：</p><div>$$\textbf{P} \cdot \textbf{Q}= P_{x}Q_{x} + P_{y}Q_{y} + P_{z}Q_{z} \tag{1.10}$$</div><p><strong>【定理1.4】</strong> 对于给定的两个向量P和Q，点积满足公式：</p><div>$$\textbf{P} \cdot \textbf{Q}= \textbf{||P||}\textbf{||Q||} cos \alpha \tag{1.12}$$</div><p>\(\alpha\)是向量P和Q之间的夹角（详细的说是P和Q的起点、终点决定的平面夹角）。</p><p>Tips：定理1.4的证明要用到余弦定理，一个三角形有三条边\(a,b,c\)，\(a,b\)夹角是\(\alpha\)时，三边满足等式关系\(c^{2} = a^{2} + b^{2} - 2abcos\alpha\)。</p><p>定理1.4可以得出两个结论：</p><ul><li>当且仅当 \(\textbf{P} \cdot \textbf{Q} = 0\) 时， 向量P和向量Q相互垂直。点积为0的向量称为正交向量，零向量和任意向量正交；</li><li>点积正负号说明两个向量的方向情况，例如在看平面法线和平面外一点，可以查看点相对于平面的位置，是在法线同侧（点积为正）还是在不同侧（点积为负）。</li></ul><p><strong>【定理1.5】</strong> 对于任意给定系数a，任意的两个向量<strong>P</strong>和<strong>Q</strong>，有以下性质：</p><ul><li>\( \textbf{P} \cdot \textbf{Q} = \textbf{Q} \cdot \textbf{P} \)</li><li>\( (a\textbf{P}) \cdot \textbf{Q} = a(\textbf{P} \cdot \textbf{Q}) \)</li><li>\( \textbf{P} \cdot (\textbf{Q} + \textbf{R}) = \textbf{P} \cdot \textbf{Q} + \textbf{P} \cdot \textbf{R} \)</li><li>\( \textbf{P} \cdot \textbf{P} = \textbf{||P||}^{2} \)</li><li>\( | \textbf{P} \cdot \textbf{Q} | \leq \textbf{||P||} \cdot \textbf{||Q||} \)</li></ul><p>向量P在向量Q上的投影长度：</p><div>$$\textbf{||P||}cos\alpha= \frac{\textbf{P}\cdot\textbf{Q}}{\textbf{||Q||}} \tag{1.17}$$</div><p>如果再乘以单位向量 \( \frac{\textbf{Q}}{\textbf{||Q||}} \)，就可以得到具有该长度并且平行于Q的一个向量，即表示向量P到向量Q的投影，记作\( proj_{\textbf{Q}} \textbf{P} \)：</p><div>$$proj_{\textbf{Q}}\textbf{P} = \frac{\textbf{P} \cdot \textbf{Q}}{\textbf{||Q||}^{2}} \textbf{Q} \tag{1.18}$$</div><p>P到Q的投影也可以看作是一个线性变换过程，所以可以表示为矩阵和向量乘积，三维情况下，\( proj_{\textbf{Q}} \textbf{P} \) 也可以用下面的公式计算：</p><div>$$proj_{\textbf{Q}} \textbf{P} = \frac{1}{\textbf{Q}^{2}}\left[\begin{matrix}Q_{x}^{2} & Q_{x}Q_{y} & Q_{x}Q_{z} \\Q_{x}Q_{y} & Q_{y}^{2} & Q_{y}Q_{z} \\Q_{x}Q_{z} & Q_{y}Q_{z} & Q_{z}^{2}\end{matrix}\right]\left[\begin{matrix}P_{x} \\P_{y} \\P_{z}\end{matrix}\right]\tag{1.20}$$</div><p>向量P相对于向量Q的垂直分量记作\( perp_{\textbf{Q}} \textbf{P} \)，可以用向量P减去投影分量得到垂直分量：</p><div>$$perp_{\textbf{Q}} \textbf{P} = \textbf{P} - proj_{\textbf{Q}} \textbf{P} \tag{1.19}$$</div><h2 id="3-叉积"><a href="#3-叉积" class="headerlink" title="3 叉积"></a>3 叉积</h2><p>两个三维向量的叉积又称为向量积，结果是一个新的向量，这个向量垂直于原来的两个向量。</p><p>在3D图形学中，已知曲面上一点的两个不同方向的切向量，就可以通过求叉积得到曲面在该点的法向量。</p><p><strong>【定义1.6】</strong> 两个3D向量P和Q的叉积记作 \(\textbf{P} \times \textbf{Q}\)，结果向量为：</p><div>$$\textbf{P} \times \textbf{Q}= <P_{y}Q_{z} - P_{z}Q_{y},P_{z}Q_{x} - P_{x}Q_{z},P_{x}Q_{y} - P_{y}Q_{x} > \tag{1.21}$$</div><p>便于记忆的一个工具是伪行列式：</p><div>$$\textbf{P} \times \textbf{Q} =\left|\begin{matrix}i & j & k \\P_{x} & P_{y} & P_{z} \\Q_{x} & Q_{y} & Q_{z}\end{matrix}\right|\tag{1.22}$$</div><p>这里i,j,k是x,y,z轴的单位向量：</p><div>$$\begin{aligned}\textbf{i} &= <1, 0, 0> \\\textbf{j} &= <0, 1, 0> \\\textbf{k} &= <0, 0, 1>\end{aligned}\tag{1.23}$$</div><p>叉积\(\textbf{P} \times \textbf{Q}\)也可以用线性变换的形式表示，变换矩阵派生于P，作用于Q：</p><div>$$\textbf{P} \times \textbf{Q} =\left[\begin{matrix}0 & -P_{z} & P_{y} \\P_{z} & 0 & -P_{x} \\-P_{y} & P_{x} & 0\end{matrix}\right]\left[\begin{matrix}Q_{x} \\Q_{y} \\Q_{z}\end{matrix}\right]\tag{1.25}$$</div><p>Tips：原书P7的公式(1.25)有疏漏，变换矩阵中出现了Q的分量。</p><p>对于任意给定的三个3D向量P、Q和R，等式 \((\textbf{P} \times \textbf{Q}) \cdot \textbf{R}\) 的值可以通过伪行列式乘以R得到：</p><div>$$(\textbf{P} \times \textbf{Q}) \cdot \textbf{R} =\left|\begin{matrix}R_{x} & R_{y} & R_{z} \\P_{x} & P_{y} & P_{z} \\Q_{x} & Q_{y} & Q_{z}\end{matrix}\right|=\left|\begin{matrix}P_{x} & P_{y} & P_{z} \\Q_{x} & Q_{y} & Q_{z} \\R_{x} & R_{y} & R_{z}\end{matrix}\right|\tag{1.27}$$</div><p>Tips：行列式表达我在这里书写了两种表达形式，第一种是延续之前伪行列式的写法，只是将R替代了ijk的位置，第二种写法来自于书上，遵循PQR的出现次序的记忆法，两者的值根据初等变化法则是相等的。</p><p>如果P、Q和R中任何一个可以表示为其他两个向量的线性组合，则行列式的值为0（根据垂直法则和点积定理推导）。</p><p><strong>【定理1.8】</strong> 对于给定的两个3D向量P和Q，叉积\(\textbf{P} \times \textbf{Q}\)满足下面公式：</p><div>$$||\textbf{P} \times \textbf{Q}|| = \textbf{||P||}\textbf{||Q||}sin\alpha \tag{1.28}$$</div><p>\(\alpha\)为P和Q的夹角。</p><p>由定理1.8可知，叉积\(\textbf{P} \times \textbf{Q}\)的模等于由向量P和Q组成的平行四边形的面积。因此，一个三角形的顶点\(V_{1}, V_{2}, V_{3}\)，可以计算其面积A:</p><div>$$A = \frac{1}{2} || (V_{2} - V_{1}) \times (V_{3} - V_{1}) || \tag{1.32}$$</div><p>叉积得到的非零向量一定垂直于原本的两个向量，但满足要求的有两种方向，为了确定叉积方向，引入叉积遵循的<strong>右手法则</strong>。例如，使用右手手指指向P方向，手心朝向Q反向，则大拇指就是叉积\(\textbf{P} \times \textbf{Q}\)的方向。</p><p>空间轴的单位向量ijk，按照圆形循环的方式排序，i在j之前，j在k之前，k在i之前，则这样的顺序叉积乘等于第三个向量：</p><div>$$\begin{aligned} \textbf{i} \times \textbf{j} &= \textbf{k} \\ \textbf{j} \times \textbf{k} &= \textbf{i} \\ \textbf{k} \times \textbf{i} &= \textbf{j}\end{aligned}\tag{1.33}$$</div><p>反之，按照相反的顺序相接的叉乘等于第三个向量的负值。</p><p><strong>【定理1.9】</strong> 对于给定系数a，b和任意三个3D向量P、Q和R，有以下性质：</p><ul><li>\( \textbf{P} \times \textbf{Q} = - (\textbf{Q} \times \textbf{P}) \)</li><li>\( (a\textbf{P}) \times \textbf{Q} = a(\textbf{P} \times \textbf{Q}) \)</li><li>\( \textbf{P} \times (\textbf{Q} + \textbf{R}) = \textbf{P} \times \textbf{Q} + \textbf{P} \times \textbf{R} \)</li><li>\( \textbf{P} \times \textbf{P} = \textbf{0} = &lt;0, 0, 0&gt; \)</li><li>\( (\textbf{P} \times \textbf{Q}) \cdot \textbf{R} = (\textbf{R} \times \textbf{P}) \cdot \textbf{Q} = (\textbf{Q} \times \textbf{R}) \cdot \textbf{P} \) （注意顺序，满足圆形循环）</li><li>\( \textbf{P} \times (\textbf{Q} \times \textbf{P}) = \textbf{P} \times \textbf{Q} \times \textbf{P} = \textbf{P}^{2}\textbf{Q} - (\textbf{P} \cdot \textbf{Q}) \textbf{P} \)</li></ul><p>前五条都比较容易证明，稍微说一下最后一条的证明方式：</p><div>$$\begin{aligned}\textbf{P} \times (\textbf{Q} \times \textbf{P}) &= \textbf{P} \times [-(\textbf{P} \times \textbf{Q})] \\ &= [\textbf{P} \times -(\textbf{P} \times \textbf{Q})] \\ &= -[-(\textbf{P} \times \textbf{Q}) \times \textbf{P}] \\ &= (\textbf{P} \times \textbf{Q}) \times \textbf{P} \\ &= \textbf{P} \times \textbf{Q} \times \textbf{P}\end{aligned}\tag{1.35}$$</div><p>后面的具体计算式，是通过对三个分量分别求值得到的结果，不再赘述。</p><p>由定理1.9可以得到 <strong>叉积不满足交换律和结合律</strong>。</p><h2 id="4-向量空间"><a href="#4-向量空间" class="headerlink" title="4 向量空间"></a>4 向量空间</h2><p><strong>【定理1.10】</strong> 向量空间是一个集合V，元素成为向量，下面定义向量空间中的加法和乘数，并介绍一些性质：</p><ul><li>V对于加法运算封闭；</li><li>V对于乘数运算封闭；</li><li>V中存在一个零元素 \(\textbf{0}\)；</li><li>V中任意向量P存在向量Q使其 \( \textbf{P} + \textbf{Q} = \textbf{0}\)；</li><li>加法满足结合律；</li><li>乘数满足结合律；</li><li>乘数对于加法满足分配率，\( a(\textbf{P} + \textbf{Q}) = a\textbf{P} + a\textbf{Q}\)；</li><li>系数加法对于乘数满足分配率，\( (a + b)\textbf{P} = a\textbf{P} + b\textbf{P}\)。</li></ul><p>将由n元组组成的向量空间记作 \(R^{n}\)，比如三维的向量空间记作\(R^{3}\)。</p><p>每一个向量空间都可以由一组向量的线性组合来生成，生成向量空间的向量组成为基。</p><p><strong>【定义1.11】</strong> 对于一组向量 {\( \textbf{e}_{1}, \textbf{e}_{2}, …, \textbf{e}_{n} \)}，<strong>如果不存在</strong>这样一组实数 {\(a_{1}, a_{2}, …, a_{n}\)}，其中<strong>至少有一个</strong> \(a_{i}\) 不为0，使得下式成立：</p><div>$$a_{1}\textbf{e}_{1} + a_{2}\textbf{e}_{2} + \cdots + a_{n}\textbf{e}_{n} = 0 \tag{1.40}$$</div><p><strong>则称这组向量线性无关，否则称向量组线性相关</strong>。</p><p>一个n维向量空间可以由n个线性无关的向量组成的向量集合生成，这个向量组成为基。</p><p><strong>【定义1.12】</strong> 向量空间V的基B是一个由n个线性无关的向量组成的集合，即 \(\textbf{B}\)={\(\textbf{e}_{1}, \textbf{e}_{2}, …, \textbf{e}_{n} \)}，对于向量空间V中的任意一个元素P，都存在一组实数使得：</p><div>$$\textbf{P} = a_{1}\textbf{e}_{1} + a_{2}\textbf{e}_{2} + \cdots + a_{n}\textbf{e}_{n} \tag{1.41}$$</div><p>任意空间向量\(R^{n}\)都具有无限个基，对基的形式进行一些限定后，可以使基具有特定的性质。</p><p><strong>【定义1.13】</strong> 对于向量空间的基\(\textbf{B}\)={\(\textbf{e}_{1}, \textbf{e}_{2}, …, \textbf{e}_{n} \)}，如果对于任意 \(i \neq j\) 都有 \(\textbf{e}_{i} \cdot \textbf{e}_{j} = 0\)，则该基为正交基。</p><p><strong>【定理1.14】</strong> 对于给定的两个向量 \(\textbf{e}_{1}\) 和 \(\textbf{e}_{2}\)， 如果\(\textbf{e}_{1} \cdot \textbf{e}_{2} = 0\)，则\(\textbf{e}_{1}\) 和 \(\textbf{e}_{2}\)线性无关。</p><p>对基的另一个形式限定就是基的所有向量都具有单位长度（更简单化了），引入Kronecker delta符号 \(\delta_{ij}\)，定义如下：</p><div>$$\delta_{ij} =\left\{\begin{aligned} 1, i&=j  \\ 0, i&\neq j\end{aligned}\right.\tag{1.42}$$</div><p><strong>【定理1.15】</strong> 如果对于每一对 \((i, j)\) 有 \(\textbf{e}_{i} \cdot \textbf{e}_{j} = \delta_{ij}\)，则基 \(\beta\)={\(\textbf{e}_{1}, \textbf{e}_{2}, …, \textbf{e}_{n} \)}称为向量空间的正交规范基。</p><p>显然向量组{\(\textbf{i}, \textbf{j}, \textbf{k}\)}是\(R^{3}\)的一个正交规范基。</p><p>有一个方法可以将具有n个线性无关向量的向量组转换为向量空间\(R^{n}\)的正交基，基本思想是减去向量在前面每个向量上的投影，结果肯定和前面所有的向量正交。</p><p><strong>【定理1.16】</strong> <strong>Gram-Schmidt 正交规范化：</strong> 对于由n个线性无关想了组成的向量组\(\textbf{B}\)={\(\textbf{e}_{1}, \textbf{e}_{2}, …, \textbf{e}_{n} \)}，算法可以产生向量组\(\beta\)={\(\textbf{e}_{1}^{‘}, \textbf{e}_{2}^{‘}, …, \textbf{e}_{n}^{‘} \)}，当 \(i \neq j\)时，\(\textbf{e}_{i}^{i} \cdot \textbf{e}_{j}^{i} = 0\)。</p><ol><li>设 \(\textbf{e}_{1}^{‘} = \textbf{e}_{1}\)；</li><li>从i=2开始；</li><li>从\(\textbf{e}_{i}\)中减去\(\textbf{e}_{i}\)在向量\(\textbf{e}_{1}^{‘}, \textbf{e}_{2}^{‘}, …, \textbf{e}_{i-1}^{‘} \)上地投影，结果为\(\textbf{e}_{i}^{‘}\)，即</li></ol><div>$$\textbf{e}_{i}^{'} =\textbf{e}_{i} - \sum_{k=1}^{i-1} proj_{\textbf{e}_{k}} \textbf{e}_{i} =\textbf{e}_{i} - \sum_{k=1}^{i-1} \frac{\textbf{e}_{i} \cdot \textbf{e}_{k}}{\textbf{e}_{k}^{2}} \textbf{e}_{k} \tag{1.43}$$</div><ol start="4"><li>如果i &lt; n，i加1，重复步骤3。</li><li>如果需要进一步生成正交规范基，就对每个\(\textbf{e}_{i}^{‘}\)进行规范化。</li></ol>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;对于成功的3D程序猿，掌握如何进行向量运算是一种基本的技能要求。&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="3D游戏与图形学的数学" scheme="https://yumi-cn.github.io/categories/3D%E6%B8%B8%E6%88%8F%E4%B8%8E%E5%9B%BE%E5%BD%A2%E5%AD%A6%E7%9A%84%E6%95%B0%E5%AD%A6/"/>
    
    
    <category term="笔记" scheme="https://yumi-cn.github.io/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>《剑指Offer》第2章笔记 数组</title>
    <link href="https://yumi-cn.github.io/2020/11/26/s2o-c2-array/"/>
    <id>https://yumi-cn.github.io/2020/11/26/s2o-c2-array/</id>
    <published>2020-11-26T13:57:25.000Z</published>
    <updated>2020-11-28T14:12:10.637Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>数据结构是技术面的重点，主要围绕数组、字符串、链表、树、栈以及队列这几种常见的数据结构展开。</p></blockquote><a id="more"></a><p>嗯，除了语言和算法以外的最重要的（废话）。</p><hr><p>数组的一些特点（主要是指C/C++中的基础数组类型）：</p><ul><li>连续的内存，按照顺序存储；</li><li>创建时需要指定数组的容量大小；</li><li><code>O(1)</code>时间读/写任何位置元素；</li></ul><p>为了解决基础数组空间效率不高的问题，人们设计了动态数组，比如 <code>C++ STL</code> 中的 <code>vector</code> ，其中为了避免空间浪费，先为数组开辟小空间，当数据数目超过容量时，再重新分配一块更大的空间，把之间的数据复制到新的数组中，再把之前的内存释放（一般没有延续之前地址往后申请内存的操作，所以只能整块申请，然后再释放掉新的），但是这样就会带来内存空间申请和数据迁移的时间开销，因此使用动态数组要尽量减少改变数组容量大小的操作。</p><blockquote><p>在C/C++中，数组和指针既相互关联又有区别。</p></blockquote><p>声明一个数组时，数组的名字也是一个指针（不可修改的指针变量），该指针指向数组的第一个元素。需要注意的是，C/C++不会主动记录数组的大小，所以在访问数组元素时，程序要确保不会超过边界。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">get_size</span><span class="params">(<span class="keyword">int</span> data[])</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">sizeof</span>(data);</span><br><span class="line">&#125;Error: Cannot find module &#x27;gulplog&#x27;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> data1[] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line">  <span class="keyword">int</span> size1 = <span class="keyword">sizeof</span>(data1);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span>* data2 = data1;</span><br><span class="line">  <span class="keyword">int</span> size2 = <span class="keyword">sizeof</span>(data2);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span> size3 = get_size(data1);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%d, %d, %d&quot;</span>, size1, size2, size3);</span><br><span class="line">  <span class="comment">// 20, 4, 4</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>在上面的代码中：</p><ul><li><code>sizeof(data1) == 20</code>：<code>sizeof(data1)</code>求数组的大小（字节数），<code>data1</code>包含5个整数，每个整数4字节，所以20字节；</li><li><code>sizeof(data2) == 4</code>：<code>data2</code>声明是指针，尽管指向了数组指针，但本质仍然是指针，在32位系统上，对任意指针求<code>sizeof</code>都是4(32位系统是4个字节的地址)；</li><li><code>get_size(data1) == 4</code>：在C/C++中，数组作为函数参数传递时，会退化为同类型的指针，尽管函数声明的是数组参数，但还是会退化为指针（语言概念特色），所以结果仍然是4。</li></ul><hr><blockquote><p>面试题3 题目一：找出数组中重复的数字。</p></blockquote><p>数组长度n，数字都在 <code>0</code> - <code>n-1</code> 的范围内，数组中某些数字重复，但不知道有几个数字重复，请找出数组中任意一个重复数字；例如<code>&#123;2, 3, 1, 0, 2, 5, 3&#125;</code>，重复数字2或者3。</p><ul><li><strong>思路1</strong>：简单的排序再搜索就可以，但需要 <code>O(nlogn)</code> 的时间开销；</li><li><strong>改进思路2</strong>：常用的一种优化思路是使用哈希表，从头到尾记录所有数字的出现次数，如果次数大于2就是重复的数字，时间开销降低到了 <code>O(n)</code> ，但凭空多了哈希表的 <code>O(n)</code> 开销；</li></ul><p>大部分的人都能想到第二种方法，然后书的作者会介绍第三种方法：</p><blockquote><p>数字都在0~n-1的范围内，如果数组不重复，则数字i出现在下标i的位置，如果重复，则某些位置有多个数字，同时有些位置没有数字。</p></blockquote><p>但我觉得对这种方法的阐述，<strong>稍微有点凭空跳脱</strong>，没有和之前提到的前两种思路有任何延续，所以一时可能较于难以理解这里的思路，尤其是之后的算法流程。</p><p>我们可以延续之前的<strong>改进思路2</strong>，使用哈希表的优点是时间开销少，缺点是多了空间开销，那么进一步的优化思路是：<strong>如何减少空间上的开销？</strong></p><p>在已知数字出现在 <code>0</code> ~ <code>n-1</code> 范围内时，哈希表的一种简单实现是位置<code>i</code>存储数字<code>i</code>的出现频率：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> <span class="built_in">array</span>[<span class="number">5</span>] = &#123;<span class="number">1</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">0</span>, <span class="number">2</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> hash[<span class="number">5</span>] = &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>&#125;;</span><br><span class="line">... <span class="comment">// for num in array to finish hash</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; hash &lt;&lt; <span class="built_in">endl</span>; <span class="comment">// [1, 1, 1, 2, 0]</span></span><br></pre></td></tr></table></figure><p>那么，你可以想到的一种优化思路是：原数组存储的数字在读取过一次后其实就没有作用了，所以在数字<code>i</code>被读取了之后，<strong>将它“自己的位置”作为哈希表的存储位</strong>，<strong>不就不需要额外的空间了么</strong>？</p><p>更加细节地，在数字<code>i</code>被读取了过后，尽管它本身可能不在位置<code>i</code>上，可以把原本位置<code>i</code>的数字替换到当前的位置，最后我们使用位置<code>i</code>作为数字<code>i</code>的哈希表存储位，就完成了一步操作；对全数组的数字都执行这样的操作，就可以找出重复的数字了。</p><p>这个方法本质上是延续哈希表的思路，并且具体实现的方式你就会发现和作者提出的方法是一致的，所以我猜测作者的实质本意是将改进思路2的一种延续优化，但并没有在书中进行说明这种思路转变，稍微有点儿可惜。</p><p>PS：这样的改进思路在延续了简单哈希表实现的同时，也延续了这样的哈希表缺点，即无法处理<code>0</code> ~ <code>n-1</code> 范围以外的数字情况。</p><p>从头到尾依次扫描数组中的每个数字，当扫描到位置<code>i</code>的数字<code>m</code>时，判断<code>m==i</code>：</p><ul><li>如果相等，说明数字<code>i</code>在位置<code>i</code>上，继续执行；</li><li>如果不相等，将位置<code>m</code>上的数字交换到位置<code>i</code>上，位置<code>m</code>上放置了数字<code>m</code>，从位置<code>i</code>继续下一步判断；如果在交换之前发现，位置<code>m</code>上已经是数字<code>m</code>了，那么就说明数字<code>m</code>重复了，程序结束。</li></ul><p>一个栗子：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">1</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">0</span>, <span class="number">2</span>] <span class="comment">// i=0</span></span><br><span class="line">[<span class="number">3</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">0</span>, <span class="number">2</span>] <span class="comment">// i=0 1 on 1</span></span><br><span class="line">[<span class="number">0</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">2</span>] <span class="comment">// i=0 3 on 3</span></span><br><span class="line">[<span class="number">0</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">2</span>] <span class="comment">// i=0 0 on 0</span></span><br><span class="line">[<span class="number">0</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">2</span>] <span class="comment">// i=1 1 on 1</span></span><br><span class="line">[<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">3</span>] <span class="comment">// i=2 2 on 2</span></span><br><span class="line">[<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">3</span>] <span class="comment">// i=3 3 on 3</span></span><br><span class="line">[<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">3</span>] <span class="comment">// i=4 3 already on 3, 3 repeat</span></span><br></pre></td></tr></table></figure><p>完整代码实现：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find_repeat</span><span class="params">(<span class="keyword">int</span> <span class="built_in">array</span>[], <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(i &lt; len) &#123;</span><br><span class="line">        <span class="keyword">int</span> m = <span class="built_in">array</span>[i];</span><br><span class="line">        <span class="keyword">if</span>(m != i) &#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">array</span>[m] != m) &#123;</span><br><span class="line">                <span class="comment">// swap</span></span><br><span class="line">                <span class="keyword">int</span> temp = <span class="built_in">array</span>[m];</span><br><span class="line">                <span class="built_in">array</span>[m] = m;</span><br><span class="line">                <span class="built_in">array</span>[i] = temp;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> m;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> len;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> <span class="built_in">array</span>[] = &#123;<span class="number">1</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">0</span>, <span class="number">2</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> len = <span class="keyword">sizeof</span>(<span class="built_in">array</span>) / <span class="keyword">sizeof</span>(<span class="built_in">array</span>[<span class="number">0</span>]);</span><br><span class="line">    <span class="keyword">int</span> dup = find_repeat(<span class="built_in">array</span>, len);</span><br><span class="line">    <span class="keyword">if</span>(dup == len) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;No Repeat Number\n&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Repeat Number: %d\n&quot;</span>, dup);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在其中还可以加上前一节提到的安全、边界等问题的考虑，在下面贴的作者的实现里面可以看到：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">duplicate</span><span class="params">(<span class="keyword">int</span> <span class="built_in">array</span>[], <span class="keyword">int</span> len, <span class="keyword">int</span>* dup)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 考虑参数失效</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">array</span> == <span class="literal">nullptr</span> || len &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 考虑超过边界</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">array</span>[i] &lt; <span class="number">0</span> || <span class="built_in">array</span>[i] &gt; len - <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 实现比较优雅 流程相同</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="built_in">array</span>[i] != i) &#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">array</span>[i] == <span class="built_in">array</span>[<span class="built_in">array</span>[i]]) &#123;</span><br><span class="line">                *dup = <span class="built_in">array</span>[i];</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// swap</span></span><br><span class="line">                <span class="keyword">int</span> temp = <span class="built_in">array</span>[i];</span><br><span class="line">                <span class="built_in">array</span>[i] = <span class="built_in">array</span>[temp];</span><br><span class="line">                <span class="built_in">array</span>[temp] = temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><blockquote><p>面试题3 题目二：不修改数组找出重复的数字。</p></blockquote><p>在长度n+1的数组里的所有数字都在1~n的范围内，所以数组至少有一个数字是重复的。请找出数组中任意一个重复的数字，但不能修改输入的数组。</p><p>这一题虽然可以像题目一那样，只需要多开辟一个n+1长度的辅助数组，用来解决问题，但是这样就多了O(n)的空间开销。</p><p>一般在这种限定情况下，很难再和题目一一样做到时间、空间开销非常小的情况下完成任务，所以可以退一步，不需要缩减到O(n)时间，比如维持和快排复杂度O(nlogn)相同情况下，达成O(1)的空间开销也是一种优化的思路。</p><p>因为出发点不同，我们再次退回到最简单的方法：</p><ul><li>没有额外的空间帮助记录时，就只能每次判断一个数字是否有重复，即判断n次，每次有n长度的遍历开销，也就是O(n^2)；</li></ul><p>所以有<strong>两个优化的方向</strong>：（1）减少判断的次数n；（2）减少遍历长度n。</p><p>在没有额外信息辅助的情况下，优化（2）一般是很难做的（因为每个数只有遍历了全部才知道是否有重复），所以我们可以尝试优化（1）的部分。</p><p>最简单思路下，只有遍历了1~n的n个数在数组中的情况，才能知道谁重复了，我们可以用一些技巧来减少需要判断的次数。</p><p>其实非常巧妙，这条技巧就在题目中：“1~n范围内的数，在长度n+1的数组中必然存在一个重复”，这个命题成立的原因是，如果你遍历一次数组，统计1~n范围内数字的出现次数(n+1)，出现情况是大于n的（这里的n指1~n的这个范围长度），进一步地推广到一个普适命题“i~j范围内的数，在长度n+1的数组中，如果出现次数大于(j-i+1)，那必然存在重复”；</p><p>也就是意味着我们只用使用一次O(n)的遍历时间，就可以确定一个范围的数字是否存在重复。这样的性质可以让我们不断地缩小所需要判断的数字范围，这也就是时间开销上的优化。</p><p>具体地，我们可以联想到二分法：</p><ul><li>一开始将范围1~n分为两部分，一半是1~m，另一半是m+1~n；</li><li>如果范围1~m的数字的统计次数大于m，则这个范围内有重复的数字；否则另一半m+1~n的区间里一定有包含重复的数字；</li><li>继续二分存在重复数字的范围，重复步骤；</li><li>直到确定到某个重复数字。</li></ul><p>比如说题目给的例子{ 2, 3, 5, 4, 3, 2, 6, 7 }：</p><ul><li>[1-4]范围的数字出现5次，[5-7]范围的数字出现3次，重复在[1-4];</li><li>[1-2]范围的数字出现2次，[3-4]范围的数字出现3次，重复在[3-4]；</li><li>[3]数字出现2次，[4]数字出现1次，重复数字是3。</li></ul><p>然后简单分析一下时间复杂度，每次遍历统计的时间开销不变O(n)，因为数字范围二分，一共需要走O(logn)步，所以在O(nlogn)时间中可以找出重复数字。</p><p>完整代码实现：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">is_repeat</span><span class="params">(<span class="keyword">int</span> <span class="built_in">array</span>[], <span class="keyword">int</span> len, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">array</span>[i] &lt;= end &amp;&amp; <span class="built_in">array</span>[i] &gt;= start) &#123;</span><br><span class="line">            count += <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count &gt; (end - start + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find_repeat</span><span class="params">(<span class="keyword">int</span> <span class="built_in">array</span>[], <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> start = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> end = len<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">while</span>(end != start) &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = (end + start) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(is_repeat(<span class="built_in">array</span>, len, start, mid)) &#123;</span><br><span class="line">            end = mid;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            start = mid+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> start;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> <span class="built_in">array</span>[] = &#123;<span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">6</span>, <span class="number">7</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> len = <span class="keyword">sizeof</span>(<span class="built_in">array</span>) / <span class="keyword">sizeof</span>(<span class="built_in">array</span>[<span class="number">0</span>]);</span><br><span class="line">    <span class="keyword">int</span> dup = find_repeat(<span class="built_in">array</span>, len);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Repeat Number: %d\n&quot;</span>, dup); <span class="comment">// 3</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Tips：上述代码没有考虑一些安全、边界问题，所以比较简短。</p><p>需要指出的一点是，上面的使用的这种方法不能保证找出所有重复的数字，例如其中的2也是重复数字，但是算法只找出了3，一个原因是因为只会检查其中一半范围，例如检查到前一半有重复的时候，就不会再检查后一半范围了，另一个原因是算法无法确定是其中一个数字出现2次还是几次。</p><hr><blockquote><p>面试题4：二维数组中的查找</p></blockquote><p>在一个二维整数数组中，每一行从左到右递增，每一列从上到下递增，判断数组中是否含有指定数字。</p><p>例如：</p><div>$$\begin{matrix}1 & 2 & 8 & 9 \\2 & 4 & 9 & 12 \\4 & 7 & 10 & 13 \\6 & 8 & 11 & 15\end{matrix}$$</div><p>当一个数和矩阵中间的一个数比较时，除了相等，还有两种情况：</p><ul><li>(a)当查询数字<strong>小于</strong>目标数字时，说明目标数字<strong>一定不会出现在左上角</strong>，剩下需要判断的区域在其右边和下边；</li><li>(b)当查询数字<strong>大于</strong>目标数字时，说明目标数字<strong>一定不会出现在右下角</strong>，剩下需要判断的区域在其左边和上边。</li></ul><div align="center"><p><img src="/images/s2o-c2-array-cv4.jpg" alt="比较的两种情况"></p></div><p>当我们按照常规思路，尝试从<code>(0,0)</code>出发，向右下角进行搜索时，我们跳转到下一格只有通过2种方式，从上转移到下，和从左转移到右，如果我们把已遍历的位置称为“已知信息”，我们可以看到这种搜索方式，<strong>大部分“已知信息”都集中在左上部</strong>，这在比较出现的两种情况中，要么无法提供任何信息，要么只能提供重叠区域的信息，<strong>无法让转移确定下一次的方向</strong>。</p><p>所以为了<strong>避免“已知信息”的浪费</strong>，我们可以尝试从右上角<code>(0, n-1)</code>出发，向左下角进行搜索，这样会提供更多的信息，如果发生向下转移，代表上边没有比目标数更大的，如果发生向左转移，代表右边的数比目标数更大，所以导致更加明确的在左下角区域中搜索目标数。</p><div align="center"><p><img src="/images/s2o-c2-array-cv4-2.jpg" alt="例子"></p></div><p>完整代码实现：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> matrix[][<span class="number">4</span>], <span class="keyword">int</span> rows, <span class="keyword">int</span> cols, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> j = cols - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(i &lt; rows &amp;&amp; j &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span>(matrix[i][j] &lt; target) &#123;</span><br><span class="line">            i++;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(matrix[i][j] &gt; target) &#123;</span><br><span class="line">            j--;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> matrix[][<span class="number">4</span>] = &#123;</span><br><span class="line">        &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">8</span>, <span class="number">9</span>&#125;,</span><br><span class="line">        &#123;<span class="number">2</span>, <span class="number">4</span>, <span class="number">9</span>, <span class="number">12</span>&#125;,</span><br><span class="line">        &#123;<span class="number">4</span>, <span class="number">7</span>, <span class="number">10</span>, <span class="number">13</span>&#125;,</span><br><span class="line">        &#123;<span class="number">6</span>, <span class="number">8</span>, <span class="number">11</span>, <span class="number">15</span>&#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">int</span> target = <span class="number">7</span>;</span><br><span class="line">    <span class="keyword">if</span>(find(matrix, <span class="number">4</span>, <span class="number">4</span>, target)) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Found!\n&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Not Found!\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;数据结构是技术面的重点，主要围绕数组、字符串、链表、树、栈以及队列这几种常见的数据结构展开。&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="剑指Offer" scheme="https://yumi-cn.github.io/categories/%E5%89%91%E6%8C%87Offer/"/>
    
    
    <category term="笔记" scheme="https://yumi-cn.github.io/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>《剑指Offer》第2章笔记 编程语言</title>
    <link href="https://yumi-cn.github.io/2020/11/25/s2o-c2-lg/"/>
    <id>https://yumi-cn.github.io/2020/11/25/s2o-c2-lg/</id>
    <published>2020-11-25T12:57:25.000Z</published>
    <updated>2020-11-28T09:20:58.171Z</updated>
    
    <content type="html"><![CDATA[<p>第2章主要围绕<strong>编程语言</strong>、<strong>数据结构</strong>和<strong>算法</strong>，介绍技术面所需要的“基础知识”。</p><a id="more"></a><h2 id="编程语言"><a href="#编程语言" class="headerlink" title="编程语言"></a>编程语言</h2><p>书里代码都是用 <code>C/C++/C#</code> 实现的，后面分别从 <code>C++</code> 和 <code>C#</code> 语言的角度来讲述其中一些被问道的细节点，这样的细节点因为篇幅限制，不可能都写进书里，所以还需要通过阅读对应编程语言的书籍来进阶了解，同时其他语言的使用者也可以从其中窥探到面试官在针对语言掌握的考量时，都是从什么样的角度出发的。</p><h3 id="C"><a href="#C" class="headerlink" title="C++"></a>C++</h3><p>通常语言面试的问题有3种类型：</p><ol><li>对于语言中概念的理解程度；</li><li>面对代码，分析运行结果（或错误）；</li><li>在上下文环境中，定义类型或实现函数。</li></ol><p>作者推荐的几本C++书，根据自己的情况选择阅读顺序：</p><ul><li><strong>《Effective C++》</strong>：书中列举了C++经常出现的问题以及解决这些问题的技巧（大多是面试官比较喜欢问的方向），适合面试之前突击C++；</li><li><strong>《C++ Primer》</strong>：人称C++全书，适合全面了解的时候阅读，也可以当作宝典查询；</li><li><strong>《深度探索C++对象模型》</strong>：深度了解C++对象的内部机制，介绍很多较为底层的知识点；</li><li><strong>《The C++ Programming Language》</strong>：C++圣经（大概），适合全面深入掌握C++。</li></ul><p>下面通过一道面试题（第3种类型）来表现一下这类题目是如何考查语言知识点的。</p><blockquote><p>面试题1：赋值运算符函数，如下为类型CMyString的声明，请为该类型添加赋值运算符函数。</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CMyString</span> &#123;</span></span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    CMyString(<span class="keyword">char</span>* pData=<span class="literal">nullptr</span>);</span><br><span class="line">    CMyString(<span class="keyword">const</span> CMyString&amp; str);</span><br><span class="line">    ~CMyString(<span class="keyword">void</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">char</span>* m_pData;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>Tips：赋值运算符主要负责变量在进行赋值 <code>=</code> 运算时，如何处理变量对象内部成员变化。</p><p>定义C++中的<strong>赋值运算符</strong>函数时，需要关注点有：</p><ul><li><strong>返回值类型声明为引用，函数结束前返回实例自身的引用</strong>，因为返回引用才允许连续赋值的情况，例如 <code>str1 = str2 = str3</code>，否则无法通过编译；</li><li>把<strong>传入的参数类型声明为常量引用</strong>，如果不是引用，形参到实参传递会调用一次复制构造函数（函数的传值引用），引用可以避免这样的开销；同时因为赋值运算并不会修改传入的实例的状态，所以应进一步加上 <code>const</code> 关键字；</li><li><strong>释放实例自身已有的内存</strong>，主要在对象有动态分配内存情况下考虑，如果忘记在分配新内存前释放旧内存空间，程序旧出现了内存泄漏(memory leakge)，这块内存无法被回收使用（资源浪费、占用空间导致空间不够用）；</li><li><strong>判断传入参数和当前实例</strong>(*this)是不是同一个实例，是则不进行赋值，如果不判断就直接赋值，在同一个实例情况下，会导致在还没有拷贝到传入参数（自己）的内存时，就释放自己的内存，这也就导致传入参数的内存被释放了（因为函数是传引用），最后找不到待赋值的内容。</li></ul><p>经典解法：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line">CMyString&amp; CMyString::<span class="keyword">operator</span>=(<span class="keyword">const</span> CMyString&amp; str) &#123;</span><br><span class="line">  <span class="keyword">if</span>(<span class="keyword">this</span> == &amp;str) &#123;  <span class="comment">// 对象的 this 是一个地址</span></span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;     <span class="comment">// 传对象 而不是地址</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">delete</span> []m_pData;   <span class="comment">// 数组的释放方式</span></span><br><span class="line">  m_pData = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">  m_pData = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="built_in">strlen</span>(str.m_pData) + <span class="number">1</span>]; <span class="comment">// 申请新空间，多的1位给&#x27;\0&#x27;</span></span><br><span class="line">  <span class="built_in">strcpy</span>(m_pData, str.m_pData); <span class="comment">// 复制 赋值</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果对自己有更高的要求，应该再进一步地考虑其中涉及到的问题。</p><p>前面的函数中，<strong>分配内存之前先释放了内存</strong>，如果在分配内存时，内存不足就会导致 <code>new char</code> 排除异常，<code>m_pData</code>将是一个空指针，并且无法回退到之前的结果，也就是说一旦赋值运算符内部抛出了异常，实例不再保持有效的状态（并不是原有的状态），这违背了异常安全性（Exception Safety）原则（正常情况下，如果抛出异常也不应该导致内容被错误操作）。</p><ul><li>简单的方法是先用 <code>new</code> 分配新内容，再 <code>delete</code> 释放已有的；</li><li>更好的办法是<strong>创建一个临时实例</strong>，再交换临时实例和原来的实例。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line">CMyString&amp; CMyString::<span class="keyword">operator</span>=(<span class="keyword">const</span> CMyString&amp; str) &#123;</span><br><span class="line">  <span class="keyword">if</span>(<span class="keyword">this</span> == &amp;str) &#123;</span><br><span class="line">    CMyString tmp(str); <span class="comment">// 复制构造函数</span></span><br><span class="line">    <span class="built_in">std</span>::swap(m_pData, tmp.m_pData); <span class="comment">// 交换地址</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当 <code>tmp</code> 局部变量遇到 <code>if</code> 结束时，会自动调用它的析构函数，会把交换下来的 <code>this</code> 的 <code>m_pData</code> 所指向的内存释放掉；在新的代码中，在复制构造函数中分配内存，如果由于内存不足抛出异常时，由于此时还没有修改原来的实例状态，实例的状态依旧是有效的（原有的），也就保证了异常安全性。</p><p>完整代码（包含所有实现和测试）：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CMyString</span> &#123;</span></span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    CMyString(<span class="keyword">char</span>* pData); <span class="comment">// 第一个参数设定默认值会导致无法通过编译</span></span><br><span class="line">    CMyString(<span class="keyword">const</span> CMyString&amp; str);</span><br><span class="line">    ~CMyString(<span class="keyword">void</span>);</span><br><span class="line">    CMyString&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> CMyString&amp; str); <span class="comment">// 赋值运算符函数声明</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">void</span>)</span></span>; <span class="comment">// 标准输出函数</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">char</span>* m_pData;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 构造函数</span></span><br><span class="line">CMyString::CMyString(<span class="keyword">char</span>* pData) &#123;</span><br><span class="line">    <span class="keyword">if</span>(pData != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        m_pData = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="built_in">strlen</span>(pData) + <span class="number">1</span>];</span><br><span class="line">        <span class="built_in">strcpy</span>(m_pData, pData);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 复制构造函数</span></span><br><span class="line">CMyString::CMyString(<span class="keyword">const</span> CMyString&amp; str) &#123;</span><br><span class="line">    <span class="keyword">if</span>(str.m_pData != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        m_pData = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="built_in">strlen</span>(str.m_pData) + <span class="number">1</span>];</span><br><span class="line">        <span class="built_in">strcpy</span>(m_pData, str.m_pData);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 析构函数</span></span><br><span class="line">CMyString::~CMyString(<span class="keyword">void</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span>(m_pData != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="keyword">delete</span> []m_pData;</span><br><span class="line">        m_pData = <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CMyString::print</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; m_pData &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 赋值运算符函数</span></span><br><span class="line">CMyString&amp; CMyString::<span class="keyword">operator</span>=(<span class="keyword">const</span> CMyString&amp; str) &#123;</span><br><span class="line">  <span class="keyword">if</span>(<span class="keyword">this</span> != &amp;str) &#123;</span><br><span class="line">    CMyString tmp(str); <span class="comment">// 复制构造函数</span></span><br><span class="line">    <span class="built_in">std</span>::swap(m_pData, tmp.m_pData); <span class="comment">// 交换地址</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 测试CMyString</span></span><br><span class="line">    <span class="function">CMyString <span class="title">str1</span><span class="params">(<span class="string">&quot;Sword&quot;</span>)</span></span>;</span><br><span class="line">    <span class="function">CMyString <span class="title">str2</span><span class="params">(<span class="string">&quot;2&quot;</span>)</span></span>;</span><br><span class="line">    <span class="function">CMyString <span class="title">str3</span><span class="params">(<span class="string">&quot;Offer&quot;</span>)</span></span>;</span><br><span class="line">    str1 = str2 = str3;</span><br><span class="line">    str1.print(); <span class="comment">// Offer</span></span><br><span class="line">    str2.print(); <span class="comment">// Offer</span></span><br><span class="line">    str3.print(); <span class="comment">// Offer</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果完整的去实现上面这个题目，会引出一些非常容易忽略的细节问题（并且会导致严重错误），例如在初始化变量 <code>str1</code> 时，<code>CMyString str1(&quot;Sword&quot;);</code>，其中所传入的参数一般都是程序声明的<strong>字符串常量</strong>，如果在构造函数中简单地实现为：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Mem Error</span></span><br><span class="line">CMyString::CMyString(<span class="keyword">char</span>* pData) &#123;</span><br><span class="line">    m_pData = pData;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>就会导致赋值运算符函数中的析构函数调用过程发生错误，因为析构函数中的 <code>delete []m_pData</code> 的delete操作符只负责操作堆(Heap)中的内存区域(因为new只在堆里申请内存区域)，如果使用delete操作符去释放一个字符串常量指针所指向的区域，就会发生错误（大概是访问越界）。</p><p>所以在初始化时应该使用和delete对应的new操作，在堆中申请内存，再把传入参数的内容复制到其中。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">CMyString::CMyString(<span class="keyword">char</span>* pData) &#123;</span><br><span class="line">    <span class="keyword">if</span>(pData != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        m_pData = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="built_in">strlen</span>(pData) + <span class="number">1</span>];</span><br><span class="line">        <span class="built_in">strcpy</span>(m_pData, pData);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="C-1"><a href="#C-1" class="headerlink" title="C#"></a>C#</h3><p>因为还没怎么学C#的东西，C#的部分暂时跳过，记录一下推荐的书：</p><ul><li>《Professional C#》：特点是附录中有描述C#和其他语言的区别；</li><li>《CLR Via C#》：深入介绍C#，对CLR和.NET进行剖析，可以方便理解装箱卸箱、垃圾回收、反射等概念。</li></ul><blockquote><p>面试题2：实现Singleton模式（单例模式）</p></blockquote><p>暂时跳过。</p><p>涉及到设计模式的部分，列举一些可以参考阅读的资料：</p><ul><li>《设计模式：C++常用设计模式》：<a href="https://refactoringguru.cn/design-patterns/cpp">https://refactoringguru.cn/design-patterns/cpp</a> ；</li><li>《Head First 设计模式》：感觉是一本比较老的书，可能之后看看吧；</li><li>《Game Programming Patterns》：<a href="http://gameprogrammingpatterns.com/contents.html">http://gameprogrammingpatterns.com/contents.html</a> 。</li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;第2章主要围绕&lt;strong&gt;编程语言&lt;/strong&gt;、&lt;strong&gt;数据结构&lt;/strong&gt;和&lt;strong&gt;算法&lt;/strong&gt;，介绍技术面所需要的“基础知识”。&lt;/p&gt;</summary>
    
    
    
    <category term="剑指Offer" scheme="https://yumi-cn.github.io/categories/%E5%89%91%E6%8C%87Offer/"/>
    
    
    <category term="笔记" scheme="https://yumi-cn.github.io/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>《剑指Offer》第1章笔记</title>
    <link href="https://yumi-cn.github.io/2020/11/24/s2o-c1/"/>
    <id>https://yumi-cn.github.io/2020/11/24/s2o-c1/</id>
    <published>2020-11-24T04:57:25.000Z</published>
    <updated>2020-11-28T09:20:54.477Z</updated>
    
    <content type="html"><![CDATA[<p>第1章主要介绍的是几种面试方式的不同流程以及注意事项。</p><blockquote><p>“…技术面试中的5个要素，是全书的大纲,…”</p></blockquote><a id="more"></a><h2 id="远程桌面面试"><a href="#远程桌面面试" class="headerlink" title="远程桌面面试"></a>远程桌面面试</h2><ul><li>思考清楚再开始编码；</li><li>良好的代码命名和缩进对齐；</li><li>单元测试、断点调试。</li></ul><h2 id="面试的3个环节"><a href="#面试的3个环节" class="headerlink" title="面试的3个环节"></a>面试的3个环节</h2><p>行为面试、技术面试、应聘者提问。</p><h3 id="行为面试"><a href="#行为面试" class="headerlink" title="行为面试"></a>行为面试</h3><ol start="0"><li>自我介绍：30s-1min，介绍主要学习和工作经历；</li><li>项目经验：STAR模型描述项目经历；<ul><li>Situation：简短的项目背景；</li><li>Task：自己完成的任务，注意区分“参与”和“负责”；</li><li>Action：如何完成任务的，详细介绍自己完成任务的方式方法；</li><li>Result：自己的贡献，尝试量化自己的产出，让人直接接收到你的成果。</li></ul></li><li>掌握技能：注意区分“了解”、“熟悉”和“精通”；<ul><li>了解：上过课、看过书，但没有做过实际项目，通常只建议有用的时候再写；</li><li>熟悉：通常的情况，指能够独立解决大部分问题；</li><li>精通：得心应手，能够轻松回答领域内的绝大多数问题。</li></ul></li><li>为什么跳槽：尽量不说抱怨层面的原因，多从自我发展的角度阐述选择的理由。</li></ol><h3 id="技术面试"><a href="#技术面试" class="headerlink" title="技术面试"></a>技术面试</h3><p>平均1个小时的面试，技术面试会占据40-50分钟的时间。</p><p>总的来说面试官关注应聘者的5种素质：</p><ul><li>扎实的基础知识：编程语言、数据结构和算法；</li><li>能写高质量的代码：代码鲁棒性，边界考虑（另外还需要注意代码规范或者风格）；</li><li>分析问题的思路清晰：从简单完备的思路出发，用各种方法来尝试优化，例如画图形象化，举例具象化，分解简单化；</li><li>能够优化时间、空间效率：熟知数据结构优缺点，熟练掌握常用算法；</li><li>学习、沟通、综合能力。</li></ul><p>PS：5个要素分别对应本书的第2、3、4、5、6章节内容。</p><h3 id="应聘者提问"><a href="#应聘者提问" class="headerlink" title="应聘者提问"></a>应聘者提问</h3><p>如果觉得面试后临时想比较困难，可以在面试前提前准备一些问题。</p><p>主要围绕公司、职位、项目等工作上的事情，不太适合问较远较模糊或者和工薪相关的问题（之后再和HR聊也可以）。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;第1章主要介绍的是几种面试方式的不同流程以及注意事项。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;“…技术面试中的5个要素，是全书的大纲,…”&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="剑指Offer" scheme="https://yumi-cn.github.io/categories/%E5%89%91%E6%8C%87Offer/"/>
    
    
    <category term="笔记" scheme="https://yumi-cn.github.io/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>11月的计划</title>
    <link href="https://yumi-cn.github.io/2020/11/19/plan-2020-11/"/>
    <id>https://yumi-cn.github.io/2020/11/19/plan-2020-11/</id>
    <published>2020-11-18T16:00:00.000Z</published>
    <updated>2020-12-12T07:42:20.623Z</updated>
    
    <content type="html"><![CDATA[<p>11月大概还剩下一周的时间，主要是在尝试起步学一些东西：</p><ul><li>《剑指Offer》：大概前几章，简单过一下摸一下这本书的安排规律，每章尽量写一点浓缩知识点；</li><li>《3D游戏与计算机图形学中的数学方法》：之前把Games101课程简单过了一下，再通过刷这本书巩固一下基础的数学。</li></ul><a id="more"></a><p>12月的初步规划：</p><ul><li>《剑指Offer》；</li><li>《3D游戏与计算机图形学中的数学方法》；</li><li>《Fundamentals of Computer Graphics》 。</li></ul><p>1月的初步规划：</p><ul><li>《Effictive C++》；</li><li>《Real Time Rendering 4th》；</li><li>《游戏引擎架构》。</li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;11月大概还剩下一周的时间，主要是在尝试起步学一些东西：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;《剑指Offer》：大概前几章，简单过一下摸一下这本书的安排规律，每章尽量写一点浓缩知识点；&lt;/li&gt;
&lt;li&gt;《3D游戏与计算机图形学中的数学方法》：之前把Games101课程简单过了一下，再通过刷这本书巩固一下基础的数学。&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="计划-Flags" scheme="https://yumi-cn.github.io/categories/%E8%AE%A1%E5%88%92-Flags/"/>
    
    
  </entry>
  
</feed>
