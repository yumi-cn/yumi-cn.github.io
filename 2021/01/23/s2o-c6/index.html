<!doctype html><html lang="zh"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1"><meta><title>《剑指Offer》第6章笔记 各项能力 - 画码余生</title><link rel="manifest" href="/manifest.json"><meta name="application-name" content="画码余生"><meta name="msapplication-TileImage" content="/images/favicon.ico"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="画码余生"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta description="沟通和学习能力是面试中关键的考查点。"><meta property="og:type" content="blog"><meta property="og:title" content="《剑指Offer》第6章笔记 各项能力"><meta property="og:url" content="https://yumi-cn.github.io/2021/01/23/s2o-c6/"><meta property="og:site_name" content="画码余生"><meta property="og:description" content="沟通和学习能力是面试中关键的考查点。"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://yumi-cn.github.io/images/s2o-c6-f1.jpg"><meta property="og:image" content="https://yumi-cn.github.io/images/s2o-c6-f2.jpg"><meta property="og:image" content="https://yumi-cn.github.io/images/s2o-c6-f3.jpg"><meta property="og:image" content="https://yumi-cn.github.io/images/s2o-c6-f4.jpg"><meta property="og:image" content="https://yumi-cn.github.io/images/s2o-c6-f5.jpg"><meta property="og:image" content="https://yumi-cn.github.io/images/s2o-c6-f6.jpg"><meta property="og:image" content="https://yumi-cn.github.io/images/s2o-c6-f7.jpg"><meta property="article:published_time" content="2021-01-23T08:04:48.000Z"><meta property="article:modified_time" content="2021-01-23T08:07:25.468Z"><meta property="article:author" content="Yumiko"><meta property="article:tag" content="笔记"><meta property="twitter:card" content="summary"><meta property="twitter:image" content="/images/s2o-c6-f1.jpg"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"https://yumi-cn.github.io/2021/01/23/s2o-c6/"},"headline":"画码余生","image":["https://yumi-cn.github.io/images/s2o-c6-f1.jpg","https://yumi-cn.github.io/images/s2o-c6-f2.jpg","https://yumi-cn.github.io/images/s2o-c6-f3.jpg","https://yumi-cn.github.io/images/s2o-c6-f4.jpg","https://yumi-cn.github.io/images/s2o-c6-f5.jpg","https://yumi-cn.github.io/images/s2o-c6-f6.jpg","https://yumi-cn.github.io/images/s2o-c6-f7.jpg"],"datePublished":"2021-01-23T08:04:48.000Z","dateModified":"2021-01-23T08:07:25.468Z","author":{"@type":"Person","name":"Yumiko"},"description":"沟通和学习能力是面试中关键的考查点。"}</script><link rel="canonical" href="https://yumi-cn.github.io/2021/01/23/s2o-c6/"><link rel="alternate" href="/atom.xml" title="画码余生" type="application/atom+xml"><link rel="icon" href="/images/favicon.ico"><link rel="stylesheet" href="https://cdn.bootcdn.net/ajax/libs/font-awesome/5.15.1/css/all.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@9.12.0/styles/atom-one-light.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link rel="stylesheet" href="/css/default.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/css/justifiedGallery.min.css"><script src="https://cdn.jsdelivr.net/npm/pace-js@1.0.2/pace.min.js"></script><meta name="generator" content="Hexo 5.2.0"></head><body class="is-3-column"><nav class="navbar navbar-main"><div class="container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/"><img src="/images/logo.jpg" alt="画码余生" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">主页</a><a class="navbar-item" href="/archives">文章</a><a class="navbar-item" href="/categories">专栏</a><a class="navbar-item" href="/tags">主题</a><a class="navbar-item" href="/about">关于我</a></div><div class="navbar-end"><a class="navbar-item" target="_blank" rel="noopener" title="Github" href="https://github.com/yumi-cn"><i class="fab fa-github"></i></a><a class="navbar-item is-hidden-tablet catalogue" title="目录" href="javascript:;"><i class="fas fa-list-ul"></i></a><a class="navbar-item search" title="搜索" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-6-widescreen"><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time datetime="2021-01-23T08:04:48.000Z" title="2021-01-23T08:04:48.000Z">2021-01-23</time>发表</span><span class="level-item"><time datetime="2021-01-23T08:07:25.468Z" title="2021-01-23T08:07:25.468Z">2021-01-23</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/%E5%89%91%E6%8C%87Offer/">剑指Offer</a></span><span class="level-item">1 小时读完 (大约10117个字)</span></div></div><h1 class="title is-3 is-size-4-mobile">《剑指Offer》第6章笔记 各项能力</h1><div class="content"><blockquote><p>沟通和学习能力是面试中关键的考查点。</p></blockquote><a id="more"></a><h2 id="1-面试官谈能力"><a href="#1-面试官谈能力" class="headerlink" title="1 面试官谈能力"></a>1 面试官谈能力</h2><p>大佬们说的名言名句。</p><p>咕咕待更。</p><h2 id="2-沟通能力和学习能力"><a href="#2-沟通能力和学习能力" class="headerlink" title="2 沟通能力和学习能力"></a>2 沟通能力和学习能力</h2><ol><li>沟通能力</li></ol><p>随着软件、系统功能越来越复杂，开发团队的规模也随之扩张，开发者、测试者和项目经理之间的沟通交流也变得越来越重要。也正因如此，很多公司在面试的时候都会注意考查应聘者的沟通能力。这邀请应聘者无论是在<strong>介绍项目经验</strong>还是在<strong>介绍解题思路</strong>的时候，都需要<strong>逻辑清晰明了</strong>，<strong>语言详略得当</strong>，表述的时候<strong>重点突出、观点明确</strong>。</p><ol start="2"><li>学习能力</li></ol><p>计算机是一门更新速度很快的学科，每年都有新的技术不断涌现。因此，作为从业人员<strong>需要具备很强的学习能力</strong>，否则时间一长就会跟不上技术进步的步伐，也正是因为这个原因，IT公司在面试的时候，都会重视考查应聘者的学习能力。只有具备很强的学习能力及学习愿望的人，才能<strong>不断完善自己的知识结构，不断学习新的先进技术</strong>，让自己的职业生涯保持长久的生命力。</p><p>通常面试官有<strong>两种方法考查应聘者的学习能力</strong>。<strong>第一种方法</strong>是询问应聘者最近在<strong>看什么书或者在做什么项目、从中学到了哪些新技术</strong>。面试官可以用这个问题了解应聘者的学习愿望和学习能力。<strong>第二种方法是抛出一个新概念</strong>，接下来观察应聘者能不能在短时间内理解这个新概念并解决相关的问题。当面试官提出新概念时，他期待应聘者能够通过<strong>思考、提问、再思考的过程，理解它们并最终解决问题</strong>。</p><ol start="3"><li>善于学习、沟通的人也善于提问</li></ol><p>面试官提出一个新概念，应聘者没有听说过它，于是他在已有的理解基础上提出进一步地问题，在得到面试官答复之后，思考再提问，几个来回之后掌握了这个概念。这个过程就能体现应聘者的学习能力。建议应聘者在面试过程中遇到不明白的地方多提问，这样可以表现自己态度积极、求知欲望强烈（但是一些行业领域基础的东西不知道还是蛮尴尬的hhh）。</p><p>有些面试官故意一开始不把题目描述清楚，让题目存在一定的二义性，他期待应聘者可以一步步通过提问来弄明白题目的要求，这也是在考查应聘者的沟通能力（因为实际工作中也是这样的）。</p><h2 id="3-知识迁移能力"><a href="#3-知识迁移能力" class="headerlink" title="3 知识迁移能力"></a>3 知识迁移能力</h2><p>所谓学习能力，很重要的一点就是<strong>根据已经掌握的知识、技术，能够迅速学习、理解新的技术并运用到实际工作中去</strong>。大部分新的技术都不是凭空产生的，而是在已有技术的基础上发展起来的。这就要求我们能够把对已有技术的理解迁移到学习新技术的过程中去，也就是要具备很强的知识迁移能力。</p><p>面试官考查应聘者知识迁移能力的<strong>一种方法是把经典的问题稍作变换</strong>。这时候面试官期待应聘者能够找到和经典问题的联系，并从中受到启发，把解决经典问题的思路迁移过来解决新的问题。<strong>另一种方法是先问一个简单地问题</strong>，在应聘者答完简单地问题后，<strong>再追问一个相关的同时难度也更大的问题</strong>。这时候面试官希望应聘者能够总结前面解决简单问题的经验，把前面的思路、方法迁移过来。</p><p><strong>知识迁移能力的一种通俗的说法是“举一反三”的能力</strong>。<strong>面试题是刷不完的</strong>，不可能把所有的面试题都准备一遍，因此更重要的是每做一道面试题的时候，都要总结这道题的解法有什么特点，有哪些思路是可以应用到同类型的题目中去的。</p><h2 id="面试题53-59"><a href="#面试题53-59" class="headerlink" title="面试题53-59"></a>面试题53-59</h2><blockquote><p>面试题53：在排序数组中查找数字。</p></blockquote><p>题目一：数字在排序数组中出现的次数。</p><p>统计一个数字在排序数组中出现的次数，例如，输入排序数组<code>&#123;1,2,3,3,3,3,4,5&#125;</code>和3，由于3在这个数组中出现了4次，因此输出4。</p><p>最普通的遍历法时间复杂度<code>O(n)</code>，所以优化方法的时间复杂度肯定要优于<code>O(n)</code>。可以考虑用二分法方式寻找该数字的第一个位置和最后一个位置，然后就可以计算出出现次数了。在二分法时，首先找到有这个数的区间，当<code>mid</code>为寻找的目标数时，如果是寻找第一个位置，则看其左边是不是同样的数，如果是则在左侧继续寻找第一个位置，如果不是则<code>mid</code>就是第一个位置，寻找最后一个位置原理类似。</p><p>完整实现代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find_head</span><span class="params">(<span class="keyword">int</span>* data, <span class="keyword">int</span> start, <span class="keyword">int</span> end, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(start == end) &#123;</span><br><span class="line">        <span class="keyword">if</span>(data[start] == target) &#123;</span><br><span class="line">            <span class="keyword">return</span> start;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> mid = (start + end) / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span>(data[mid] == target) &#123;</span><br><span class="line">        <span class="keyword">if</span>(mid == <span class="number">0</span> || data[mid<span class="number">-1</span>] != target) &#123;</span><br><span class="line">            <span class="keyword">return</span> mid;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> find_head(data, start, mid<span class="number">-1</span>, target);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(data[mid] &lt; target) &#123;</span><br><span class="line">        <span class="keyword">return</span> find_head(data, mid+<span class="number">1</span>, end, target);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> find_head(data, start, mid<span class="number">-1</span>, target);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find_tail</span><span class="params">(<span class="keyword">int</span>* data, <span class="keyword">int</span> start, <span class="keyword">int</span> end, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(start == end) &#123;</span><br><span class="line">        <span class="keyword">if</span>(data[start] == target) &#123;</span><br><span class="line">            <span class="keyword">return</span> start;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> mid = (start + end) / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span>(data[mid] == target) &#123;</span><br><span class="line">        <span class="keyword">if</span>(mid == end || data[mid+<span class="number">1</span>] != target) &#123;</span><br><span class="line">            <span class="keyword">return</span> mid;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> find_tail(data, mid+<span class="number">1</span>, end, target);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(data[mid] &lt; target) &#123;</span><br><span class="line">        <span class="keyword">return</span> find_tail(data, mid+<span class="number">1</span>, end, target);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> find_tail(data, start, mid<span class="number">-1</span>, target);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">counts_in_order</span><span class="params">(<span class="keyword">int</span>* data, <span class="keyword">int</span> len, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(data == <span class="literal">nullptr</span> || len &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> head = find_head(data, <span class="number">0</span>, len<span class="number">-1</span>, target);</span><br><span class="line">    <span class="keyword">int</span> tail = find_tail(data, <span class="number">0</span>, len<span class="number">-1</span>, target);</span><br><span class="line">    <span class="keyword">if</span>(head == <span class="number">-1</span> || tail == <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> tail - head + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> data[] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Count:%d\n&quot;</span>, counts_in_order(data, <span class="number">8</span>, <span class="number">3</span>));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码中，<code>find_head</code>、<code>find_tail</code>都是二分查找算法在数组中查找数字，时间复杂度都是<code>O(logn)</code>，因此总的时间复杂度也是<code>O(logn)</code>。</p><p>题目二：<code>0~n-1</code>中缺失的数字。</p><p>一个长度<code>n-1</code>的递增排序数组中，所有数字都是唯一的，并且每个数字都在范围<code>0~n-1</code>中，在范围<code>0~n-1</code>内的n个数字中<strong>有且只有一个数字不在数组中</strong>，请找出这个数字。</p><p>最简单的方法是遍历数组求和，用<code>0~n-1</code>的总和<code>n(n-1)/2</code>相减就可以得到缺失的数字，但时间复杂度<code>O(n)</code>，可以观察<code>n-1</code>长度的数组，如果缺失了第<code>i</code>个数，由于排序的性质，对任意的<code>i&lt;j</code>第<code>j</code>个数会在<code>j-1</code>位置上，即不满足<code>j</code>在第<code>j</code>个位置上，所以问题转换为，找出第一个值和下标不相等的元素，利用二分法查找即可。</p><p>完整实现代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find_miss_num</span><span class="params">(<span class="keyword">int</span>* data, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(start == end) &#123;</span><br><span class="line">        <span class="keyword">if</span>(data[start] != start) &#123;</span><br><span class="line">            <span class="keyword">return</span> start;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> mid = (start + end) / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span>(data[mid] != mid) &#123;</span><br><span class="line">        <span class="keyword">if</span>(mid == start || data[mid<span class="number">-1</span>] == mid<span class="number">-1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> mid;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> find_miss_num(data, start, mid - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> find_miss_num(data, mid + <span class="number">1</span>, end);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find_miss_num</span><span class="params">(<span class="keyword">int</span>* data, <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(data == <span class="literal">nullptr</span> || len &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> find_miss_num(data, <span class="number">0</span>, len<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> data[] = &#123;<span class="number">0</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>&#125;;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Miss is %d\n&quot;</span>, find_miss_num(data, <span class="number">9</span>));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>题目三：数组中数值和下标相等的元素。</p><p>假设一个<strong>单调递增的数组</strong>里的每个元素都是整数并且<strong>唯一</strong>。请实现一个函数，找出数组中<strong>任意一个</strong>数值等于其下标的元素。例如，在数组<code>&#123;-3,-1,1,3,5&#125;</code>中，数字3和它的下标相等。</p><p>以<code>&#123;-3,-1,1,3,5&#125;</code>和<code>&#123;0,1,2,3,4&#125;</code>为例来分析，可以发现规律，<code>3</code>的左边都是<code>value &lt; index</code>，<code>3</code>的右边都是<code>value &gt; index</code>，根据这一点来判断二分查找的下一个位置。</p><p>完整实现代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find_index_eq_value</span><span class="params">(<span class="keyword">int</span>* data, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(start == end) &#123;</span><br><span class="line">        <span class="keyword">if</span>(data[start] == start) &#123;</span><br><span class="line">            <span class="keyword">return</span> start;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> mid = (start + end) / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span>(data[mid] == mid) &#123;</span><br><span class="line">        <span class="keyword">return</span> mid;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(data[mid] &lt; mid) &#123;</span><br><span class="line">        <span class="keyword">return</span> find_index_eq_value(data, mid + <span class="number">1</span>, end);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> find_index_eq_value(data, start, mid - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find_index_eq_value</span><span class="params">(<span class="keyword">int</span>* data, <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(data == <span class="literal">nullptr</span> || len &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> find_index_eq_value(data, <span class="number">0</span>, len<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> data[] = &#123;<span class="number">-3</span>, <span class="number">-1</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>&#125;;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Result: %d\n&quot;</span>, find_index_eq_value(data, <span class="number">5</span>));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><blockquote><p>面试题54：二叉搜索树的第K大节点。</p></blockquote><p>给定一棵二叉搜索树，请找出其中<strong>第K大的节点</strong>。例如在下图中的二叉搜索树，按节点数值大小顺序，第3大节点的值是4。</p><div align="center"><p><img src="/images/s2o-c6-f1.jpg"></p></div><p>书上的方法是直接简单的用二叉搜索树的性质，中序遍历即树中节点的递增排序，在中序遍历中找到第K大的节点。</p><p>完整实现代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> value;</span><br><span class="line">    node* pleft;</span><br><span class="line">    node* pright;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">node* <span class="title">init_node</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123; ... &#125;</span><br><span class="line"><span class="function">node* <span class="title">init_tree</span><span class="params">()</span> </span>&#123; ... &#125;</span><br><span class="line"></span><br><span class="line"><span class="function">node* <span class="title">find_kth_in_tree_core</span><span class="params">(node* proot, <span class="keyword">unsigned</span> <span class="keyword">int</span>&amp; k)</span> </span>&#123;</span><br><span class="line">    node* target = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="comment">// 中序遍历</span></span><br><span class="line">    <span class="keyword">if</span>(proot-&gt;pleft != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        target = find_kth_in_tree_core(proot-&gt;pleft, k);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(target == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="comment">// 没有在左子树中找到第k大</span></span><br><span class="line">        <span class="keyword">if</span>(k == <span class="number">1</span>) &#123;</span><br><span class="line">            target = proot;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 继续减少k</span></span><br><span class="line">        k--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(target == <span class="literal">nullptr</span> &amp;&amp; proot-&gt;pright != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        target = find_kth_in_tree_core(proot-&gt;pright, k);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> target;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">node* <span class="title">find_kth_in_tree</span><span class="params">(node* proot, <span class="keyword">unsigned</span> <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(proot == <span class="literal">nullptr</span> || k == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> find_kth_in_tree_core(proot, k);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    node* proot = init_tree();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%dth node is: %d&quot;</span>, <span class="number">3</span>, find_kth_in_tree(proot, <span class="number">3</span>)-&gt;value);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><blockquote><p>面试题55：二叉树的深度。</p></blockquote><p>题目一：二叉树的深度。</p><p>输入一棵二叉树的根节点，求该树的深度。从根节点到叶节点一次经过的节点（含根、叶节点）形成树的一条路径，<strong>最长路径的长度为树的深度</strong>。</p><p>节点定义如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> value;</span><br><span class="line">    node* pleft;</span><br><span class="line">    node* pright;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>思路比较简单，就是<strong>节点的深度等于左右子树的最大深度+1</strong>，递归地实现即可。</p><p>完整实现代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> value;</span><br><span class="line">    node* pleft;</span><br><span class="line">    node* pright;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">node* <span class="title">init_node</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123; ... &#125;</span><br><span class="line"><span class="function">node* <span class="title">init_tree</span><span class="params">()</span> </span>&#123; ... &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">tree_depth</span><span class="params">(node* proot)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(proot == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> left_depth = tree_depth(proot-&gt;pleft);</span><br><span class="line">    <span class="keyword">int</span> right_depth = tree_depth(proot-&gt;pright);</span><br><span class="line">    <span class="keyword">return</span> (left_depth &gt; right_depth) ? (left_depth + <span class="number">1</span>) : (right_depth + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    node* proot = init_tree();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Tree depth:%d\n&quot;</span>, tree_depth(proot));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>题目二：平衡二叉树。</p><p>输入一棵二叉树的根节点，<strong>判断该树是不是平衡二叉树</strong>。如果某二叉树中任意节点的左、右子树的深度相差不超过1，那么它就是一棵平衡二叉树。例如，下图就是一颗平衡二叉树。</p><div align="center"><p><img src="/images/s2o-c6-f2.jpg"></p></div><p>在题目一的基础上，在每个节点上一边判断是否平衡，同时一边返回他们的深度，如果是先检查深度，再去检查子树是否平衡，就会频繁多次的访问子节点，导致时间上的浪费。</p><p>完整实现代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> value;</span><br><span class="line">    node* pleft;</span><br><span class="line">    node* pright;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">node* <span class="title">init_node</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123; ... &#125;</span><br><span class="line"><span class="function">node* <span class="title">init_tree</span><span class="params">()</span> </span>&#123; ... &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">is_balanced</span><span class="params">(node* proot, <span class="keyword">int</span>* pdepth)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(proot == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        *pdepth = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> left, right;</span><br><span class="line">    <span class="keyword">if</span>(is_balanced(proot-&gt;pleft, &amp;left)</span><br><span class="line">       &amp;&amp; is_balanced(proot-&gt;pright, &amp;right)) &#123;</span><br><span class="line">        <span class="keyword">int</span> diff = left - right;</span><br><span class="line">        <span class="keyword">if</span>(diff &lt;= <span class="number">1</span> &amp;&amp; diff &gt;= <span class="number">-1</span>) &#123;</span><br><span class="line">            *pdepth = <span class="number">1</span> + (left &gt; right ? left : right);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">is_balanced</span><span class="params">(node* proot)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> depth = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> is_balanced(proot, &amp;depth);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    node* proot = init_tree();</span><br><span class="line">    <span class="keyword">if</span>(is_balanced(proot)) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Is Balanced.\n&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Is Not Balanced.\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><blockquote><p>面试题56：数组中数字出现的次数。</p></blockquote><p><strong>题目一</strong>：数组中只出现一次的两个数字。</p><p><strong>一个整型数组里除两个数字之外，其他数字都出现了两次</strong>。请写程序找出这<strong>两个只出现一次</strong>的数字。要求时间复杂度是<code>O(n)</code>，空间复杂度是<code>O(1)</code>。</p><p>这个题常规思路很难解决，需要使用到<strong>两个相同的数的异或为0</strong>这种知识点，首先把问题分解为<strong>在一个整数数组中，除了一个数字之外，其他都出现两次</strong>的一个子问题，对于这个子问题的求解方式是对所有数进行异或操作，最后结果数就是出现一次的数字（其中使用到了异或操作的交换律以及结合律，这里不再证明）。</p><p>再回到原始问题，看看有没有相同的思路。还是从头到尾异或每个数字，结果是两个只出现一次的数字的异或结果，因为其他数字都出现两次，在异或中全部抵消了。<strong>由于这两个数字不一样，所以异或的结果肯定不为0，至少有一位是1</strong>（这代表这两个数，一个在该位上为1，一个在该位上为0），我们在结果数字中找到第一个为1的位的位置，记为第n位。现在我们<strong>以第n位是不是1位标准把原数组中的数字分为两个子数组</strong>，第一个子数组中每个数字的第n位都是1，第二个子数组中每个数字的第n位都是0，这样两个不同的数字就分到了两个数组中，并且相同的数字一定会被分到一个数组中，也就<strong>拆分成了两个可以解决的子问题了</strong>。</p><p>完整实现代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 找到从右边数起的第一个1位（方便一点）</span></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">find_first_1_bit</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>((num &amp; <span class="number">1</span>) == <span class="number">0</span> &amp;&amp; index &lt; <span class="number">8</span> * <span class="keyword">sizeof</span>(<span class="keyword">int</span>)) &#123;</span><br><span class="line">        num = num &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        index++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> index;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">is_bit_1</span><span class="params">(<span class="keyword">int</span> num, <span class="keyword">unsigned</span> <span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    num = num &gt;&gt; index; <span class="comment">// 直接右移</span></span><br><span class="line">    <span class="keyword">return</span> (num &amp; <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> g_invalid_input = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">find_nums_appear_once</span><span class="params">(<span class="keyword">int</span> data[], <span class="keyword">int</span> len, <span class="keyword">int</span>* num1, <span class="keyword">int</span>* num2)</span> </span>&#123;</span><br><span class="line">    g_invalid_input = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span>(data == <span class="literal">nullptr</span> || len &lt; <span class="number">2</span> || len % <span class="number">2</span> != <span class="number">0</span>) &#123;</span><br><span class="line">        g_invalid_input = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> xor_result = <span class="number">0</span>; <span class="comment">// 异或初始值0</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">        xor_result ^= data[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> index_of_1 = find_first_1_bit(xor_result);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这里直接用一次O(n)来遍历，并不是显式地分为两个部分</span></span><br><span class="line">    <span class="comment">// 而是直接地根据位的情况来选择性异或，最后结果也一样</span></span><br><span class="line">    *num1 = *num2 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(is_bit_1(data[i], index_of_1)) &#123;</span><br><span class="line">            *num1 ^= data[i];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            *num2 ^= data[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> data[] = &#123;<span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">5</span>, <span class="number">3</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> num1 = <span class="number">0</span>, num2 = <span class="number">0</span>;</span><br><span class="line">    find_nums_appear_once(data, <span class="number">10</span>, &amp;num1, &amp;num2);</span><br><span class="line">    <span class="keyword">if</span>(g_invalid_input) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Error: Invalid Input.\n&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Num1: %d, Num2: %d\n&quot;</span>, num1, num2);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>题目二</strong>：数组中唯一只出现一次的数字。</p><p>在一个数组中<strong>除一个数字只出现一次之外</strong>，其他数字都<strong>出现了三次</strong>。请找出那个只出现一次的数字。</p><p><strong>如果一个数字出现三次，那么它的二进制表示的每一位（0或者1）也出现3次</strong>，如果把所有出现三次的数字的二进制表示的每一位分别都加起来，那么每一位的和都能被3整除。这样我们把数组中所有数字的二进制表示的每一位都加起来。如果某一位的和能被3整除，那么那个只出现一次的数字的二进制表示中对应的那一位就是0，否则是1。</p><p>完整实现代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> g_invalid_input = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find_num_appear_once</span><span class="params">(<span class="keyword">int</span> data[], <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">    g_invalid_input = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span>(data == <span class="literal">nullptr</span> || len &lt;= <span class="number">0</span> || len % <span class="number">3</span> != <span class="number">1</span>) &#123;</span><br><span class="line">        g_invalid_input = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 0 是最高位， 31 是最低位</span></span><br><span class="line">    <span class="comment">// 注意int的最高位是符号位，这里连同符号位一起处理了</span></span><br><span class="line">    <span class="keyword">int</span> bit_sum[<span class="number">32</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> bit_mask = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">31</span>; j &gt;= <span class="number">0</span>; j--) &#123;</span><br><span class="line">            <span class="keyword">int</span> bit = data[i] &amp; bit_mask;</span><br><span class="line">            <span class="keyword">if</span>(bit != <span class="number">0</span>) &#123;</span><br><span class="line">                bit_sum[j]++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 这里是基于bit_mask=1的左移</span></span><br><span class="line">            bit_mask = bit_mask &lt;&lt; <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这里使用的还原法是基于位移操作的</span></span><br><span class="line">    <span class="comment">// 要比使用2幂级更加高效，同时符号位处理也更加自然</span></span><br><span class="line">    <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">32</span>; ++i) &#123;</span><br><span class="line">        result = result &lt;&lt; <span class="number">1</span>; <span class="comment">// 先左移，空出最低位</span></span><br><span class="line">        result += bit_sum[i] % <span class="number">3</span>; <span class="comment">// 载入当前最低位</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> data[] = &#123;<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">-2</span>, <span class="number">-2</span>, <span class="number">-2</span>, <span class="number">-100</span>, <span class="number">4</span>, <span class="number">4</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">5</span>, <span class="number">5</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> result = find_num_appear_once(data, <span class="number">13</span>);</span><br><span class="line">    <span class="keyword">if</span>(g_invalid_input) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Error: Invalid Input.\n&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Result: %d\n&quot;</span>, result);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种方法同样只需要<code>O(n)</code>的时间以及<code>O(1)</code>的空间，相比于其他方法有更好的时间效率(例如用排序需要<code>O(logn)</code>)，同时也不会有多余的空间开销(例如用哈希表，需要额外的<code>O(n)</code>空间)。</p><hr><blockquote><p>面试题57：和为s的数字。</p></blockquote><p>题目一：和为s的两个数字。</p><p>输入一个<strong>递增排序</strong>的数组和一个数字<code>s</code>，在数组中<strong>查找两个数</strong>，使得它们的和正好是<code>s</code>。如果有<strong>多对数字的和</strong>等于<code>s</code>，则输出任意一对即可。</p><p>PS：在面试的时候，很重要的一点是应聘者要表现出很快的反应能力。只要想到一种方法，应聘者就可以马上告诉面试官（仅限于面谈形式的），即使这种方法不一定是最好的。</p><p>根据已排序数组的特性，当指定数组中的两个数字时：</p><ul><li>如果两个数字的和小于<code>s</code>，需要一个更大的数字，这个时候可以在较小数字的<strong>右侧**</strong>或者<strong>是较大数字的</strong>右侧**去寻找；</li><li>如果两个数字的和大于<code>s</code>，需要一个更小的数字，这个时候可以在较小数字的<strong>左侧**</strong>或者<strong>是较大数字的</strong>左侧**去寻找；</li><li>如果两个数字的和等于<code>s</code>，则找到两个满足要求的数字。</li></ul><p>仅仅分析到这里是还不够的，如果每个位置都要考虑两种情况，最后的复杂度会是<code>O(2^n)</code>，在这种去情况时，可以考虑固定一个方向寻找，并且要能够覆盖到所有情况，例如本题中，可以初始化一头一尾两个指针，如果和小于<code>s</code>，移动头指针向右，如果和大于<code>s</code>，移动头指针向左，<strong>这样可以遍历到所有情况</strong>。</p><p>PS：<strong>为什么说这样可以遍历到所有情况？</strong>对于每一个头指针指向的数字，你不能在当前尾指针的右侧找到一个更适合的数（都是大于s）；对于每一个尾指针指向的数字，你不能在当前头指针的左侧找到一个更适合的数（都是小于s），所以这样逐步缩小范围，同时也考虑到了所有情况。</p><p>完整实现代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> g_invalid_input = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find_nums_with_sum</span><span class="params">(<span class="keyword">int</span> data[], <span class="keyword">int</span> len, <span class="keyword">int</span> sum, <span class="keyword">int</span>* num1, <span class="keyword">int</span>* num2)</span> </span>&#123;</span><br><span class="line">    g_invalid_input = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">bool</span> found = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span>(data == <span class="literal">nullptr</span> || len &lt; <span class="number">2</span> || !num1 || !num2) &#123;</span><br><span class="line">        g_invalid_input = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> found;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> head = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> tail = len - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(head &lt; tail) &#123;</span><br><span class="line">        <span class="comment">// 使用了long long来存储</span></span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> cur_sum = data[head] + data[tail];</span><br><span class="line">        <span class="keyword">if</span>(cur_sum == sum) &#123;</span><br><span class="line">            *num1 = data[head];</span><br><span class="line">            *num2 = data[tail];</span><br><span class="line">            found = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(cur_sum &gt; sum) &#123;</span><br><span class="line">            tail--;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            head++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> found;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> data[] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">7</span>, <span class="number">11</span>, <span class="number">15</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> num1, num2;</span><br><span class="line">    <span class="keyword">if</span>(find_nums_with_sum(data, <span class="number">6</span>, <span class="number">15</span>, &amp;num1, &amp;num2)) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Found! Num1: %d, Num2: %d\n&quot;</span>, num1, num2);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(g_invalid_input) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Error: Invalid Input.\n&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Not Found!\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>题目二</strong>：和为s的连续正数序列。</p><p>输入一个正数<code>s</code>，打印出所有和为s的<strong>连续正数序列</strong>（至少含有两个数）。例如，输入15，由于<code>1+2+3+4+5=4+5+6+7=7+8=15</code>，所以打印出3个连续序列<code>1~5</code>、<code>4~6</code>、<code>7~8</code>。</p><p>和题目一思路类似。</p><p>完整实现代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">find_seqs_with_sum</span><span class="params">(<span class="keyword">int</span> sum)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(sum &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> head = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> tail = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">int</span> cur_sum = head + tail;</span><br><span class="line">    <span class="keyword">while</span>(!(head == tail - <span class="number">1</span> &amp;&amp; cur_sum &gt; sum)) &#123;</span><br><span class="line">        <span class="keyword">if</span>(cur_sum == sum) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d~%d\n&quot;</span>, head, tail);</span><br><span class="line">            cur_sum -= head;</span><br><span class="line">            head++;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(cur_sum &gt; sum) &#123;</span><br><span class="line">            cur_sum -= head;</span><br><span class="line">            head++;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            tail++;</span><br><span class="line">            cur_sum += tail;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    find_seqs_with_sum(<span class="number">15</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><blockquote><p>面试题58：翻转字符串。</p></blockquote><p><strong>题目一</strong>：翻转单词顺序。</p><p>输入一个英语句子，翻转句子中单词的顺序，但单词内字符的顺序不变。简单起见，标点符号和字幕一样处理。例如输入<code>I am a student.</code>，则输出<code>student. a am I</code>.</p><p>普通方法的思路也不是特别难，不过这里说一下书上的两次翻转字符串的解法：</p><ul><li>第一步<strong>翻转句子中所有的字符</strong>；</li><li>第二步<strong>翻转每个单词中的字符的顺序</strong>，就得到了最终结果。</li></ul><p>完整实现代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">reverse</span><span class="params">(<span class="keyword">char</span>* pstart, <span class="keyword">char</span>* pend)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(pstart == <span class="literal">nullptr</span> || pend == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(pstart &lt; pend) &#123;</span><br><span class="line">        <span class="keyword">char</span> temp = *pstart;</span><br><span class="line">        *pstart = *pend;</span><br><span class="line">        *pend = temp;</span><br><span class="line">        pstart++;</span><br><span class="line">        pend--;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">str_reverse</span><span class="params">(<span class="keyword">char</span>* str)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(str == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">char</span>* pstart = str;</span><br><span class="line">    <span class="keyword">char</span>* pend = str;</span><br><span class="line">    <span class="keyword">while</span>(*pend != <span class="string">&#x27;\0&#x27;</span>) &#123;</span><br><span class="line">        pend++;</span><br><span class="line">    &#125;</span><br><span class="line">    pend--;</span><br><span class="line"></span><br><span class="line">    reverse(pstart, pend);</span><br><span class="line"></span><br><span class="line">    pstart = pend = str;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(*pstart != <span class="string">&#x27;\0&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span>(*pstart == <span class="string">&#x27; &#x27;</span>) &#123;</span><br><span class="line">            pstart++;</span><br><span class="line">            pend++;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(*pend == <span class="string">&#x27; &#x27;</span> || *pend == <span class="string">&#x27;\0&#x27;</span>) &#123;</span><br><span class="line">            reverse(pstart, pend - <span class="number">1</span>);</span><br><span class="line">            pstart = pend;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            pend++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> str[] = <span class="string">&quot;  I am a student.  &quot;</span>;</span><br><span class="line">    str_reverse(str);</span><br><span class="line">    <span class="keyword">if</span>(str != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>, str);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>题目二</strong>：左旋转字符串。</p><p>字符串的左旋转操作是把字符串<strong>前面的若干个字符</strong>转移到<strong>字符串的尾部</strong>。比如输入字符串<code>abcdefg</code>和数字<code>2</code>，函数返回左旋两位得到的结果<code>cdefgab</code>。</p><p>题目一中的翻转字符串，如果在本例中，可以类比于将<code>ab cdefg</code>翻转为<code>cdefg ab</code>，所以可以使用和题目一类似的思路。</p><p>完整实现代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">reverse</span><span class="params">(<span class="keyword">char</span>* pstart, <span class="keyword">char</span>* pend)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(pstart == <span class="literal">nullptr</span> || pend == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(pstart &lt; pend) &#123;</span><br><span class="line">        <span class="keyword">char</span> temp = *pstart;</span><br><span class="line">        *pstart = *pend;</span><br><span class="line">        *pend = temp;</span><br><span class="line">        pstart++;</span><br><span class="line">        pend--;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">str_left_rotate</span><span class="params">(<span class="keyword">char</span>* str, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len = <span class="built_in">strlen</span>(str);</span><br><span class="line">    <span class="keyword">if</span>(str == <span class="literal">nullptr</span> || n &lt; <span class="number">0</span> || n &gt;= len || len == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 三次翻转即可</span></span><br><span class="line">    <span class="keyword">char</span>* pstart;</span><br><span class="line">    <span class="keyword">char</span>* pend;</span><br><span class="line">    pstart = str;</span><br><span class="line">    pend = str + n - <span class="number">1</span>;</span><br><span class="line">    reverse(pstart, pend);</span><br><span class="line">    pstart = str + n;</span><br><span class="line">    pend = str + len - <span class="number">1</span>;</span><br><span class="line">    reverse(pstart, pend);</span><br><span class="line">    pstart = str;</span><br><span class="line">    pend = str + len - <span class="number">1</span>;</span><br><span class="line">    reverse(pstart, pend);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> str[] = <span class="string">&quot;abcdefg&quot;</span>;</span><br><span class="line">    str_left_rotate(str, <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">if</span>(str != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>, str);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><blockquote><p>面试题59：队列的最大值。</p></blockquote><p><strong>题目一</strong>：滑动窗口的最大值。</p><p>给定一个数组和滑动窗口大小，请找出所有滑动窗口里的最大值。例如<code>&#123;2,3,4,2,6,2,5,1&#125;</code>以及滑动窗口大小<code>3</code>，那么一共存在6个滑动窗口，他们的最大值分别是<code>&#123;4,4,6,6,6,5&#125;</code>。</p><p><strong>使用一个双端队列来保存当前窗口最大值以及可能的次最大值们</strong>；如果新入窗口的元素大于队列的头元素（最大值），则清空队列，头部入队新元素；如果新入窗口的元素小于队列的头元素，则出尾部所有小于该新元素的数字，并在尾部入队新元素；同时在队列中只需要保存元素的<code>index</code>，用来同时获取数字以及判断当前其是否在窗口内，如果不在窗口内就要进行出队。</p><p>完整实现代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;deque&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">windows_max</span><span class="params">(<span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; num, <span class="keyword">unsigned</span> <span class="keyword">int</span> size)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; maxs;</span><br><span class="line">    <span class="keyword">if</span>(num.size() &lt; size &amp;&amp; size &gt;= <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> maxs;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt; index;</span><br><span class="line">    <span class="comment">// 初始化第一个窗口的状态</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">unsigned</span> <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">        <span class="keyword">while</span>(!index.empty() &amp;&amp; num[i] &gt;= num[index.back()]) &#123;</span><br><span class="line">            index.pop_back();</span><br><span class="line">        &#125;</span><br><span class="line">        index.push_back(i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 开始滑动窗口</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">unsigned</span> <span class="keyword">int</span> i = size; i &lt; num.size(); i++) &#123;</span><br><span class="line">        maxs.push_back(num[index.front()]);</span><br><span class="line">        <span class="comment">// 清除所有尾部小于新元素的</span></span><br><span class="line">        <span class="keyword">while</span>(!index.empty() &amp;&amp; num[i] &gt;= num[index.back()]) &#123;</span><br><span class="line">            index.pop_back();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 清除所有头部已经不在窗口的</span></span><br><span class="line">        <span class="keyword">if</span>(!index.empty() &amp;&amp; index.front() &lt;= (<span class="keyword">int</span>)(i - size)) &#123;</span><br><span class="line">            index.pop_front();</span><br><span class="line">        &#125;</span><br><span class="line">        index.push_back(i);</span><br><span class="line">    &#125;</span><br><span class="line">    maxs.push_back(num[index.front()]);</span><br><span class="line">    <span class="keyword">return</span> maxs;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">num</span><span class="params">(&#123;<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">2</span>,<span class="number">6</span>,<span class="number">2</span>,<span class="number">5</span>,<span class="number">1</span>&#125;)</span></span>;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; maxs = windows_max(num, <span class="number">3</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; maxs.size(); i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, maxs[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>题目二</strong>：队列的最大值。</p><p>定义一个队列，并实现函数<code>max</code>得到队列里的最大值，要求函数<code>max</code>、<code>push_back</code>和<code>pop_front</code>的时间复杂度都是<code>O(1)</code>。</p><p>思路和题目一类似，使用一个双端队列实现<code>max</code>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;deque&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="class"><span class="keyword">class</span> <span class="title">QueueWithMAx</span> &#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        QueueWithMAx(): cur_index(<span class="number">0</span>) &#123;&#125;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">push_back</span><span class="params">(T num)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">while</span>(!maxs.empty() &amp;&amp; num &gt;= maxs.back().num) &#123;</span><br><span class="line">                maxs.pop_back();</span><br><span class="line">            &#125;</span><br><span class="line">            InternalData idata = &#123; num, cur_index &#125;;</span><br><span class="line">            data.push_back(idata);</span><br><span class="line">            maxs.push_back(idata);</span><br><span class="line">            cur_index++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">pop_front</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(maxs.empty()) &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;Error: queue is empty\n&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(maxs.front().index == data.front().index) &#123;</span><br><span class="line">                <span class="comment">// 如果要出队最大元素，maxs也要出队</span></span><br><span class="line">                maxs.pop_front();</span><br><span class="line">            &#125;</span><br><span class="line">            data.pop_front();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">int</span> <span class="title">front</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(data.empty()) &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;Error: queue is empty\n&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> data.front().num;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function">T <span class="title">max</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(maxs.empty()) &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;Error: queue is empty\n&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> maxs.front().num;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">InternalData</span> &#123;</span></span><br><span class="line">            T num;</span><br><span class="line">            <span class="keyword">int</span> index;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="built_in">deque</span>&lt;InternalData&gt; data;</span><br><span class="line">        <span class="built_in">deque</span>&lt;InternalData&gt; maxs;</span><br><span class="line">        <span class="keyword">int</span> cur_index;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> num[] = &#123;<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">2</span>,<span class="number">6</span>,<span class="number">2</span>,<span class="number">5</span>,<span class="number">1</span>&#125;;</span><br><span class="line">    QueueWithMAx&lt;<span class="keyword">int</span>&gt; <span class="built_in">queue</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">8</span>; i++) &#123;</span><br><span class="line">        <span class="built_in">queue</span>.push_back(num[i]);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;After push %d, max is %d\n&quot;</span>, num[i], <span class="built_in">queue</span>.max());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">7</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> front = <span class="built_in">queue</span>.front();</span><br><span class="line">        <span class="built_in">queue</span>.pop_front();</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;After pop %d, max is %d\n&quot;</span>, front, <span class="built_in">queue</span>.max());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-抽象建模能力"><a href="#4-抽象建模能力" class="headerlink" title="4 抽象建模能力"></a>4 抽象建模能力</h2><p>有些面试官喜欢从日常生活中抽取提炼出问题，考查应聘者是否能简历数学模型并解决问题。</p><p>建模的第一步是<strong>选择合理的数据结构来表述问题</strong>。我们在根据问题的特点，综合考虑性能、编程难度等因素之后，选择最合适的数据结构来表达问题，也就是建立模型。</p><p>建模的第二步是<strong>分析模型中的内在规律，并用编程语言表述这种规律</strong>。</p><h2 id="面试题60-63"><a href="#面试题60-63" class="headerlink" title="面试题60-63"></a>面试题60-63</h2><blockquote><p>面试题60：n个骰子的点数。</p></blockquote><p>把<code>n</code>个骰子扔在地上，所有骰子朝上一面的点数之和为<code>s</code>。输入<code>n</code>，打印出现<code>s</code>的所有可能的值出现的概率。</p><p>最简单的方法递归地遍历骰子的所有值情况，然后记录和<code>s</code>的出现次数，时间复杂度<code>O(6^n)</code>，当<code>n</code>很大时难以接受。</p><p>其实可以简化这个问题，例如设<code>f(n,s)</code>为n个骰子时和<code>s</code>的出现次数，则有<code>f(n,s)=f(n-1,s-1)+f(n-1,s-2)+f(n-1,s-3)+f(n-1,s-4)+f(n-1,s-5)+f(n-1,s-6)</code>，写出这样的递归式，我们就可以想到通过迭代来代替递归的方式计算结果，设初值<code>f(1,k)=1, 1&lt;=k&lt;=6</code>，每次迭代，向后计算即可，时间复杂度<code>O(n^2)</code>。</p><p>完整实现代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print_probability</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n &lt; <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> size = <span class="number">6</span> * n + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span>* prob1 = <span class="keyword">new</span> <span class="keyword">int</span>[size];</span><br><span class="line">    <span class="keyword">int</span>* prob2 = <span class="keyword">new</span> <span class="keyword">int</span>[size];</span><br><span class="line">    <span class="built_in">std</span>::fill(prob1, prob1 + size, <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">std</span>::fill(prob2, prob2 + size, <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">std</span>::fill(prob1 + <span class="number">1</span>, prob1 + <span class="number">7</span>, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; size; j++) &#123;</span><br><span class="line">            prob2[j] = <span class="number">0</span>; <span class="comment">// 别忘了数值重置</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">1</span>; k &lt;= <span class="number">6</span> &amp;&amp; j-k&gt;=<span class="number">0</span>; k++) &#123;</span><br><span class="line">                prob2[j] += prob1[j-k];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 交换数组</span></span><br><span class="line">        <span class="keyword">int</span>* temp = prob1;</span><br><span class="line">        prob1 = prob2;</span><br><span class="line">        prob2 = temp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">double</span> total = (<span class="keyword">double</span>)<span class="built_in">std</span>::<span class="built_in">pow</span>(<span class="number">6</span>, n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = n; i &lt; size; i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d: %d\n&quot;</span>, i, prob1[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">delete</span>[] prob1;</span><br><span class="line">    <span class="keyword">delete</span>[] prob2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    print_probability(<span class="number">11</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>相比于书上的代码，这一版本更加简洁。</p><hr><blockquote><p>面试题61：扑克牌中的顺子。</p></blockquote><p>从扑克牌中随机抽5张牌，判断是不是一个顺子，即这5张牌是不是连续的。<code>2~10</code>为数字，<code>A</code>为<code>1</code>、<code>J</code>为<code>11</code>、<code>Q</code>为<code>12</code>、<code>K</code>为<code>13</code>，而<strong>大、小王可以看成任意数字</strong>。</p><p>思路比较基础，就是先把手里的数组排序（大小王当作0），统计0的个数，统计排序相邻数字之间的空缺总数，如果综述小于等于0的个数，则数组连续，否则不连续。如果数组中非0数字重复出现，则该数字不是连续的。</p><p>完整实现代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">is_straight</span><span class="params">(<span class="keyword">int</span>* numbers, <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(numbers == <span class="literal">nullptr</span> || len &lt; <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">std</span>::sort(numbers, numbers+len);</span><br><span class="line">    <span class="keyword">int</span> zeros = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> gaps = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(numbers[i] == <span class="number">0</span>) &#123;</span><br><span class="line">            zeros++;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(i &gt; <span class="number">0</span> &amp;&amp; numbers[i] == numbers[i<span class="number">-1</span>]) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(i &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            gaps += numbers[i] - numbers[i<span class="number">-1</span>] - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(gaps &lt;= zeros) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> nums[] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line">    <span class="keyword">if</span>(is_straight(nums, <span class="keyword">sizeof</span>(nums)/<span class="keyword">sizeof</span>(<span class="keyword">int</span>))) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Is straight.&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Is not straight.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果觉得代码中排序的部分<code>O(nlogn)</code>不够快，因为这里出现的数字只有<code>0~13</code>，所以还可以使用哈希表实现<code>O(n)</code>的排序。</p><hr><blockquote><p>面试题62：圆圈中最后剩下的数字。</p></blockquote><p><code>0,1,...,n-1</code>这<code>n</code>个数字排成一个圆圈，从数字<code>0</code>开始，每次从这个圆圈里删除第<code>m</code>个数字。求出这个圆圈里剩下的最后一个数字。</p><div align="center"><p><img src="/images/s2o-c6-f3.jpg"></p></div><p>例如上图的圆圈，从数字<code>0</code>开始，每次删除第<code>3</code>个数字，则删除的前4个数字是<code>2、0、4、1</code>，最后剩下的数字是<code>3</code>。</p><p>本题就是有名的约瑟夫(Josephuse)环问题。一种方法是用环形链表模拟圆圈的经典解法，时间复杂度<code>O(nm)</code>，另一种方法是分析被删除数字的规律，直接计算出圆圈中最后剩下的数字，时间复杂度<code>O(n)</code>。</p><p>链表模拟法就不再赘述了，主要讲一下第二个的规律分析法。</p><p>定义一个关于n和m的函数<code>f(n,m)</code>，表示每次在<code>n</code>个数字<code>0,1,...,n-1</code>中删除第<code>m</code>个数字最后剩下的数字。</p><p>在这n个数字中，第一个被删除的是<code>(m-1)%n</code>，简单起见，记为<code>k</code>，删除k之后剩下的n-1个数字为<code>0,1,...,k-1,k+1,...,n-1</code>，并且在下一次删除从数字<code>k+1</code>开始计数。相当于在剩下的序列中，<code>k+1</code>排在最前面，从而形成<code>k+1,...,n-1,0,1,...,k-1</code>。这个序列最后剩下的数字应该也是关于<code>n</code>和<code>m</code>的函数。</p><p>由于第二个序列和前面最初的序列不一样，因此函数不同于前面的函数，记为<code>f&#39;(n-1,m)</code>，所以有<code>f(n,m)=f&#39;(n-1,m)</code>。</p><p>接下来我们把，剩下的这<code>n-1</code>个数字的序列<code>k+1,...,n-1,0,1,...,k-1</code>进行映射，结果形成一个<code>0~n-2</code>的序列。</p><div align="center"><p><img src="/images/s2o-c6-f4.jpg"></p></div><p>把映射定义为<code>p</code>，则有<code>p(x)=(x-k-1)%n</code>，映射的逆映射是<code>p&#39;(x)=(x+k+1)%n</code>。</p><p>由于映射之后的序列和最初的序列具有相同的形式，即都是从0开始的连续序列，因此仍然可以用函数<code>f</code>来表示，记为<code>f(n-1,m)</code>。根据我们之前的推导，映射之前的序列剩下的数字是<code>f&#39;(n-1,m)=p&#39;(f(n-1,m))=(f(n-1,m)+k+1)%n</code>，把<code>k=(m-1)%n</code>代入，可以得到<code>f(n,m)=f&#39;(n-1,m)=[f(n-1,m)+m]%n</code>。</p><p>通过分析后，我们找到了一个递归公式，要得到这n个数的序列中最后剩下的数字，只需要得到n-1个数字的序列中最后剩下的数字，并以此类推。</p><p>当n=1时，序列中只有一个数字<code>0</code>，那么很显然最后剩下的数字就是<code>0</code>，这种递归可以写为：</p><div align="center"><p><img src="/images/s2o-c6-f5.jpg"></p></div><p>公式无论是用递归还是循环，都很容易实现。</p><p>完整实现代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">last_remaining</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> n, <span class="keyword">unsigned</span> <span class="keyword">int</span> m)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n &lt; <span class="number">1</span> || m &lt; <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> last = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        last = (last + m) % i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> last;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, last_remaining(<span class="number">5</span>, <span class="number">3</span>));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度<code>O(n)</code>，空间复杂度<code>O(1)</code>。</p><hr><blockquote><p>面试题63：股票的最大利润。</p></blockquote><p>假设把某股票的价格按照时间先后顺序存储在数组中，请问买卖该股票一次，可能获得的<strong>最大利润</strong>是多少？例如一支股票在某些时间节点的价格为<code>&#123;9,11,8,5,7,12,16,14&#125;</code>。如果我们能在价格<code>5</code>时买入，并在价格<code>16</code>时卖出，则收获最大利润<code>11</code>。</p><p>暴力遍历法时间复杂度<code>O(n^2)</code>，但是只要在从前向后计算的时候，保存前面序列中的最小值，就可以计算出当前值和前面序列的最小值的差值，最后获得最大差值就是最大利润。</p><p>完整实现代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;limits.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">max_profit</span><span class="params">(<span class="keyword">int</span>* numbers, <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(numbers == <span class="literal">nullptr</span> || len &lt; <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> min = numbers[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">int</span> max_profits = INT_MIN;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; len; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(numbers[i] - min &gt; max_profits) &#123;</span><br><span class="line">            max_profits = numbers[i] - min;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(min &gt; numbers[i]) &#123;</span><br><span class="line">            min = numbers[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> max_profits;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> numbers[] = &#123;<span class="number">9</span>,<span class="number">11</span>,<span class="number">8</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">12</span>,<span class="number">16</span>,<span class="number">14</span>&#125;;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;max profit is %d&quot;</span>, max_profit(numbers, <span class="keyword">sizeof</span>(numbers)/<span class="keyword">sizeof</span>(<span class="keyword">int</span>)));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>只需要扫描数组一次，该算法的时间复杂度<code>O(n)</code>。</p><h2 id="5-发散思维能力"><a href="#5-发散思维能力" class="headerlink" title="5 发散思维能力"></a>5 发散思维能力</h2><p>发散思维的特点是思维活动的多向性和变通性，也就是思考问题时，注重运动多思路、多方案、多途径来解决问题。对于同一个问题，我们可以从不同的方向、侧面和层次，采用探索、转移、迁移、组合和分解等方法，提出多种创新的解法。</p><h2 id="面试题64-66"><a href="#面试题64-66" class="headerlink" title="面试题64-66"></a>面试题64-66</h2><blockquote><p>面试题64：求1+2+…+n。</p></blockquote><p>求<code>1+2+...+n</code>，要求不能使用乘除法、for、while、if、else、switch、case等关键字及条件判断语句(A?B:C)。</p><p>循环和递归实现在本题中就没办法使用了，可以尝试从一些语言特性的方面来解决。</p><p><strong>解法一</strong>：利用构造函数求解。</p><p>循环只是让相同的代码重复执行n次而已，完全可以不用for和while来达到这个效果。比如定义一个类型，接着创建n个该类型的实例，那么这个类型的构造函数将确定会被调用n次，可以将与累加相关的代码放到构造函数里。</p><p>完整实现代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Temp</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Temp() &#123;</span><br><span class="line">        ++N;</span><br><span class="line">        Sum+=N;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">reset</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        N = <span class="number">0</span>;</span><br><span class="line">        Sum = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">get_sum</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Sum;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> N;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> Sum;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> Temp::N = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> Temp::Sum = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">sum_solution1</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    Temp::reset();</span><br><span class="line"></span><br><span class="line">    Temp* a = <span class="keyword">new</span> Temp[n]; <span class="comment">// 靠内部的循环来作弊，绝了</span></span><br><span class="line">    <span class="keyword">delete</span>[] a;</span><br><span class="line">    a = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> Temp::get_sum();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, sum_solution1(<span class="number">10</span>));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>解法二</strong>：利用虚函数求解。</p><p>同样可以围绕递归来做，既然不能在一个函数中判断是不是应该终止递归，那么不妨定义两个函数，一个充当递归函数，另一个函数处理终止递归地情况，需要做的就是在两个函数里二选一，从二选一我们很自然地想到布尔变量，比如值为<code>true</code>时，调用第一个函数，值为<code>false</code>时，调用第二个函数。</p><p>完整实现代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>;</span></span><br><span class="line">A* Array[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span>:</span> <span class="keyword">public</span> A &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 使用状态来选择函数，实现if else</span></span><br><span class="line">        <span class="keyword">return</span> Array[(<span class="keyword">bool</span>)n]-&gt;sum(n<span class="number">-1</span>)+n;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sum_solution2</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    A a;</span><br><span class="line">    B b;</span><br><span class="line">    Array[<span class="number">0</span>] = &amp;a;</span><br><span class="line">    Array[<span class="number">1</span>] = &amp;b;</span><br><span class="line">    <span class="keyword">int</span> value = Array[<span class="number">1</span>]-&gt;sum(n);</span><br><span class="line">    <span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, sum_solution2(<span class="number">10</span>));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用虚函数来实现函数的选择，当n不为0时，调用函数<code>B::sum</code>，当<code>n</code>等于<code>0</code>时，调用函数<code>A::sum</code>。</p><p><strong>解法三</strong>：利用函数指针求解。</p><p>纯C语言的变成环境中，我们不能使用虚函数，此时可以用函数指针来模拟，这样代码可能还更加直观一点。</p><p>完整实现代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="title">int</span> <span class="params">(*fun)</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">terminator</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">sum_solution3</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> fun f[<span class="number">2</span>] = &#123;terminator, sum_solution3&#125;;</span><br><span class="line">    <span class="keyword">return</span> n + f[(<span class="keyword">bool</span>)n](n<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, sum_solution3(<span class="number">10</span>));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>解法四</strong>：利用模板类求解。</p><p>还可以让编译器帮助完成类似于递归地计算。</p><p>完整能够代码实现：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">unsigned</span> <span class="keyword">int</span> n&gt; <span class="class"><span class="keyword">struct</span> <span class="title">sum_solution4</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">enum</span> <span class="title">value</span> &#123;</span> N = sum_solution4&lt;n<span class="number">-1</span>&gt;::N + n &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;&gt; <span class="class"><span class="keyword">struct</span> <span class="title">sum_solution4</span>&lt;</span><span class="number">1</span>&gt; &#123;</span><br><span class="line">    <span class="class"><span class="keyword">enum</span> <span class="title">Value</span> &#123;</span>N = <span class="number">1</span>&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, sum_solution4&lt;<span class="number">10</span>&gt;::N);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当编译器看到<code>sum_solution4&lt;10&gt;</code>，就会为模板类<code>sum_solution4</code>以参数<code>10</code>生成该类型的代码，并且以<code>10</code>为参数的类型需要得到以<code>9</code>为参数的类型，这个过程会一直递归到参数为<code>1</code>的类型（已经显式定义，编译器无须生成）。</p><p>由于这个过程是在编译过程中完成的，因此要求输入的n必须是在编译期间就能确定的常量，不能动态输入。而且编译器对递归编译代码的递归深度是有限制的，要求n不能太大。</p><hr><blockquote><p>面试题65：不用加减乘除做加法。</p></blockquote><p>写一个函数，求两个整数之和，要求在函数体内不得使用<code>+</code>、<code>-</code>、<code>×</code>、<code>÷</code>四则运算符号。</p><p>不能用四则运算的话，就只能考虑用位运算（与、或、非、异或）的方式来实现加法了。</p><p>例如<code>5+17=22</code>，<code>5</code>的二进制是<code>101</code>，<code>17</code>的二进制是<code>10001</code>，我们试着把计算分成三步：</p><ul><li>第一步，各位相加，不计进位，得到的结果是<code>10100</code>（1+1溢出后就是0）；</li><li>第二步，记下进位，在这个例子中只在最后一位相加时产生一个进位，结果是二进制的<code>10</code>；</li><li>第三步，把前两步的结果相加，得到结果<code>10110</code>，转换成十进制就是<code>22</code>。</li></ul><p>现在把二进制的加法用位运算来代替：</p><ul><li>第一步，非进位加法，其实和异或运算相同，例如<code>101^10001=10100</code>；</li><li>第二步，只有<code>1</code>加<code>1</code>时，会向前产生一个进位<code>1</code>，此时我们可以想象成两个数先做位与运算，然后再向左移动一位，例如<code>101&amp;10001 &lt;&lt; 1 = 10</code>；</li><li>第三步，把前面两步结果相加，又变成一个新的问题，递归调用前两步，直到不会再产生进位为止。</li></ul><p>完整实现代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">same_sign</span><span class="params">(<span class="keyword">int</span> num1, <span class="keyword">int</span> num2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (num1 &gt;&gt; <span class="number">31</span>) == (num2 &gt;&gt; <span class="number">31</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bit_add</span><span class="params">(<span class="keyword">int</span> num1, <span class="keyword">int</span> num2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sum, carry;</span><br><span class="line">    <span class="keyword">int</span> tnum1 = num1, tnum2 = num2;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        sum = tnum1^tnum2;</span><br><span class="line">        carry = (tnum1 &amp; tnum2) &lt;&lt; <span class="number">1</span>;</span><br><span class="line">        tnum1 = sum;</span><br><span class="line">        tnum2 = carry;</span><br><span class="line">    &#125; <span class="keyword">while</span>(tnum2 != <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(same_sign(num1, num2) &amp;&amp; !same_sign(num1, sum)) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Error: add overflow\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, bit_add(<span class="number">200</span>, <span class="number">20</span>));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在书上的代码基础上，加入对溢出的异常判断，其中对于溢出判定方法是，只有当两个数同号时才会在加法中溢出，并且最后结果和原来的两个数异号时，就代表发生了溢出，此时应该抛出异常。</p><p>PS：不使用新的变量，交换两个变量的值（适用于数值类）。比如有<code>a</code>、<code>b</code>，我们希望交换它们的值。有两种不同的方法：</p><div align="center"><p><img src="/images/s2o-c6-f6.jpg"></p></div><hr><blockquote><p>面试题66：构建乘积数组。</p></blockquote><p>给定一个数组<code>A[0,1,...,n-1]</code>，请构建一个数组<code>B[0,1,...,n-1]</code>，其中B中的元素<code>B[i]=A[0]*A[1]*...*A[i-1]*A[i+1]*...*A[n-1]</code>。不能使用除法。</p><p>因为不能使用除法，所以只能另辟蹊径，如果用暴力求解法，时间复杂度是<code>O(n)</code>。</p><p>如果单独地求解<code>A[0]*A[1]*...*A[i-1]</code>，我们是可以迭代地在<code>O(n)</code>时间里求解出所有的前序乘积的，同理所有的<code>A[i-1]*A[i+1]*...*A[n-1]</code>，我们也可以逆序地迭代<code>O(n)</code>的时间中求解，最后对于每一个<code>B[i]</code>找到对应的前序序列和逆序序列就可以用乘法得到最后的结果了。</p><p>PS：不知道这道题要不要考虑什么乘积大数溢出的问题，根据面试的具体情况来分析吧，这种题再加上大数就稍微有点复杂了。</p><p>完整实现代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">multi_array</span><span class="params">(<span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt;&amp; array1, <span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt;&amp; array2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len1 = array1.size();</span><br><span class="line">    <span class="keyword">int</span> len2 = array2.size();</span><br><span class="line">    <span class="keyword">if</span>(len1 != len2 || len2 &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 先计算正序序列值，暂存在array2中</span></span><br><span class="line">    <span class="keyword">double</span> temp = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len1; i++) &#123;</span><br><span class="line">        array2[i] = temp;</span><br><span class="line">        temp *= array1[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 计算逆序序列值，乘出最后结果</span></span><br><span class="line">    temp = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = len2 - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        array2[i] *= temp;</span><br><span class="line">        temp *= array1[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt; <span class="title">array1</span><span class="params">(&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;)</span></span>;</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt; <span class="title">array2</span><span class="params">(<span class="number">5</span>)</span></span>;</span><br><span class="line">    multi_array(array1, array2);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; array2.size(); i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%e &quot;</span>, array2[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种思路的时间复杂度是<code>O(n)</code>。</p><h2 id="6-总结"><a href="#6-总结" class="headerlink" title="6 总结"></a>6 总结</h2><p>面试是我们展示自己综合素质的时候，除了扎实的编程能力，我们还需要表现自己的沟通能力和学习能力，以及知识迁移能力、抽象建模能力和发散思维能力等方面的综合实力。</p><div align="center"><p><img src="/images/s2o-c6-f7.jpg"></p></div></div><div class="article-licensing box"><div class="licensing-title"><p>《剑指Offer》第6章笔记 各项能力</p><p><a href="https://yumi-cn.github.io/2021/01/23/s2o-c6/">https://yumi-cn.github.io/2021/01/23/s2o-c6/</a></p></div><div class="licensing-meta level is-mobile"><div class="level-left"><div class="level-item is-narrow"><div><h6>作者</h6><p>Yumiko</p></div></div><div class="level-item is-narrow"><div><h6>发布于</h6><p>2021-01-23</p></div></div><div class="level-item is-narrow"><div><h6>更新于</h6><p>2021-01-23</p></div></div><div class="level-item is-narrow"><div><h6>许可协议</h6><p><a class="icon" rel="noopener" target="_blank" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a><a class="icon" rel="noopener" target="_blank" title="Attribution" href="https://creativecommons.org/licenses/by/4.0/"><i class="fab fa-creative-commons-by"></i></a><a class="icon" rel="noopener" target="_blank" title="Noncommercial" href="https://creativecommons.org/licenses/by-nc/4.0/"><i class="fab fa-creative-commons-nc"></i></a></p></div></div></div></div></div><div class="article-tags is-size-7 mb-4"><span class="mr-2">#</span><a class="link-muted mr-2" rel="tag" href="/tags/%E7%AC%94%E8%AE%B0/">笔记</a></div></article></div><div class="card"><div class="card-content"><h3 class="menu-label has-text-centered">喜欢这篇文章？打赏一下作者吧</h3><div class="buttons is-centered"><a class="button donate" data-type="alipay"><span class="icon is-small"><i class="fab fa-alipay"></i></span><span>支付宝</span><span class="qrcode"><img src="/images/zfb.jpg" alt="支付宝"></span></a><a class="button donate" data-type="wechat"><span class="icon is-small"><i class="fab fa-weixin"></i></span><span>微信</span><span class="qrcode"><img src="/images/wx.jpg" alt="微信"></span></a><a class="button donate" href="https://afdian.net/@yumiko-cn" target="_blank" rel="noopener" data-type="afdian"><span class="icon is-small"><i class="fas fa-charging-station"></i></span><span>爱发电</span></a></div></div></div><nav class="post-navigation mt-4 level is-mobile"><div class="level-start"><a class="article-nav-prev level level-item link-muted" href="/2021/01/23/learnopengl-c1/"><i class="level-item fas fa-chevron-left"></i><span class="level-item">《LearnOpenGL》入门 笔记</span></a></div><div class="level-end"><a class="article-nav-next level level-item link-muted" href="/2021/01/11/s2o-c5-optimize/"><span class="level-item">《剑指Offer》第5章笔记 优化效率</span><i class="level-item fas fa-chevron-right"></i></a></div></nav><div class="card"><div class="card-content"><h3 class="title is-5">评论</h3><div id="comment-container"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/gitalk@1.6.2/dist/gitalk.css"><script src="https://cdn.jsdelivr.net/npm/gitalk@1.6.2/dist/gitalk.min.js"></script><script>var gitalk=new Gitalk({id:"6f7965396a8499e4c3c13598f3bea54b",repo:"yumi-cn.github.io",owner:"yumi-cn",clientID:"30141472b2ad1cb657d1",clientSecret:"80e26278051f7251bd46f5ec93317fec6675a7b4",admin:["yumi-cn"],createIssueManually:!1,distractionFreeMode:!1,perPage:20,pagerDirection:"last",enableHotKey:!0,language:"zh-CN"});gitalk.render("comment-container")</script></div></div></div><div class="column column-left is-4-tablet is-4-desktop is-3-widescreen order-1"><div class="card widget" data-type="profile"><div class="card-content"><nav class="level"><div class="level-item has-text-centered flex-shrink-1"><div><figure class="image is-128x128 mx-auto mb-2"><img class="avatar is-rounded" src="/images/avatar.jpg" alt="Yumiko"></figure><p class="title is-size-4 is-block" style="line-height:inherit">Yumiko</p><p class="is-size-6 is-block">游戏/引擎/技美</p><p class="is-size-6 is-flex justify-content-center"><i class="fas fa-map-marker-alt mr-1"></i><span>中国 杭州</span></p></div></div></nav><nav class="level is-mobile"><div class="level-item has-text-centered is-marginless"><div><p class="heading">文章</p><a href="/archives"><p class="title">26</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">专栏</p><a href="/categories"><p class="title">5</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">主题</p><a href="/tags"><p class="title">1</p></a></div></div></nav><div class="level"><a class="level-item button is-primary is-rounded" href="https://github.com/yumi-cn" target="_blank" rel="noopener">关注我</a></div><div class="level is-mobile"><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Github" href="https://github.com/yumi-cn"><i class="fab fa-github"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Bilibili" href="https://space.bilibili.com/11413916"><i class="fab fa-youtube"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Pixiv" href="https://www.pixiv.net/users/25096815"><i class="fas fa-palette"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="RSS" href="/atom.xml"><i class="fas fa-rss"></i></a></div></div></div><div class="card widget" data-type="categories"><div class="card-content"><div class="menu"><h3 class="menu-label">专栏</h3><ul class="menu-list"><li><a class="level is-mobile" href="/categories/3D%E6%B8%B8%E6%88%8F%E4%B8%8E%E5%9B%BE%E5%BD%A2%E5%AD%A6%E7%9A%84%E6%95%B0%E5%AD%A6/"><span class="level-start"><span class="level-item">3D游戏与图形学的数学</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/categories/LearnOpenGL/"><span class="level-start"><span class="level-item">LearnOpenGL</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/categories/Real-Time-Rendering-4th/"><span class="level-start"><span class="level-item">Real Time Rendering 4th</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/%E5%89%91%E6%8C%87Offer/"><span class="level-start"><span class="level-item">剑指Offer</span></span><span class="level-end"><span class="level-item tag">15</span></span></a></li><li><a class="level is-mobile" href="/categories/%E8%AE%A1%E5%88%92-Flags/"><span class="level-start"><span class="level-item">计划-Flags</span></span><span class="level-end"><span class="level-item tag">5</span></span></a></li></ul></div></div></div><div class="card widget" data-type="recent-posts"><div class="card-content"><h3 class="menu-label">最新文章</h3><article class="media"><div class="media-content"><p class="date"><time datetime="2021-03-13T03:28:19.000Z">2021-03-13</time></p><p class="title"><a href="/2021/03/13/plan-2021-03/">3月的计划</a></p><p class="categories"><a href="/categories/%E8%AE%A1%E5%88%92-Flags/">计划-Flags</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time datetime="2021-02-02T12:05:19.000Z">2021-02-02</time></p><p class="title"><a href="/2021/02/02/plan-2021-02/">2月的计划</a></p><p class="categories"><a href="/categories/%E8%AE%A1%E5%88%92-Flags/">计划-Flags</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time datetime="2021-01-26T13:34:18.000Z">2021-01-26</time></p><p class="title"><a href="/2021/01/26/learnopengl-c2/">《LearnOpenGL》光照 笔记</a></p><p class="categories"><a href="/categories/LearnOpenGL/">LearnOpenGL</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time datetime="2021-01-24T01:26:52.000Z">2021-01-24</time></p><p class="title"><a href="/2021/01/24/leetcode-200-select/">《LeetCode》精选200题计划</a></p><p class="categories"><a href="/categories/%E8%AE%A1%E5%88%92-Flags/">计划-Flags</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time datetime="2021-01-23T11:46:18.000Z">2021-01-23</time></p><p class="title"><a href="/2021/01/23/learnopengl-c1/">《LearnOpenGL》入门 笔记</a></p><p class="categories"><a href="/categories/LearnOpenGL/">LearnOpenGL</a></p></div></article></div></div><div class="column-right-shadow is-hidden-widescreen is-sticky"></div></div><div class="column column-right is-4-tablet is-4-desktop is-3-widescreen is-hidden-touch is-hidden-desktop-only order-3 is-sticky"><div class="card widget" id="toc" data-type="toc"><div class="card-content"><div class="menu"><h3 class="menu-label">目录</h3><ul class="menu-list"><li><a class="level is-mobile" href="#1-面试官谈能力"><span class="level-left"><span class="level-item">1 面试官谈能力</span></span></a></li><li><a class="level is-mobile" href="#2-沟通能力和学习能力"><span class="level-left"><span class="level-item">2 沟通能力和学习能力</span></span></a></li><li><a class="level is-mobile" href="#3-知识迁移能力"><span class="level-left"><span class="level-item">3 知识迁移能力</span></span></a></li><li><a class="level is-mobile" href="#面试题53-59"><span class="level-left"><span class="level-item">面试题53-59</span></span></a></li><li><a class="level is-mobile" href="#4-抽象建模能力"><span class="level-left"><span class="level-item">4 抽象建模能力</span></span></a></li><li><a class="level is-mobile" href="#面试题60-63"><span class="level-left"><span class="level-item">面试题60-63</span></span></a></li><li><a class="level is-mobile" href="#5-发散思维能力"><span class="level-left"><span class="level-item">5 发散思维能力</span></span></a></li><li><a class="level is-mobile" href="#面试题64-66"><span class="level-left"><span class="level-item">面试题64-66</span></span></a></li><li><a class="level is-mobile" href="#6-总结"><span class="level-left"><span class="level-item">6 总结</span></span></a></li></ul></div></div><script src="/js/toc.js" defer></script></div></div></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/"><img src="/images/logo.jpg" alt="画码余生" height="28"></a><p class="is-size-7"><span>&copy; 2021 Yumiko</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a></p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Attribution 4.0 International" href="https://creativecommons.org/licenses/by/4.0/"><i class="fab fa-creative-commons-by"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="GitHub" href="https://github.com/yumi-cn"><i class="fab fa-github"></i></a></p></div></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" async></script><script>moment.locale("zh-CN")</script><script>var IcarusThemeSettings={article:{highlight:{clipboard:!0,fold:"unfolded"}}}</script><script src="/js/column.js"></script><script src="/js/animation.js"></script><a id="back-to-top" title="回到顶端" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back_to_top.js" defer></script><script src="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.js" defer></script><script>window.addEventListener("load", () => {
      window.cookieconsent.initialise({
        type: "info",
        theme: "edgeless",
        static: false,
        position: "bottom-left",
        content: {
          message: "此网站使用Cookie来改善您的体验。",
          dismiss: "知道了！",
          allow: "允许使用Cookie",
          deny: "拒绝",
          link: "了解更多",
          policy: "Cookie政策",
          href: "https://www.cookiesandyou.com/",
        },
        palette: {
          popup: {
            background: "#edeff5",
            text: "#838391"
          },
          button: {
            background: "#4b81e8"
          },
        },
      });
    });</script><script src="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/js/lightgallery.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/katex.min.css"><script src="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/katex.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/contrib/auto-render.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/contrib/mhchem.js" defer></script><script>window.addEventListener("load",function(){document.querySelectorAll('[role="article"] > .content').forEach(function(e){renderMathInElement(e)})})</script><script src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="想要查找什么..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/js/insight.js" defer></script><script>document.addEventListener("DOMContentLoaded",function(){loadInsight({contentUrl:"/content.json"},{hint:"想要查找什么...",untitled:"(无标题)",posts:"文章",pages:"页面",categories:"专栏",tags:"主题"})})</script></body></html>