<!doctype html><html lang="zh"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1"><meta><title>《LearnOpenGL》入门 笔记 - 画码余生</title><link rel="manifest" href="/manifest.json"><meta name="application-name" content="画码余生"><meta name="msapplication-TileImage" content="/images/favicon.ico"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="画码余生"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta description="Hello OpenGL!"><meta property="og:type" content="blog"><meta property="og:title" content="《LearnOpenGL》入门 笔记"><meta property="og:url" content="https://yumi-cn.github.io/2021/01/23/learnopengl-c1/"><meta property="og:site_name" content="画码余生"><meta property="og:description" content="Hello OpenGL!"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://yumi-cn.github.io/images/learnopengl-c1-f44.jpg"><meta property="article:published_time" content="2021-01-23T11:46:18.000Z"><meta property="article:modified_time" content="2021-01-23T11:46:37.961Z"><meta property="article:author" content="Yumiko"><meta property="article:tag" content="笔记"><meta property="twitter:card" content="summary"><meta property="twitter:image" content="/images/learnopengl-c1-f44.jpg"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"https://yumi-cn.github.io/2021/01/23/learnopengl-c1/"},"headline":"画码余生","image":["https://yumi-cn.github.io/images/learnopengl-c1-f44.jpg"],"datePublished":"2021-01-23T11:46:18.000Z","dateModified":"2021-01-23T11:46:37.961Z","author":{"@type":"Person","name":"Yumiko"},"description":"Hello OpenGL!"}</script><link rel="canonical" href="https://yumi-cn.github.io/2021/01/23/learnopengl-c1/"><link rel="alternate" href="/atom.xml" title="画码余生" type="application/atom+xml"><link rel="icon" href="/images/favicon.ico"><link rel="stylesheet" href="https://cdn.bootcdn.net/ajax/libs/font-awesome/5.15.1/css/all.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@9.12.0/styles/atom-one-light.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link rel="stylesheet" href="/css/default.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/css/justifiedGallery.min.css"><script src="https://cdn.jsdelivr.net/npm/pace-js@1.0.2/pace.min.js"></script><meta name="generator" content="Hexo 5.2.0"></head><body class="is-3-column"><nav class="navbar navbar-main"><div class="container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/"><img src="/images/logo.jpg" alt="画码余生" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">主页</a><a class="navbar-item" href="/archives">文章</a><a class="navbar-item" href="/categories">专栏</a><a class="navbar-item" href="/tags">主题</a><a class="navbar-item" href="/about">关于我</a></div><div class="navbar-end"><a class="navbar-item" target="_blank" rel="noopener" title="Github" href="https://github.com/yumi-cn"><i class="fab fa-github"></i></a><a class="navbar-item is-hidden-tablet catalogue" title="目录" href="javascript:;"><i class="fas fa-list-ul"></i></a><a class="navbar-item search" title="搜索" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-6-widescreen"><div class="card"><div class="card-image"><span class="image is-7by3"><img class="fill" src="/images/learnopengl-c1-f44.jpg" alt="《LearnOpenGL》入门 笔记"></span></div><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time datetime="2021-01-23T11:46:18.000Z" title="2021-01-23T11:46:18.000Z">2021-01-23</time>发表</span><span class="level-item"><time datetime="2021-01-23T11:46:37.961Z" title="2021-01-23T11:46:37.961Z">2021-01-23</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/LearnOpenGL/">LearnOpenGL</a></span><span class="level-item">5 小时读完 (大约43097个字)</span></div></div><h1 class="title is-3 is-size-4-mobile">《LearnOpenGL》入门 笔记</h1><div class="content"><blockquote><p>Hello OpenGL!</p></blockquote><a id="more"></a><blockquote><p>笔记摘录源地址：<a target="_blank" rel="noopener" href="https://learnopengl-cn.github.io/">LearnOpenGL CN</a></p></blockquote><h2 id="OpenGL"><a href="#OpenGL" class="headerlink" title="OpenGL"></a>OpenGL</h2><h2 id="创建窗口"><a href="#创建窗口" class="headerlink" title="创建窗口"></a>创建窗口</h2><h2 id="你好，窗口"><a href="#你好，窗口" class="headerlink" title="你好，窗口"></a>你好，窗口</h2><div align="center"><p><img src="/images/learnopengl-c1-f0.jpg"></p></div><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="comment">// GLAD must be include before GLFW</span></span><br><span class="line"><span class="comment">// GL/GLES/EGL/GLX/WGL Loader-Generator based on the official specs.</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;glad/glad.h&gt; </span></span></span><br><span class="line"><span class="comment">// GLFW is an Open Source, multi-platform library for OpenGL, OpenGL ES and Vulkan application development.</span></span><br><span class="line"><span class="comment">// It provides a simple, platform-independent API for creating windows, contexts and surfaces, reading input, handling events, etc.</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;GLFW/glfw3.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">framebuffer_size_callback</span><span class="params">(GLFWwindow* window, <span class="keyword">int</span> width, <span class="keyword">int</span> height)</span> </span>&#123;</span><br><span class="line">    glViewport(<span class="number">0</span>, <span class="number">0</span>, width, height);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 望能够在GLFW中实现一些输入控制，可以通过使用GLFW的几个输入函数来完成</span></span><br><span class="line"><span class="comment">// 使用GLFW的glfwGetKey函数，它需要一个窗口以及一个按键作为输入</span></span><br><span class="line"><span class="comment">// 这个函数将会返回这个按键是否正在被按下</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">process_input</span><span class="params">(GLFWwindow *window)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 检查用户是否按下了返回键(Esc)，如果没有按下，glfwGetKey将会返回GLFW_RELEASE</span></span><br><span class="line">    <span class="keyword">if</span> (glfwGetKey(window, GLFW_KEY_ESCAPE) == GLFW_PRESS) &#123;</span><br><span class="line">        glfwSetWindowShouldClose(window, <span class="literal">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    glfwInit();</span><br><span class="line">    glfwWindowHint(GLFW_CONTEXT_VERSION_MAJOR, <span class="number">3</span>);</span><br><span class="line">    glfwWindowHint(GLFW_CONTEXT_VERSION_MINOR, <span class="number">3</span>);</span><br><span class="line">    glfwWindowHint(GLFW_OPENGL_PROFILE, GLFW_OPENGL_CORE_PROFILE);</span><br><span class="line">    <span class="comment">// glfwWindowHint(GLFW_OPENGL_FORWARD_COMPAT, GL_TRUE); // for max os x</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// glfwCreateWindow(width, height, title, ..., ...)</span></span><br><span class="line">    GLFWwindow* window = glfwCreateWindow(<span class="number">800</span>, <span class="number">600</span>, <span class="string">&quot;LearnOpenGL&quot;</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (window == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Failed to create GLFW window&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">        glfwTerminate();</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    glfwMakeContextCurrent(window);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// GLAD是用来管理OpenGL的函数指针的</span></span><br><span class="line">    <span class="comment">// 所以在调用任何OpenGL的函数之前我们需要初始化GLAD</span></span><br><span class="line">    <span class="comment">// 给GLAD传入了用来加载系统相关的OpenGL函数指针地址的函数</span></span><br><span class="line">    <span class="comment">// GLFW给我们的是glfwGetProcAddress</span></span><br><span class="line">    <span class="comment">// 它根据我们编译的系统定义了正确的函数</span></span><br><span class="line">    <span class="keyword">if</span> (!gladLoadGLLoader((GLADloadproc)glfwGetProcAddress)) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Failed to initialize GLAD&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 告诉OpenGL渲染窗口的尺寸大小, 视口 Viewport</span></span><br><span class="line">    <span class="comment">// 窗口左下角的位置，宽度，高度</span></span><br><span class="line">    glViewport(<span class="number">0</span>, <span class="number">0</span>, <span class="number">800</span>, <span class="number">600</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当用户改变窗口的大小的时候，视口也应该被调整</span></span><br><span class="line">    <span class="comment">// 可以对窗口注册一个回调函数(Callback Function)</span></span><br><span class="line">    <span class="comment">// 它会在每次窗口大小被调整的时候被调用</span></span><br><span class="line">    <span class="comment">// void framebuffer_size_callback(GLFWwindow* window, int width, int height);</span></span><br><span class="line">    <span class="comment">// 需要注册这个函数，告诉GLFW我们希望每当窗口调整大小的时候调用这个函数</span></span><br><span class="line">    glfwSetFramebufferSizeCallback(window, framebuffer_size_callback);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Render Loop</span></span><br><span class="line">    <span class="comment">// glfwWindowShouldClose函数在我们每次循环的开始前检查一次GLFW是否被要求退出</span></span><br><span class="line">    <span class="comment">// 如果是的话该函数返回true然后渲染循环便结束了，之后为我们就可以关闭应用程序了</span></span><br><span class="line">    <span class="keyword">while</span> (!glfwWindowShouldClose(window)) &#123;</span><br><span class="line">        <span class="comment">// 检测用户输入</span></span><br><span class="line">        process_input(window);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 渲染指令</span></span><br><span class="line">        <span class="comment">// 使用一个自定义的颜色清空屏幕</span></span><br><span class="line">        <span class="comment">// 调用了glClearColor来设置清空屏幕所用的颜色</span></span><br><span class="line">        glClearColor(<span class="number">0.2f</span>, <span class="number">0.3f</span>, <span class="number">0.3f</span>, <span class="number">1.0f</span>); <span class="comment">// 状态设置函数</span></span><br><span class="line">        <span class="comment">// 调用glClear函数来清空屏幕的颜色缓冲，它接受一个缓冲位(Buffer Bit)来指定要清空的缓冲</span></span><br><span class="line">        <span class="comment">// 可能的缓冲位有GL_COLOR_BUFFER_BIT，GL_DEPTH_BUFFER_BIT和GL_STENCIL_BUFFER_BIT</span></span><br><span class="line">        glClear(GL_COLOR_BUFFER_BIT); <span class="comment">// 状态使用函数</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// glfwSwapBuffers函数会交换颜色缓冲</span></span><br><span class="line">        <span class="comment">// 它是一个储存着GLFW窗口每一个像素颜色值的大缓冲</span></span><br><span class="line">        <span class="comment">// 它在这一迭代中被用来绘制，并且将会作为输出显示在屏幕上。</span></span><br><span class="line">        glfwSwapBuffers(window);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// glfwPollEvents函数检查有没有触发什么事件</span></span><br><span class="line">        <span class="comment">// 比如键盘输入、鼠标移动、更新窗口状态等</span></span><br><span class="line">        <span class="comment">// 并调用对应的回调函数（可以通过回调方法手动设置）</span></span><br><span class="line">        glfwPollEvents();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当渲染循环结束后我们需要正确释放/删除之前的分配的所有资源</span></span><br><span class="line">    <span class="comment">// 在main函数的最后调用glfwTerminate函数来完成</span></span><br><span class="line">    glfwTerminate();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="你好，三角形"><a href="#你好，三角形" class="headerlink" title="你好，三角形"></a>你好，三角形</h2><ul><li>顶点数组对象：Vertex Array Object，VAO</li><li>顶点缓冲对象：Vertex Buffer Object，VBO</li><li>索引缓冲对象：Element Buffer Object，EBO或Index Buffer Object，IBO</li></ul><p>3D坐标转为2D坐标的处理过程是由OpenGL的图形渲染管线（Graphics Pipeline，大多译为管线，实际上指的是一堆原始图形数据途经一个输送管道，期间经过各种变化处理最终出现在屏幕的过程）管理的。</p><p>图形渲染管线可以被划分为两个主要部分：</p><ul><li>第一部分把你的3D坐标转换为2D坐标；</li><li>第二部分是把2D坐标转变为实际的有颜色的像素。</li></ul><p>2D坐标和像素也是不同的，2D坐标精确表示（通常是浮点数的形式）一个点在2D空间中的位置，而2D像素是这个点的近似值，2D像素受到你的屏幕/窗口分辨率的限制。</p><p>图形渲染管线可以被划分为几个阶段，每个阶段将会把前一个阶段的输出作为输入。所有这些阶段都是高度专门化的（它们都有一个特定的函数），并且很容易并行执行。正是由于它们具有并行执行的特性，当今大多数显卡都有成千上万的小处理核心，它们在GPU上为每一个（渲染管线）阶段运行各自的小程序，从而在图形渲染管线中快速处理你的数据。这些小程序叫做着色器(Shader)。</p><p>有些着色器允许开发者自己配置，这就允许我们用自己写的着色器来替换默认的。这样我们就可以更细致地控制图形渲染管线中的特定部分了，而且因为它们运行在GPU上，所以它们可以给我们节约宝贵的CPU时间。OpenGL着色器是用OpenGL着色器语言(OpenGL Shading Language, GLSL)写成的，在下一节中我们再花更多时间研究它。</p><div align="center"><p><img src="/images/learnopengl-c1-f1.jpg" alt="蓝色部分代表可以注入自定义的着色器"></p></div><p>首先，我们以数组的形式传递3个3D坐标作为图形渲染管线的输入，用来表示一个三角形，这个数组叫做顶点数据(Vertex Data)；顶点数据是一系列顶点的集合。一个顶点(Vertex)是一个3D坐标的数据的集合。而顶点数据是用顶点属性(Vertex Attribute)表示的，它可以包含任何我们想用的数据。</p><p>为了让OpenGL知道我们的坐标和颜色值构成的到底是什么，OpenGL需要你去指定这些数据所表示的渲染类型。是希望把这些数据渲染成一系列的点？一系列的三角形？还是仅仅是一个长长的线？做出的这些提示叫做图元(Primitive)，任何一个绘制指令的调用都将把图元传递给OpenGL。这是其中的几个：GL_POINTS、GL_TRIANGLES、GL_LINE_STRIP。</p><p>图形渲染管线的第一个部分是<strong>顶点着色器</strong>(Vertex Shader)，它把一个单独的顶点作为输入。顶点着色器主要的目的是把3D坐标转为另一种3D坐标（后面会解释），同时顶点着色器允许我们对顶点属性进行一些基本处理。</p><p><strong>图元装配</strong>(Primitive Assembly)阶段将顶点着色器输出的所有顶点作为输入（如果是GL_POINTS，那么就是一个顶点），并所有的点装配成指定图元的形状。</p><p>图元装配阶段的输出会传递给<strong>几何着色器</strong>(Geometry Shader)。几何着色器把图元形式的一系列顶点的集合作为输入，它可以通过产生新顶点构造出新的（或是其它的）图元来生成其他形状。</p><p>几何着色器的输出会被传入<strong>光栅化阶段</strong>(Rasterization Stage)，这里它会把图元映射为最终屏幕上相应的像素，生成供片段着色器(Fragment Shader)使用的片段(Fragment)。在片段着色器运行之前会<strong>执行裁切</strong>(Clipping)。裁切会丢弃超出你的视图以外的所有像素，用来提升执行效率。</p><p>OpenGL中的一个片段(Fragment)是OpenGL渲染一个像素所需的所有数据。</p><p><strong>片段着色器</strong>(Fragment Shader or Pixel Shader)的主要目的是计算一个像素的最终颜色，这也是所有OpenGL高级效果产生的地方。通常，<strong>片段着色器包含3D场景的数据（比如光照、阴影、光的颜色等等）</strong>，这些数据可以被用来计算最终像素的颜色。</p><p>在所有对应颜色值确定以后，最终的对象将会被传到最后一个阶段，我们叫做<strong>Alpha测试和混合</strong>(Blending)阶段。这个阶段检测片段的对应的<strong>深度</strong>（和模板(Stencil)）值（后面会讲），用它们来判断这个像素是其它物体的前面还是后面，决定是否应该丢弃。这个阶段也会检查<strong>alpha值</strong>（alpha值定义了一个物体的透明度）并对物体进行<strong>混合</strong>(Blend)。所以，即使在片段着色器中计算出来了一个像素输出的颜色，在渲染多个三角形的时候最后的像素颜色也可能完全不同。</p><p>可以看到，图形渲染管线非常复杂，它包含很多可配置的部分。<strong>然而，对于大多数场合</strong>，我们只需要配置<strong>顶点和片段着色器</strong>就行了，<strong>几何着色器是可选的</strong>，通常使用它默认的着色器就行了。</p><p>在<strong>现代OpenGL中</strong>，我们必须定义<strong>至少一个顶点着色器和一个片段着色器</strong>（因为<strong>GPU中没有默认的顶点/片段着色器</strong>）。出于这个原因，刚开始学习现代OpenGL的时候可能会非常困难，因为在你能够渲染自己的第一个三角形之前已经需要了解一大堆知识了。</p><h3 id="顶点输入"><a href="#顶点输入" class="headerlink" title="顶点输入"></a>顶点输入</h3><p>开始绘制图形之前，我们必须先给OpenGL输入一些顶点数据。OpenGL是一个3D图形库，所以我们在OpenGL中指定的所有坐标都是3D坐标（x、y和z）。OpenGL仅当3D坐标在3个轴（x、y和z）上都为-1.0到1.0的范围内时才处理它。所有在所谓的<strong>标准化设备坐标</strong>(Normalized Device Coordinates)范围内的坐标才会最终呈现在屏幕上（在这个范围<strong>以外的坐标都不会显示</strong>）。</p><p>由于我们希望渲染一个三角形，我们一共要指定<strong>三个顶点</strong>，每个顶点都有一个3D位置。我们会将它们以标准化设备坐标的形式（OpenGL的可见区域）定义为一个float数组。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">float</span> vertices[] = &#123;</span><br><span class="line">    <span class="number">-0.5f</span>, <span class="number">-0.5f</span>, <span class="number">0.0f</span>,</span><br><span class="line">     <span class="number">0.5f</span>, <span class="number">-0.5f</span>, <span class="number">0.0f</span>,</span><br><span class="line">     <span class="number">0.0f</span>,  <span class="number">0.5f</span>, <span class="number">0.0f</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>由于OpenGL是在3D空间中工作的，而我们渲染的是一个2D三角形，我们将它顶点的z坐标设置为0.0。这样子的话三角形每一点的深度(Depth)都是一样的，从而使它看上去像是2D的。</p><p><strong>标准化设备坐标</strong>(Normalized Device Coordinates, NDC)：一旦你的顶点坐标已经在顶点着色器中处理过，它们就应该是标准化设备坐标了，标准化设备坐标是一个x、y和z值在-1.0到1.0的一小段空间。任何落在范围外的坐标都会被丢弃/裁剪，不会显示在你的屏幕上。下面你会看到我们定义的在标准化设备坐标中的三角形(忽略z轴)：</p><div align="center"><p><img src="/images/learnopengl-c1-f2.jpg"></p></div><p>与通常的屏幕坐标不同，<strong>y轴正方向为向上</strong>，(0, 0)坐标是这个图像的中心，而不是左上角。最终你希望所有(变换过的)坐标都在这个坐标空间中，否则它们就不可见了。</p><p>你的标准化设备坐标接着会变换为<strong>屏幕空间坐标</strong>(Screen-space Coordinates)，这是使用你通过glViewport函数提供的数据，进行<strong>视口变换</strong>(Viewport Transform)完成的。所得的屏幕空间坐标又会被变换为片段输入到片段着色器中。</p><p>定义这样的顶点数据以后，我们会把它作为输入发送给图形渲染管线的第一个处理阶段：<strong>顶点着色器</strong>。它会在GPU上<strong>创建内存用于储存我们的顶点数据</strong>，还要配置OpenGL如何解释这些内存，并且指定其如何发送给显卡。顶点着色器接着会<strong>处理我们在内存中指定数量的顶点</strong>。</p><p>我们通过<strong>顶点缓冲对象</strong>(Vertex Buffer Objects, VBO)管理这个内存，它会在<strong>GPU内存</strong>（通常被称为显存）中储存大量顶点。使用这些<strong>缓冲对象</strong>的好处是我们可以<strong>一次性的发送一大批数据到显卡上</strong>，而不是每个顶点发送一次。从CPU把数据发送到显卡相对较慢，所以只要可能我们都要尝试<strong>尽量一次性发送尽可能多的数据</strong>。当数据发送至显卡的内存中后，顶点着色器几乎能立即访问顶点，这是个非常快的过程。</p><p><strong>顶点缓冲对象</strong>是我们在OpenGL教程中第一个出现的OpenGL对象。就像OpenGL中的其它对象一样，这个缓冲有一个独一无二的ID，所以我们可以使用glGenBuffers函数和一个缓冲ID生成一个VBO对象：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> VBO;</span><br><span class="line">glGenBuffers(<span class="number">1</span>, &amp;VBO);</span><br></pre></td></tr></table></figure><p>OpenGL有很多缓冲对象类型，<strong>顶点缓冲对象</strong>的缓冲类型是<code>GL_ARRAY_BUFFER</code>。OpenGL允许我们<strong>同时绑定多个缓冲</strong>，只要它们是不同的缓冲类型。我们可以使用glBindBuffer函数把<strong>新创建的缓冲</strong>绑定到GL_ARRAY_BUFFER目标上：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">glBindBuffer(GL_ARRAY_BUFFER, VBO);</span><br></pre></td></tr></table></figure><p>从这一刻起，我们使用的任何（在GL_ARRAY_BUFFER目标上的）<strong>缓冲调用</strong>都会用来<strong>配置当前绑定的缓冲</strong>(VBO)。然后我们可以调用glBufferData函数，它会把之前定义的<strong>顶点数据复制到缓冲的内存中</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">glBufferData(GL_ARRAY_BUFFER, <span class="keyword">sizeof</span>(vertices), vertices, GL_STATIC_DRAW);</span><br></pre></td></tr></table></figure><p>glBufferData是一个专门用来把<strong>用户定义的数据</strong>复制到<strong>当前绑定缓冲</strong>的函数。</p><ul><li><strong>第一个参数</strong>是目标缓冲的<strong>类型</strong>：顶点缓冲对象当前绑定到<strong>GL_ARRAY_BUFFER目标上</strong>；</li><li><strong>第二个参数</strong>指定传输数据的大小(<strong>以字节为单位</strong>)；用一个简单的sizeof计算出顶点数据大小就行；</li><li><strong>第三个参数</strong>是我们希望发送的实际数据；</li><li><strong>第四个参数</strong>指定了我们希望显卡<strong>如何管理给定的数据</strong>。它有三种形式：<ul><li>GL_STATIC_DRAW：数据不会或几乎不会改变；</li><li>GL_DYNAMIC_DRAW：数据会被改变很多；</li><li>GL_STREAM_DRAW：数据每次绘制时都会改变。</li><li>三角形的位置数据不会改变，每次渲染调用时都保持原样，所以它的使用类型最好是GL_STATIC_DRAW；</li><li>如果，比如说一个缓冲中的数据将频繁被改变，那么使用的类型就是GL_DYNAMIC_DRAW或GL_STREAM_DRAW，这样就能确保<strong>显卡把数据放在能够高速写入的内存部分</strong>。</li></ul></li></ul><p>现在我们已经把<strong>顶点数据储存在显卡的内存中</strong>，用<strong>VBO</strong>这个顶点缓冲对象管理。下面我们会创建一个<strong>顶点和片段着色器</strong>来真正处理这些数据。</p><h3 id="顶点着色器-Vertex-Shader"><a href="#顶点着色器-Vertex-Shader" class="headerlink" title="顶点着色器 Vertex Shader"></a>顶点着色器 Vertex Shader</h3><p>我们需要做的第一件事是用<strong>着色器语言GLSL</strong>(OpenGL Shading Language)编写顶点着色器，然后<strong>编译这个着色器</strong>，这样我们就可以在程序中使用它了。下面你会看到一个非常基础的GLSL顶点着色器的源代码：</p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#version 330 core</span></span><br><span class="line"><span class="keyword">layout</span> (<span class="keyword">location</span> = <span class="number">0</span>) <span class="keyword">in</span> <span class="type">vec3</span> aPos;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> main() &#123;</span><br><span class="line">    <span class="built_in">gl_Position</span> = <span class="type">vec4</span>(aPos.x, aPos.y, aPos.z, <span class="number">1.0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>GLSL看起来很像C语言。每个着色器都起始于一个版本声明。OpenGL 3.3以及和更高版本中，<strong>GLSL版本号和OpenGL的版本是匹配的</strong>（比如说GLSL 420版本对应于OpenGL 4.2）。我们同样明确表示我们会使用核心模式。</p><p>下一步，使用<code>in</code>关键字，在顶点着色器中声明<strong>所有的输入顶点属性</strong>(Input Vertex Attribute)。现在我们只关心<strong>位置</strong>(Position)数据，所以我们只需要<strong>一个顶点属性</strong>。GLSL有一个<strong>向量数据类型</strong>，它包含1到4个float分量，包含的数量可以从它的后缀数字看出来。由于每个顶点都有<strong>一个3D坐标</strong>，我们就创建一个vec3输入变量aPos。我们同样也通过<code>layout (location = 0)</code>设定了输入变量的位置值(Location)你后面会看到为什么我们会需要这个位置值。</p><p><strong>向量</strong>(Vector)：在GLSL中一个向量有最多4个分量，每个分量值都代表空间中的一个坐标，它们可以通过<code>vec.x、vec.y、vec.z</code>和<code>vec.w</code>来获取。注意<code>vec.w</code>分量不是用作表达空间中的位置的（我们处理的是3D不是4D），而是用在所谓<strong>透视除法</strong>(Perspective Division)上。</p><p>为了设置顶点着色器的输出，我们必须把<strong>位置数据赋值</strong>给预定义的<strong>gl_Position</strong>变量，它在幕后是vec4类型的。在main函数的最后，gl_Position设置的值会成为该顶点着色器的输出。</p><p>当前这个顶点着色器可能是我们能想到的最简单的顶点着色器了，因为我们<strong>对输入数据什么都没有处理就把它传到着色器的输出了</strong>。在真实的程序里<strong>输入数据通常都不是标准化设备坐标</strong>，所以我们首先必须先把它们转换至OpenGL的可视区域内。</p><h3 id="编译着色器"><a href="#编译着色器" class="headerlink" title="编译着色器"></a>编译着色器</h3><p>上面写的顶点着色器源码存储在一个C字符串中，为了能让OpenGL能使用它，我们必须在运行时动态编译它的源码。</p><p>我们首先要做的是<strong>创建一个着色器对象</strong>，注意还是用<strong>ID来引用的</strong>。所以我们储存这个顶点着色器为<code>unsigned int</code>，然后用glCreateShader创建这个着色器：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> vertexShader;</span><br><span class="line">vertexShader = glCreateShader(GL_VERTEX_SHADER);</span><br></pre></td></tr></table></figure><p>我们把需要创建的着色器类型以参数形式提供给<code>glCreateShader</code>。由于我们正在创建一个顶点着色器，传递的参数是<code>GL_VERTEX_SHADER</code>。</p><p>下一步我们把这个着色器源码附加到着色器对象上，然后编译它：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">glShaderSource(vertexShader, <span class="number">1</span>, &amp;vertexShaderSource, <span class="literal">NULL</span>);</span><br><span class="line">glCompileShader(vertexShader);</span><br></pre></td></tr></table></figure><p><code>glShaderSource</code>函数：</p><ul><li>把要<strong>编译的着色器对象</strong>作为第一个参数；</li><li>第二参数指定了传递的<strong>源码字符串数量</strong>，这里<strong>只有一个</strong>；</li><li>第三个参数是<strong>顶点着色器真正的源码</strong>；</li><li>第四个参数我们先设置为NULL。</li></ul><p>检测编译时错误可以通过以下代码来实现：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>  success;</span><br><span class="line"><span class="keyword">char</span> infoLog[<span class="number">512</span>];</span><br><span class="line">glGetShaderiv(vertexShader, GL_COMPILE_STATUS, &amp;success);</span><br></pre></td></tr></table></figure><p>首先我们定义一个<strong>整型变量来表示是否成功编译</strong>，还定义了一个储存错误消息（如果有的话）的容器。然后我们用<code>glGetShaderiv</code>检查是否编译成功。<strong>如果编译失败</strong>，我们会用<code>glGetShaderInfoLog</code>获取错误消息，然后打印它。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(!success) &#123;</span><br><span class="line">    glGetShaderInfoLog(vertexShader, <span class="number">512</span>, <span class="literal">NULL</span>, infoLog);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;ERROR::SHADER::VERTEX::COMPILATION_FAILED\n&quot;</span> &lt;&lt; infoLog &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果编译的时候没有检测到任何错误，顶点着色器就被编译成功了。</p><h3 id="片段着色器"><a href="#片段着色器" class="headerlink" title="片段着色器"></a>片段着色器</h3><p>片段着色器(Fragment Shader)是第二个也是最后一个我们打算创建的，用于渲染三角形的着色器。段着色器所做的是计算像素最后的颜色输出。为了让事情更简单，我们的片段着色器将会一直输出橘黄色(1.0f, 0.5f, 0.2f)。</p><p>在计算机图形中颜色被表示为有<strong>4个元素的数组</strong>：红色(R)、绿色(G)、蓝色(B)和alpha(透明度)分量(A)，通常缩写为RGBA。当在OpenGL或GLSL中定义一个颜色的时候，我们把颜色每个分量的强度设置在0.0到1.0之间。比如说我们设置红为1.0f，绿为1.0f，我们会得到两个颜色的混合色，即黄色。这三种颜色分量的不同调配可以生成超过1600万种不同的颜色！</p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#version 330 core</span></span><br><span class="line"><span class="keyword">out</span> <span class="type">vec4</span> FragColor;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> main() &#123;</span><br><span class="line">    FragColor = <span class="type">vec4</span>(<span class="number">1.0</span>f, <span class="number">0.5</span>f, <span class="number">0.2</span>f, <span class="number">1.0</span>f);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>片段着色器只需要一个输出变量，这个变量是一个4分量向量</strong>，它表示的是最终的输出颜色，我们应该自己将其计算出来。我们可以用<code>out</code>关键字<strong>声明输出变量</strong>，这里我们命名为<code>FragColor</code>。下面，我们将一个<code>alpha</code>值为<code>1.0</code>(1.0代表完全不透明)的橘黄色的vec4赋值给颜色输出。</p><p><strong>编译片段着色器</strong>的过程与顶点着色器类似，只不过我们使用<code>GL_FRAGMENT_SHADER</code>常量作为着色器类型：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> fragmentShader;</span><br><span class="line">fragmentShader = glCreateShader(GL_FRAGMENT_SHADER);</span><br><span class="line">glShaderSource(fragmentShader, <span class="number">1</span>, &amp;fragmentShaderSource, <span class="literal">NULL</span>);</span><br><span class="line">glCompileShader(fragmentShader);</span><br></pre></td></tr></table></figure><p>两个着色器现在都编译了，剩下的事情是把<strong>两个着色器对象链接</strong>到<strong>一个用来渲染的着色器程序</strong>(Shader Program)中。</p><h3 id="着色器程序"><a href="#着色器程序" class="headerlink" title="着色器程序"></a>着色器程序</h3><p><strong>着色器程序对象</strong>(Shader Program Object)是<strong>多个着色器合并之后并最终链接完成的版本</strong>。如果要使用刚才编译的着色器（顶点、片段），我们必须把它们<strong>链接</strong>(Link)为一个着色器程序对象，然后在<strong>渲染对象的时候激活这个着色器程序</strong>。<strong>已激活</strong>着色器程序的着色器将在我们发送<strong>渲染调用</strong>(draw call)的时候被使用。</p><p>当链接着色器至一个程序的时候，它会把每个着色器的输出链接到下个着色器的输入。当<strong>输出和输入不匹配的时候，你会得到一个连接错误</strong>。</p><p>创建一个程序对象：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> shaderProgram;</span><br><span class="line">shaderProgram = glCreateProgram();</span><br></pre></td></tr></table></figure><p>glCreateProgram函数创建一个程序，<strong>并返回新创建程序对象的ID引用</strong>。现在我们需要把之前编译的着色器附加(glAttachShader)到程序对象上，然后用<code>glLinkProgram</code>链接它们：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">glAttachShader(shaderProgram, vertexShader);</span><br><span class="line">glAttachShader(shaderProgram, fragmentShader);</span><br><span class="line">glLinkProgram(shaderProgram);</span><br></pre></td></tr></table></figure><p>代码应该很清楚，我们把着色器附加到了程序上，然后用glLinkProgram链接。</p><p>就像着色器的编译一样，我们也可以<strong>检测链接着色器程序是否失败</strong>，并获取相应的日志。与上面不同，我们不会调用glGetShaderiv和glGetShaderInfoLog，现在我们使用：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>  success;</span><br><span class="line"><span class="keyword">char</span> infoLog[<span class="number">512</span>];</span><br><span class="line">glGetProgramiv(shaderProgram, GL_LINK_STATUS, &amp;success);</span><br><span class="line"><span class="keyword">if</span>(!success) &#123;</span><br><span class="line">    glGetProgramInfoLog(shaderProgram, <span class="number">512</span>, <span class="literal">NULL</span>, infoLog);</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>得到的结果就是一个程序对象，我们可以调<code>用glUseProgram</code>函数，用刚创建的程序对象作为它的参数，以<strong>激活</strong>这个程序对象：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">glUseProgram(shaderProgram);</span><br></pre></td></tr></table></figure><p>在glUseProgram函数调用之后，<strong>每个着色器调用和渲染调用</strong>都会使用<strong>这个程序对象</strong>（也就是之前写的着色器)了。</p><p>对了，在把着色器对象<strong>链接到程序对象以后</strong>，记得<strong>删除着色器对象</strong>，我们不再需要它们了：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">glDeleteShader(vertexShader);</span><br><span class="line">glDeleteShader(fragmentShader);</span><br></pre></td></tr></table></figure><p>现在，我们已经把<strong>输入顶点数据发送给了GPU</strong>，并指示了GPU如何在顶点和片段着色器中处理它。就快要完成了，但还没结束，<strong>OpenGL还不知道它该如何解释内存中的顶点数据</strong>，以及它该如何<strong>将顶点数据链接到顶点着色器的属性上</strong>。我们需要告诉OpenGL怎么做。</p><h3 id="链接顶点属性"><a href="#链接顶点属性" class="headerlink" title="链接顶点属性"></a>链接顶点属性</h3><p>顶点着色器允许我们<strong>指定任何以顶点属性为形式的输入</strong>。这使其具有很强的灵活性的同时，它还的确意味着我们<strong>必须手动指定输入数据的哪一个部分</strong>对应顶点着色器的<strong>哪一个顶点属性</strong>。所以，我们必须在<strong>渲染前指定</strong>OpenGL该如何解释顶点数据。</p><p>顶点缓冲数据会被解析为下面这样子：</p><div align="center"><p><img src="/images/learnopengl-c1-f3.jpg"></p></div><ul><li>位置数据被储存为32位（4字节）浮点值；</li><li>每个位置包含3个这样的值；</li><li>这几个值在数组中紧密排列(Tightly Packed)；</li><li>数据中第一个值在缓冲开始的位置。</li></ul><p>有了这些信息我们就可以使用<code>glVertexAttribPointer</code>函数告诉OpenGL该如何解析顶点数据（应用到逐个顶点属性上）了：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">glVertexAttribPointer(<span class="number">0</span>, <span class="number">3</span>, GL_FLOAT, GL_FALSE, <span class="number">3</span> * <span class="keyword">sizeof</span>(<span class="keyword">float</span>), (<span class="keyword">void</span>*)<span class="number">0</span>);</span><br><span class="line">glEnableVertexAttribArray(<span class="number">0</span>);</span><br></pre></td></tr></table></figure><p><code>glVertexAttribPointer</code>函数的参数非常多，所以我会逐一介绍它们：</p><ul><li><strong>第一个参数</strong>指定我们要配置的顶点属性。还记得我们在顶点着色器中使用<code>layout(location = 0)</code>定义了<code>position</code>顶点属性的位置值(Location)吗？它可以把<strong>顶点属性的位置值</strong>设置为0。因为我们希望把<strong>数据传递到这一个顶点属性</strong>中，所以这里我们传入0；</li><li><strong>第二个参数</strong>指定顶点属性的大小。顶点属性是一个vec3，它由<code>3</code>个值组成，所以大小是3；</li><li><strong>第三个参数</strong>指定数据的类型，这里是GL_FLOAT(GLSL中vec*都是由浮点数值组成的)。</li><li><strong>第四个参数</strong>定义我们是否希望数据被<strong>标准化</strong>(Normalize)。如果我们设置为GL_TRUE，所有数据都会<strong>被映射到</strong>0（对于<strong>有符号型</strong>signed数据是-1）到1之间。我们把它设置为GL_FALSE，所有数据不会被处理。</li><li><strong>第五个参数叫做步长</strong>(Stride)，它告诉我们在<strong>连续的顶点属性组之间的间隔</strong>。由于下个组位置数据在3个float之后，我们把步长设置为<code>3 * sizeof(float)</code>。要注意的是由于我们知道这个数组是紧密排列的（在两个顶点属性之间没有空隙）我们也可以设置为<code>0</code>来<strong>让OpenGL决定具体步长是多少</strong>（只有当数值是紧密排列时才可用）。一旦我们<strong>有更多的顶点属性</strong>，我们就必须更<strong>小心地定义每个顶点属性之间的间隔</strong>，我们在后面会看到更多的例子（译注: 这个参数的意思简单说就是从这个属性<strong>第二次出现的地方到整个数组0位置之间有多少字节</strong>）；</li><li><strong>最后一个参数</strong>的类型是<code>void*</code>，所以需要我们进行<strong>这个奇怪的强制类型转换</strong>。它表示<strong>位置数据在缓冲中起始位置的偏移量</strong>(Offset)。由于位置数据在数组的开头，所以这里是0。我们会在后面详细解释这个参数。</li></ul><p>每个顶点属性从一个<strong>VBO管理的内存</strong>中获得它的数据，而具体是从哪个VBO（<strong>程序中可以有多个VBO</strong>）获取则是通过在调用<code>glVertexAttribPointer</code>时绑定到<code>GL_ARRAY_BUFFER</code>的VBO决定的。由于在调用<code>glVertexAttribPointer</code>之前绑定的是先前定义的VBO对象，<strong>顶点属性0现在会链接到它的顶点数据</strong>。</p><p>现在我们已经定义了OpenGL该如何解释顶点数据，我们现在应该使用<code>glEnableVertexAttribArray</code>，以<strong>顶点属性位置值作为参数</strong>，<strong>启用顶点属性</strong>；顶点属性默认是禁用的。</p><p>自此，<strong>所有东西都已经设置好了</strong>：</p><ul><li>我们使用一个顶点缓冲对象将顶点数据初始化至缓冲中；</li><li>建立了一个<strong>顶点</strong>和一个<strong>片段着色器</strong>；</li><li>告诉了OpenGL<strong>如何把顶点数据链接到顶点着色器的顶点属性</strong>上。</li></ul><p>在OpenGL中绘制一个物体，代码会像是这样：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 0. 复制顶点数组到缓冲中供OpenGL使用</span></span><br><span class="line">glBindBuffer(GL_ARRAY_BUFFER, VBO);</span><br><span class="line">glBufferData(GL_ARRAY_BUFFER, <span class="keyword">sizeof</span>(vertices), vertices, GL_STATIC_DRAW);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1. 设置顶点属性指针</span></span><br><span class="line">glVertexAttribPointer(<span class="number">0</span>, <span class="number">3</span>, GL_FLOAT, GL_FALSE, <span class="number">3</span> * <span class="keyword">sizeof</span>(<span class="keyword">float</span>), (<span class="keyword">void</span>*)<span class="number">0</span>);</span><br><span class="line">glEnableVertexAttribArray(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 当我们渲染一个物体时要使用着色器程序，已经编译链接好</span></span><br><span class="line">glUseProgram(shaderProgram);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 绘制物体</span></span><br><span class="line">drawCall();</span><br></pre></td></tr></table></figure><p>每当我们<strong>绘制一个物体的时候都必须重复这一过程</strong>。这看起来可能不多，但是如果有超过5个顶点属性，上百个不同物体呢（这其实并不罕见）。<strong>绑定正确的缓冲对象，为每个物体配置所有顶点属性很快就变成一件麻烦事</strong>。</p><p>有没有一些方法可以使我们把<strong>所有这些状态配置储存在一个对象</strong>中，并且可以<strong>通过绑定这个对象</strong>来恢复状态呢？</p><h3 id="顶点数组对象"><a href="#顶点数组对象" class="headerlink" title="顶点数组对象"></a>顶点数组对象</h3><p>顶点数组对象(Vertex Array Object, VAO)可以像顶点缓冲对象那样被绑定，<strong>任何随后的顶点属性调用</strong>都会储存在这个VAO中。这样的好处就是，当配置顶点属性指针时，你<strong>只需要将那些调用执行一次</strong>，之后<strong>再绘制物体的时候只需要绑定相应的VAO</strong>就行了。这使在<strong>不同顶点数据和属性配置之间切换变得非常简单</strong>，只需要绑定不同的VAO就行了。</p><p><strong>OpenGL的核心模式要求我们使用VAO</strong>，所以它知道该如何处理我们的顶点输入。如果我们绑定VAO失败，OpenGL会拒绝绘制任何东西。</p><p>一个顶点数组对象会储存以下这些内容：</p><ul><li>glEnableVertexAttribArray和glDisableVertexAttribArray的调用；</li><li>通过glVertexAttribPointer设置的顶点属性配置；</li><li>通过glVertexAttribPointer调用与顶点属性关联的顶点缓冲对象。</li></ul><div align="center"><p><img src="/images/learnopengl-c1-f4.jpg"></p></div><p>创建一个VAO和创建一个VBO很类似：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> VAO;</span><br><span class="line">glGenVertexArrays(<span class="number">1</span>, &amp;VAO);</span><br></pre></td></tr></table></figure><p>要想使用VAO，要做的只是使用glBindVertexArray<strong>绑定VAO</strong>。从绑定之后起，我们应该<strong>绑定和配置对应的VBO和属性指针，之后解绑VAO供之后使用</strong>。当我们打算绘制一个物体的时候，我们只要在<strong>绘制物体前</strong>简单地把<strong>VAO绑定到希望使用的设定</strong>上就行了：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ..:: 初始化代码（只运行一次 (除非你的物体频繁改变)） :: ..</span></span><br><span class="line"><span class="comment">// 1. 绑定VAO</span></span><br><span class="line">glBindVertexArray(VAO);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 把顶点数组复制到缓冲中供OpenGL使用</span></span><br><span class="line">glBindBuffer(GL_ARRAY_BUFFER, VBO);</span><br><span class="line">glBufferData(GL_ARRAY_BUFFER, <span class="keyword">sizeof</span>(vertices), vertices, GL_STATIC_DRAW);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 设置顶点属性指针</span></span><br><span class="line">glVertexAttribPointer(<span class="number">0</span>, <span class="number">3</span>, GL_FLOAT, GL_FALSE, <span class="number">3</span> * <span class="keyword">sizeof</span>(<span class="keyword">float</span>), (<span class="keyword">void</span>*)<span class="number">0</span>);</span><br><span class="line">glEnableVertexAttribArray(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ..:: 绘制代码（渲染循环中） :: ..</span></span><br><span class="line"><span class="comment">// 4. 绘制物体</span></span><br><span class="line">glUseProgram(shaderProgram);</span><br><span class="line">glBindVertexArray(VAO);</span><br><span class="line">drawCall();</span><br></pre></td></tr></table></figure><p>就这么多了！前面做的一切都是等待这一刻，一个<strong>储存了</strong>我们<strong>顶点属性配置</strong>和<strong>应使用的VBO</strong>的<strong>顶点数组对象</strong>。一般当你打算<strong>绘制多个物体时</strong>，你首先要生成/配置<strong>所有的VAO（和必须的VBO及属性指针)**，然后</strong>储存它们供后面使用<strong>。当我们打算</strong>绘制物体的时候就拿出相应的VAO，绑定它，绘制完物体后，再解绑VAO**。</p><h3 id="一直期待的三角形"><a href="#一直期待的三角形" class="headerlink" title="一直期待的三角形"></a>一直期待的三角形</h3><p>要想绘制我们想要的物体，OpenGL给我们提供了<code>glDrawArrays</code>函数，<strong>它使用当前激活的着色器</strong>，之前定义的顶点属性配置，和VBO的顶点数据（通过VAO间接绑定）来绘制图元。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">glUseProgram(shaderProgram);</span><br><span class="line">glBindVertexArray(VAO);</span><br><span class="line">glDrawArrays(GL_TRIANGLES, <span class="number">0</span>, <span class="number">3</span>);</span><br></pre></td></tr></table></figure><p><code>glDrawArrays</code>函数：</p><ul><li><strong>第一个参数</strong>是我们打算绘制的<strong>OpenGL图元的类型</strong>。由于我们在一开始时说过，我们希望绘制的是一个三角形，这里传递GL_TRIANGLES给它；</li><li><strong>第二个参数</strong>指定了<strong>顶点数组的起始索引</strong>，我们这里填0；</li><li><strong>最后一个参数</strong>指定我们打算<strong>绘制多少个顶点</strong>，这里是3（我们只从我们的数据中渲染一个三角形，它只有3个顶点长）。</li></ul><div align="center"><p><img src="/images/learnopengl-c1-f5.jpg"></p></div><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ... 其他代码没有修改</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span>* vertexShaderSource = <span class="string">&quot;#version 330 core\n&quot;</span></span><br><span class="line">    <span class="string">&quot;layout (location = 0) in vec3 aPos;\n&quot;</span></span><br><span class="line">    <span class="string">&quot;void main() &#123;\n&quot;</span></span><br><span class="line">    <span class="string">&quot;   gl_Position = vec4(aPos.x, aPos.y, aPos.z, 1.0);\n&quot;</span></span><br><span class="line">    <span class="string">&quot;&#125;\0&quot;</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span>* fragmentShaderSource = <span class="string">&quot;#version 330 core\n&quot;</span></span><br><span class="line">    <span class="string">&quot;out vec4 FragColor;\n&quot;</span></span><br><span class="line">    <span class="string">&quot;void main() &#123;\n&quot;</span></span><br><span class="line">    <span class="string">&quot;   FragColor = vec4(1.0f, 0.5f, 0.2f, 1.0f);\n&quot;</span></span><br><span class="line">    <span class="string">&quot;&#125;\n\0&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">get_shader_program</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建顶点着色器 VertexShader</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> vertexShader = glCreateShader(GL_VERTEX_SHADER);</span><br><span class="line">    <span class="comment">// 把着色器源码附加到着色器对象上</span></span><br><span class="line">    glShaderSource(vertexShader, <span class="number">1</span>, &amp;vertexShaderSource, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="comment">// 编译着色器</span></span><br><span class="line">    glCompileShader(vertexShader);</span><br><span class="line">    <span class="comment">// 检测编译错误</span></span><br><span class="line">    <span class="keyword">int</span> success;</span><br><span class="line">    <span class="keyword">char</span> infoLog[<span class="number">512</span>];</span><br><span class="line">    glGetShaderiv(vertexShader, GL_COMPILE_STATUS, &amp;success);</span><br><span class="line">    <span class="keyword">if</span> (!success) &#123;</span><br><span class="line">        glGetShaderInfoLog(vertexShader, <span class="number">512</span>, <span class="literal">NULL</span>, infoLog);</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;ERROR::SHADER::VERTEX::COMPILATION_FAILED\n&quot;</span> &lt;&lt; infoLog &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 创建片段着色器 FragmentShader</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> fragmentShader = glCreateShader(GL_FRAGMENT_SHADER);</span><br><span class="line">    <span class="comment">// 着色器源码附加到着色器对象上</span></span><br><span class="line">    glShaderSource(fragmentShader, <span class="number">1</span>, &amp;fragmentShaderSource, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="comment">// 编译着色器</span></span><br><span class="line">    glCompileShader(fragmentShader);</span><br><span class="line">    <span class="comment">// 检测编译错误</span></span><br><span class="line">    glGetShaderiv(fragmentShader, GL_COMPILE_STATUS, &amp;success);</span><br><span class="line">    <span class="keyword">if</span> (!success) &#123;</span><br><span class="line">        glGetShaderInfoLog(fragmentShader, <span class="number">512</span>, <span class="literal">NULL</span>, infoLog);</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;ERROR::SHADER::FRAGMENT::COMPILATION_FAILED\n&quot;</span> &lt;&lt; infoLog &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 创建程序对象</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> shaderProgram = glCreateProgram();</span><br><span class="line">    <span class="comment">// 着色器附加到程序对象上</span></span><br><span class="line">    glAttachShader(shaderProgram, vertexShader);</span><br><span class="line">    glAttachShader(shaderProgram, fragmentShader);</span><br><span class="line">    <span class="comment">// 链接</span></span><br><span class="line">    glLinkProgram(shaderProgram);</span><br><span class="line">    <span class="comment">// 检测链接错误</span></span><br><span class="line">    glGetProgramiv(shaderProgram, GL_LINK_STATUS, &amp;success);</span><br><span class="line">    <span class="keyword">if</span> (!success) &#123;</span><br><span class="line">        glGetProgramInfoLog(shaderProgram, <span class="number">512</span>, <span class="literal">NULL</span>, infoLog);</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;ERROR::SHADER::PROGRAM::LINKING_FAILED\n&quot;</span> &lt;&lt; infoLog &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 删除创建的着色器（已经不再需要了）</span></span><br><span class="line">    glDeleteShader(vertexShader);</span><br><span class="line">    glDeleteShader(fragmentShader);</span><br><span class="line">    <span class="keyword">return</span> shaderProgram;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">get_vbo_and_vao</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> &amp;VBO, <span class="keyword">unsigned</span> <span class="keyword">int</span> &amp;VAO)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">float</span> vertices[] = &#123;</span><br><span class="line">        <span class="number">-0.5f</span>, <span class="number">-0.5f</span>, <span class="number">0.0f</span>, <span class="comment">// left</span></span><br><span class="line">         <span class="number">0.5f</span>, <span class="number">-0.5f</span>, <span class="number">0.0f</span>, <span class="comment">// right</span></span><br><span class="line">         <span class="number">0.0f</span>,  <span class="number">0.5f</span>, <span class="number">0.0f</span> <span class="comment">// top</span></span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">// 创建顶点属性对象</span></span><br><span class="line">    glGenVertexArrays(<span class="number">1</span>, &amp;VAO);</span><br><span class="line">    <span class="comment">// 创建顶点缓冲对象</span></span><br><span class="line">    glGenBuffers(<span class="number">1</span>, &amp;VBO);</span><br><span class="line">    <span class="comment">// 先绑定VAO，再绑定VBO，然后再配置顶点属性</span></span><br><span class="line">    glBindVertexArray(VAO);</span><br><span class="line">    <span class="comment">// 绑定VBO到GL_ARRAY_BUFFER</span></span><br><span class="line">    glBindBuffer(GL_ARRAY_BUFFER, VBO);</span><br><span class="line">    <span class="comment">// 顶点数据复制到缓冲的内存中</span></span><br><span class="line">    glBufferData(GL_ARRAY_BUFFER, <span class="keyword">sizeof</span>(vertices), vertices, GL_STATIC_DRAW);</span><br><span class="line">    <span class="comment">// 告诉OpenGL如何解析顶点数据</span></span><br><span class="line">    glVertexAttribPointer(<span class="number">0</span>, <span class="number">3</span>, GL_FLOAT, GL_FALSE, <span class="number">3</span> * <span class="keyword">sizeof</span>(<span class="keyword">float</span>), (<span class="keyword">void</span>*)<span class="number">0</span>);</span><br><span class="line">    <span class="comment">// 以顶点属性值作为参数，启动顶点属性</span></span><br><span class="line">    glEnableVertexAttribArray(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 先解绑VAO</span></span><br><span class="line">    glBindVertexArray(<span class="number">0</span>);</span><br><span class="line">    <span class="comment">// 解绑VBO</span></span><br><span class="line">    glBindBuffer(GL_ARRAY_BUFFER, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    glfwInit();</span><br><span class="line">    glfwWindowHint(GLFW_CONTEXT_VERSION_MAJOR, <span class="number">3</span>);</span><br><span class="line">    glfwWindowHint(GLFW_CONTEXT_VERSION_MINOR, <span class="number">3</span>);</span><br><span class="line">    glfwWindowHint(GLFW_OPENGL_PROFILE, GLFW_OPENGL_CORE_PROFILE);</span><br><span class="line">    <span class="comment">// glfwWindowHint(GLFW_OPENGL_FORWARD_COMPAT, GL_TRUE); // for max os x</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// glfwCreateWindow(width, height, title, ..., ...)</span></span><br><span class="line">    GLFWwindow* window = glfwCreateWindow(<span class="number">800</span>, <span class="number">600</span>, <span class="string">&quot;LearnOpenGL&quot;</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (window == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Failed to create GLFW window&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">        glfwTerminate();</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    glfwMakeContextCurrent(window);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// GLAD是用来管理OpenGL的函数指针的</span></span><br><span class="line">    <span class="comment">// 所以在调用任何OpenGL的函数之前我们需要初始化GLAD</span></span><br><span class="line">    <span class="comment">// 给GLAD传入了用来加载系统相关的OpenGL函数指针地址的函数</span></span><br><span class="line">    <span class="comment">// GLFW给我们的是glfwGetProcAddress</span></span><br><span class="line">    <span class="comment">// 它根据我们编译的系统定义了正确的函数</span></span><br><span class="line">    <span class="keyword">if</span> (!gladLoadGLLoader((GLADloadproc)glfwGetProcAddress)) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Failed to initialize GLAD&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 告诉OpenGL渲染窗口的尺寸大小, 视口 Viewport</span></span><br><span class="line">    <span class="comment">// 窗口左下角的位置，宽度，高度</span></span><br><span class="line">    glViewport(<span class="number">0</span>, <span class="number">0</span>, <span class="number">800</span>, <span class="number">600</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当用户改变窗口的大小的时候，视口也应该被调整</span></span><br><span class="line">    <span class="comment">// 可以对窗口注册一个回调函数(Callback Function)</span></span><br><span class="line">    <span class="comment">// 它会在每次窗口大小被调整的时候被调用</span></span><br><span class="line">    <span class="comment">// void framebuffer_size_callback(GLFWwindow* window, int width, int height);</span></span><br><span class="line">    <span class="comment">// 需要注册这个函数，告诉GLFW我们希望每当窗口调整大小的时候调用这个函数</span></span><br><span class="line">    glfwSetFramebufferSizeCallback(window, framebuffer_size_callback);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 准备ShaderProgram和VBO、VAO</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> shaderProgram = get_shader_program();</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> VBO, VAO;</span><br><span class="line">    get_vbo_and_vao(VBO, VAO);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Render Loop</span></span><br><span class="line">    <span class="comment">// glfwWindowShouldClose函数在我们每次循环的开始前检查一次GLFW是否被要求退出</span></span><br><span class="line">    <span class="comment">// 如果是的话该函数返回true然后渲染循环便结束了，之后为我们就可以关闭应用程序了</span></span><br><span class="line">    <span class="keyword">while</span> (!glfwWindowShouldClose(window)) &#123;</span><br><span class="line">        <span class="comment">// 检测用户输入</span></span><br><span class="line">        process_input(window);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 渲染指令</span></span><br><span class="line">        <span class="comment">// 使用一个自定义的颜色清空屏幕</span></span><br><span class="line">        <span class="comment">// 调用了glClearColor来设置清空屏幕所用的颜色</span></span><br><span class="line">        glClearColor(<span class="number">0.2f</span>, <span class="number">0.3f</span>, <span class="number">0.3f</span>, <span class="number">1.0f</span>); <span class="comment">// 状态设置函数</span></span><br><span class="line">        <span class="comment">// 调用glClear函数来清空屏幕的颜色缓冲，它接受一个缓冲位(Buffer Bit)来指定要清空的缓冲</span></span><br><span class="line">        <span class="comment">// 可能的缓冲位有GL_COLOR_BUFFER_BIT，GL_DEPTH_BUFFER_BIT和GL_STENCIL_BUFFER_BIT</span></span><br><span class="line">        glClear(GL_COLOR_BUFFER_BIT); <span class="comment">// 状态使用函数</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 激活程序对象</span></span><br><span class="line">        glUseProgram(shaderProgram);</span><br><span class="line">        <span class="comment">// 绑定VAO</span></span><br><span class="line">        glBindVertexArray(VAO);</span><br><span class="line">        <span class="comment">// 绘制</span></span><br><span class="line">        glDrawArrays(GL_TRIANGLES, <span class="number">0</span>, <span class="number">3</span>);</span><br><span class="line">        <span class="comment">// 解绑VAO</span></span><br><span class="line">        glBindVertexArray(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// glfwSwapBuffers函数会交换颜色缓冲</span></span><br><span class="line">        <span class="comment">// 它是一个储存着GLFW窗口每一个像素颜色值的大缓冲</span></span><br><span class="line">        <span class="comment">// 它在这一迭代中被用来绘制，并且将会作为输出显示在屏幕上。</span></span><br><span class="line">        glfwSwapBuffers(window);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// glfwPollEvents函数检查有没有触发什么事件</span></span><br><span class="line">        <span class="comment">// 比如键盘输入、鼠标移动、更新窗口状态等</span></span><br><span class="line">        <span class="comment">// 并调用对应的回调函数（可以通过回调方法手动设置）</span></span><br><span class="line">        glfwPollEvents();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 可选，程序结束前释放申请的资源</span></span><br><span class="line">    glDeleteVertexArrays(<span class="number">1</span>, &amp;VAO);</span><br><span class="line">    glDeleteBuffers(<span class="number">1</span>, &amp;VBO);</span><br><span class="line">    glDeleteProgram(shaderProgram);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当渲染循环结束后我们需要正确释放/删除之前的分配的所有资源</span></span><br><span class="line">    <span class="comment">// 在main函数的最后调用glfwTerminate函数来完成</span></span><br><span class="line">    glfwTerminate();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="索引缓冲对象"><a href="#索引缓冲对象" class="headerlink" title="索引缓冲对象"></a>索引缓冲对象</h3><p>在渲染顶点这一话题上我们还有最后一个需要讨论的东西——<strong>索引缓冲对象</strong>(Element Buffer Object，EBO，也叫Index Buffer Object，IBO)。要解释索引缓冲对象的工作方式最好还是举个例子：假设我们<strong>不再绘制一个三角形而是绘制一个矩形</strong>。我们可以绘制两个三角形来组成一个矩形（OpenGL主要处理三角形）。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">float</span> vertices[] = &#123;</span><br><span class="line">    <span class="comment">// 第一个三角形</span></span><br><span class="line">    <span class="number">0.5f</span>, <span class="number">0.5f</span>, <span class="number">0.0f</span>,   <span class="comment">// 右上角</span></span><br><span class="line">    <span class="number">0.5f</span>, <span class="number">-0.5f</span>, <span class="number">0.0f</span>,  <span class="comment">// 右下角</span></span><br><span class="line">    <span class="number">-0.5f</span>, <span class="number">0.5f</span>, <span class="number">0.0f</span>,  <span class="comment">// 左上角</span></span><br><span class="line">    <span class="comment">// 第二个三角形</span></span><br><span class="line">    <span class="number">0.5f</span>, <span class="number">-0.5f</span>, <span class="number">0.0f</span>,  <span class="comment">// 右下角</span></span><br><span class="line">    <span class="number">-0.5f</span>, <span class="number">-0.5f</span>, <span class="number">0.0f</span>, <span class="comment">// 左下角</span></span><br><span class="line">    <span class="number">-0.5f</span>, <span class="number">0.5f</span>, <span class="number">0.0f</span>   <span class="comment">// 左上角</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>可以看到，<strong>有几个顶点叠加了</strong>。我们指定了右下角和左上角两次！一个矩形只有4个而不是6个顶点，这样就产生50%的额外开销。当我们有包括上千个三角形的模型之后这个问题会更糟糕，这会产生一大堆浪费。<strong>更好的解决方案是只储存不同的顶点，并设定绘制这些顶点的顺序</strong>。这样子我们只要<strong>储存4个顶点</strong>就能绘制矩形了，之后只要指定绘制的顺序就行了。如果OpenGL提供这个功能就好了，对吧？</p><p>很幸运，<strong>索引缓冲对象</strong>的工作方式正是这样的。和顶点缓冲对象一样，EBO也是一个缓冲，它<strong>专门储存索引</strong>，OpenGL调用这些<strong>顶点的索引来决定该绘制哪个顶点</strong>。所谓的<strong>索引绘制</strong>(Indexed Drawing)正是我们问题的解决方案。</p><p>首先，我们<strong>先要定义（不重复的）顶点</strong>，和绘制出矩形<strong>所需的索引</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 顶点</span></span><br><span class="line"><span class="keyword">float</span> vertices[] = &#123;</span><br><span class="line">    <span class="number">0.5f</span>, <span class="number">0.5f</span>, <span class="number">0.0f</span>,   <span class="comment">// 右上角</span></span><br><span class="line">    <span class="number">0.5f</span>, <span class="number">-0.5f</span>, <span class="number">0.0f</span>,  <span class="comment">// 右下角</span></span><br><span class="line">    <span class="number">-0.5f</span>, <span class="number">-0.5f</span>, <span class="number">0.0f</span>, <span class="comment">// 左下角</span></span><br><span class="line">    <span class="number">-0.5f</span>, <span class="number">0.5f</span>, <span class="number">0.0f</span>   <span class="comment">// 左上角</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 索引</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> indices[] = &#123; <span class="comment">// 注意索引从0开始! </span></span><br><span class="line">    <span class="number">0</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="comment">// 第一个三角形</span></span><br><span class="line">    <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>  <span class="comment">// 第二个三角形</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>下一步我们需要<strong>创建索引缓冲对象</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> EBO;</span><br><span class="line">glGenBuffers(<span class="number">1</span>, &amp;EBO);</span><br></pre></td></tr></table></figure><p>与VBO类似，我们<strong>先绑定EBO</strong>然后用<code>glBufferData</code>把<strong>索引复制到缓冲里</strong>。同样，和VBO类似，我们会<strong>把这些函数调用放在绑定和解绑函数调用之间</strong>，只不过这次我们把<strong>缓冲的类型定义</strong>为GL_ELEMENT_ARRAY_BUFFER。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, EBO);</span><br><span class="line">glBufferData(GL_ELEMENT_ARRAY_BUFFER, <span class="keyword">sizeof</span>(indices), indices, GL_STATIC_DRAW);</span><br></pre></td></tr></table></figure><p>要注意的是，我们传递了GL_ELEMENT_ARRAY_BUFFER当作缓冲目标。最后一件要做的事是<strong>用glDrawElements来替换glDrawArrays函数</strong>，来指明我们<strong>从索引缓冲渲染</strong>。使用glDrawElements时，我们会使用<strong>当前绑定的索引缓冲对象中的索引</strong>进行绘制：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, EBO);</span><br><span class="line">glDrawElements(GL_TRIANGLES, <span class="number">6</span>, GL_UNSIGNED_INT, <span class="number">0</span>);</span><br></pre></td></tr></table></figure><p><code>glDrawElements</code>的参数说明：</p><ul><li><strong>第一个参数</strong>指定了我们<strong>绘制的模式</strong>，这个和glDrawArrays的一样；</li><li><strong>第二个参数</strong>是我们打算<strong>绘制顶点的个数</strong>，这里填6，也就是说我们一共需要绘制6个顶点；</li><li><strong>第三个参数</strong>是<strong>索引的类型</strong>，这里是GL_UNSIGNED_INT；</li><li><strong>最后一个参数</strong>里我们可以指定<strong>EBO中的偏移量</strong>（或者传递一个索引数组，但是这是当你不在使用索引缓冲对象的时候），但是我们会在这里填写0。</li></ul><p><code>glDrawElements</code>函数从当前绑定到GL_ELEMENT_ARRAY_BUFFER目标的EBO中获取索引。这意味着我们必须在每次要用索引渲染一个物体时绑定相应的EBO，这还是有点麻烦。<strong>不过顶点数组对象VAO同样可以保存索引缓冲对象的绑定状态</strong>。VAO绑定时正在绑定的索引缓冲对象会被保存为VAO的元素缓冲对象。绑定VAO的同时也会自动绑定EBO。</p><div align="center"><p><img src="/images/learnopengl-c1-f6.jpg"></p></div><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ..:: 初始化代码 :: ..</span></span><br><span class="line"><span class="comment">// 1. 绑定顶点数组对象</span></span><br><span class="line">glBindVertexArray(VAO);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 把我们的顶点数组复制到一个顶点缓冲中，供OpenGL使用</span></span><br><span class="line">glBindBuffer(GL_ARRAY_BUFFER, VBO);</span><br><span class="line">glBufferData(GL_ARRAY_BUFFER, <span class="keyword">sizeof</span>(vertices), vertices, GL_STATIC_DRAW);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 复制我们的索引数组到一个索引缓冲中，供OpenGL使用</span></span><br><span class="line">glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, EBO);</span><br><span class="line">glBufferData(GL_ELEMENT_ARRAY_BUFFER, <span class="keyword">sizeof</span>(indices), indices, GL_STATIC_DRAW);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 4. 设定顶点属性指针</span></span><br><span class="line">glVertexAttribPointer(<span class="number">0</span>, <span class="number">3</span>, GL_FLOAT, GL_FALSE, <span class="number">3</span> * <span class="keyword">sizeof</span>(<span class="keyword">float</span>), (<span class="keyword">void</span>*)<span class="number">0</span>);</span><br><span class="line">glEnableVertexAttribArray(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// [...]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ..:: 绘制代码（渲染循环中） :: ..</span></span><br><span class="line">glUseProgram(shaderProgram);</span><br><span class="line">glBindVertexArray(VAO);</span><br><span class="line">glDrawElements(GL_TRIANGLES, <span class="number">6</span>, GL_UNSIGNED_INT, <span class="number">0</span>);</span><br><span class="line">glBindVertexArray(<span class="number">0</span>);</span><br></pre></td></tr></table></figure><p>当<strong>目标是GL_ELEMENT_ARRAY_BUFFER的时候</strong>，VAO会<strong>储存glBindBuffer的函数调用</strong>。这也意味着它<strong>也会储存解绑调用</strong>，所以<strong>确保你没有在解绑VAO之前解绑索引数组缓冲，否则它就没有这个EBO配置了</strong>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ... 其他代码都没有修改</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">get_vbo_ebo_and_vao</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> &amp;VBO, <span class="keyword">unsigned</span> <span class="keyword">int</span> &amp;EBO, <span class="keyword">unsigned</span> <span class="keyword">int</span> &amp;VAO)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 顶点</span></span><br><span class="line">    <span class="keyword">float</span> vertices[] = &#123;</span><br><span class="line">        <span class="number">0.5f</span>, <span class="number">0.5f</span>, <span class="number">0.0f</span>,   <span class="comment">// 右上角</span></span><br><span class="line">        <span class="number">0.5f</span>, <span class="number">-0.5f</span>, <span class="number">0.0f</span>,  <span class="comment">// 右下角</span></span><br><span class="line">        <span class="number">-0.5f</span>, <span class="number">-0.5f</span>, <span class="number">0.0f</span>, <span class="comment">// 左下角</span></span><br><span class="line">        <span class="number">-0.5f</span>, <span class="number">0.5f</span>, <span class="number">0.0f</span>   <span class="comment">// 左上角</span></span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">// 索引</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> indices[] = &#123; <span class="comment">// 注意索引从0开始! </span></span><br><span class="line">        <span class="number">0</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="comment">// 第一个三角形</span></span><br><span class="line">        <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>  <span class="comment">// 第二个三角形</span></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建顶点属性对象</span></span><br><span class="line">    glGenVertexArrays(<span class="number">1</span>, &amp;VAO);</span><br><span class="line">    <span class="comment">// 创建顶点缓冲对象和索引缓冲对象</span></span><br><span class="line">    glGenBuffers(<span class="number">1</span>, &amp;VBO);</span><br><span class="line">    glGenBuffers(<span class="number">1</span>, &amp;EBO);</span><br><span class="line">    <span class="comment">// 先绑定VAO，再绑定VBO，然后再配置顶点属性</span></span><br><span class="line">    glBindVertexArray(VAO);</span><br><span class="line">    <span class="comment">// 绑定VBO到GL_ARRAY_BUFFER</span></span><br><span class="line">    glBindBuffer(GL_ARRAY_BUFFER, VBO);</span><br><span class="line">    <span class="comment">// 顶点数据复制到缓冲的内存中</span></span><br><span class="line">    glBufferData(GL_ARRAY_BUFFER, <span class="keyword">sizeof</span>(vertices), vertices, GL_STATIC_DRAW);</span><br><span class="line">    <span class="comment">// 绑定EBO到GL_ELEMENT_ARRAY_BUFFER</span></span><br><span class="line">    glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, EBO);</span><br><span class="line">    <span class="comment">// 索引数据复制到缓冲的内存中</span></span><br><span class="line">    glBufferData(GL_ELEMENT_ARRAY_BUFFER, <span class="keyword">sizeof</span>(indices), indices, GL_STATIC_DRAW);</span><br><span class="line">    <span class="comment">// 告诉OpenGL如何解析顶点数据</span></span><br><span class="line">    glVertexAttribPointer(<span class="number">0</span>, <span class="number">3</span>, GL_FLOAT, GL_FALSE, <span class="number">3</span> * <span class="keyword">sizeof</span>(<span class="keyword">float</span>), (<span class="keyword">void</span>*)<span class="number">0</span>);</span><br><span class="line">    <span class="comment">// 以顶点属性值作为参数，启动顶点属性</span></span><br><span class="line">    glEnableVertexAttribArray(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 先解绑VAO</span></span><br><span class="line">    glBindVertexArray(<span class="number">0</span>);</span><br><span class="line">    <span class="comment">// 解绑VBO和EBO</span></span><br><span class="line">    glBindBuffer(GL_ARRAY_BUFFER, <span class="number">0</span>);</span><br><span class="line">    glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ... 其他代码都没有修改，不再赘述</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 准备ShaderProgram和VBO、VAO</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> shaderProgram = get_shader_program();</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> VBO, EBO, VAO;</span><br><span class="line">    get_vbo_ebo_and_vao(VBO, EBO, VAO);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// glPolygonMode(GL_FRONT_AND_BACK, GL_LINE);</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Render Loop</span></span><br><span class="line">    <span class="comment">// glfwWindowShouldClose函数在我们每次循环的开始前检查一次GLFW是否被要求退出</span></span><br><span class="line">    <span class="comment">// 如果是的话该函数返回true然后渲染循环便结束了，之后为我们就可以关闭应用程序了</span></span><br><span class="line">    <span class="keyword">while</span> (!glfwWindowShouldClose(window)) &#123;</span><br><span class="line">        <span class="comment">// 检测用户输入</span></span><br><span class="line">        process_input(window);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 渲染指令</span></span><br><span class="line">        <span class="comment">// 使用一个自定义的颜色清空屏幕</span></span><br><span class="line">        <span class="comment">// 调用了glClearColor来设置清空屏幕所用的颜色</span></span><br><span class="line">        glClearColor(<span class="number">0.2f</span>, <span class="number">0.3f</span>, <span class="number">0.3f</span>, <span class="number">1.0f</span>); <span class="comment">// 状态设置函数</span></span><br><span class="line">        <span class="comment">// 调用glClear函数来清空屏幕的颜色缓冲，它接受一个缓冲位(Buffer Bit)来指定要清空的缓冲</span></span><br><span class="line">        <span class="comment">// 可能的缓冲位有GL_COLOR_BUFFER_BIT，GL_DEPTH_BUFFER_BIT和GL_STENCIL_BUFFER_BIT</span></span><br><span class="line">        glClear(GL_COLOR_BUFFER_BIT); <span class="comment">// 状态使用函数</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 激活程序对象</span></span><br><span class="line">        glUseProgram(shaderProgram);</span><br><span class="line">        <span class="comment">// 绑定VAO</span></span><br><span class="line">        glBindVertexArray(VAO);</span><br><span class="line">        <span class="comment">// 绘制</span></span><br><span class="line">        glDrawElements(GL_TRIANGLES, <span class="number">6</span>, GL_UNSIGNED_INT, <span class="number">0</span>);</span><br><span class="line">        <span class="comment">// 解绑VAO</span></span><br><span class="line">        glBindVertexArray(<span class="number">0</span>); </span><br><span class="line"></span><br><span class="line">        <span class="comment">// glfwSwapBuffers函数会交换颜色缓冲</span></span><br><span class="line">        <span class="comment">// 它是一个储存着GLFW窗口每一个像素颜色值的大缓冲</span></span><br><span class="line">        <span class="comment">// 它在这一迭代中被用来绘制，并且将会作为输出显示在屏幕上。</span></span><br><span class="line">        glfwSwapBuffers(window);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// glfwPollEvents函数检查有没有触发什么事件</span></span><br><span class="line">        <span class="comment">// 比如键盘输入、鼠标移动、更新窗口状态等</span></span><br><span class="line">        <span class="comment">// 并调用对应的回调函数（可以通过回调方法手动设置）</span></span><br><span class="line">        glfwPollEvents();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// glPolygonMode(GL_FRONT_AND_BACK, GL_FILL);</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 可选，程序结束前释放申请的资源</span></span><br><span class="line">    glDeleteVertexArrays(<span class="number">1</span>, &amp;VAO);</span><br><span class="line">    glDeleteBuffers(<span class="number">1</span>, &amp;VBO);</span><br><span class="line">    glDeleteBuffers(<span class="number">1</span>, &amp;EBO);</span><br><span class="line">    glDeleteProgram(shaderProgram);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当渲染循环结束后我们需要正确释放/删除之前的分配的所有资源</span></span><br><span class="line">    <span class="comment">// 在main函数的最后调用glfwTerminate函数来完成</span></span><br><span class="line">    glfwTerminate();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><div align="center"><p><img src="/images/learnopengl-c1-f7.jpg"></p></div><p><strong>线框模式</strong>(Wireframe Mode)：要想用线框模式绘制你的三角形，你可以通过<code>glPolygonMode(GL_FRONT_AND_BACK, GL_LINE)</code>函数配置OpenGL如何绘制图元。<strong>第一个参数</strong>表示我们打算将其应用到所有的三角形的正面和背面，<strong>第二个参数</strong>告诉我们用线来绘制。之后的绘制调用会一直以线框模式绘制三角形，直到我们用<code>glPolygonMode(GL_FRONT_AND_BACK, GL_FILL)</code>将其设置回默认模式。</p><h3 id="练习题"><a href="#练习题" class="headerlink" title="练习题"></a>练习题</h3><ol><li>添加更多顶点到数据中，使用glDrawArrays，尝试绘制两个彼此相连的三角形；</li><li>创建相同的两个三角形，但对它们的数据使用不同的VAO和VBO；</li><li>创建两个着色器程序，第二个程序使用一个不同的片段着色器，输出黄色；再次绘制这两个三角形，让其中一个输出为黄色。</li></ol><p>（咕咕，之后再做）</p><hr><h2 id="着色器"><a href="#着色器" class="headerlink" title="着色器"></a>着色器</h2><p>从基本意义上来说，着色器只是一种把输入转化为输出的程序。着色器也是一种非常独立的程序，因为它们之间不能相互通信；它们之间唯一的沟通只有通过输入和输出。</p><p>现在我们会用一种更加广泛的形式详细解释着色器，特别是OpenGL着色器语言(GLSL)。</p><h3 id="GLSL"><a href="#GLSL" class="headerlink" title="GLSL"></a>GLSL</h3><p>着色器是使用一种叫<strong>GLSL的类C语言</strong>写成的。<strong>GLSL是为图形计算量身定制的</strong>，它包含一些针对向量和矩阵操作的有用特性。</p><p>着色器的开头总是要<strong>声明版本</strong>，接着是<strong>输入和输出变量、uniform和main函数</strong>。每个着色器的入口点都是main函数，在这个函数中我们处理所有的输入变量，并将结果输出到输出变量中。如果你不知道什么是uniform也不用担心，我们后面会进行讲解。</p><p>一个典型的着色器有下面的结构：</p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#version version_number</span></span><br><span class="line"><span class="keyword">in</span> type in_variable_name;</span><br><span class="line"><span class="keyword">in</span> type in_variable_name;</span><br><span class="line"></span><br><span class="line"><span class="keyword">out</span> type out_variable_name;</span><br><span class="line"></span><br><span class="line"><span class="keyword">uniform</span> type uniform_name;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> main()</span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// 处理输入并进行一些图形操作</span></span><br><span class="line">  ...</span><br><span class="line">  <span class="comment">// 输出处理过的结果到输出变量</span></span><br><span class="line">  out_variable_name = weird_stuff_we_processed;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当我们特别谈论到<strong>顶点着色器</strong>的时候，每个输入变量也叫<strong>顶点属性</strong>(Vertex Attribute)。我们能声明的<strong>顶点属性是有上限的，它一般由硬件来决定</strong>。OpenGL确保<strong>至少有16个包含4分量的顶点属性可用</strong>，但是有些硬件或许允许更多的顶点属性，你可以查询<code>GL_MAX_VERTEX_ATTRIBS</code>来获取具体的上限：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> nrAttributes;</span><br><span class="line">glGetIntegerv(GL_MAX_VERTEX_ATTRIBS, &amp;nrAttributes);</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Maximum nr of vertex attributes supported: &quot;</span> &lt;&lt; nrAttributes &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure><p>通常情况下它至少会返回16个，大部分情况下是够用了。</p><h3 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h3><p>和其他编程语言一样，GLSL有数据类型可以来指定变量的种类。GLSL中包含C等其它语言大部分的默认基础数据类型：<code>int</code>、<code>float</code>、<code>double</code>、<code>uint</code>和<code>bool</code>。GLSL也有<strong>两种容器类型</strong>，它们会在这个教程中使用很多，分别是<strong>向量</strong>(Vector)和<strong>矩阵</strong>(Matrix)，其中矩阵我们会在之后的教程里再讨论。</p><p><strong>向量</strong>(Vector)：GLSL中的向量是一个可以包含有1、2、3或者4个分量的容器，分量的类型可以是前面默认基础类型的任意一个。它们可以是下面的形式（<code>n</code>代表分量的数量）：</p><ul><li><code>vecn</code>：包含<code>n</code>个<code>float</code>分量的默认向量；</li><li><code>bvecn</code>：包含<code>n</code>个<code>bool</code>分量的向量；</li><li><code>ivecn</code>：包含<code>n</code>个<code>int</code>分量的向量；</li><li><code>uvecn</code>：包含<code>n</code>个<code>unsigned int</code>分量的向量；</li><li><code>dvecn</code>：包含<code>n</code>个<code>double</code>分量的向量。</li></ul><p>大多数时候我们使用<code>vecn</code>，因为<code>float</code>足够满足大多数要求了。</p><p>一个向量的分量可以通过<code>vec.x</code>这种方式获取，这里<code>x</code>是指这个向量的第一个分量。你可以分别使用<code>.x、.y、.z</code>和<code>.w</code>来获取它们的第<code>1、2、3、4</code>个分量。GLSL也允许你对颜色使用<code>rgba</code>，或是对纹理坐标使用<code>stpq</code>访问相同的分量。</p><p>向量这一数据类型也允许一些有趣而灵活的分量选择方式，叫做<strong>重组</strong>(Swizzling)。重组允许这样的语法：</p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">vec2</span> someVec;</span><br><span class="line"><span class="type">vec4</span> differentVec = someVec.xyxx;</span><br><span class="line"><span class="type">vec3</span> anotherVec = differentVec.zyw;</span><br><span class="line"><span class="type">vec4</span> otherVec = someVec.xxxx + anotherVec.yxzy;</span><br></pre></td></tr></table></figure><p>你可以使用上面<strong>4个字母任意组合</strong>来创建一个和原来向量一样长的（同类型）新向量，只要原来向量有那些分量即可；然而，<strong>你不允许在一个vec2向量中去获取.z元素</strong>。我们也可以<strong>把一个向量作为一个参数传给不同的向量构造函数</strong>，以减少需求参数的数量：</p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">vec2</span> vect = <span class="type">vec2</span>(<span class="number">0.5</span>, <span class="number">0.7</span>);</span><br><span class="line"><span class="type">vec4</span> result = <span class="type">vec4</span>(vect, <span class="number">0.0</span>, <span class="number">0.0</span>);</span><br><span class="line"><span class="type">vec4</span> otherResult = <span class="type">vec4</span>(result.xyz, <span class="number">1.0</span>);</span><br></pre></td></tr></table></figure><p>向量是一种灵活的数据类型，我们可以把用在各种输入和输出上。</p><h3 id="输入与输出"><a href="#输入与输出" class="headerlink" title="输入与输出"></a>输入与输出</h3><p>我们希望<strong>每个着色器都有输入和输出</strong>，这样才能进行数据交流和传递。GLSL定义了<code>in</code>和<code>out</code>关键字专门来实现这个目的。每个着色器使用这两个关键字设定输入和输出，<strong>只要一个输出变量与下一个着色器阶段的输入匹配</strong>，它就会传递下去。但在<strong>顶点和片段着色器</strong>中会有点不同。</p><p><strong>顶点着色器</strong>应该接收的是一种<strong>特殊形式的输入</strong>，否则就会效率低下。顶点着色器的输入特殊在，它<strong>从顶点数据中直接接收输入</strong>。为了定义顶点数据该如何管理，我们使用<code>location</code>这一<strong>元数据指定输入变量</strong>，这样我们才可以在CPU上配置顶点属性。我们已经在前面的教程看过这个了，<code>layout (location = 0)</code>。顶点着色器需要为它的输入提供一个<strong>额外的layout标识</strong>，这样我们才能把它链接到顶点数据。</p><p>你也可以忽略layout (location = 0)标识符，通过在OpenGL代码中使用<code>glGetAttribLocation</code>查询属性位置值(Location)，但是我更喜欢在着色器中设置它们，这样会更容易理解而且节省你（和OpenGL）的工作量。</p><p>另一个例外是<strong>片段着色器</strong>，它需要一个<code>vec4</code>颜色输出变量，因为片段着色器需要生成一个最终输出的颜色。如果你在片段着色器没有定义输出颜色，OpenGL会把你的物体渲染为黑色（或白色）。</p><p>所以，如果我们打算从一个着色器向另一个着色器发送数据，我们必须在<strong>发送方着色器中声明一个输出</strong>，在<strong>接收方着色器中声明一个类似的输入</strong>。当<strong>类型和名字</strong>都一样的时候，OpenGL就会把两个变量链接到一起，它们之间就能发送数据了（这是在<strong>链接程序对象</strong>时完成的）。</p><p>为了展示这是如何工作的，我们会稍微改动一下之前教程里的那个着色器，让顶点着色器为片段着色器决定颜色。</p><p>顶点着色器：</p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#version 330 core</span></span><br><span class="line"><span class="keyword">layout</span> (<span class="keyword">location</span> = <span class="number">0</span>) <span class="keyword">in</span> <span class="type">vec3</span> aPos; <span class="comment">// 位置变量的属性位置值为0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">out</span> <span class="type">vec4</span> vertexColor; <span class="comment">// 为片段着色器指定一个颜色输出</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> main() &#123;</span><br><span class="line">    <span class="built_in">gl_Position</span> = <span class="type">vec4</span>(aPos, <span class="number">1.0</span>); <span class="comment">// 把一个vec3作为vec4的构造器的参数</span></span><br><span class="line">    vertexColor = <span class="type">vec4</span>(<span class="number">0.5</span>, <span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">1.0</span>); <span class="comment">// 把输出变量设置为暗红色</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>片段着色器：</p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#version 330 core</span></span><br><span class="line"><span class="keyword">out</span> <span class="type">vec4</span> FragColor;</span><br><span class="line"></span><br><span class="line"><span class="keyword">in</span> <span class="type">vec4</span> vertexColor; <span class="comment">// 从顶点着色器传来的输入变量（名称相同、类型相同）</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> main() &#123;</span><br><span class="line">    FragColor = vertexColor;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>你可以看到我们在顶点着色器中声明了一个vertexColor变量作为vec4输出，并在片段着色器中声明了一个类似的vertexColor。由于它们<strong>名字相同且类型相同</strong>，片段着色器中的vertexColor就和顶点着色器中的vertexColor链接了。由于我们在顶点着色器中将颜色设置为深红色，最终的片段也是深红色的。</p><p>让我们更上一层楼，看看能否从应用程序中直接给片段着色器发送一个颜色！</p><h3 id="Uniform"><a href="#Uniform" class="headerlink" title="Uniform"></a>Uniform</h3><p><strong>Uniform</strong>是一种<strong>从CPU中的应用</strong>向<strong>GPU中的着色器</strong>发送数据的方式，但uniform和顶点属性有些不同。首先，uniform是<strong>全局的</strong>(Global)。全局意味着uniform变量<strong>必须在每个着色器程序对象中都是独一无二的</strong>(只有一个，而不是每个着色器都有单独一个的意思)，而且它可以被着色器程序的<strong>任意着色器在任意阶段访问</strong>。第二，无论你把uniform值设置成什么，<strong>uniform会一直保存它们的数据</strong>，直到它们被重置或更新。</p><p>我们可以在一个着色器中添加<code>uniform</code>关键字至<strong>类型和变量名前</strong>来声明一个GLSL的uniform。从此处开始我们就可以在着色器中使用新声明的uniform了。我们来看看这次是否能通过uniform设置三角形的颜色：</p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#version 330 core</span></span><br><span class="line"><span class="keyword">out</span> <span class="type">vec4</span> FragColor;</span><br><span class="line"></span><br><span class="line"><span class="keyword">uniform</span> <span class="type">vec4</span> ourColor; <span class="comment">// 在OpenGL程序代码中设定这个变量</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> main() &#123;</span><br><span class="line">    FragColor = ourColor;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们在<strong>片段着色器</strong>中声明了一个<code>uniform vec4</code>的ourColor，并把片段着色器的输出颜色设置为uniform值的内容。因为uniform是全局变量，我们可以在<strong>任何着色器中定义它们</strong>，而无需通过顶点着色器作为中介。顶点着色器中不需要这个uniform，所以我们不用在那里定义它。</p><p>如果你声明了一个uniform却在GLSL代码中没用过，<strong>编译器会静默移除这个变量</strong>，导致最后编译出的版本中并不会包含它，这可能导致几个非常麻烦的错误，记住这点！</p><p>这个uniform现在还是空的；我们还没有给它添加任何数据，所以下面我们就做这件事。我们首先需要<strong>找到着色器中</strong>uniform属性的<strong>索引/位置值</strong>。当我们得到uniform的索引/位置值后，我们就可以<strong>更新它的值了</strong>。这次我们不去给像素传递单独一个颜色，而是让它随着时间改变颜色：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">float</span> timeValue = glfwGetTime();</span><br><span class="line"><span class="keyword">float</span> greenValue = (<span class="built_in">sin</span>(timeValue) / <span class="number">2.0f</span>) + <span class="number">0.5f</span>;</span><br><span class="line"><span class="keyword">int</span> vertexColorLocation = glGetUniformLocation(shaderProgram, <span class="string">&quot;ourColor&quot;</span>);</span><br><span class="line">glUseProgram(shaderProgram);</span><br><span class="line">glUniform4f(vertexColorLocation, <span class="number">0.0f</span>, greenValue, <span class="number">0.0f</span>, <span class="number">1.0f</span>);</span><br></pre></td></tr></table></figure><p>首先我们通过glfwGetTime()获取运行的秒数。然后我们使用sin函数让颜色在0.0到1.0之间改变，最后将结果储存到greenValue里。</p><p>接着，我们用glGetUniformLocation查询uniform ourColor的位置值。我们为查询函数提供着色器程序和uniform的名字（这是我们希望获得的位置值的来源）。如果glGetUniformLocation返回-1就代表没有找到这个位置值。最后，我们可以通过glUniform4f函数设置uniform值。注意，<strong>查询uniform地址不要求你之前使用过着色器程序</strong>，但是<strong>更新一个uniform之前你必须先使用程序</strong>（调用glUseProgram)，因为它是在<strong>当前激活的着色器程序中设置uniform的</strong>。</p><p>因为OpenGL在其核心是一个C库，所以<strong>它不支持类型重载</strong>，<strong>在函数参数不同的时候就要为其定义新的函数</strong>；<code>glUniform</code>是一个典型例子。这个函数有一个特定的后缀，标识设定的uniform的类型。可能的后缀有：</p><ul><li><code>f</code>：函数需要一个float作为它的值；</li><li><code>i</code>：函数需要一个int作为它的值；</li><li><code>ui</code>：函数需要一个unsigned int作为它的值；</li><li><code>3f</code>：函数需要3个float作为它的值；</li><li><code>fv</code>：函数需要一个float向量/数组作为它的值。</li></ul><p>每当你打算配置一个OpenGL的选项时就可以简单地根据这些规则选择适合你的数据类型的重载函数。在我们的例子里，我们希望分别设定uniform的4个float值，所以我们通过glUniform4f传递我们的数据(注意，我们也可以使用fv版本，一维向量)。</p><p>现在你知道如何设置uniform变量的值了，我们可以使用它们来渲染了。如果我们打算让颜色慢慢变化，我们就要在游戏循环的<strong>每一次迭代中</strong>（所以他会逐帧改变）<strong>更新这个</strong>uniform，否则三角形就不会改变颜色。</p><p>uniform对于<strong>设置一个在渲染迭代中会改变的属性是一个非常有用的工具</strong>，它也是一个在<strong>程序和着色器间数据交互的很好工具</strong>，但假如我们打算为<strong>每个顶点设置一个颜色</strong>的时候该怎么办？这种情况下，我们就不得不声明和顶点数目一样多的uniform了。在这一问题上<strong>更好的解决方案是在顶点属性中包含更多的数据</strong>，这是我们接下来要做的事情。</p><h3 id="更多属性"><a href="#更多属性" class="headerlink" title="更多属性"></a>更多属性</h3><p>在前面的教程中，我们了解了如何填充VBO、配置顶点属性指针以及如何把它们都储存到一个VAO里。这次，我们同样打算把颜色数据加进顶点数据中。我们将把颜色数据添加为3个float值至vertices数组。我们将把三角形的三个角分别指定为红色、绿色和蓝色：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">float</span> vertices[] = &#123;</span><br><span class="line">    <span class="comment">// 位置              // 颜色</span></span><br><span class="line">     <span class="number">0.5f</span>, <span class="number">-0.5f</span>, <span class="number">0.0f</span>,  <span class="number">1.0f</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span>,   <span class="comment">// 右下</span></span><br><span class="line">    <span class="number">-0.5f</span>, <span class="number">-0.5f</span>, <span class="number">0.0f</span>,  <span class="number">0.0f</span>, <span class="number">1.0f</span>, <span class="number">0.0f</span>,   <span class="comment">// 左下</span></span><br><span class="line">     <span class="number">0.0f</span>,  <span class="number">0.5f</span>, <span class="number">0.0f</span>,  <span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">1.0f</span>    <span class="comment">// 顶部</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>由于现在有更多的数据要发送到顶点着色器，我们有必要去<strong>调整一下顶点着色器</strong>，使它能够<strong>接收颜色值作为一个顶点属性输入</strong>。需要注意的是我们用<code>layout</code>标识符来把<code>aColor</code>属性的位置值设置为<code>1</code>：</p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#version 330 core</span></span><br><span class="line"><span class="keyword">layout</span> (<span class="keyword">location</span> = <span class="number">0</span>) <span class="keyword">in</span> <span class="type">vec3</span> aPos;   <span class="comment">// 位置变量的属性位置值为 0</span></span><br><span class="line"><span class="keyword">layout</span> (<span class="keyword">location</span> = <span class="number">1</span>) <span class="keyword">in</span> <span class="type">vec3</span> aColor; <span class="comment">// 颜色变量的属性位置值为 1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">out</span> <span class="type">vec3</span> ourColor; <span class="comment">// 向片段着色器输出一个颜色</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> main() &#123;</span><br><span class="line">    <span class="built_in">gl_Position</span> = <span class="type">vec4</span>(aPos, <span class="number">1.0</span>);</span><br><span class="line">    ourColor = aColor; <span class="comment">// 将ourColor设置为我们从顶点数据那里得到的输入颜色</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于我们不再使用uniform来传递片段的颜色了，现在使用ourColor输出变量，我们必须再修改一下片段着色器：</p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#version 330 core</span></span><br><span class="line"><span class="keyword">out</span> <span class="type">vec4</span> FragColor;  </span><br><span class="line"><span class="keyword">in</span> <span class="type">vec3</span> ourColor;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> main() &#123;</span><br><span class="line">    FragColor = <span class="type">vec4</span>(ourColor, <span class="number">1.0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为我们添加了另一个顶点属性，并且更新了VBO的内存，我们就必须<strong>重新配置顶点属性指针</strong>。更新后的VBO内存中的数据现在看起来像这样：</p><div align="center"><p><img src="/images/learnopengl-c1-f8.jpg"></p></div><p>知道了现在使用的布局，我们就可以使用<code>glVertexAttribPointer</code>函数更新顶点格式，</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 位置属性</span></span><br><span class="line">glVertexAttribPointer(<span class="number">0</span>, <span class="number">3</span>, GL_FLOAT, GL_FALSE, <span class="number">6</span> * <span class="keyword">sizeof</span>(<span class="keyword">float</span>), (<span class="keyword">void</span>*)<span class="number">0</span>);</span><br><span class="line">glEnableVertexAttribArray(<span class="number">0</span>);</span><br><span class="line"><span class="comment">// 颜色属性</span></span><br><span class="line">glVertexAttribPointer(<span class="number">1</span>, <span class="number">3</span>, GL_FLOAT, GL_FALSE, <span class="number">6</span> * <span class="keyword">sizeof</span>(<span class="keyword">float</span>), (<span class="keyword">void</span>*)(<span class="number">3</span>* <span class="keyword">sizeof</span>(<span class="keyword">float</span>)));</span><br><span class="line">glEnableVertexAttribArray(<span class="number">1</span>);</span><br></pre></td></tr></table></figure><p>glVertexAttribPointer函数的前几个参数比较明了。这次我们配置属性位置值为1的顶点属性。颜色值有3个float那么大，我们不去标准化这些值。</p><p>由于我们现在有了两个顶点属性，我们不得不<strong>重新计算步长值</strong>。为获得数据队列中下一个属性值（比如位置向量的下个x分量）我们必须向右移动6个float，其中3个是位置值，另外3个是颜色值。这使我们的步长值为<strong>6乘以float的字节数**</strong>（=24字节）。</p><p>同样，这次我们必须指定一个偏移量。对于每个顶点来说，位置顶点属性在前，所以它的偏移量是0。颜色属性紧随位置数据之后，所以<strong>偏移量</strong>就是3 * sizeof(float)，用字节来计算就是12字节。</p><div align="center"><p><img src="/images/learnopengl-c1-f9.jpg" alt="沿用了上一节的矩形渲染"></p></div><p>这个图片可能不是你所期望的那种，因为我们只提供了3个颜色，而不是我们现在看到的大调色板。这是在片段着色器中进行的所谓<strong>片段插值</strong>(Fragment Interpolation)的结果。当渲染一个三角形时，<strong>光栅化</strong>(Rasterization)阶段通常会造成比原指定顶点<strong>更多的片段</strong>。光栅会根据<strong>每个片段在三角形形状上所处相对位置</strong>决定这些片段的位置（属性？）。</p><h3 id="我们自己的着色器类"><a href="#我们自己的着色器类" class="headerlink" title="我们自己的着色器类"></a>我们自己的着色器类</h3><p>编写、编译、管理着色器是件麻烦事。在着色器主题的最后，我们会<strong>写一个类</strong>来让我们的生活轻松一点，它可以<strong>从硬盘读取着色器</strong>，然后<strong>编译并链接它们</strong>，并对它们进行错误检测，这就变得很好用了。这也会让你了解该如何封装目前所学的知识到一个抽象对象中。</p><p>我们会把<strong>着色器类全部放在在头文件里</strong>，主要是为了学习用途，当然也方便移植。我们先来添加必要的include，并定义类结构：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> SHADER_H <span class="comment">// 避免重复include</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SHADER_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;glad/glad.h&gt;; // 包含glad来获取所有的必须OpenGL头文件</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Shader</span> &#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="comment">// 程序ID</span></span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">int</span> ID;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 构造器读取并构建着色器</span></span><br><span class="line">        Shader(<span class="keyword">const</span> GLchar* vertexPath, <span class="keyword">const</span> GLchar* fragmentPath);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 使用/激活程序</span></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">use</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// uniform工具函数</span></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">setBool</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp;name, <span class="keyword">bool</span> value)</span> <span class="keyword">const</span></span>;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">setInt</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp;name, <span class="keyword">int</span> value)</span> <span class="keyword">const</span></span>;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">setFloat</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp;name, <span class="keyword">float</span> value)</span> <span class="keyword">const</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>在上面，我们在<strong>头文件顶部使用了几个预处理指令</strong>(Preprocessor Directives)。这些预处理指令(<code>#ifndef SHADER_H</code>)会告知你的编译器<strong>只在它没被包含过的情况下才包含和编译这个头文件</strong>，<strong>即使多个文件都包含了这个着色器头文件</strong>。它是用来防止链接冲突的。</p><p><strong>着色器类储存了着色器程序的ID</strong>。它的构造器需要顶点和片段着色器源代码的文件路径，这样我们就可以把源码的文本文件储存在硬盘上了。除此之外，为了让我们的生活更轻松一点，还加入了一些工具函数：<code>use</code>用来激活着色器程序，所有的<code>set…</code>函数能够查询一个<code>unform</code>的位置值并设置它的值。</p><h3 id="从文件读取"><a href="#从文件读取" class="headerlink" title="从文件读取"></a>从文件读取</h3><p>我们使用C++文件流读取着色器内容，储存到几个string对象里：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 构造器读取并构建着色器</span></span><br><span class="line">Shader(<span class="keyword">const</span> GLchar* vertexPath, <span class="keyword">const</span> GLchar* fragmentPath) &#123;</span><br><span class="line">    <span class="comment">// 1. 从文件路径中获取顶点/片段着色器</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> vertexCode;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> fragmentCode;</span><br><span class="line">    <span class="built_in">std</span>::ifstream vShaderFile;</span><br><span class="line">    <span class="built_in">std</span>::ifstream fShaderFile;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 保证ifstream对象可以抛出异常</span></span><br><span class="line">    vShaderFile.exceptions(<span class="built_in">std</span>::ifstream::failbit | <span class="built_in">std</span>::ifstream::badbit);</span><br><span class="line">    fShaderFile.exceptions(<span class="built_in">std</span>::ifstream::failbit | <span class="built_in">std</span>::ifstream::badbit);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 打开文件</span></span><br><span class="line">        vShaderFile.open(vertexPath);</span><br><span class="line">        fShaderFile.open(fragmentPath);</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">stringstream</span> vShaderStream, fShaderStream;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 读取文件的缓冲内容到数据流中</span></span><br><span class="line">        vShaderStream &lt;&lt; vShaderFile.rdbuf();</span><br><span class="line">        fShaderStream &lt;&lt; fShaderFile.rdbuf();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 关闭文件处理器</span></span><br><span class="line">        vShaderFile.close();</span><br><span class="line">        fShaderFile.close();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 转换数据流到string</span></span><br><span class="line">        vertexCode = vShaderStream.str();</span><br><span class="line">        fragmentCode = fShaderStream.str();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (<span class="built_in">std</span>::ifstream::failure e) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;ERROR::SHADER::FILE_NOT_SUCCESFULLY_READ&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>* vShaderCode = vertexCode.c_str();</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>* fShaderCode = fragmentCode.c_str();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ... 后续代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下一步，我们需要<strong>编译和链接着色器</strong>。注意，我们也将检查编译/链接是否失败，如果失败则打印编译时错误，调试的时候这些错误输出会及其重要（你总会需要这些错误日志的）：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 构造器读取并构建着色器</span></span><br><span class="line">Shader(<span class="keyword">const</span> GLchar* vertexPath, <span class="keyword">const</span> GLchar* fragmentPath) &#123;</span><br><span class="line">    <span class="comment">// 1. 从文件路径中获取顶点/片段着色器</span></span><br><span class="line">    <span class="comment">// ... 这部分代码见上面</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 编译着色器</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> vertexShader, fragmentShader;</span><br><span class="line">    <span class="keyword">int</span> success;</span><br><span class="line">    <span class="keyword">char</span> infoLog[<span class="number">512</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 顶点着色器</span></span><br><span class="line">    vertexShader = glCreateShader(GL_VERTEX_SHADER);</span><br><span class="line">    glShaderSource(vertexShader, <span class="number">1</span>, &amp;vShaderCode, <span class="literal">NULL</span>);</span><br><span class="line">    glCompileShader(vertexShader);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打印编译错误（如果有的话）</span></span><br><span class="line">    glGetShaderiv(vertexShader, GL_COMPILE_STATUS, &amp;success);</span><br><span class="line">    <span class="keyword">if</span> (!success) &#123;</span><br><span class="line">        glGetShaderInfoLog(vertexShader, <span class="number">512</span>, <span class="literal">NULL</span>, infoLog);</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;ERROR::SHADER::VERTEX::COMPILATION_FAILED\n&quot;</span> &lt;&lt; infoLog &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 片段着色器</span></span><br><span class="line">    fragmentShader = glCreateShader(GL_FRAGMENT_SHADER);</span><br><span class="line">    glShaderSource(fragmentShader, <span class="number">1</span>, &amp;fShaderCode, <span class="literal">NULL</span>);</span><br><span class="line">    glCompileShader(fragmentShader);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打印编译错误（如果有的话）</span></span><br><span class="line">    glGetShaderiv(fragmentShader, GL_COMPILE_STATUS, &amp;success);</span><br><span class="line">    <span class="keyword">if</span> (!success) &#123;</span><br><span class="line">        glGetShaderInfoLog(fragmentShader, <span class="number">512</span>, <span class="literal">NULL</span>, infoLog);</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;ERROR::SHADER::VERTEX::COMPILATION_FAILED\n&quot;</span> &lt;&lt; infoLog &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    ID = glCreateProgram();</span><br><span class="line">    glAttachShader(ID, vertexShader);</span><br><span class="line">    glAttachShader(ID, fragmentShader);</span><br><span class="line">    glLinkProgram(ID);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打印连接错误（如果有的话）</span></span><br><span class="line">    glGetProgramiv(ID, GL_LINK_STATUS, &amp;success);</span><br><span class="line">    <span class="keyword">if</span> (!success) &#123;</span><br><span class="line">        glGetProgramInfoLog(ID, <span class="number">512</span>, <span class="literal">NULL</span>, infoLog);</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;ERROR::SHADER::PROGRAM::LINKING_FAILED\n&quot;</span> &lt;&lt; infoLog &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 删除着色器，它们已经链接到我们的程序中了，已经不再需要了</span></span><br><span class="line">    glDeleteShader(vertexShader);</span><br><span class="line">    glDeleteShader(fragmentShader);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>use函数非常简单：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用/激活程序</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">use</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    glUseProgram(ID);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>uniform的setter函数也很类似：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// uniform工具函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setBool</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp;name, <span class="keyword">bool</span> value)</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">    glUniform1i(glGetUniformLocation(ID, name.c_str()), (<span class="keyword">int</span>)value);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setInt</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp;name, <span class="keyword">int</span> value)</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">    glUniform1i(glGetUniformLocation(ID, name.c_str()), value);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setFloat</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp;name, <span class="keyword">float</span> value)</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">    glUniform1f(glGetUniformLocation(ID, name.c_str()), value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在我们就写完了一个完整的着色器类。使用这个着色器类很简单；只要创建一个着色器对象，从那一点开始我们就可以开始使用了：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ... GLFW GLAD初始化</span></span><br><span class="line"><span class="comment">// ... VBO EBO VAO初始化</span></span><br><span class="line"><span class="function">Shader <span class="title">ourShader</span><span class="params">(<span class="string">&quot;shader.vs&quot;</span>, <span class="string">&quot;shader.fs&quot;</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(...) &#123;</span><br><span class="line">    <span class="comment">// ... 其他操作</span></span><br><span class="line">    ourShader.use(); <span class="comment">// 代替了原本的glUseProgram(shaderProgram);</span></span><br><span class="line">    <span class="comment">// 绑定VAO</span></span><br><span class="line">    glBindVertexArray(VAO);</span><br><span class="line">    <span class="comment">// 绘制</span></span><br><span class="line">    glDrawElements(GL_TRIANGLES, <span class="number">6</span>, GL_UNSIGNED_INT, <span class="number">0</span>);</span><br><span class="line">    <span class="comment">// 解绑VAO</span></span><br><span class="line">    glBindVertexArray(<span class="number">0</span>);</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们把顶点和片段着色器储存为两个叫做<code>shader.vs</code>和<code>shader.fs</code>的文件。你可以使用自己喜欢的名字命名着色器文件；我自己觉得用<code>.vs</code>和<code>.fs</code>作为扩展名很直观。</p><h2 id="纹理"><a href="#纹理" class="headerlink" title="纹理"></a>纹理</h2><p>我们已经了解到，我们可以为每个顶点添加颜色来增加图形的细节，从而创建出有趣的图像。但是，如果<strong>想让图形看起来更真实</strong>，我们就必须有足够多的顶点，从而指定足够多的颜色。这将会产生很多额外开销，因为每个模型都会需求更多的顶点，每个顶点又需求一个颜色属性。</p><p>艺术家和程序员更喜欢使用<strong>纹理</strong>(Texture)。纹理是一个2D图片（甚至也有1D和3D的纹理），它可以用来添加物体的细节；你可以想象纹理是一张绘有砖块的纸，无缝折叠贴合到你的3D的房子上，这样你的房子看起来就像有砖墙外表了。因为我们可以在一张图片上插入非常多的细节，这样就可以让物体非常精细而不用指定额外的顶点。</p><p>除了图像以外，<strong>纹理也可以被用来储存大量的数据，这些数据可以发送到着色器上</strong>（例如纹理深度信息），但是这不是我们现在的主题。</p><p>为了能够把<strong>纹理映射</strong>(Map)到三角形上，我们需要<strong>指定三角形的每个顶点各自对应纹理的哪个部分</strong>。这样每个顶点就会关联着一个<strong>纹理坐标</strong>(Texture Coordinate)，用来标明该<strong>从纹理图像的哪个部分采样</strong>（译注：采集片段颜色）。之后在图形的<strong>其它片段上进行片段插值</strong>(Fragment Interpolation)（插值纹理坐标）。</p><p>纹理坐标在<code>x</code>和<code>y</code>轴上，范围为<code>0</code>到<code>1</code>之间（注意我们使用的是<strong>2D纹理图像</strong>）。使用<strong>纹理坐标获取纹理颜色</strong>叫做<strong>采样</strong>(Sampling)。<strong>纹理坐标起始于</strong>(0, 0)，也就是<strong>纹理图片的左下角</strong>，终于(1, 1)，即纹理图片的<strong>右上角</strong>。下面的图片展示了我们是如何把纹理坐标映射到三角形上的。</p><div align="center"><p><img src="/images/learnopengl-c1-f10.jpg"></p></div><p>我们为三角形指定了<strong>3个纹理坐标点</strong>。如上图所示，我们希望三角形的<strong>左下角对应纹理的左下角</strong>，因此我们把三角形<strong>左下角</strong>顶点的纹理坐标设置为<code>(0, 0)</code>；三角形的上顶点对应于图片的上中位置所以我们把它的纹理坐标设置为<code>(0.5, 1.0)</code>；同理右下方的顶点设置为<code>(1, 0)</code>。我们只要给<strong>顶点着色器传递这三个纹理坐标就行了</strong>，接下来<strong>它们会被传片段着色器</strong>中，它会为<strong>每个片段进行纹理坐标的插值</strong>。</p><p>纹理坐标看起来就像这样：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">float</span> texCoords[] = &#123;</span><br><span class="line">    <span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="comment">// 左下角</span></span><br><span class="line">    <span class="number">1.0f</span>, <span class="number">0.0f</span>, <span class="comment">// 右下角</span></span><br><span class="line">    <span class="number">0.5f</span>, <span class="number">1.0f</span> <span class="comment">// 上中</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>对纹理采样的解释非常宽松，它可以<strong>采用几种不同的插值方式</strong>。所以我们<strong>需要自己告诉OpenGL该怎样对纹理采样</strong>。</p><h3 id="纹理环绕方式"><a href="#纹理环绕方式" class="headerlink" title="纹理环绕方式"></a>纹理环绕方式</h3><p>纹理坐标的范围通常是从(0, 0)到(1, 1)，那<strong>如果我们把纹理坐标设置在范围之外会发生什么</strong>？OpenGL默认的行为是<strong>重复这个纹理图像</strong>（我们基本上忽略浮点纹理坐标的整数部分），但OpenGL提供了更多的选择：</p><ul><li><code>GL_REPEAT</code>：对纹理的默认行为。重复纹理图像；</li><li><code>GL_MIRRORED_REPEAT</code>：和GL_REPEAT一样，但每次重复图片是镜像放置的；</li><li><code>GL_CLAMP_TO_EDGE</code>：纹理坐标会被约束在0到1之间，超出的部分会重复纹理坐标的边缘，产生一种边缘被拉伸的效果；</li><li><code>GL_CLAMP_TO_BORDER</code>：超出的坐标为用户指定的边缘颜色。</li></ul><p>当纹理坐标超出默认范围时，每个选项都有不同的视觉效果输出。我们来看看这些纹理图像的例子：</p><div align="center"><p><img src="/images/learnopengl-c1-f11.jpg"></p></div><p>前面提到的每个选项都可以使用<code>glTexParameter*</code>函数(*不是指针，是不同类型的重载，看后面代码就知道了)对<strong>单独的一个坐标轴(str)设置</strong>（s、t（如果是使用3D纹理那么还有一个r）它们和x、y、z是等价的）：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_MIRRORED_REPEAT);</span><br><span class="line">glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_MIRRORED_REPEAT);</span><br></pre></td></tr></table></figure><ul><li><strong>第一个参数</strong>指定了纹理目标；我们使用的是2D纹理，因此纹理目标是GL_TEXTURE_2D；</li><li><strong>第二个参数</strong>需要我们指定设置的选项与应用的纹理轴。我们打算配置的是WRAP选项，并且指定S和T轴；</li><li><strong>最后一个参数</strong>需要我们传递一个环绕方式(Wrapping)，在这个例子中OpenGL会给当前激活的纹理设定纹理环绕方式为GL_MIRRORED_REPEAT。</li></ul><p>如果我们选择<code>GL_CLAMP_TO_BORDER</code>选项，我们还需要指定一个边缘的颜色。这需要使用<code>glTexParameter</code>函数的<code>fv</code>后缀形式(float vector)，用<code>GL_TEXTURE_BORDER_COLOR</code>作为它的选项，并且传递一个float数组作为边缘的颜色值：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">float</span> borderColor[] = &#123; <span class="number">1.0f</span>, <span class="number">1.0f</span>, <span class="number">0.0f</span>, <span class="number">1.0f</span> &#125;;</span><br><span class="line">glTexParameterfv(GL_TEXTURE_2D, GL_TEXTURE_BORDER_COLOR, borderColor);</span><br></pre></td></tr></table></figure><h3 id="纹理过滤"><a href="#纹理过滤" class="headerlink" title="纹理过滤"></a>纹理过滤</h3><p><strong>纹理坐标</strong>不依赖于分辨率(Resolution)，它可以是任意浮点值，所以OpenGL需要知道怎样将<strong>纹理像素</strong>(Texture Pixel，也叫Texel，译注1)映射到<strong>纹理坐标</strong>。</p><p>当你有一个<strong>很大的物体</strong>但是<strong>纹理的分辨率很低</strong>的时候这就变得很重要了。你可能已经猜到了，OpenGL也有对于<strong>纹理过滤</strong>(Texture Filtering)的选项。纹理过滤有很多个选项，但是现在我们只讨论最重要的两种：<code>GL_NEAREST</code>和<code>GL_LINEAR</code>。</p><p><code>Texture Pixel</code>也叫<code>Texel</code>，你可以想象你打开一张.jpg格式图片，不断放大你会发现它是由无数像素点组成的，这个<strong>点就是纹理像素</strong>；注意不要和纹理坐标搞混，<strong>纹理坐标是你给模型顶点设置的那个数组</strong>，OpenGL以这个顶点的纹理坐标数据去查找纹理图像上的像素，然后进行采样提取纹理像素的颜色。</p><p><code>GL_NEAREST</code>（也叫<strong>邻近过滤</strong>，Nearest Neighbor Filtering）是<strong>OpenGL默认的纹理过滤方式</strong>。当设置为GL_NEAREST的时候，OpenGL会选择<strong>中心点最接近纹理坐标的那个像素</strong>。下图中你可以看到四个像素，加号代表纹理坐标。左上角那个纹理像素的中心距离纹理坐标最近，所以它会被选择为样本颜色：</p><div align="center"><p><img src="/images/learnopengl-c1-f12.jpg"></p></div><p><code>GL_LINEAR</code>（也叫线性过滤，(Bi)linear Filtering）它会基于纹理坐标附近的纹理像素，<strong>计算出一个插值</strong>，近似出这些纹理像素之间的颜色。<strong>一个纹理像素的中心距离纹理坐标越近，那么这个纹理像素的颜色对最终的样本颜色的贡献越大</strong>。下图中你可以看到返回的颜色是邻近像素的混合色：</p><div align="center"><p><img src="/images/learnopengl-c1-f13.jpg"></p></div><p>那么这两种纹理过滤方式有怎样的视觉效果呢？让我们看看在一个很大的物体上应用一张低分辨率的纹理会发生什么吧（纹理被放大了，每个纹理像素都能看到）：</p><div align="center"><p><img src="/images/learnopengl-c1-f14.jpg"></p></div><p><code>GL_NEAREST</code>产生了<strong>颗粒状的图案</strong>，我们能够清晰看到组成纹理的像素，而<code>GL_LINEAR</code>能够产生<strong>更平滑的图案</strong>，很难看出单个的纹理像素（但是变得有点模糊了）。GL_LINEAR可以产生更真实的输出，但有些开发者更喜欢8-bit风格，所以他们会用GL_NEAREST选项。</p><p>当进行<strong>放大</strong>(Magnify)和<strong>缩小</strong>(Minify)操作的时候可以设置纹理过滤的选项，比如你可以在<strong>纹理被缩小的时候使用邻近过滤</strong>，<strong>被放大时使用线性过滤</strong>。我们需要使用<code>glTexParameter*</code>函数为放大和缩小指定过滤方式。这段代码看起来会和纹理环绕方式的设置很相似：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_NEAREST);</span><br><span class="line">glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);</span><br></pre></td></tr></table></figure><h3 id="多级渐远纹理"><a href="#多级渐远纹理" class="headerlink" title="多级渐远纹理"></a>多级渐远纹理</h3><p>假设我们有一个包含着上千物体的大房间，每个物体上都有纹理。<strong>有些物体会很远，但其纹理会拥有与近处物体同样高的分辨率</strong>。由于<strong>远处的物体可能只产生很少的片段，OpenGL从高分辨率纹理中为这些片段获取正确的颜色值就很困难</strong>，因为它需要对一个<strong>跨过纹理很大部分的片段只拾取一个纹理颜色</strong>。在<strong>小物体上这会产生不真实的感觉</strong>，更不用说对它们使用<strong>高分辨率纹理浪费内存</strong>的问题了。</p><p>OpenGL使用一种叫做<strong>多级渐远纹理</strong>(Mipmap)的概念来解决这个问题，它简单来说就是一系列的纹理图像，<strong>后一个纹理图像是前一个的二分之一</strong>（宽高同时二分之一，总面积四分之一）。多级渐远纹理背后的理念很简单：<strong>距观察者的距离超过一定的阈值</strong>，OpenGL会使用<strong>不同的多级渐远纹理</strong>，即最适合物体的距离的那个。由于距离远，解析度不高也不会被用户注意到。同时，<strong>多级渐远纹理另一加分之处是它的性能非常好</strong>。让我们看一下多级渐远纹理是什么样子的：</p><div align="center"><p><img src="/images/learnopengl-c1-f15.jpg"></p></div><p>手工为每个纹理图像创建一系列多级渐远纹理很麻烦，幸好OpenGL有一个<code>glGenerateMipmaps</code>函数，在创建完一个纹理后调用它，<strong>OpenGL就会承担接下来的所有工作了</strong>。</p><p>在渲染中切换多级渐远纹理级别(Level)时，OpenGL在<strong>两个不同级别的多级渐远纹理层之间会产生不真实的生硬边界</strong>。就像普通的纹理过滤一样，切换多级渐远纹理级别时你也可以在<strong>两个不同多级渐远纹理级别之间使用NEAREST和LINEAR过滤</strong>。</p><p>为了指定不同多级渐远纹理级别之间的过滤方式，你可以使用下面<strong>四个选项中的一个代替原有的过滤方式</strong>：</p><ul><li><code>GL_NEAREST_MIPMAP_NEAREST</code>：使用<strong>最邻近的多级渐远纹理</strong>来匹配像素大小，并使用<strong>邻近插值进行纹理采样</strong>；</li><li><code>GL_LINEAR_MIPMAP_NEAREST</code>：使用<strong>最邻近的多级渐远纹理</strong>级别，并使用<strong>线性插值进行采样</strong>；</li><li><code>GL_NEAREST_MIPMAP_LINEAR</code>：在<strong>两个</strong>最匹配像素大小的<strong>多级渐远纹理之间进行线性插值</strong>，使用<strong>邻近插值进行采样</strong>；</li><li><code>GL_LINEAR_MIPMAP_LINEAR</code>：在<strong>两个</strong>邻近的<strong>多级渐远纹理之间使用线性插值</strong>，并使用<strong>线性插值进行采样</strong>。</li></ul><p>就像纹理过滤一样，我们可以使用<code>glTexParameteri</code>将过滤方式设置为前面四种提到的方法之一：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR_MIPMAP_LINEAR);</span><br><span class="line">glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);</span><br></pre></td></tr></table></figure><p>一个<strong>常见的错误</strong>是，将<strong>放大过滤</strong>的选项设置为<strong>多级渐远纹理过滤选项之一</strong>。<strong>这样没有任何效果</strong>，因为多级渐远纹理主要是使用在<strong>纹理被缩小的情况下</strong>的：<strong>纹理放大不会使用多级渐远纹理</strong>，为放大过滤设置多级渐远纹理的选项会产生一个GL_INVALID_ENUM错误代码。</p><h3 id="加载与创建纹理"><a href="#加载与创建纹理" class="headerlink" title="加载与创建纹理"></a>加载与创建纹理</h3><p>使用纹理之前要做的第一件事是把它们加载到我们的应用中。<strong>纹理图像可能被储存为各种各样的格式，每种都有自己的数据结构和排列</strong>，所以我们如何才能把这些图像加载到应用中呢？一个解决方案是选一个需要的文件格式，比如.PNG，然后自己写一个图像加载器，把图像转化为字节序列。<strong>写自己的图像加载器虽然不难，但仍然挺麻烦的</strong>，而且如果要支持更多文件格式呢？你就不得不为每种你希望支持的格式写加载器了。</p><p>另一个解决方案也许是一种更好的选择，使用一个<strong>支持多种流行格式的图像加载库</strong>来为我们解决这个问题。比如说我们要用的<code>stb_image.h</code>库。</p><p><code>stb_image.h</code>是Sean Barrett的一个非常流行的<strong>单头文件图像加载库</strong>，它能够加载<strong>大部分流行的文件格式</strong>，并且能够很简单得整合到你的工程之中。下载这一个头文件，将它以<code>stb_image.h</code>的名字加入你的工程，并另创建一个新的C++文件，输入以下代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> STB_IMAGE_IMPLEMENTATION</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;stb_image.h&quot;</span></span></span><br></pre></td></tr></table></figure><p>通过定义<code>STB_IMAGE_IMPLEMENTATION</code>，<strong>预处理器会修改头文件</strong>，让其<strong>只包含相关的函数定义源码</strong>，等于是将这个头文件变为一个 <code>.cpp</code> 文件了。现在只需要在你的程序中包含<code>stb_image.h</code>并编译就可以了。</p><p>下面的教程中，我们会使用一张木箱的图片。要使用<code>stb_image.h</code>加载图片，我们需要使用它的<code>stbi_load</code>函数：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> width, height, nrChannels;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span> *data = stbi_load(<span class="string">&quot;container.jpg&quot;</span>, &amp;width, &amp;height, &amp;nrChannels, <span class="number">0</span>);</span><br></pre></td></tr></table></figure><p>这个函数首先接受一个<strong>图像文件的位置</strong>作为输入。接下来它需要三个<code>int</code>作为它的第二、第三和第四个参数，<code>stb_image.h</code>将会用图像的<strong>宽度</strong>、<strong>高度</strong>和<strong>颜色通道的个数</strong>填充这三个变量。我们之后生成纹理的时候会用到的<strong>图像的宽度和高度的</strong>。</p><h3 id="生成纹理"><a href="#生成纹理" class="headerlink" title="生成纹理"></a>生成纹理</h3><p>和之前生成的OpenGL对象一样，<strong>纹理也是使用ID引用的</strong>。让我们来创建一个：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> texture;</span><br><span class="line">glGenTextures(<span class="number">1</span>, &amp;texture);</span><br></pre></td></tr></table></figure><p>glGenTextures函数<strong>首先需要输入生成纹理的数量</strong>（本例子中是1），然后把它们储存在<strong>第二个参数</strong>的unsigned int<strong>数组</strong>中（我们的例子中<strong>只是单独的一个</strong>unsigned int），就像其他对象一样，我们<strong>需要绑定它</strong>，<strong>让之后任何的纹理指令</strong>都可以<strong>配置当前绑定的纹理</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">glBindTexture(GL_TEXTURE_2D, texture);</span><br></pre></td></tr></table></figure><p>现在纹理已经绑定了，我们可以使用<strong>前面载入的图片数据生成一个纹理</strong>了。纹理可以通过<code>glTexImage2D</code>来生成：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">glTexImage2D(GL_TEXTURE_2D, <span class="number">0</span>, GL_RGB, width, height, <span class="number">0</span>, GL_RGB, GL_UNSIGNED_BYTE, data);</span><br><span class="line">glGenerateMipmap(GL_TEXTURE_2D);</span><br></pre></td></tr></table></figure><p><code>glTexImage2D</code>参数不少，所以我们一个一个地讲解：</p><ul><li><strong>第一个参数</strong>指定了<strong>纹理目标</strong>(Target)。设置为GL_TEXTURE_2D意味着会生成与<strong>当前绑定的纹理对象在同一个目标上的纹理</strong>（任何绑定到GL_TEXTURE_1D和GL_TEXTURE_3D的纹理<strong>不会受到影响</strong>）；</li><li><strong>第二个参数</strong>为纹理指定<strong>多级渐远纹理的级别</strong>，如果你希望<strong>单独手动设置每个多级渐远纹理的级别的话</strong>。这里我们填0，也就是基本级别。</li><li><strong>第三个参数</strong>告诉OpenGL我们希望把<strong>纹理储存为何种格式</strong>。我们的图像只有RGB值，因此我们也把纹理储存为RGB值。</li><li><strong>第四个和第五个参数</strong>设置<strong>最终的纹理</strong>的<strong>宽度和高度</strong>。我们之前加载图像的时候储存了它们，所以我们使用对应的变量；</li><li>第六个参数总是被设置为0（历史遗留的问题）；</li><li><strong>第七第八个参数</strong>定义了源图的<strong>格式和数据类型</strong>。我们使用<strong>RGB值加载这个图像</strong>，并把它们储存为<code>char(byte)</code>数组，我们将会传入对应值；</li><li><strong>最后一个参数</strong>是<strong>真正的图像数据</strong>（之前stbi_load加载的图像数据，<code>unsigned char* data</code>）。</li></ul><p>当调用glTexImage2D时，当前<strong>绑定的纹理对象</strong>就会被<strong>附加上纹理图像</strong>。然而，目前只有<strong>基本级别</strong>(Base-level)的纹理图像被加载了，如果要使用多级渐远纹理，我们<strong>必须手动设置所有不同的图像</strong>（不断递增<strong>第二个参数</strong>）。<strong>或者</strong>，直接在生成纹理之后调用<code>glGenerateMipmap</code>。这会为当前绑定的纹理<strong>自动生成所有需要的多级渐远纹理</strong>。</p><p>生成了纹理和相应的多级渐远纹理后，释放图像的内存是一个很好的习惯。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">stbi_image_free(data);</span><br></pre></td></tr></table></figure><p>生成一个纹理的过程应该看起来像这样：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> texture;</span><br><span class="line">glGenTextures(<span class="number">1</span>, &amp;texture);</span><br><span class="line">glBindTexture(GL_TEXTURE_2D, texture);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 为当前绑定的纹理对象设置环绕、过滤方式</span></span><br><span class="line">glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_REPEAT);</span><br><span class="line">glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_REPEAT);</span><br><span class="line">glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);</span><br><span class="line">glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 加载并生成纹理</span></span><br><span class="line"><span class="keyword">int</span> width, height, nrChannels;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span> *data = stbi_load(<span class="string">&quot;container.jpg&quot;</span>, &amp;width, &amp;height, &amp;nrChannels, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (data) &#123;</span><br><span class="line">    glTexImage2D(GL_TEXTURE_2D, <span class="number">0</span>, GL_RGB, width, height, <span class="number">0</span>, GL_RGB, GL_UNSIGNED_BYTE, data);</span><br><span class="line">    glGenerateMipmap(GL_TEXTURE_2D);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Failed to load texture&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 释放之前加载的图像</span></span><br><span class="line">stbi_image_free(data);</span><br><span class="line"><span class="comment">// glBindTexture(GL_TEXTURE_2D, 0); // 可选的解绑操作</span></span><br></pre></td></tr></table></figure><h3 id="应用纹理"><a href="#应用纹理" class="headerlink" title="应用纹理"></a>应用纹理</h3><p>后面的这部分我们会使用<code>glDrawElements</code>绘制「你好，三角形」教程最后一部分的矩形。我们需要告知OpenGL如何采样纹理，所以我们必须使用纹理坐标更新顶点数据：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">float</span> vertices[] = &#123;</span><br><span class="line"><span class="comment">//     ---- 位置 ----       ---- 颜色 ----     - 纹理坐标 -</span></span><br><span class="line">     <span class="number">0.5f</span>,  <span class="number">0.5f</span>, <span class="number">0.0f</span>,   <span class="number">1.0f</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span>,   <span class="number">1.0f</span>, <span class="number">1.0f</span>,   <span class="comment">// 右上</span></span><br><span class="line">     <span class="number">0.5f</span>, <span class="number">-0.5f</span>, <span class="number">0.0f</span>,   <span class="number">0.0f</span>, <span class="number">1.0f</span>, <span class="number">0.0f</span>,   <span class="number">1.0f</span>, <span class="number">0.0f</span>,   <span class="comment">// 右下</span></span><br><span class="line">    <span class="number">-0.5f</span>, <span class="number">-0.5f</span>, <span class="number">0.0f</span>,   <span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">1.0f</span>,   <span class="number">0.0f</span>, <span class="number">0.0f</span>,   <span class="comment">// 左下</span></span><br><span class="line">    <span class="number">-0.5f</span>,  <span class="number">0.5f</span>, <span class="number">0.0f</span>,   <span class="number">1.0f</span>, <span class="number">1.0f</span>, <span class="number">0.0f</span>,   <span class="number">0.0f</span>, <span class="number">1.0f</span>    <span class="comment">// 左上</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>由于我们添加了一个额外的顶点属性，我们必须告诉OpenGL我们新的顶点格式：</p><div align="center"><p><img src="/images/learnopengl-c1-f16.jpg"></p></div><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">glVertexAttribPointer(<span class="number">2</span>, <span class="number">2</span>, GL_FLOAT, GL_FALSE, <span class="number">8</span> * <span class="keyword">sizeof</span>(<span class="keyword">float</span>), (<span class="keyword">void</span>*)(<span class="number">6</span> * <span class="keyword">sizeof</span>(<span class="keyword">float</span>)));</span><br><span class="line">glEnableVertexAttribArray(<span class="number">2</span>);</span><br></pre></td></tr></table></figure><p>注意，我们同样需要<strong>调整前面两个顶点属性的步长参数</strong>为<code>8 * sizeof(float)</code>。</p><p>接着我们需要<strong>调整顶点着色器</strong>使其能够<strong>接受顶点坐标为一个顶点属性</strong>，并把坐标传给片段着色器：</p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#version 330 core</span></span><br><span class="line"><span class="keyword">layout</span> (<span class="keyword">location</span> = <span class="number">0</span>) <span class="keyword">in</span> <span class="type">vec3</span> aPos;</span><br><span class="line"><span class="keyword">layout</span> (<span class="keyword">location</span> = <span class="number">1</span>) <span class="keyword">in</span> <span class="type">vec3</span> aColor;</span><br><span class="line"><span class="keyword">layout</span> (<span class="keyword">location</span> = <span class="number">2</span>) <span class="keyword">in</span> <span class="type">vec2</span> aTexCoord;</span><br><span class="line"></span><br><span class="line"><span class="keyword">out</span> <span class="type">vec3</span> ourColor;</span><br><span class="line"><span class="keyword">out</span> <span class="type">vec2</span> TexCoord;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> main() &#123;</span><br><span class="line">    <span class="built_in">gl_Position</span> = <span class="type">vec4</span>(aPos, <span class="number">1.0</span>);</span><br><span class="line">    ourColor = aColor;</span><br><span class="line">    TexCoord = aTexCoord;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>片段着色器应该接下来会把输出变量TexCoord作为输入变量。</p><p><strong>片段着色器也应该能访问纹理对象</strong>，但是我们<strong>怎样能把纹理对象传给片段着色器呢</strong>？GLSL有一个<strong>供纹理对象使用的内建数据类型，叫做采样器</strong>(Sampler)，它以<strong>纹理类型作为后缀</strong>，比如sampler1D、sampler3D，或在我们的例子中的sampler2D。我们可以简单声明一个<code>uniform sampler2D</code>把一个纹理添加到片段着色器中，稍后我们会把纹理赋值给这个uniform。</p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#version 330 core</span></span><br><span class="line"><span class="keyword">out</span> <span class="type">vec4</span> FragColor;</span><br><span class="line"></span><br><span class="line"><span class="keyword">in</span> <span class="type">vec3</span> ourColor;</span><br><span class="line"><span class="keyword">in</span> <span class="type">vec2</span> TexCoord;</span><br><span class="line"></span><br><span class="line"><span class="keyword">uniform</span> <span class="type">sampler2D</span> ourTexture;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> main() &#123;</span><br><span class="line">    FragColor = <span class="built_in">texture</span>(ourTexture, TexCoord);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们使用GLSL内建的<code>texture</code>函数来<strong>采样纹理的颜色</strong>，它<strong>第一个参数</strong>是纹理采样器，<strong>第二个参数</strong>是对应的纹理坐标。texture函数会使用之前设置的纹理参数对相应的颜色值进行采样。这个片段着色器的输出就是纹理的（插值）纹理坐标上的(过滤后的)颜色。</p><p>现在只剩下在调用<code>glDrawElements</code>之前<strong>绑定纹理</strong>了，它会<strong>自动把纹理赋值给片段着色器的采样器</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">glBindTexture(GL_TEXTURE_2D, texture);</span><br><span class="line">glBindVertexArray(VAO);</span><br><span class="line">glDrawElements(GL_TRIANGLES, <span class="number">6</span>, GL_UNSIGNED_INT, <span class="number">0</span>);</span><br></pre></td></tr></table></figure><div align="center"><p><img src="/images/learnopengl-c1-f17.jpg"></p></div><p>我们还可以把得到的纹理颜色与顶点颜色混合，来获得更有趣的效果。我们只需把<strong>纹理颜色与顶点颜色在片段着色器中相乘</strong>来混合二者的颜色：</p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">FragColor = <span class="built_in">texture</span>(ourTexture, TexCoord) * <span class="type">vec4</span>(ourColor, <span class="number">1.0</span>);</span><br></pre></td></tr></table></figure><div align="center"><p><img src="/images/learnopengl-c1-f18.jpg"></p></div><h3 id="纹理单元"><a href="#纹理单元" class="headerlink" title="纹理单元"></a>纹理单元</h3><p>你可能会奇怪为什么<code>sampler2D</code>变量是个uniform，我们却不用<code>glUniform</code>给它赋值。使用<code>glUniform1i</code>，我们可以给<strong>纹理采样器分配一个位置值</strong>，这样的话我们能<strong>够在一个片段着色器中设置多个纹理</strong>。一个纹理的<strong>位置值</strong>通常称为一个<strong>纹理单元</strong>(Texture Unit)。一个纹理的<strong>默认纹理单元是0</strong>，它是默认的激活纹理单元，所以教程前面部分我们没有分配一个位置值。</p><p>纹理单元的<strong>主要目的</strong>是让我们在着色器中可以<strong>使用多于一个的纹理</strong>。通过把<strong>纹理单元赋值给采样器</strong>，我们可以<strong>一次绑定多个纹理</strong>，只要我们首先激活对应的纹理单元。就像<code>glBindTexture</code>一样，我们可以使用<code>glActiveTexture</code>激活纹理单元，传入我们需要使用的纹理单元：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">glActiveTexture(GL_TEXTURE0); <span class="comment">// 在绑定纹理之前先激活纹理单元</span></span><br><span class="line">glBindTexture(GL_TEXTURE_2D, texture);</span><br></pre></td></tr></table></figure><p>激活纹理单元之后，接下来的<code>glBindTexture</code>函数调用<strong>会绑定这个纹理到当前激活的纹理单元</strong>，纹理单元<code>GL_TEXTURE0</code><strong>默认总是被激活</strong>，所以我们在前面的例子里当我们使用glBindTexture的时候，无需激活任何纹理单元。</p><p>OpenGL<strong>至少保证</strong>有<strong>16个纹理单元</strong>供你使用，也就是说你可以激活从<code>GL_TEXTURE0</code>到<code>GL_TEXTRUE15</code>。它们都是按顺序定义的，所以我们也可以通过<code>GL_TEXTURE0 + 8</code>的方式获得GL_TEXTURE8，这在当我们<strong>需要循环一些纹理单元的时候会很有用</strong>。</p><p>我们仍然需要编辑片段着色器来接收另一个采样器。这应该相对来说非常直接了：</p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#version 330 core</span></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="keyword">uniform</span> <span class="type">sampler2D</span> texture1;</span><br><span class="line"><span class="keyword">uniform</span> <span class="type">sampler2D</span> texture2;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> main() &#123;</span><br><span class="line">    FragColor = <span class="built_in">mix</span>(<span class="built_in">texture</span>(texture1, TexCoord), <span class="built_in">texture</span>(texture2, TexCoord), <span class="number">0.2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最终输出颜色现在是两个纹理的结合。GLSL内建的<code>mix</code>函数需要接受<strong>两个值作为参数</strong>，并对它们根据<strong>第三个参数进行线性插值</strong>。如果第三个值是<code>0.0</code>，<strong>它会返回第一个输入</strong>；如果是<code>1.0</code>，会返回<strong>第二个输入值</strong>。<code>0.2</code>会返回<strong>80%的第一个输入颜色和20%的第二个输入颜色</strong>，即返回两个纹理的混合色。</p><p>我们现在需要载入并创建另一个纹理；你应该对这些步骤很熟悉了。记得创建另一个纹理对象，载入图片，使用glTexImage2D生成最终纹理。对于第二个纹理我们使用一张你学习OpenGL时的面部表情图片（草）。</p><p>为了使用<strong>第二个纹理（以及第一个）</strong>，我们必须改变一点渲染流程，<strong>先绑定两个纹理到对应的纹理单元</strong>，然后<strong>定义哪个uniform采样器对应哪个纹理单元</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">glActiveTexture(GL_TEXTURE0);</span><br><span class="line">glBindTexture(GL_TEXTURE_2D, texture1);</span><br><span class="line">glActiveTexture(GL_TEXTURE1);</span><br><span class="line">glBindTexture(GL_TEXTURE_2D, texture2);</span><br><span class="line"></span><br><span class="line">glBindVertexArray(VAO);</span><br><span class="line">glDrawElements(GL_TRIANGLES, <span class="number">6</span>, GL_UNSIGNED_INT, <span class="number">0</span>);</span><br></pre></td></tr></table></figure><p>我们还要通过使用<code>glUniform1i</code><strong>设置每个采样器</strong>的方式告诉OpenGL<strong>每个着色器采样器属于哪个纹理单元</strong>。我们只需要设置一次即可，所以这个会放在渲染循环的前面：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ourShader.use(); <span class="comment">// 不要忘记在设置uniform变量之前激活着色器程序！</span></span><br><span class="line">glUniform1i(glGetUniformLocation(ourShader.ID, <span class="string">&quot;texture1&quot;</span>), <span class="number">0</span>); <span class="comment">// 手动设置</span></span><br><span class="line">ourShader.setInt(<span class="string">&quot;texture2&quot;</span>, <span class="number">1</span>); <span class="comment">// 或者使用着色器类设置</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(...) &#123;</span><br><span class="line">    <span class="comment">// [...]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过使用<code>glUniform1i</code>设置采样器，我们保证了每个<code>uniform</code>采样器对应着正确的纹理单元。你应该能得到下面的结果：</p><div align="center"><p><img src="/images/learnopengl-c1-f20.jpg"></p></div><p>你可能注意到纹理上下颠倒了！这是因为<strong>OpenGL要求y轴0.0坐标是在图片的底部的</strong>，但是<strong>图片的y轴0.0坐标通常在顶部</strong>。很幸运，<code>stb_image.h</code>能够在图像加载时帮助我们<strong>翻转y轴</strong>，只需要在<strong>加载任何图像</strong>前加入以下语句即可：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">stbi_set_flip_vertically_on_load(<span class="literal">true</span>);</span><br></pre></td></tr></table></figure><p>在让stb_image.h在加载图片时翻转y轴之后你就应该能够获得下面的结果了：</p><div align="center"><p><img src="/images/learnopengl-c1-f21.jpg"></p></div><h3 id="练习题-1"><a href="#练习题-1" class="headerlink" title="练习题"></a>练习题</h3><ul><li>修改片段着色器，仅让笑脸图案朝另一个方向看；</li><li>尝试用不同的纹理环绕方式，设定一个从0.0f到2.0f范围内的（而不是原来的0.0f到1.0f）纹理坐标。试试看能不能在箱子的角落放置4个笑脸：参考解答，结果。记得一定要试试其它的环绕方式；</li><li>尝试在矩形上只显示纹理图像的中间一部分，修改纹理坐标，达到能看见单个的像素的效果。尝试使用GL_NEAREST的纹理过滤方式让像素显示得更清晰；</li><li>使用一个uniform变量作为mix函数的第三个参数来改变两个纹理可见度，使用上和下键来改变箱子或笑脸的可见度。</li></ul><h2 id="变换"><a href="#变换" class="headerlink" title="变换"></a>变换</h2><p>尽管我们现在已经知道了如何创建一个物体、着色、加入纹理，给它们一些细节的表现，但因为它们都还是静态的物体，仍是不够有趣。我们可以尝试着在<strong>每一帧改变物体的顶点并且重配置缓冲区从而使它们移动</strong>，但这<strong>太繁琐了</strong>，而且<strong>会消耗很多的处理时间</strong>。</p><p><strong>矩阵</strong>(Matrix)对象可以更好的<strong>变换</strong>(Transform)一个物体。当然，这并不是说我们会去讨论武术和数字虚拟世界（译注：Matrix同样也是电影「黑客帝国」的英文名，电影中人类生活在数字虚拟世界，主角（基努·里维斯）会武术）（草）。</p><p>为了深入了解变换，我们首先要在讨论矩阵之前进一步了解一下向量。这一节的目标是让你拥有将来需要的最基础的数学背景知识。如果你发现这节十分困难，尽量尝试去理解它们，当你以后需要它们的时候回过头来复习这些概念。</p><h3 id="向量"><a href="#向量" class="headerlink" title="向量"></a>向量</h3><p>向量最基本的定义就是一个方向。或者更正式的说，向量有一个方向(Direction)和大小(Magnitude，也叫做强度或长度)。向量可以在任意维度(Dimension)上，但是我们通常只使用2至4维。如果一个向量有2个维度，它表示一个平面的方向(想象一下2D的图像)，当它有3个维度的时候它可以表达一个3D世界的方向。</p><p>由于向量是一个方向，所以有些时候会很难形象地将它们用位置(Position)表示出来。为了让其更为直观，我们通常设定这个方向的原点为(0, 0, 0)，然后指向一个方向，对应一个点，使其变为位置向量(Position Vector)（你也可以把起点设置为其他的点，然后说：这个向量从这个点起始指向另一个点）。</p><p>注意，<strong>数学上是没有向量与标量相加这个运算的</strong>，但是很多线性代数的库都对它有支持（比如说我们用的GLM）。如果你使用过numpy的话，可以把它理解为Broadcasting。</p><p>我们使用**勾股定理(**Pythagoras Theorem)来获取向量的长度(Length)/大小(Magnitude)。</p><p>有一个特殊类型的向量叫做<strong>单位向量</strong>(Unit Vector)。单位向量有一个特别的性质——它的<strong>长度是1</strong>。我们可以用任意向量的每个分量除以向量的长度得到它的单位向量。我们把这种方法叫做一个<strong>向量的标准化</strong>(Normalizing)。单位向量头上有一个^样子的记号。</p><p>在相乘的时候我们有两种特定情况可以选择：一个是<strong>点乘</strong>(Dot Product)，记作<code>v⋅k</code>，另一个是<strong>叉乘</strong>(Cross Product)，记作<code>v×k</code>。</p><p>两个向量的<strong>点乘</strong>等于它们的<strong>数乘结果</strong>乘以<strong>两个向量之间夹角的余弦值</strong>。使用点乘可以很容易测试两个向量是否正交(Orthogonal)或平行（正交意味着两个向量互为直角）。你也可以通过点乘的结果计算<strong>两个非单位向量的夹角</strong>，点乘的结果除以两个向量的长度之积，得到的结果就是夹角的余弦值，即cosθ。点乘是通过将对应分量逐个相乘，然后再把所得积相加来计算的。</p><p><strong>叉乘只在3D空间中有定义</strong>，它需要两个不平行向量作为输入，生成一个正交于两个输入向量的第三个向量。如果输入的两个向量也是正交的，那么叉乘之后将会产生3个互相正交的向量。</p><div align="center"><p><img src="/images/learnopengl-c1-f22.jpg"></p></div><h3 id="矩阵"><a href="#矩阵" class="headerlink" title="矩阵"></a>矩阵</h3><p>矩阵中每一项叫做矩阵的元素(Element)。</p><p>矩阵可以通过(i, j)进行索引，i是行，j是列。矩阵有几个运算，分别是：矩阵加法、减法和乘法。</p><p>矩阵与标量之间的加减要处理到每一个元素上，和向量类似。</p><p>注意，<strong>数学上是没有矩阵与标量相加减的运算的</strong>，但是很多线性代数的库都对它有支持（比如说我们用的GLM）。如果你使用过numpy的话，可以把它理解为Broadcasting。</p><p><strong>矩阵与矩阵之间的加减</strong>就是两个矩阵<strong>对应元素的加减运算</strong>，所以总体的规则和与标量运算是差不多的，只不过在相同索引下的元素才能进行运算。这也就是说加法和减法<strong>只对同维度的矩阵才是有定义的</strong>。</p><p>和矩阵与标量的加减一样，矩阵与标量之间的乘法也是矩阵的<strong>每一个元素分别乘以该标量</strong>。现在我们也就能明白为什么这些<strong>单独的数字</strong>要叫做<strong>标量</strong>(Scalar)了。简单来说，<strong>标量就是用它的值缩放</strong>(Scale)<strong>矩阵的所有元素</strong>（译注：注意Scalar是由Scale + -ar演变过来的）。</p><p>矩阵之间的<strong>乘法</strong>不见得有多复杂，但的确很难让人适应。矩阵乘法基本上意味着遵照规定好的法则进行相乘。当然，相乘还有一些限制：</p><ol><li>只有当<strong>左侧</strong>矩阵的<strong>列数</strong>与<strong>右侧</strong>矩阵的<strong>行数</strong>相等，两个矩阵才能相乘；</li><li><strong>矩阵相乘不遵守交换律</strong>(Commutative)，也就是说A⋅B≠B⋅A。</li></ol><p>假设A ⋅ B = C，那么Cij的值为A矩阵的第i行向量与B矩阵的第j列向量的点积结果，这基本上就是矩阵乘法的内核。</p><h3 id="矩阵与向量相乘"><a href="#矩阵与向量相乘" class="headerlink" title="矩阵与向量相乘"></a>矩阵与向量相乘</h3><p>目前为止，通过这些教程我们已经相当了解向量了。我们用<strong>向量来表示位置，表示颜色，甚至是纹理坐标</strong>。如果我们有一个<code>M×N</code>维矩阵，我们可以用这个矩阵乘以我们的<code>N×1</code>向量，因为这个矩阵的列数等于向量的行数，所以它们就能相乘。</p><h3 id="单位矩阵"><a href="#单位矩阵" class="headerlink" title="单位矩阵"></a>单位矩阵</h3><p>在OpenGL中，由于某些原因（齐次坐标系，为了能够方便地在变换矩阵中加入平移变换）我们通常使用4×4的变换矩阵，而其中最重要的原因就是大部分的向量都是4分量的。我们能想到的最简单的变换矩阵就是单<strong>位矩阵</strong>(Identity Matrix)。这种变换矩阵使一个向量完全不变。</p><h3 id="缩放"><a href="#缩放" class="headerlink" title="缩放"></a>缩放</h3><p>对一个向量进行缩放(Scaling)就是对向量的长度进行缩放，而保持它的方向不变。由于我们进行的是2维或3维操作，我们可以分别定义一个有2或3个缩放变量的向量，每个变量缩放一个轴(x、y或z)。</p><p><strong>不均匀</strong>(Non-uniform)缩放，因为<strong>每个轴的缩放因子</strong>(Scaling Factor)<strong>都不一样</strong>。如果每个轴的缩放因子都一样那么就叫<strong>均匀缩放</strong>(Uniform Scale)。</p><div align="center"><p><img src="/images/learnopengl-c1-f23.jpg"></p></div><p>注意，第四个缩放向量仍然是1，因为在3D空间中缩放w分量是无意义的。w分量另有其他用途，在后面我们会看到。</p><h3 id="位移"><a href="#位移" class="headerlink" title="位移"></a>位移</h3><p>位移(Translation)是在原始向量的基础上加上另一个向量从而获得一个在不同位置的新向量的过程，从而在位移向量基础上移动了原始向量。</p><div align="center"><p><img src="/images/learnopengl-c1-f24.jpg"></p></div><p><strong>齐次坐标</strong>(Homogeneous Coordinates)：向量的w分量也叫<strong>齐次坐标</strong>。想要<strong>从齐次向量得到3D向量</strong>，我们<strong>可以把x、y和z坐标分别除以w坐标</strong>。我们通常不会注意这个问题，因为w分量通常是1.0。使用齐次坐标有几点好处：它允许我们在3D向量上进行位移（如果没有w分量我们是不能位移向量的），而且下一章我们会用w值创建3D视觉效果。如果一个向量的齐次坐标是0，这个坐标就是<strong>方向向量</strong>(Direction Vector)，因为w坐标是0，<strong>这个向量就不能位移</strong>（译注：这也就是我们说的不能位移一个方向）。</p><h3 id="旋转"><a href="#旋转" class="headerlink" title="旋转"></a>旋转</h3><p>首先我们来定义一个向量的旋转到底是什么。2D或3D空间中的旋转用<strong>角</strong>(Angle)来表示。角可以是<strong>角度制或弧度制的</strong>，<strong>周角</strong>是<strong>360角度</strong>或<strong>2PI弧度</strong>。我个人更喜欢用角度，因为它们看起来更直观。</p><p>大多数旋转函数需要用<strong>弧度制的角</strong>，但幸运的是角度制的角也可以很容易地转化为弧度制的：</p><ul><li><strong>弧度转角度</strong>：<code>角度 = (弧度 / PI) * 180.0f</code>；</li><li><strong>角度转弧度</strong>：<code>弧度 = (角度 / 180.0f) * PI</code>。</li></ul><p>PI约等于<code>3.14159265359</code>。</p><p>在3D空间中旋转需要定义一个<strong>角</strong>和一个<strong>旋转轴</strong>(Rotation Axis)，物体会沿着给定的旋转轴旋转特定角度。</p><p>旋转矩阵在3D空间中每个单位轴都有不同定义，旋转角度用θ表示。</p><p>沿x轴旋转：</p><div align="center"><p><img src="/images/learnopengl-c1-f25.jpg"></p></div><p>沿y轴旋转：</p><div align="center"><p><img src="/images/learnopengl-c1-f26.jpg"></p></div><p>沿z轴旋转：</p><div align="center"><p><img src="/images/learnopengl-c1-f27.jpg"></p></div><p>利用旋转矩阵我们可以把任意位置向量<strong>沿一个单位旋转轴进行旋转</strong>。也可以将多个矩阵复合，比如先沿着x轴旋转再沿着y轴旋转。但是这会很快导致一个问题——<strong>万向节死锁</strong>（Gimbal Lock）。在这里我们不会讨论它的细节，但是对于3D空间中的旋转，一个<strong>更好的模型是沿着任意的一个轴</strong>，而不是对一系列旋转矩阵进行复合。样的一个（超级麻烦的）矩阵是存在的，见下面这个公式，其中(Rx,Ry,Rz)代表任意旋转轴：</p><div align="center"><p><img src="/images/learnopengl-c1-f28.jpg"></p></div><p>在数学上讨论如何生成这样的矩阵仍然超出了本节内容。但是记住，<strong>即使这样一个矩阵也不能完全解决万向节死锁问题</strong>（尽管会极大地避免）。<strong>避免万向节死锁的真正解决方案是使用四元数</strong>(Quaternion)，它不仅更安全，而且计算会更有效率。</p><p>对四元数的理解会用到非常多的数学知识。如果你想了解四元数与3D旋转之间的关系，可以来阅读这篇的教程<a target="_blank" rel="noopener" href="https://krasjet.github.io/quaternion/quaternion.pdf">四元数与三维旋转</a>。如果你对万向节死锁的概念仍不是那么清楚，可以来阅读教程的Bonus章节()。现在3Blue1Brown也已经开始了一个四元数的视频系列，他采用球极平面投影(Stereographic Projection)的方式将四元数投影到3D空间，同样有助于理解四元数的概念<a target="_blank" rel="noopener" href="https://www.youtube.com/watch?v=d4EgbgTm0Bg">Visualizing quaternions</a>。</p><h3 id="矩阵的组合"><a href="#矩阵的组合" class="headerlink" title="矩阵的组合"></a>矩阵的组合</h3><p>使用矩阵进行变换的真正力量在于，根据矩阵之间的乘法，我们可以把<strong>多个变换组合到一个矩阵中</strong>。让我们看看我们是否能生成一个变换矩阵，让它组合多个变换。假设我们有一个顶点(x, y, z)，我们希望将其缩放2倍，然后位移(1, 2, 3)个单位。我们需要一个位移和缩放矩阵来完成这些变换。结果的变换矩阵看起来像这样：</p><div align="center"><p><img src="/images/learnopengl-c1-f29.jpg"></p></div><p>注意，<strong>当矩阵相乘时我们先写位移再写缩放变换的</strong>。矩阵乘法是不遵守交换律的，这意味着它们的顺序很重要。当矩阵相乘时，<strong>在最右边的矩阵是第一个与向量相乘的</strong>，所以你应该从右向左读这个乘法。建议您在组合矩阵时，<strong>先进行缩放操作，然后是旋转，最后才是位移</strong>，否则它们会（消极地）互相影响。比如，如果<strong>你先位移再缩放，位移的向量也会同样被缩放</strong>（译注：比如向某方向移动2米，2米也许会被缩放成1米）！</p><p>用最终的变换矩阵左乘我们的向量会得到以下结果：</p><div align="center"><p><img src="/images/learnopengl-c1-f30.jpg"></p></div><h3 id="实践"><a href="#实践" class="headerlink" title="实践"></a>实践</h3><p><strong>OpenGL没有自带任何的矩阵和向量知识</strong>，所以我们必须定义自己的数学类和函数。在教程中我们更希望抽象所有的数学细节，使用已经做好了的数学库。幸运的是，有个易于使用，<strong>专门为OpenGL量身定做的数学库，那就是GLM</strong>。</p><p>GLM是<code>OpenGL Mathematics</code>的缩写，它是一个只有头文件的库，也就是说我们只需包含对应的头文件就行了，不用链接和编译。GLM可以在它们的网站上下载<a target="_blank" rel="noopener" href="https://github.com/g-truc/glm">OpenGL Mathematics</a>。把头文件的根目录复制到你的includes文件夹，然后你就可以使用这个库了。</p><p>PS：GLM库从0.9.9版本起，<strong>默认会将矩阵类型初始化为一个零矩阵</strong>（所有元素均为0），而<strong>不是单位矩阵</strong>（对角元素为1，其它元素为0）。如果你使用的是0.9.9或0.9.9以上的版本，你需要将所有的<strong>矩阵初始化</strong>改为 <code>glm::mat4 mat = glm::mat4(1.0f)</code>。如果你想与本教程的代码保持一致，请使用低于0.9.9版本的GLM，或者改用上述代码初始化所有的矩阵。</p><p>我们需要的GLM的大多数功能都可以从下面这3个头文件中找到：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;glm/glm.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;glm/gtc/matrix_transform.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;glm/gtc/type_ptr.hpp&gt;</span></span></span><br></pre></td></tr></table></figure><p>我们来看看是否可以利用我们刚学的变换知识把一个向量<code>(1, 0, 0)</code>位移<code>(1, 1, 0)</code>个单位（注意，我们把它定义为一个<code>glm::vec4</code>类型的值，齐次坐标设定为<code>1.0</code>）：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">glm::vec4 <span class="title">vec</span><span class="params">(<span class="number">1.0f</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">1.0f</span>)</span></span>;</span><br><span class="line"><span class="comment">// 译注：下面就是矩阵初始化的一个例子，如果使用的是0.9.9及以上版本</span></span><br><span class="line"><span class="comment">// 下面这行代码就需要改为:</span></span><br><span class="line">glm::mat4 trans = glm::mat4(<span class="number">1.0f</span>);</span><br><span class="line"><span class="comment">// 0.9.9以下的版本矩阵初始化为：</span></span><br><span class="line"><span class="comment">// glm::mat4 trans; // 会初始化为单位阵</span></span><br><span class="line">trans = glm::translate(trans, glm::vec3(<span class="number">1.0f</span>, <span class="number">1.0f</span>, <span class="number">0.0f</span>));</span><br><span class="line">vec = trans * vec;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; vec.x &lt;&lt; vec.y &lt;&lt; vec.z &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure><p>我们先用GLM内建的向量类定义一个叫做<code>vec</code>的向量。接下来定义一个<code>mat4</code>类型的<code>trans</code>，默认是一个<code>4×4</code>单位矩阵。下一步是创建一个变换矩阵，我们是把<strong>单位矩阵</strong>和<strong>一个位移向量</strong>传递给<code>glm::translate</code>函数来完成这个工作的（然后用给定的矩阵乘以位移矩阵就能获得最后需要的矩阵）。</p><p>之后我们把<strong>向量乘以位移矩阵并且输出最后的结果</strong>。如果你仍记得位移矩阵是如何工作的话，得到的向量应该是(1 + 1, 0 + 1, 0 + 0)，也就是(2, 1, 0)。这个代码片段将会输出210，所以这个位移矩阵是正确的。</p><p>我们来做些更有意思的事情，让我们来旋转和缩放之前教程中的那个箱子。首先我们把<strong>箱子逆时针旋转90度</strong>。然后<strong>缩放0.5倍</strong>，使它变成原来的一半大。我们先来创建变换矩阵：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">glm::mat4 trans = glm::mat4(<span class="number">1.0f</span>);</span><br><span class="line">trans = glm::rotate(trans, glm::radians(<span class="number">90.0f</span>), glm::vec3(<span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">1.0</span>));</span><br><span class="line">trans = glm::scale(trans, glm::vec3(<span class="number">0.5</span>, <span class="number">0.5</span>, <span class="number">0.5</span>));</span><br><span class="line"><span class="comment">// 注意这里的顺序 identity · rotate · scale · vector</span></span><br><span class="line"><span class="comment">// 感觉glm的函数是在原矩阵后面追加矩阵</span></span><br></pre></td></tr></table></figure><p>首先，我们把箱子在<strong>每个轴都缩放到0.5倍</strong>，然后<strong>沿z轴旋转90度</strong>。GLM希望它的角度是<strong>弧度制的</strong>(Radian)，所以我们使用<code>glm::radians</code>将角度转化为弧度。注意<strong>有纹理的那面矩形是在XY平面上的</strong>，所以我们需要把它绕着z轴旋转。因为我们把这个矩阵传递给了GLM的每个函数，<strong>GLM会自动将矩阵相乘</strong>，返回的结果是一个包括了多个变换的变换矩阵。</p><p><strong>下一个大问题是：如何把矩阵传递给着色器？</strong>我们在前面简单提到过GLSL里也有一个<code>mat4</code>类型。所以我们将修改<strong>顶点着色器</strong>让其接收一个<code>mat4</code>的<code>uniform</code>变量，然后再用矩阵<code>uniform</code>乘以位置向量：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#version 330 core</span></span><br><span class="line">layout (location = <span class="number">0</span>) in vec3 aPos;</span><br><span class="line">layout (location = <span class="number">1</span>) in vec2 aTexCoord;</span><br><span class="line"></span><br><span class="line">out vec2 TexCoord;</span><br><span class="line"></span><br><span class="line">uniform mat4 transform;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    gl_Position = transform * vec4(aPos, <span class="number">1.0f</span>);</span><br><span class="line">    TexCoord = vec2(aTexCoord.x, <span class="number">1.0</span> - aTexCoord.y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>GLSL也有<code>mat2</code>和<code>mat3</code>类型，从而允许了<strong>像向量一样的混合运算</strong>。前面提到的所有数学运算（像是<strong>标量-矩阵相乘</strong>，<strong>矩阵-向量相乘</strong>和<strong>矩阵-矩阵相乘</strong>）在矩阵类型里都可以使用。当出现特殊的矩阵运算的时候我们会特别说明。</p><p>在把位置向量传给gl_Position之前，我们先添加一个uniform，并且将其与变换矩阵相乘。我们的箱子现在应该是原来的二分之一大小并（向左）旋转了90度。当然，我们仍需要把变换矩阵传递给着色器：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> transformLoc = glGetUniformLocation(ourShader.ID, <span class="string">&quot;transform&quot;</span>);</span><br><span class="line">glUniformMatrix4fv(transformLoc, <span class="number">1</span>, GL_FALSE, glm::value_ptr(trans));</span><br></pre></td></tr></table></figure><p>我们首先查询uniform变量的地址，然后用有Matrix4fv后缀的glUniform函数把矩阵数据发送给着色器。<strong>第一个参数</strong>你现在应该很熟悉了，它是uniform的位置值。<strong>第二个参数</strong>告诉OpenGL我们将要<strong>发送多少个矩阵</strong>，这里是1。<strong>第三个参数</strong>询问我们我们是否希望<strong>对我们的矩阵进行置换</strong>(Transpose)，也就是说交换我们矩阵的行和列。OpenGL开发者通常使用一种<strong>内部矩阵布局</strong>，叫做<strong>列主序</strong>(Column-major Ordering)布局。<strong>GLM的默认布局就是列主序</strong>，所以并不需要置换矩阵，我们填<code>GL_FALSE</code>。<strong>最后一个参数</strong>是真正的矩阵数据，但是GLM并不是把它们的矩阵储存为OpenGL所希望接受的那种，因此我们要先用GLM的自带的函数<code>value_ptr</code>来变换这些数据。</p><p>我们创建了一个变换矩阵，在顶点着色器中声明了一个uniform，并把矩阵发送给了着色器，<strong>着色器会变换我们的顶点坐标</strong>。最后的结果应该看起来像这样：</p><div align="center"><p><img src="/images/learnopengl-c1-f31.jpg"></p></div><p>完美！我们的箱子向左侧旋转，并是原来的一半大小，所以变换成功了。我们现在做些更有意思的，<strong>看看我们是否可以让箱子随着时间旋转</strong>，我们还会重新把箱子放在窗口的右下角。要让箱子随着时间推移旋转，我们必须<strong>在游戏循环中更新变换矩阵</strong>，因为它在每一次渲染迭代中都要更新。我们使用<strong>GLFW的时间函数</strong>来获取不同时间的角度：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">glm::mat4 trans = glm::mat4(<span class="number">1.0f</span>);</span><br><span class="line">trans = glm::translate(trans, glm::vec3(<span class="number">0.5f</span>, <span class="number">-0.5f</span>, <span class="number">0.0f</span>));</span><br><span class="line">trans = glm::rotate(trans, (<span class="keyword">float</span>)glfwGetTime(), glm::vec3(<span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">1.0f</span>));</span><br></pre></td></tr></table></figure><p>要记住的是前面的例子中我们可以在任何地方声明变换矩阵，<strong>但是现在我们必须在每一次迭代中创建它</strong>，从而保证我们能够不断更新旋转角度。这也就意味着<strong>我们不得不在每次游戏循环的迭代中重新创建变换矩阵</strong>。通常在渲染场景的时候，我们也会有多个需要在每次渲染迭代中都<strong>用新值重新创建的变换矩阵</strong>。</p><p>在这里我们先把<strong>箱子围绕原点(0, 0, 0)旋转</strong>，之后，我们把<strong>旋转过后的箱子位移到屏幕的右下角</strong>。记住，<strong>实际的变换顺序应该与阅读顺序相反</strong>：尽管在代码中我们先位移再旋转，实际的变换却是先应用旋转再是位移的。</p><div align="center"><p><img src="/images/learnopengl-c1-f32.jpg"></p></div><p>下一节中，我们会讨论<strong>怎样使用矩阵为顶点定义不同的坐标空间</strong>。这将是我们进入实时3D图像的第一步！</p><h2 id="坐标系统"><a href="#坐标系统" class="headerlink" title="坐标系统"></a>坐标系统</h2><p>在上一个教程中，我们学习了如何有效地利用矩阵的变换来对所有顶点进行变换。OpenGL希望在<strong>每次顶点着色器运行后</strong>，我们<strong>可见的所有顶点都为标准化设备坐标</strong>(Normalized Device Coordinate, <strong>NDC</strong>)。也就是说，每个顶点的<code>x，y，z</code>坐标都应该在<code>-1.0</code>到<code>1.0</code>之间，超出这个坐标范围的顶点都将不可见。我们通常会自己设定一个坐标的范围，之后再在<strong>顶点着色器中</strong>将这些坐标变换为标准化设备坐标。然后将这些<strong>标准化设备坐标</strong>传入<strong>光栅器</strong>(Rasterizer)，将它们变换为屏幕上的二维坐标或像素。</p><p>将<strong>坐标变换为标准化设备坐标</strong>，接着<strong>再转化为屏幕坐标</strong>的过程通常是分步进行的，也就是类似于流水线那样子。在流水线中，物体的顶点在最终转化为屏幕坐标之前还会被变换到多个<strong>坐标系统</strong>(Coordinate System)。将物体的坐标变换到几个<strong>过渡坐标系</strong>(Intermediate Coordinate System)的优点在于，在这些特定的坐标系统中，一些操作或运算更加方便和容易，这一点很快就会变得很明显。对我们来说比较重要的总共有5个不同的坐标系统：</p><ul><li><strong>局部空间</strong>(Local Space，或者称为<strong>物体空间</strong>(Object Space))；</li><li><strong>世界空间</strong>(World Space)；</li><li><strong>观察空间</strong>(View Space，或者称为<strong>视觉空间</strong>(Eye Space))；</li><li><strong>裁剪空间</strong>(Clip Space)；</li><li><strong>屏幕空间</strong>(Screen Space)。</li></ul><p>这就是一个顶点在最终被转化为片段之前需要经历的所有不同状态。</p><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>为了将坐标<strong>从一个坐标系变换到另一个坐标系</strong>，我们需要用到<strong>几个变换矩阵</strong>，最重要的几个分别是<strong>模型</strong>(Model)、<strong>观察</strong>(View)、<strong>投影</strong>(Projection)三个矩阵。</p><p>我们的顶点坐标起始于<strong>局部空间</strong>(Local Space)，在这里它称为局部坐标(Local Coordinate)，它在之后会变为<strong>世界坐标</strong>(World Coordinate)，<strong>观察坐标</strong>(View Coordinate)，<strong>裁剪坐标</strong>(Clip Coordinate)，并最后以<strong>屏幕坐标</strong>(Screen Coordinate)的形式结束。下面的这张图展示了整个流程以及各个变换过程做了什么：</p><div align="center"><p><img src="/images/learnopengl-c1-f33.jpg"></p></div><ol><li><strong>局部坐标</strong>是对象相对于局部原点的坐标，也是<strong>物体起始的坐标</strong>；</li><li>下一步是将<strong>局部坐标变换为世界空间坐标</strong>，世界空间坐标是处于一个更大的空间范围的。这些坐<strong>标相对于世界的全局原点</strong>，它们会和其它物体一起相对于世界的原点进行摆放；</li><li>接下来我们将<strong>世界坐标变换为观察空间坐标</strong>，使得每个坐标都是<strong>从摄像机或者说观察者的角度进行观察的</strong>；</li><li>坐标到达观察空间之后，我们需要将其<strong>投影到裁剪坐标</strong>。裁剪坐标会被处理至<code>-1.0</code>到<code>1.0</code>的范围内，并<strong>判断哪些顶点将会出现在屏幕上</strong>（深度测试）；</li><li>最后，我们将<strong>裁剪坐标变换为屏幕坐标</strong>，我们将使用一个叫做<strong>视口变换</strong>(Viewport Transform)的过程。<strong>视口变换</strong>将位于<code>-1.0</code>到<code>1.0</code>范围的坐标变换到由<code>glViewport</code>函数所定义的坐标范围内。最后变换出来的坐标将会送到光栅器，将其转化为片段。</li></ol><p>我们之所以将顶点变换到各个不同的空间的原因是，<strong>有些操作在特定的坐标系统中才有意义且更方便</strong>。例如，<strong>当需要对物体进行修改的时候，在局部空间中来操作会更说得通</strong>；如果要<strong>对一个物体做出一个相对于其它物体位置</strong>的操作时，在<strong>世界坐标系</strong>中来做这个才更说得通，等等。</p><p>接下来我们将要更仔细地讨论各个坐标系统。</p><h3 id="局部空间"><a href="#局部空间" class="headerlink" title="局部空间"></a>局部空间</h3><p>局部空间是指物体所在的坐标空间，即对象最开始所在的地方。</p><p>模型的所有顶点都是在局部空间中：它们相对于你的物体来说都是局部的。</p><p>我们一直使用的那个箱子的顶点是被设定在-0.5到0.5的坐标范围中，<code>(0, 0)</code>是它的原点。这些都是局部坐标。</p><h3 id="世界空间"><a href="#世界空间" class="headerlink" title="世界空间"></a>世界空间</h3><p>如果我们将我们所有的物体导入到程序当中，它们有可能会全挤在世界的原点(0, 0, 0)上，这并不是我们想要的结果。<strong>我们想为每一个物体定义一个位置</strong>，从而能在更大的世界当中放置它们。世界空间中的坐标正如其名：<strong>是指顶点相对于世界的坐标</strong>。如果你希望将物体分散在世界上摆放（特别是非常真实的那样），这就是你希望物体变换到的空间。物体的坐标将会<strong>从局部变换到世界空间</strong>；该变换是由<strong>模型矩阵</strong>(Model Matrix)实现的。</p><p><strong>模型矩阵是一种变换矩阵</strong>，它能通过对物体进行<strong>位移、缩放、旋转</strong>来将它置于它本应该在的位置或朝向。你可以将它想像为变换一个房子，你需要先将它<strong>缩小</strong>（它在局部空间中太大了），并将其<strong>位移至郊区的一个小镇</strong>，然后在<strong>y轴上往左旋转一点以搭配附近的房子</strong>。你也可以把上一节将箱子到处摆放在场景中用的那个矩阵大致看作一个模型矩阵；我们将箱子的局部坐标变换到场景/世界中的不同位置。</p><h3 id="观察空间"><a href="#观察空间" class="headerlink" title="观察空间"></a>观察空间</h3><p><strong>观察空间</strong>经常被人们称之OpenGL的<strong>摄像机</strong>(Camera)（所以有时也称为摄像机空间(Camera Space)或视觉空间(Eye Space)）。<strong>观察空间</strong>是将世界空间坐标转化为<strong>用户视野前方的坐标而产生的结果</strong>。因此<strong>观察空间就是从摄像机的视角所观察到的空间</strong>。而这通常是由<strong>一系列的位移和旋转</strong>的组合来完成，平移/旋转场景从而使得特定的对象被变换到摄像机的前方。这些组合在一起的变换通常存储在一个<strong>观察矩阵</strong>(View Matrix)里，它被用来将世界坐标变换到观察空间。在下一节中我们将深入讨论如何创建一个这样的观察矩阵来模拟一个摄像机。</p><h3 id="裁剪空间"><a href="#裁剪空间" class="headerlink" title="裁剪空间"></a>裁剪空间</h3><p>在一个<strong>顶点着色器运行的最后</strong>，OpenGL期望所有的坐标都能落在一个特定的范围内，且<strong>任何在这个范围之外的点都应该被裁剪掉</strong>(Clipped)。被裁剪掉的坐标就会被忽略，所以<strong>剩下的坐标就将变为屏幕上可见的片段</strong>。这也就是<strong>裁剪空间</strong>(Clip Space)名字的由来。</p><p>为了将顶点坐标<strong>从观察变换到裁剪空间</strong>，我们需要定义一个<strong>投影矩阵</strong>(Projection Matrix)，它指定了一个<strong>范围的坐标</strong>，比如在<strong>每个维度上的-1000到1000</strong>。投影矩阵接着会将在这个指定的范围内的坐标变换为标准化设备坐标的范围<code>(-1.0, 1.0)</code>。所有在范围外的坐标不会被映射到在<code>-1.0</code>到<code>1.0</code>的范围之间，所以会被裁剪掉。在上面这个投影矩阵所指定的范围内，坐标<code>(1250, 500, 750)</code>将是不可见的，这是由于它的<strong>x坐标超出了范围</strong>，它被转化为一个大于<code>1.0</code>的标准化设备坐标，所以被裁剪掉了。</p><p>如果只是<strong>图元</strong>(Primitive)，例如三角形，的<strong>一部分超出了裁剪体积</strong>(Clipping Volume)，则OpenGL会<strong>重新构建这个三角形为一个或多个三角形让其能够适合这个裁剪范围</strong>。</p><p>由投影矩阵创建的<strong>观察箱</strong>(Viewing Box)被称为<strong>平截头体</strong>(Frustum)，每个出现在平截头体范围内的坐标都会最终出现在用户的屏幕上。将<strong>特定范围内的坐标转化到标准化设备坐标系的过程</strong>（而且它很容易被映射到2D观察空间坐标）被称之为<strong>投影</strong>(Projection)，因为使用投影矩阵能将<strong>3D坐标投影</strong>(Project)到很容易映射到<strong>2D的标准化设备坐标系中</strong>。</p><p>一旦所有顶点被变换到裁剪空间，最终的操作——<strong>透视除法</strong>(Perspective Division)将会执行，在这个过程中我们将位置向量的<code>x，y，z</code>分量分别除以向量的齐次<code>w</code>分量；透视除法是将<strong>4D裁剪空间坐标变换为3D标准化设备坐标的过程</strong>。这一步会在<strong>每一个顶点着色器运行的最后被自动执行</strong>。</p><p>在这一阶段之后，最终的坐标将会被映射到屏幕空间中（使用glViewport中的设定），并被<strong>变换成片段</strong>。</p><p>将<strong>观察坐标变换为裁剪坐标的投影矩阵</strong>可以为两种不同的形式，每种形式都定义了不同的平截头体。我们可以选择创建一个<strong>正射投影矩阵</strong>(Orthographic Projection Matrix)或一个<strong>透视投影矩阵</strong>(Perspective Projection Matrix)。</p><h3 id="正射投影"><a href="#正射投影" class="headerlink" title="正射投影"></a>正射投影</h3><p>正射投影矩阵定义了一个<strong>类似立方体的平截头箱，它定义了一个裁剪空间</strong>，在这空间之外的顶点都会被裁剪掉。创建一个正射投影矩阵需要指定<strong>可见平截头体</strong>的<strong>宽、高和长度</strong>。在使用正射投影矩阵变换至裁剪空间之后处于这个平截头体内的所有坐标将不会被裁剪掉。它的平截头体看起来像一个容器：</p><div align="center"><p><img src="/images/learnopengl-c1-f34.jpg"></p></div><p>上面的平截头体定义了可见的坐标，它由由<strong>宽、高</strong>、<strong>近</strong>(Near)<strong>平面和远</strong>(Far)<strong>平面</strong>所指定。任何出现在近平面之前或远平面之后的坐标都会被裁剪掉。正射平截头体<strong>直接将平截头体内部的所有坐标映射为标准化设备坐标</strong>，因为<strong>每个向量的w分量都没有进行改变</strong>；如果w分量等于1.0，透视除法则不会改变这个坐标。</p><p>要创建一个正射投影矩阵，我们可以使用GLM的内置函数<code>glm::ortho</code>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">glm::ortho(<span class="number">0.0f</span>, <span class="number">800.0f</span>, <span class="number">0.0f</span>, <span class="number">600.0f</span>, <span class="number">0.1f</span>, <span class="number">100.0f</span>);</span><br><span class="line"><span class="comment">//         left, right,  bottom, top,  near,  far</span></span><br></pre></td></tr></table></figure><p><strong>前两个参数</strong>指定了平截头体的<strong>左右坐标</strong>，<strong>第三和第四参数</strong>指定了平截头体的<strong>底部和顶部</strong>。通过这四个参数我们定义了<strong>近平面和远平面的大小</strong>，然后<strong>第五和第六个参数</strong>则定义了近平面和远平面的距离。这个投影矩阵会将处于这些<code>x，y，z</code>值范围内的坐标变换为标准化设备坐标。</p><p>正射投影矩阵直接将坐标映射到2D平面中，即你的屏幕，但实际上一个直接的投影矩阵<strong>会产生不真实的结果</strong>，因为这个投影<strong>没有将透视</strong>(Perspective)考虑进去。所以我们需要透视投影矩阵来解决这个问题。</p><h3 id="透视投影"><a href="#透视投影" class="headerlink" title="透视投影"></a>透视投影</h3><p>如果你曾经体验过实际生活给你带来的景象，你就会注意到<strong>离你越远的东西看起来更小</strong>。这个奇怪的效果称之为<strong>透视</strong>(Perspective)。<strong>透视的效果在我们看一条无限长的高速公路或铁路时尤其明显</strong>，正如下面图片显示的那样：</p><div align="center"><p><img src="/images/learnopengl-c1-f35.jpg"></p></div><p>正如你看到的那样，由于透视，<strong>这两条线在很远的地方看起来会相交</strong>。这正是透视投影想要模仿的效果，它是使用<strong>透视投影矩阵来完成的</strong>。这个投影矩阵将给定的平截头体范围映射到裁剪空间，除此之外还<strong>修改了每个顶点坐标的w值</strong>，从而<strong>使得离观察者越远的顶点坐标w分量越大</strong>。被变换到裁剪空间的坐标都会在<code>-w</code>到<code>w</code>的范围之间（<strong>任何大于这个范围的坐标都会被裁剪掉</strong>）。OpenGL要求所有可见的坐标都落在<code>-1.0</code>到<code>1.0</code>范围内，作为顶点着色器最后的输出，因此，一旦坐标在裁剪空间内之后，<strong>透视除法就会被应用到裁剪空间坐标上</strong>：</p><div align="center"><p><img src="/images/learnopengl-c1-f36.jpg"></p></div><p>顶点坐标的每个分量都会除以它的w分量，距离观察者越远顶点坐标就会越小。这是也是w分量非常重要的另一个原因，它能够帮助我们进行透视投影。最后的结果坐标就是处于标准化设备空间中的。如果你对正射投影矩阵和透视投影矩阵是如何计算的很感兴趣（且不会对数学感到恐惧的话）我推荐这篇由Songho写的<a target="_blank" rel="noopener" href="http://www.songho.ca/opengl/gl_projectionmatrix.html">文章</a>。</p><p>在GLM中可以这样创建一个透视投影矩阵：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">glm::perspective(glm::radians(<span class="number">45.0f</span>), (<span class="keyword">float</span>)width/(<span class="keyword">float</span>)height, <span class="number">0.1f</span>, <span class="number">100.0f</span>);</span><br></pre></td></tr></table></figure><p>同样，<code>glm::perspective</code>所做的其实就是<strong>创建了一个定义了可视空间的大平截头体</strong>，任何在这个平截头体以外的东西最后都不会出现在裁剪空间体积内，并且将会受到裁剪。一个透视平截头体可以被看作一个<strong>不均匀形状的箱子</strong>，在这个箱子内部的每个坐标都会被映射到裁剪空间上的一个点。下面是一张透视平截头体的图片：</p><div align="center"><p><img src="/images/learnopengl-c1-f37.jpg"></p></div><p><code>glm::perspective</code>的第一个参数定义了<code>fov</code>的值，它表示的是<strong>视野</strong>(Field of View)，并且设置了<strong>观察空间的大小</strong>。如果想要一个真实的观察效果，它的值通常设置为<code>45.0f</code>，但想要一个末日风格的结果你可以将其设置一个更大的值。第二个参数设置了<strong>宽高比</strong>，<strong>由视口的宽除以高所得</strong>。<strong>第三和第四个参数</strong>设置了平截头体的<strong>近和远平面</strong>。我们通常设置近距离为<code>0.1f</code>，而远距离设为<code>100.0f</code>。所有在近平面和远平面内且处于平截头体内的顶点都会被渲染。</p><p>当你把透视矩阵的 <code>near</code> 值设置太大时（如<code>10.0f</code>），OpenGL会将靠近摄像机的坐标（在0.0f和10.0f之间）都裁剪掉，这会导致一个你在游戏中很熟悉的视觉效果：<strong>在太过靠近一个物体的时候你的视线会直接穿过去</strong>。</p><p>当使用正射投影时，每一个顶点坐标都会直接映射到裁剪空间中而不经过任何精细的透视除法（它仍然会进行透视除法，只是w分量没有被改变（它保持为1），因此没有起作用）。因为正射投影没有使用透视，远处的物体不会显得更小，所以产生奇怪的视觉效果。由于这个原因，正射投影主要用于二维渲染以及一些建筑或工程的程序，在这些场景中我们更希望顶点不会被透视所干扰。某些如 Blender 等进行三维建模的软件有时在建模时也会使用正射投影，因为它在各个维度下都更准确地描绘了每个物体。下面你能够看到在Blender里面使用两种投影方式的对比：</p><div align="center"><p><img src="/images/learnopengl-c1-f38.jpg"></p></div><h3 id="把它们都组合到一起"><a href="#把它们都组合到一起" class="headerlink" title="把它们都组合到一起"></a>把它们都组合到一起</h3><p>我们为上述的每一个步骤都创建了一个变换矩阵：<strong>模型矩阵</strong>、<strong>观察矩阵</strong>和<strong>投影矩阵</strong>。一个顶点坐标将会根据以下过程<strong>被变换到裁剪坐标</strong>：</p><div align="center"><p><img src="/images/learnopengl-c1-f39.jpg"></p></div><p>注意矩阵运算的顺序是相反的（<strong>记住我们需要从右往左阅读矩阵的乘法</strong>）。最后的顶点应该被赋值到顶点着色器中的<code>gl_Position</code>，OpenGL将会<strong>自动进行透视除法和裁剪</strong>。</p><p>然后呢？<strong>顶点着色器的输出要求所有的顶点都在裁剪空间内</strong>，这正是我们刚才使用变换矩阵所做的。OpenGL然后<strong>对裁剪坐标执行透视除法</strong>从而将<strong>它们变换到标准化设备坐标。</strong>OpenGL会使用<code>glViewPort</code>内部的参数来将标准化设备坐标映射到屏幕坐标，每个坐标都关联了一个屏幕上的点（在我们的例子中是一个800x600的屏幕）。这个过程称为<strong>视口变换</strong>。</p><h3 id="进入3D"><a href="#进入3D" class="headerlink" title="进入3D"></a>进入3D</h3><p>既然我们知道了如何将3D坐标变换为2D坐标，我们可以开始使用真正的3D物体，而不是枯燥的2D平面了。</p><p>在开始进行3D绘图时，我们首先<strong>创建一个模型矩阵</strong>。这个模型矩阵包含了<strong>位移、缩放与旋转操作</strong>，它们会被应用到所有物体的顶点上，<strong>以变换它们到全局的世界空间</strong>。让我们变换一下我们的平面，将其绕着<code>x</code>轴旋转，<strong>使它看起来像放在地上一样</strong>。这个模型矩阵看起来是这样的：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">glm::mat4 model = glm::mat4(<span class="number">1.0f</span>);</span><br><span class="line">model = glm::rotate(model, glm::radians(<span class="number">-55.0f</span>), glm::vec3(<span class="number">1.0f</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span>));</span><br></pre></td></tr></table></figure><p>通过将顶点坐标乘以这个模型矩阵，我们将该顶点坐标变换到世界坐标。我们的平面看起来就是在地板上，代表全局世界里的平面。</p><p>接下来我们需要创建一个<strong>观察矩阵</strong>。我们想要在场景里面<strong>稍微往后移动</strong>，以使得物体变成可见的（当在世界空间时，我们位于原点(0,0,0)）。要想在场景里面移动，先仔细想一想下面这个句子：</p><ul><li><strong>将摄像机向后移动，和将整个场景向前移动是一样的</strong>。</li></ul><p>这正是<strong>观察矩阵</strong>所做的，我们<strong>以相反于摄像机移动的方向移动整个场景</strong>。因为我们想要往后移动，并且OpenGL是一个<strong>右手坐标系</strong>(Right-handed System)，所以我们（摄像机）需要沿着<code>z</code>轴的正方向移动。我们会通过将场景沿着<code>z</code>轴负方向平移来实现。它会给我们一种<strong>我们在往后移动的感觉</strong>。</p><p><strong>右手坐标系</strong>(Right-handed System)：按照惯例，<strong>OpenGL是一个右手坐标系</strong>。简单来说，就是<strong>正x轴在你的右手边</strong>，<strong>正y轴朝上</strong>，而<strong>正z轴是朝向后方的</strong>。想象你的屏幕处于三个轴的中心，则正z轴穿过你的屏幕朝向你。坐标系画起来如下：</p><div align="center"><p><img src="/images/learnopengl-c1-f40.jpg"></p></div><p>为了理解为什么被称为右手坐标系，按如下的步骤做：</p><ul><li>沿着正y轴方向伸出你的右臂，手指着上方；</li><li>大拇指指向右方；</li><li>食指指向上方；</li><li>中指向下弯曲90度。</li></ul><p>如果你的动作正确，那么你的大拇指指向正x轴方向，食指指向正y轴方向，中指指向正z轴方向。<strong>如果你用左臂来做这些动作，你会发现z轴的方向是相反的</strong>。这个叫做<strong>左手坐标系</strong>，它被DirectX广泛地使用。注意在<strong>标准化设备坐标系</strong>中<strong>OpenGL实际上使用的是左手坐标系</strong>（投影矩阵交换了左右手）。</p><p>就目前来说，观察矩阵是这样的：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">glm::mat4 view = glm::mat4(<span class="number">1.0f</span>);</span><br><span class="line"><span class="comment">// 注意，我们将矩阵向我们要进行移动场景的反方向移动</span></span><br><span class="line"><span class="comment">// 因为这里真正移动的东西是场景而不是相机</span></span><br><span class="line">view = glm::translate(view, glm::vec3(<span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">-3.0f</span>));</span><br></pre></td></tr></table></figure><p>最后我们需要做的是定义一个<strong>投影矩阵</strong>。我们希望在场景中使用<strong>透视投影</strong>，所以像这样声明一个投影矩阵：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">glm::mat4 projection = glm::mat4(<span class="number">1.0f</span>);</span><br><span class="line">projection = glm::perspective(glm::radians(<span class="number">45.0f</span>), screenWidth / screenHeight, <span class="number">0.1f</span>, <span class="number">100.0f</span>);</span><br></pre></td></tr></table></figure><p>既然我们已经创建了<strong>变换矩阵</strong>，我们应该将它们<strong>传入顶点着色器</strong>。首先，让我们在顶点着色器中声明一个<code>uniform</code><strong>变换矩阵</strong>然后将它乘以顶点坐标：</p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#version 330 core</span></span><br><span class="line"><span class="keyword">layout</span> (<span class="keyword">location</span> = <span class="number">0</span>) <span class="keyword">in</span> <span class="type">vec3</span> aPos;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">uniform</span> <span class="type">mat4</span> model;</span><br><span class="line"><span class="keyword">uniform</span> <span class="type">mat4</span> view;</span><br><span class="line"><span class="keyword">uniform</span> <span class="type">mat4</span> projection;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> main() &#123;</span><br><span class="line">    <span class="comment">// 注意乘法要从右向左读</span></span><br><span class="line">    <span class="built_in">gl_Position</span> = projection * view * model * <span class="type">vec4</span>(aPos, <span class="number">1.0</span>);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们还应该将矩阵传入顶点着色器（这通常在每次的渲染迭代中进行，因为变换矩阵会经常变动）：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> modelLoc = glGetUniformLocation(ourShader.ID, <span class="string">&quot;model&quot;</span>);</span><br><span class="line">glUniformMatrix4fv(modelLoc, <span class="number">1</span>, GL_FALSE, glm::value_ptr(model));</span><br><span class="line"><span class="keyword">int</span> viewLoc = glGetUniformLocation(ourShader.ID, <span class="string">&quot;view&quot;</span>);</span><br><span class="line">glUniformMatrix4fv(viewLoc, <span class="number">1</span>, GL_FALSE, glm::value_ptr(view));</span><br><span class="line"><span class="keyword">int</span> projectionLoc = glGetUniformLocation(ourShader.ID, <span class="string">&quot;projection&quot;</span>);</span><br><span class="line">glUniformMatrix4fv(projectionLoc, <span class="number">1</span>, GL_FALSE, glm::value_ptr(projection));</span><br></pre></td></tr></table></figure><p>我们的顶点坐标已经使用模型、观察和投影矩阵进行变换了，最终的物体应该会：</p><ul><li>稍微向后倾斜至地板方向；</li><li>离我们有一些距离；</li><li>有透视效果（顶点越远，变得越小）。</li></ul><div align="center"><p><img src="/images/learnopengl-c1-f41.jpg"></p></div><h3 id="更多的3D"><a href="#更多的3D" class="headerlink" title="更多的3D"></a>更多的3D</h3><p>到目前为止，我们一直都在使用一个2D平面，而且甚至是在3D空间里！所以，让我们大胆地<strong>拓展我们的2D平面为一个3D立方体</strong>。要想渲染一个立方体，<strong>我们一共需要36个顶点</strong>（<code>6</code>个面 x 每个面有<code>2</code>个三角形组成 x 每个三角形有<code>3</code>个顶点）。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">float</span> vertices[] = &#123;</span><br><span class="line">    <span class="number">-0.5f</span>, <span class="number">-0.5f</span>, <span class="number">-0.5f</span>,  <span class="number">0.0f</span>, <span class="number">0.0f</span>,</span><br><span class="line">     <span class="number">0.5f</span>, <span class="number">-0.5f</span>, <span class="number">-0.5f</span>,  <span class="number">1.0f</span>, <span class="number">0.0f</span>,</span><br><span class="line">     <span class="number">0.5f</span>,  <span class="number">0.5f</span>, <span class="number">-0.5f</span>,  <span class="number">1.0f</span>, <span class="number">1.0f</span>,</span><br><span class="line">     <span class="number">0.5f</span>,  <span class="number">0.5f</span>, <span class="number">-0.5f</span>,  <span class="number">1.0f</span>, <span class="number">1.0f</span>,</span><br><span class="line">    <span class="number">-0.5f</span>,  <span class="number">0.5f</span>, <span class="number">-0.5f</span>,  <span class="number">0.0f</span>, <span class="number">1.0f</span>,</span><br><span class="line">    <span class="number">-0.5f</span>, <span class="number">-0.5f</span>, <span class="number">-0.5f</span>,  <span class="number">0.0f</span>, <span class="number">0.0f</span>,</span><br><span class="line"></span><br><span class="line">    <span class="number">-0.5f</span>, <span class="number">-0.5f</span>,  <span class="number">0.5f</span>,  <span class="number">0.0f</span>, <span class="number">0.0f</span>,</span><br><span class="line">     <span class="number">0.5f</span>, <span class="number">-0.5f</span>,  <span class="number">0.5f</span>,  <span class="number">1.0f</span>, <span class="number">0.0f</span>,</span><br><span class="line">     <span class="number">0.5f</span>,  <span class="number">0.5f</span>,  <span class="number">0.5f</span>,  <span class="number">1.0f</span>, <span class="number">1.0f</span>,</span><br><span class="line">     <span class="number">0.5f</span>,  <span class="number">0.5f</span>,  <span class="number">0.5f</span>,  <span class="number">1.0f</span>, <span class="number">1.0f</span>,</span><br><span class="line">    <span class="number">-0.5f</span>,  <span class="number">0.5f</span>,  <span class="number">0.5f</span>,  <span class="number">0.0f</span>, <span class="number">1.0f</span>,</span><br><span class="line">    <span class="number">-0.5f</span>, <span class="number">-0.5f</span>,  <span class="number">0.5f</span>,  <span class="number">0.0f</span>, <span class="number">0.0f</span>,</span><br><span class="line"></span><br><span class="line">    <span class="number">-0.5f</span>,  <span class="number">0.5f</span>,  <span class="number">0.5f</span>,  <span class="number">1.0f</span>, <span class="number">0.0f</span>,</span><br><span class="line">    <span class="number">-0.5f</span>,  <span class="number">0.5f</span>, <span class="number">-0.5f</span>,  <span class="number">1.0f</span>, <span class="number">1.0f</span>,</span><br><span class="line">    <span class="number">-0.5f</span>, <span class="number">-0.5f</span>, <span class="number">-0.5f</span>,  <span class="number">0.0f</span>, <span class="number">1.0f</span>,</span><br><span class="line">    <span class="number">-0.5f</span>, <span class="number">-0.5f</span>, <span class="number">-0.5f</span>,  <span class="number">0.0f</span>, <span class="number">1.0f</span>,</span><br><span class="line">    <span class="number">-0.5f</span>, <span class="number">-0.5f</span>,  <span class="number">0.5f</span>,  <span class="number">0.0f</span>, <span class="number">0.0f</span>,</span><br><span class="line">    <span class="number">-0.5f</span>,  <span class="number">0.5f</span>,  <span class="number">0.5f</span>,  <span class="number">1.0f</span>, <span class="number">0.0f</span>,</span><br><span class="line"></span><br><span class="line">     <span class="number">0.5f</span>,  <span class="number">0.5f</span>,  <span class="number">0.5f</span>,  <span class="number">1.0f</span>, <span class="number">0.0f</span>,</span><br><span class="line">     <span class="number">0.5f</span>,  <span class="number">0.5f</span>, <span class="number">-0.5f</span>,  <span class="number">1.0f</span>, <span class="number">1.0f</span>,</span><br><span class="line">     <span class="number">0.5f</span>, <span class="number">-0.5f</span>, <span class="number">-0.5f</span>,  <span class="number">0.0f</span>, <span class="number">1.0f</span>,</span><br><span class="line">     <span class="number">0.5f</span>, <span class="number">-0.5f</span>, <span class="number">-0.5f</span>,  <span class="number">0.0f</span>, <span class="number">1.0f</span>,</span><br><span class="line">     <span class="number">0.5f</span>, <span class="number">-0.5f</span>,  <span class="number">0.5f</span>,  <span class="number">0.0f</span>, <span class="number">0.0f</span>,</span><br><span class="line">     <span class="number">0.5f</span>,  <span class="number">0.5f</span>,  <span class="number">0.5f</span>,  <span class="number">1.0f</span>, <span class="number">0.0f</span>,</span><br><span class="line"></span><br><span class="line">    <span class="number">-0.5f</span>, <span class="number">-0.5f</span>, <span class="number">-0.5f</span>,  <span class="number">0.0f</span>, <span class="number">1.0f</span>,</span><br><span class="line">     <span class="number">0.5f</span>, <span class="number">-0.5f</span>, <span class="number">-0.5f</span>,  <span class="number">1.0f</span>, <span class="number">1.0f</span>,</span><br><span class="line">     <span class="number">0.5f</span>, <span class="number">-0.5f</span>,  <span class="number">0.5f</span>,  <span class="number">1.0f</span>, <span class="number">0.0f</span>,</span><br><span class="line">     <span class="number">0.5f</span>, <span class="number">-0.5f</span>,  <span class="number">0.5f</span>,  <span class="number">1.0f</span>, <span class="number">0.0f</span>,</span><br><span class="line">    <span class="number">-0.5f</span>, <span class="number">-0.5f</span>,  <span class="number">0.5f</span>,  <span class="number">0.0f</span>, <span class="number">0.0f</span>,</span><br><span class="line">    <span class="number">-0.5f</span>, <span class="number">-0.5f</span>, <span class="number">-0.5f</span>,  <span class="number">0.0f</span>, <span class="number">1.0f</span>,</span><br><span class="line"></span><br><span class="line">    <span class="number">-0.5f</span>,  <span class="number">0.5f</span>, <span class="number">-0.5f</span>,  <span class="number">0.0f</span>, <span class="number">1.0f</span>,</span><br><span class="line">     <span class="number">0.5f</span>,  <span class="number">0.5f</span>, <span class="number">-0.5f</span>,  <span class="number">1.0f</span>, <span class="number">1.0f</span>,</span><br><span class="line">     <span class="number">0.5f</span>,  <span class="number">0.5f</span>,  <span class="number">0.5f</span>,  <span class="number">1.0f</span>, <span class="number">0.0f</span>,</span><br><span class="line">     <span class="number">0.5f</span>,  <span class="number">0.5f</span>,  <span class="number">0.5f</span>,  <span class="number">1.0f</span>, <span class="number">0.0f</span>,</span><br><span class="line">    <span class="number">-0.5f</span>,  <span class="number">0.5f</span>,  <span class="number">0.5f</span>,  <span class="number">0.0f</span>, <span class="number">0.0f</span>,</span><br><span class="line">    <span class="number">-0.5f</span>,  <span class="number">0.5f</span>, <span class="number">-0.5f</span>,  <span class="number">0.0f</span>, <span class="number">1.0f</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>为了有趣一点，我们将让立方体随着时间旋转：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">model = glm::rotate(model, (<span class="keyword">float</span>)glfwGetTime() * glm::radians(<span class="number">50.0f</span>), glm::vec3(<span class="number">0.5f</span>, <span class="number">1.0f</span>, <span class="number">0.0f</span>));</span><br></pre></td></tr></table></figure><p>然后我们使用glDrawArrays来绘制立方体，但这一次总共有36个顶点：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">glDrawArrays(GL_TRIANGLES, <span class="number">0</span>, <span class="number">36</span>);</span><br></pre></td></tr></table></figure><div align="center"><p><img src="/images/learnopengl-c1-f42.jpg"></p></div><p>这的确有点像是一个立方体，但又有种说不出的奇怪。<strong>立方体的某些本应被遮挡住的面被绘制在了这个立方体其他面之上</strong>。之所以这样是因为OpenGL是<strong>一个三角形一个三角形地来绘制你的立方体的</strong>，所以即便之前那里有东西它也会覆盖之前的像素。因为这个原因，有些三角形会被绘制在其它三角形上面，虽然它们本不应该是被覆盖的。</p><p>幸运的是，OpenGL存储深度信息在一个叫做<strong>Z缓冲</strong>(Z-buffer)的缓冲中，它允许OpenGL决定<strong>何时覆盖一个像素而何时不覆盖</strong>。通过使用<strong>Z缓冲</strong>，我们可以配置OpenGL来进行深度测试。</p><h3 id="Z缓冲"><a href="#Z缓冲" class="headerlink" title="Z缓冲"></a>Z缓冲</h3><p>OpenGL存储它的<strong>所有深度信息于一个Z缓冲</strong>(Z-buffer)中，也被称为深度缓冲(Depth Buffer)。<strong>GLFW会自动为你生成这样一个缓冲</strong>（就像它也有一个颜色缓冲来存储输出图像的颜色）。深度值存储在<strong>每个片段里面</strong>（作为片段的z值），当片段想要输出它的颜色时，<strong>OpenGL会将它的深度值和z缓冲进行比较</strong>，如<strong>果当前的片段在其它片段之后，它将会被丢弃，否则将会覆盖</strong>。这个过程称为<strong>深度测试</strong>(Depth Testing)，它是由<strong>OpenGL自动完成的</strong>。</p><p>然而，如果我们想要确定OpenGL真的执行了深度测试，<strong>首先我们要告诉OpenGL我们想要启用深度测试，它默认是关闭的</strong>。我们可以通过<code>glEnable</code>函数来开启深度测试。<code>glEnable</code>和<code>glDisable</code>函数允许我们<strong>启用或禁用某个OpenGL功能</strong>。这个功能会一直保持启用/禁用状态，直到另一个调用来禁用/启用它。现在我们想启用深度测试，需要开启<code>GL_DEPTH_TEST</code>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">glEnable(GL_DEPTH_TEST);</span><br></pre></td></tr></table></figure><p>因为我们使用了深度测试，我们也想要在<strong>每次渲染迭代之前清除深度缓冲</strong>（否则前一帧的深度信息仍然保存在缓冲中）。就像清除颜色缓冲一样，我们可以通过在<code>glClear</code>函数中指定<code>DEPTH_BUFFER_BIT</code>位来清除深度缓冲：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);</span><br></pre></td></tr></table></figure><div align="center"><p><img src="/images/learnopengl-c1-f43.jpg"></p></div><h3 id="更多的立方体！"><a href="#更多的立方体！" class="headerlink" title="更多的立方体！"></a>更多的立方体！</h3><p>现在我们想在屏幕上<strong>显示10个立方体</strong>。每个立方体看起来都是一样的，区别在于它们在<strong>世界的位置及旋转角度不同</strong>。立方体的图形布局已经定义好了，所以当渲染更多物体的时候我们<strong>不需要改变我们的缓冲数组和属性数组</strong>，我们唯一需要做的<strong>只是改变每个对象的模型矩阵来将立方体变换到世界坐标系中</strong>。</p><p>首先，让我们<strong>为每个立方体定义一个位移向量来指定它在世界空间的位置</strong>。我们将在一个<code>glm::vec3</code>数组中定义<strong>10个立方体位置</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">glm::vec3 cubePositions[] = &#123;</span><br><span class="line">  glm::vec3( <span class="number">0.0f</span>,  <span class="number">0.0f</span>,  <span class="number">0.0f</span>), </span><br><span class="line">  glm::vec3( <span class="number">2.0f</span>,  <span class="number">5.0f</span>, <span class="number">-15.0f</span>), </span><br><span class="line">  glm::vec3(<span class="number">-1.5f</span>, <span class="number">-2.2f</span>, <span class="number">-2.5f</span>),  </span><br><span class="line">  glm::vec3(<span class="number">-3.8f</span>, <span class="number">-2.0f</span>, <span class="number">-12.3f</span>),  </span><br><span class="line">  glm::vec3( <span class="number">2.4f</span>, <span class="number">-0.4f</span>, <span class="number">-3.5f</span>),  </span><br><span class="line">  glm::vec3(<span class="number">-1.7f</span>,  <span class="number">3.0f</span>, <span class="number">-7.5f</span>),  </span><br><span class="line">  glm::vec3( <span class="number">1.3f</span>, <span class="number">-2.0f</span>, <span class="number">-2.5f</span>),  </span><br><span class="line">  glm::vec3( <span class="number">1.5f</span>,  <span class="number">2.0f</span>, <span class="number">-2.5f</span>), </span><br><span class="line">  glm::vec3( <span class="number">1.5f</span>,  <span class="number">0.2f</span>, <span class="number">-1.5f</span>), </span><br><span class="line">  glm::vec3(<span class="number">-1.3f</span>,  <span class="number">1.0f</span>, <span class="number">-1.5f</span>)  </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>现在，在游戏循环中，我们调用<code>glDrawArrays</code> 10次，但这次在我们渲染之前每次传入一个不同的模型矩阵到顶点着色器中。我们将会在<strong>游戏循环中创建一个小的循环用不同的模型矩阵渲染我们的物体10次</strong>。注意我们也对每个箱子加了一点旋转：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">glBindVertexArray(VAO);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">unsigned</span> <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">    glm::mat4 model = glm::mat4(<span class="number">1.0f</span>);;</span><br><span class="line">    model = glm::translate(model, cubePositions[i]);</span><br><span class="line">    <span class="keyword">float</span> angle = <span class="number">20.0f</span> * i;</span><br><span class="line">    model = glm::rotate(model, (<span class="keyword">float</span>)glfwGetTime() * glm::radians(angle), glm::vec3(<span class="number">1.0f</span>, <span class="number">0.3f</span>, <span class="number">0.5f</span>));</span><br><span class="line">    <span class="comment">// 这里需要给之前的Shader类添加一个setMat4函数 ，具体写法为：</span></span><br><span class="line">    <span class="comment">// glUniformMatrix4fv(glGetUniformLocation(ID, name.c_str()), 1, GL_FALSE, &amp;mat[0][0]);</span></span><br><span class="line">    ourShader.setMat4(<span class="string">&quot;model&quot;</span>, model);</span><br><span class="line"></span><br><span class="line">    glDrawArrays(GL_TRIANGLES, <span class="number">0</span>, <span class="number">36</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><div align="center"><p><img src="/images/learnopengl-c1-f44.jpg"></p></div><h3 id="练习题-2"><a href="#练习题-2" class="headerlink" title="练习题"></a>练习题</h3><ul><li>对GLM的projection函数中的FoV和aspect-ratio参数进行实验。看能否搞懂它们是如何影响透视平截头体的；</li><li>将观察矩阵在各个方向上进行位移，来看看场景是如何改变的。注意把观察矩阵当成摄像机对象；</li><li>使用模型矩阵只让是3倍数的箱子旋转（以及第1个箱子），而让剩下的箱子保持静止。</li></ul><h2 id="摄像机"><a href="#摄像机" class="headerlink" title="摄像机"></a>摄像机</h2><p>前面的教程中我们讨论了<strong>观察矩阵</strong>以及如何<strong>使用观察矩阵移动场景</strong>（我们向后移动了一点）。<strong>OpenGL本身没有摄像机</strong>(Camera)的概念，但我们<strong>可以通过把场景中的所有物体往相反方向移动的方式来模拟出摄像机</strong>，产生一种我们在移动的感觉，而不是场景在移动。</p><p>本节我们将会讨论如何在<strong>OpenGL中配置一个摄像机</strong>，并且将会讨论<strong>FPS风格的摄像机</strong>，让你能够在<strong>3D场景中自由移动</strong>。我们也会讨论<strong>键盘和鼠标输入</strong>，最终完成一个<strong>自定义的摄像机类</strong>。</p><h3 id="摄像机-观察空间"><a href="#摄像机-观察空间" class="headerlink" title="摄像机/观察空间"></a>摄像机/观察空间</h3><p>当我们讨论<strong>摄像机/观察空间</strong>(Camera/View Space)的时候，是在讨论<strong>以摄像机的视角作为场景原点时</strong>场景中所有的顶点坐标：观察矩阵把所有的世界坐标变换为相对于摄像机位置与方向的观察坐标。<strong>要定义一个摄像机</strong>，我们需要它在世界空间中的<strong>位置</strong>、<strong>观察的方向</strong>、一个<strong>指向它右侧的向量</strong>以及一个<strong>指向它上方的向量</strong>。细心的读者可能已经注意到我们实际上创建了一个<strong>三个单位轴相互垂直的</strong>、以<strong>摄像机的位置为原点的坐标系</strong>。</p><div align="center"><p><img src="/images/learnopengl-c1-f45.jpg"></p></div><ol><li>摄像机位置</li></ol><p>获取摄像机位置很简单。摄像机位置简单来说就是世界空间中一个<strong>指向摄像机位置的向量</strong>。我们把摄像机位置设置为上一节中的那个相同的位置：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">glm::vec3 cameraPos = glm::vec3(<span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">3.0f</span>);</span><br></pre></td></tr></table></figure><ol start="2"><li>摄像机方向</li></ol><p>下一个需要的向量是摄像机的方向，这里指的是摄像机指向哪个方向。<strong>现在我们让摄像机指向场景原点</strong>：``(0, 0, 0)。还记得如果将两个矢量相减，我们就能得到这两个矢量的差吗？<strong>用场景原点向量减去摄像机位置向量的结果就是摄像机的指向向量</strong>。由于我们知道<strong>摄像机指向z轴负方向</strong>，但我们<strong>希望方向向量</strong>(Direction Vector)<strong>指向摄像机的z轴正方向</strong>。如果我们交换相减的顺序，我们就会获得一个<strong>指向摄像机正z轴方向的向量</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">glm::vec3 cameraTarget = glm::vec3(<span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span>);</span><br><span class="line">glm::vec3 cameraDirection = glm::normalize(cameraPos - cameraTarget);</span><br></pre></td></tr></table></figure><p><strong>方向向量</strong>(Direction Vector)<strong>并不是最好的名字</strong>，因为它<strong>实际上指向从它到目标向量的相反方向</strong>（译注：注意看前面的那个图，蓝色的方向向量大概指向z轴的正方向，与摄像机实际指向的方向是正好相反的）。</p><ol start="3"><li>右轴</li></ol><p>我们需要的<strong>另一个向量是一个右向量</strong>(Right Vector)，它代表<strong>摄像机空间的x轴的正方向</strong>。为获取右向量我们需要先使用一个小技巧：先<strong>定义一个上向量</strong>(Up Vector)。接下来把<strong>上向量和第二步得到的方向向量进行叉乘</strong>。两个向量叉乘的结果会同时垂直于两向量，因此我们<strong>会得到指向x轴正方向的那个向量</strong>（如果我们交换两个向量叉乘的顺序就会得到相反的指向x轴负方向的向量）：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">glm::vec3 up = glm::vec3(<span class="number">0.0f</span>, <span class="number">1.0f</span>, <span class="number">0.0f</span>);</span><br><span class="line"><span class="comment">// 注意叉乘的顺序，右手系</span></span><br><span class="line">glm::vec3 cameraRight = glm::normalize(glm::cross(up, cameraDirection));</span><br></pre></td></tr></table></figure><ol start="4"><li>上轴</li></ol><p>现在我们已经有了x轴向量和z轴向量，获取一个指向摄像机的正y轴向量就相对简单了：我们把<strong>方向向量和右向量进行叉乘</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 注意叉乘顺序，右手系</span></span><br><span class="line">glm::vec3 cameraUp = glm::cross(cameraDirection, cameraRight);</span><br></pre></td></tr></table></figure><p>对于想学到更多数学原理的读者，提示一下，在线性代数中这个处理叫做<strong>格拉姆—施密特正交化</strong>(Gram-Schmidt Process)。使用这些<strong>摄像机向量</strong>我们就可以创建一个<code>LookAt</code>矩阵了，它在创建摄像机的时候非常有用。</p><h3 id="Look-At"><a href="#Look-At" class="headerlink" title="Look At"></a>Look At</h3><p>使用矩阵的好处之一是如果<strong>你使用3个相互垂直</strong>（或非线性）的<strong>轴</strong>定义了<strong>一个坐标空间</strong>，你可以用这<strong>3个轴</strong>外加<strong>一个平移向量</strong>来<strong>创建一个矩阵</strong>，并且你可以<strong>用这个矩阵乘以任何向量来将其变换到那个坐标空间</strong>。这正是LookAt矩阵所做的，现在我们有了3个相互垂直的轴和一个定义摄像机空间的位置坐标，我们可以创建我们自己的LookAt矩阵了：</p><div align="center"><p><img src="/images/learnopengl-c1-f46.jpg"></p></div><p>其中<strong>R是右向量</strong>，<strong>U是上向量</strong>，<strong>D是方向向量</strong>，<strong>P是摄像机位置向量</strong>。注意，<strong>位置向量是相反的</strong>，因为我们<strong>最终希望把世界平移到与我们自身移动的相反方向</strong>。把这个LookAt矩阵作为观察矩阵可以很高效地把<strong>所有世界坐标变换到刚刚定义的观察空间</strong>。LookAt矩阵就像它的名字表达的那样：它会创建一个看着(Look at)给定目标的观察矩阵。</p><p>幸运的是，<strong>GLM已经提供了这些支持</strong>。我们要做的<strong>只是定义一个摄像机位置</strong>，<strong>一个目标位置</strong>和<strong>一个表示世界空间中的上向量的向量</strong>（我们计算右向量使用的那个<strong>上向量</strong>）。接着GLM就会创建一个LookAt矩阵，我们可以把它当作我们的观察矩阵：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">glm::mat4 view = glm::mat4(<span class="number">1.0f</span>);</span><br><span class="line">view = glm::lookAt(glm::vec3(<span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">3.0f</span>),  <span class="comment">// position</span></span><br><span class="line">                   glm::vec3(<span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span>),  <span class="comment">// target position</span></span><br><span class="line">                   glm::vec3(<span class="number">0.0f</span>, <span class="number">1.0f</span>, <span class="number">0.0f</span>)); <span class="comment">// up vector</span></span><br></pre></td></tr></table></figure><p><code>glm::LookAt</code>函数需要一个<strong>位置、目标和上向量</strong>。它会创建一个和在上一节使用的一样的观察矩阵。</p><p>在讨论用户输入之前，我们先来做些有意思的事，把我们的摄像机在场景中旋转。我们会将摄像机的注视点保持在(0, 0, 0)。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">float</span> radius = <span class="number">10.f</span>;</span><br><span class="line"><span class="keyword">float</span> camX = <span class="built_in">sin</span>(glfwGetTime()) * radius;</span><br><span class="line"><span class="keyword">float</span> camZ = <span class="built_in">cos</span>(glfwGetTime()) * radius;</span><br><span class="line">glm::mat4 view = glm::mat4(<span class="number">1.0f</span>);</span><br><span class="line">view = glm::lookAt(</span><br><span class="line">    glm::vec3(camX, <span class="number">0.0f</span>, camZ), <span class="comment">// position</span></span><br><span class="line">    glm::vec3(<span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span>), <span class="comment">// target</span></span><br><span class="line">    glm::vec3(<span class="number">0.0f</span>, <span class="number">1.0f</span>, <span class="number">0.0f</span>)  <span class="comment">// up-vec</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure><div align="center"><p><img src="/images/learnopengl-c1-f47.jpg"></p></div><h3 id="自由移动"><a href="#自由移动" class="headerlink" title="自由移动"></a>自由移动</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">glm::vec3 cameraPos   = glm::vec3(<span class="number">0.0f</span>, <span class="number">0.0f</span>,  <span class="number">3.0f</span>);</span><br><span class="line">glm::vec3 cameraFront = glm::vec3(<span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">-1.0f</span>);</span><br><span class="line">glm::vec3 cameraUp    = glm::vec3(<span class="number">0.0f</span>, <span class="number">1.0f</span>,  <span class="number">0.0f</span>);</span><br><span class="line">glm::vec3 cameraRight = glm::normalize(glm::cross(cameraFront, cameraUp));</span><br></pre></td></tr></table></figure><p>注意，我们对<strong>右向量进行了标准化</strong>。如果我们没对这个向量进行标准化，最后的叉乘结果会<strong>根据cameraFront变量返回大小不同的向量</strong>。如果我们不对向量进行标准化，我们就得<strong>根据摄像机的朝向不同加速或减速移动了</strong>，但如果进行了<strong>标准化移动就是匀速的</strong>。</p><p>LookAt函数现在成了：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">glm::mat4 view = glm::lookAt(cameraPos, cameraPos + cameraFront, cameraUp);</span><br></pre></td></tr></table></figure><p>我们已经为GLFW的键盘输入定义过一个<code>process_input</code>函数了，我们来新添加几个需要检查的按键命令：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">float</span> cameraSpeed = <span class="number">0.05f</span>; <span class="comment">// adjust accordingly</span></span><br><span class="line"><span class="keyword">if</span> (glfwGetKey(window, GLFW_KEY_W) == GLFW_PRESS) &#123;</span><br><span class="line">    cameraPos += cameraSpeed * cameraFront;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (glfwGetKey(window, GLFW_KEY_S) == GLFW_PRESS) &#123;</span><br><span class="line">    cameraPos -= cameraSpeed * cameraFront;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (glfwGetKey(window, GLFW_KEY_A) == GLFW_PRESS) &#123;</span><br><span class="line">    cameraPos -= cameraSpeed * cameraRight;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (glfwGetKey(window, GLFW_KEY_W) == GLFW_PRESS) &#123;</span><br><span class="line">    cameraPos += cameraSpeed * cameraRight;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><div align="center"><p><img src="/images/learnopengl-c1-f48.jpg"></p></div><h3 id="移动速度"><a href="#移动速度" class="headerlink" title="移动速度"></a>移动速度</h3><p>目前我们的移动速度是个常量。理论上没什么问题，但是<strong>实际情况下根据处理器的能力不同</strong>，有些人可能<strong>会比其他人每秒绘制更多帧</strong>，也就是以<strong>更高的频率调用</strong>process_input函数。结果就是，根据配置的不同，有些人可能移动很快，而有些人会移动很慢。当你发布你的程序的时候，你必须<strong>确保它在所有硬件上移动速度都一样</strong>。</p><p>图形程序和游戏通常会跟踪一个<strong>时间差</strong>(Deltatime)<strong>变量</strong>，<strong>它储存了渲染上一帧所用的时间</strong>。我们把<strong>所有速度</strong>都去乘以<code>deltaTime</code>值。结果就是，如果我们的<code>deltaTime</code>很大，就意味着<strong>上一帧的渲染花费了更多时间</strong>，所以<strong>这一帧的速度需要变得更高来平衡渲染所花去的时间</strong>。使用这种方法时，无论你的电脑快还是慢，摄像机的速度都会相应平衡，这样每个用户的体验就都一样了。</p><p>我们跟踪两个全局变量来计算出<code>deltaTime</code>值：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">float</span> deltaTime = <span class="number">0.0f</span>; <span class="comment">// 当前帧与上一帧的时间差</span></span><br><span class="line"><span class="keyword">float</span> lastFrame = <span class="number">0.0f</span>; <span class="comment">// 上一帧的时间</span></span><br></pre></td></tr></table></figure><p>在每一帧中我们计算出<strong>新的</strong><code>deltaTime</code>以备后用。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">float</span> currentFrame = glfwGetTime();</span><br><span class="line">deltaTime = currentFrame - lastFrame;</span><br><span class="line">lastFrame = currentFrame;</span><br></pre></td></tr></table></figure><p>现在我们有了<code>deltaTime</code>，在计算速度的时候可以将其考虑进去了：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">float</span> cameraSpeed = <span class="number">2.5f</span> * deltaTime;</span><br></pre></td></tr></table></figure><div align="center"><p><img src="/images/learnopengl-c1-f49.jpg"></p></div><p>现在我们有了一个<strong>在任何系统上移动速度都一样的摄像机</strong>（近似一样）。</p><h3 id="视角移动"><a href="#视角移动" class="headerlink" title="视角移动"></a>视角移动</h3><p>现在还不能转向，移动很受限制，是时候加入鼠标了！</p><p>为了能够改变视角，我们需要根据鼠标的输入来该表<code>cameraFront</code>向量，然而，根据鼠标移动改变方向向量有点复杂，需要一些三角学知识。</p><p><strong>欧拉角</strong></p><p>欧拉角(Euler Angle)是可以表示3D空间中<strong>任何旋转的3个值</strong>，由莱昂哈德·欧拉(Leonhard Euler)在18世纪提出。一共有<strong>3种欧拉角</strong>：<strong>俯仰角</strong>(Pitch)、<strong>偏航角</strong>(Yaw)和<strong>滚转角</strong>(Roll)，下面的图片展示了它们的含义：</p><div align="center"><p><img src="/images/learnopengl-c1-f50.jpg"></p></div><p><strong>俯仰角</strong>是描述我们如何<strong>往上或往下看的角</strong>，可以在第一张图中看到。第二张图展示了<strong>偏航角</strong>，偏航角表示我们<strong>往左和往右看</strong>的程度。<strong>滚转角</strong>代表我们如何翻滚摄像机，通常在太空飞船的摄像机中使用。<strong>每个欧拉角都有一个值来表示</strong>，把三个角结合起来我们就能够计算3D空间中任何的旋转向量了。</p><p>对于我们的摄像机系统来说，我们只关心<strong>俯仰角和偏航角</strong>，所以我们不会讨论滚转角。给定一个<strong>俯仰角和偏航角</strong>，我们可以把它们<strong>转换为一个代表新的方向向量的3D向量</strong>。俯仰角和偏航角转换为方向向量的处理需要一些三角学知识，我们先从最基本的情况开始：</p><div align="center"><p><img src="/images/learnopengl-c1-f51.jpg"></p></div><p>如果我们把斜边边长定义为<code>1</code>，我们就能知道邻边的长度是<code>cos(x/h)=cos(x/1)=cosx</code>，它的对边是<code>sin(y/h)=sin(y/1)=siny</code>。这样我们获得了能够得到x和y方向长度的通用公式，它们取决于所给的角度。我们使用它来计算方向向量的分量：</p><div align="center"><p><img src="/images/learnopengl-c1-f52.jpg"></p></div><p>这个三角形看起来和前面的三角形很像，所以如果我们想象<strong>自己在xz平面上</strong>，<strong>看向y轴</strong>，我们可以基于第一个三角形计算来计算它的<strong>长度</strong>/<strong>y方向的强度</strong>(Strength)（我们往上或往下看多少）。从图中我们可以看到对于一个给定<strong>俯仰角</strong>的y值等于sinθ：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">direction.y = <span class="built_in">sin</span>(glm::radians(pitch)); <span class="comment">// 注意我们先把角度转为弧度</span></span><br></pre></td></tr></table></figure><p>这里我们只更新了y值，仔细观察x和z分量也被影响了。从三角形中我们可以看到它们的值等于：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">direction.x = <span class="built_in">cos</span>(glm::radians(pitch));</span><br><span class="line">direction.z = <span class="built_in">cos</span>(glm::radians(pitch));</span><br></pre></td></tr></table></figure><p>看看我们是否能够为偏航角找到需要的分量：</p><div align="center"><p><img src="/images/learnopengl-c1-f53.jpg"></p></div><p>就像俯仰角的三角形一样，我们可以看到<strong>x分量</strong>取决于<code>cos(yaw)</code>的值，z值同样取决于偏航角的正弦值。把这个加到前面的值中，会得到<strong>基于俯仰角和偏航角的方向向量</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">direction.x = <span class="built_in">cos</span>(glm::radians(pitch)) * <span class="built_in">cos</span>(glm::radians(yaw));</span><br><span class="line"><span class="comment">// 译注：direction代表摄像机的前轴(Front)，这个前轴是和本文第一幅图片的第二个摄像机的方向向量是相反的</span></span><br><span class="line">direction.y = <span class="built_in">sin</span>(glm::radians(pitch));</span><br><span class="line">direction.z = <span class="built_in">cos</span>(glm::radians(pitch)) * <span class="built_in">sin</span>(glm::radians(yaw));</span><br></pre></td></tr></table></figure><p>这样我们就有了一个可以把<strong>俯仰角和偏航角</strong>转化为用来自由旋转视角的摄像机的<strong>3维方向向量</strong>了。<strong>你可能会奇怪：我们怎么得到俯仰角和偏航角？</strong></p><p><strong>鼠标输入</strong></p><p>偏航角和俯仰角是通过鼠标（或手柄）移动获得的，<strong>水平的移动影响偏航角</strong>，<strong>竖直的移动影响俯仰角</strong>。它的原理就是，<strong>储存上一帧鼠标的位置，在当前帧中我们当前计算鼠标位置与上一帧的位置相差多少</strong>。如果<strong>水平/竖直差别越大</strong>那么<strong>俯仰角或偏航角就改变越大</strong>，也就是摄像机需要移动更多的距离。</p><p>首先我们要告诉<strong>GLFW</strong>，它应该<strong>隐藏光标</strong>，并<strong>捕捉</strong>(Capture)它。捕捉光标表示的是，如果<strong>焦点在你的程序上</strong>（译注：即表示你正在操作这个程序，Windows中拥有焦点的程序标题栏通常是有颜色的那个，而失去焦点的程序标题栏则是灰色的），<strong>光标应该停留在窗口中</strong>（除非程序失去焦点或者退出）。我们可以用一个简单地配置调用来完成：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">glfwSetInputMode(window, GLFW_CURSOR, GLFW_CURSOR_DISABLED);</span><br></pre></td></tr></table></figure><p>在调用这个函数之后，<strong>无论我们怎么去移动鼠标，光标都不会显示了，它也不会离开窗口</strong>（避免移出窗口就不能再旋转摄像机了）。对于FPS摄像机系统来说非常完美。</p><p>为了计算俯仰角和偏航角，我们需要让GLFW<strong>监听鼠标移动事件</strong>。（和键盘输入相似）我们会用一个<strong>回调函数来完成</strong>，函数的原型如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mouse_callback</span><span class="params">(GLFWwindow* window, <span class="keyword">double</span> xpos, <span class="keyword">double</span> ypos)</span></span>;</span><br></pre></td></tr></table></figure><p>这里的<code>xpos</code>和<code>ypos</code>代表当前<strong>鼠标的位置</strong>。当我们用GLFW注册了回调函数之后，鼠标一移动mouse_callback函数就会被调用：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">glfwSetCursorPosCallback(window, mouse_callback);</span><br></pre></td></tr></table></figure><p>在处理FPS风格摄像机的鼠标输入的时候，我们必须在<strong>最终获取方向向量之前</strong>做下面这几步：</p><ol><li>计算鼠标距上一帧的偏移量；</li><li>把偏移量添加到摄像机的俯仰角和偏航角中；</li><li>对偏航角和俯仰角进行最大和最小值的限制（视野限制）；</li><li>计算方向向量。</li></ol><p>第一步是计算鼠标自上一帧的偏移量。我们必须先在程序中储存上一帧的鼠标位置，我们把它的<strong>初始值设置为屏幕的中心</strong>（屏幕的尺寸是800x600）：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">float</span> lastX = <span class="number">400</span>, lastY = <span class="number">300</span>;</span><br></pre></td></tr></table></figure><p>然后在鼠标的回调函数中我们计算当前帧和上一帧鼠标位置的偏移量：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">float</span> xoffset = xpos - lastX;</span><br><span class="line"><span class="comment">// 注意这里是相反的，因为y坐标是从底部往顶部依次增大的</span></span><br><span class="line"><span class="keyword">float</span> yoffset = lastY - ypos;</span><br><span class="line">lastX = xpos;</span><br><span class="line">lastY = ypos;</span><br><span class="line"></span><br><span class="line"><span class="keyword">float</span> sensitivity = <span class="number">0.05f</span>;</span><br><span class="line">xoffset *= sensitivity;</span><br><span class="line">yoffset *= sensitivity;</span><br></pre></td></tr></table></figure><p>注意我们把偏移量乘以了<code>sensitivity</code>（灵敏度）值。如果我们忽略这个值，鼠标移动就会太大了；你可以自己实验一下，找到适合自己的灵敏度值。</p><p>接下来我们把偏移量加到全局变量<code>pitch</code>和<code>yaw</code>上：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">yaw   += xoffset;</span><br><span class="line">pitch += yoffset;</span><br></pre></td></tr></table></figure><p>第三步，我们需要给摄像机添加一些限制，<strong>这样摄像机就不会发生奇怪的移动了</strong>（这样也会避免一些奇怪的问题）。对于俯仰角，要让用户<strong>不能看向高于89度的地方</strong>（在90度时视角会发生逆转，所以我们把89度作为极限），<strong>同样也不允许小于-89度</strong>。这样能够保证用户只能看到天空或脚下，但是不能超越这个限制。我们可以在值超过限制的时候将其改为极限值来实现：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(pitch &gt; <span class="number">89.0f</span>)</span><br><span class="line">    pitch = <span class="number">89.0f</span>;</span><br><span class="line"><span class="keyword">if</span>(pitch &lt; <span class="number">-89.0f</span>)</span><br><span class="line">    pitch = <span class="number">-89.0f</span>;</span><br></pre></td></tr></table></figure><p>注意我们<strong>没有给偏航角设置限制</strong>，这是因为我们不希望限制用户的水平旋转。当然，给偏航角设置限制也很容易，如果你愿意可以自己实现。</p><p>第四也是最后一步，就是通过俯仰角和偏航角来计算以得到真正的方向向量：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">glm::vec3 front;</span><br><span class="line">front.x = <span class="built_in">cos</span>(glm::radians(pitch)) * <span class="built_in">cos</span>(glm::radians(yaw));</span><br><span class="line">front.y = <span class="built_in">sin</span>(glm::radians(pitch));</span><br><span class="line">front.z = <span class="built_in">cos</span>(glm::radians(pitch)) * <span class="built_in">sin</span>(glm::radians(yaw));</span><br><span class="line">cameraFront = glm::normalize(front);</span><br></pre></td></tr></table></figure><p>计算出来的方向向量就会包含根据鼠标移动计算出来的所有旋转了。由于cameraFront向量已经包含在GLM的lookAt函数中，我们这就没什么问题了。</p><div align="center"><p><img src="/images/learnopengl-c1-f54.jpg"></p></div><p>如果你现在运行代码，你会发现在窗口<strong>第一次获取焦点的时候摄像机会突然跳一下</strong>。这个问题产生的原因是，在你的<strong>鼠标移动进窗口的那一刻</strong>，鼠标回调函数就会被调用，这时候的xpos和ypos会等于鼠标刚刚进入屏幕的那个位置。<strong>这通常是一个距离屏幕中心很远的地方</strong>，因而产生一个很大的偏移量，所以就会跳了。我们可以简单的使用一个<code>bool</code>变量检验我们<strong>是否是第一次获取鼠标输入</strong>，如果是，那么我们先把鼠标的初始位置更新为xpos和ypos值，这样就能解决这个问题；接下来的鼠标移动就会使用刚进入的鼠标位置坐标来计算偏移量了：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这个bool变量初始时是设定为true的</span></span><br><span class="line"><span class="keyword">if</span>(firstMouse) &#123;</span><br><span class="line">    lastX = xpos;</span><br><span class="line">    lastY = ypos;</span><br><span class="line">    firstMouse = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后<code>mouse_callback</code>的代码应该是这样的：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mouse_callback</span><span class="params">(GLFWwindow* window, <span class="keyword">double</span> xpos, <span class="keyword">double</span> ypos)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 这个bool变量初始时是设定为true的</span></span><br><span class="line">    <span class="keyword">if</span> (firstMouse) &#123;</span><br><span class="line">        lastX = xpos;</span><br><span class="line">        lastY = ypos;</span><br><span class="line">        firstMouse = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 偏航角从-90度开始，鼠标向左移动，值变的更小</span></span><br><span class="line">    <span class="comment">// 视角要朝左旋转的话，就要更小的偏航角值</span></span><br><span class="line">    <span class="comment">// 所以直接加上 xpose - lastX即可</span></span><br><span class="line">    <span class="keyword">float</span> xoffset = xpos - lastX;</span><br><span class="line">    <span class="comment">// 而俯仰角是相反的，鼠标向上移动，值变的更小</span></span><br><span class="line">    <span class="comment">// 视角要朝上旋转的话，就要更大的俯仰角</span></span><br><span class="line">    <span class="comment">// 所以要反过来减两个坐标的差值</span></span><br><span class="line">    <span class="keyword">float</span> yoffset = lastY - ypos;</span><br><span class="line">    lastX = xpos;</span><br><span class="line">    lastY = ypos;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">float</span> sensitivity = <span class="number">0.05f</span>;</span><br><span class="line">    xoffset *= sensitivity;</span><br><span class="line">    yoffset *= sensitivity;</span><br><span class="line"></span><br><span class="line">    yaw += xoffset;</span><br><span class="line">    pitch += yoffset;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (pitch &gt; <span class="number">89.0f</span>) &#123;</span><br><span class="line">        pitch = <span class="number">89.0f</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (pitch &lt; <span class="number">-89.0f</span>) &#123;</span><br><span class="line">        pitch = <span class="number">-89.0f</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    glm::vec3 front;</span><br><span class="line">    front.x = <span class="built_in">cos</span>(glm::radians(pitch)) * <span class="built_in">cos</span>(glm::radians(yaw));</span><br><span class="line">    front.y = <span class="built_in">sin</span>(glm::radians(pitch));</span><br><span class="line">    front.z = <span class="built_in">cos</span>(glm::radians(pitch)) * <span class="built_in">sin</span>(glm::radians(yaw));</span><br><span class="line">    cameraFront = glm::normalize(front);</span><br><span class="line">    <span class="comment">// 其实还要重新计算Right和Up向量</span></span><br><span class="line">    <span class="comment">// 否则变换角度后 左右移动会发生异常</span></span><br><span class="line">    cameraRight = glm::normalize(glm::cross(cameraFront, worldUp));</span><br><span class="line">    cameraUp = glm::normalize(glm::cross(cameraRight, cameraFront));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>计算<code>cameraFront</code>这部分放在<code>mouse_callback</code>中可能更适合一点，因为它只有在鼠标移动的时候才会发生改变，如果放在渲染循环中，计算可能是比较冗余的，因为其实有可能在几个帧中间鼠标并没有发生移动，所以没有必要去计算。</p><p><strong>缩放</strong></p><p>作为我们摄像机系统的一个附加内容，我们还会来实现一个<strong>缩放</strong>(Zoom)接口。在之前的教程中我们说<strong>视野</strong>(Field of View)或<code>fov</code>定义了我们可以看到场景中多大的范围。当<strong>视野变小</strong>时，场景投影出来的<strong>空间就会减小</strong>，产生<strong>放大</strong>(Zoom In)了的感觉。我们会使用鼠标的<strong>滚轮来放大和缩小</strong>。与鼠标移动、键盘输入一样，我们需要一个<strong>鼠标滚轮的回调函数</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">scroll_callback</span><span class="params">(GLFWwindow* window, <span class="keyword">double</span> xoffset, <span class="keyword">double</span> yoffset)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(fov &gt;= <span class="number">1.0f</span> &amp;&amp; fov &lt;= <span class="number">45.0f</span>)</span><br><span class="line">        fov -= yoffset;</span><br><span class="line">    <span class="keyword">if</span>(fov &lt;= <span class="number">1.0f</span>)</span><br><span class="line">        fov = <span class="number">1.0f</span>;</span><br><span class="line">    <span class="keyword">if</span>(fov &gt;= <span class="number">45.0f</span>)</span><br><span class="line">        fov = <span class="number">45.0f</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当滚动鼠标滚轮的时候，<code>yoffset</code>值代表我们<strong>竖直滚动的大小</strong>。当<code>scroll_callback</code>函数被调用后，我们改变全局变量<code>fov</code>变量的内容。因为<code>45.0f</code>是<strong>默认的视野值</strong>，我们将会把缩放级别(Zoom Level)限制在<code>1.0f</code>到<code>45.0f</code>。</p><p>我们现在在<strong>每一帧都必须把透视投影矩阵上传到GPU</strong>，但现在使用<code>fov</code>变量作为它的视野：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">projection = glm::perspective(glm::radians(fov), <span class="number">800.0f</span> / <span class="number">600.0f</span>, <span class="number">0.1f</span>, <span class="number">100.0f</span>);</span><br></pre></td></tr></table></figure><p>最后不要忘记注册鼠标滚轮的回调函数：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">glfwSetScrollCallback(window, scroll_callback);</span><br></pre></td></tr></table></figure><p>现在，我们就实现了一个简单的摄像机系统了，它能够让我们在3D环境中自由移动。</p><p>注意，<strong>使用欧拉角的摄像机系统并不完美</strong>。根据你的视角限制或者是配置，你<strong>仍然可能引入万向节死锁问题</strong>。最好的摄像机系统是使用<strong>四元数</strong>(Quaternions)的，但我们将会把这个留到后面讨论。</p><h3 id="摄像机类"><a href="#摄像机类" class="headerlink" title="摄像机类"></a>摄像机类</h3><p>接下来的教程中，我们将会<strong>一直使用一个摄像机来浏览场景，从各个角度观察结果</strong>。然而，由于一个摄像机会占用每篇教程很大的篇幅，我们将会从细节抽象出来，创建我们自己的摄像机对象，它会完成大多数的工作，而且还会提供一些附加的功能。与着色器教程不同，我们不会带你一步一步创建摄像机类，我们只会提供你一份（有完整注释的）代码，如果你想知道它的内部构造的话可以自己去阅读。</p><p>和着色器对象一样，我们把摄像机类写在一个单独的头文件中。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><p>我们介绍的摄像机系统是一个<strong>FPS风格的摄像机</strong>，它能够满足大多数情况需要，而且与欧拉角兼容，但是<strong>在创建不同的摄像机系统，比如飞行模拟摄像机，时就要当心</strong>。每个摄像机系统都有自己的优点和不足，所以确保对它们进行了详细研究。比如，这个FPS摄像机<strong>不允许俯仰角大于90度</strong>，而且我们使用了一个<strong>固定的上向量</strong>(0, 1, 0)，这在需要<strong>考虑滚转角的时候就不能用了</strong>。</p><h2 id="词汇复习"><a href="#词汇复习" class="headerlink" title="词汇复习"></a>词汇复习</h2><ul><li><strong>OpenGL</strong>：一个<strong>定义</strong>了函数布局和输出的图形API的<strong>正式规范</strong>；</li><li><strong>GLAD</strong>：一个<strong>拓展加载库</strong>，用来为我们<strong>加载并设定所有OpenGL函数指针</strong>，从而让我们能够使用所有（现代）OpenGL函数；</li><li><strong>视口</strong>(Viewport)：我们需要渲染的窗口；</li><li><strong>图形管线</strong>(Graphics Pipeline)：一个顶点在呈现为像素之前经过的全部过程；</li><li><strong>着色器</strong>(Shader)：一个运行在显卡上的小型程序，很多阶段的图形管道都可以使用<strong>自定义的着色器来代替原有的功能</strong>，在OpenGL有些部分是我们必须提供的；</li><li><strong>标准化设备坐标</strong>(Normalized Device Coordinates, NDC)：顶点在通过在剪裁坐标系中剪裁与透视除法后最终呈现在的坐标系。所有位置在NDC下-1.0到1.0的顶点将不会被丢弃并且可见；</li><li><strong>VBO-顶点缓冲对象</strong>(Vertex Buffer Object)：一个调用<strong>显存并存储所有顶点数据</strong>供显卡使用的<strong>缓冲对象</strong>；</li><li><strong>VAO-顶点数组对象</strong>(Vertex Array Object)：存储<strong>缓冲区</strong>和<strong>顶点属性状态</strong>；</li><li><strong>EBO-索引缓冲对象</strong>(Element Buffer Object)：一个<strong>存储索引</strong>供索引化绘制使用的缓冲对象；</li><li><strong>Uniform</strong>：一个特殊类型的GLSL变量。它是全局的（在一个着色器程序中每一个着色器都能够访问uniform变量），并且<strong>只需要被设定一</strong>次；</li><li><strong>纹理</strong>(Texture)：一种包裹着物体的特殊类型图像，给物体精细的视觉效果；</li><li><strong>纹理缠绕</strong>(Texture Wrapping)：定义了一种当<strong>纹理顶点超出范围</strong>(0, 1)时指定OpenGL如何采样纹理的模式；</li><li><strong>纹理过滤</strong>(Texture Filtering)：定义了一种当有多种纹素选择时指定OpenGL如何<strong>采样纹理的模式</strong>。<strong>这通常在纹理被放大情况下发生</strong>；</li><li><strong>多级渐远纹理</strong>(Mipmaps)：被存储的材质的一些缩小版本，<strong>根据距观察者的距离会使用材质的合适大小</strong>；</li><li><strong>stb_image.h</strong>：图像加载库；</li><li><strong>纹理单元</strong>(Texture Units)：通过<strong>绑定纹理到不同纹理单元</strong>从而<strong>允许多个纹理</strong>在同一对象上渲染；</li><li><strong>向量</strong>(Vector)：一个定义了在空间中方向和/或位置的数学实体；</li><li><strong>矩阵</strong>(Matrix)：一个矩形阵列的数学表达式；</li><li><strong>GLM</strong>：一个为OpenGL打造的数学库；</li><li><strong>局部空间</strong>(Local Space)：一个物体的<strong>初始空间</strong>。所有的坐标都是相对于物体的原点的；</li><li><strong>世界空间</strong>(World Space)：所有的坐标都<strong>相对于全局原点</strong>；</li><li><strong>观察空间</strong>(View Space)：所有的坐标都是<strong>从摄像机的视角观察的</strong>；</li><li><strong>裁剪空间</strong>(Clip Space)：所有的坐标都是从摄像机视角观察的，但是<strong>该空间应用了投影</strong>。这个空间应该是一个<strong>顶点坐标最终的空间，作为顶点着色器的输出</strong>。OpenGL负责处理剩下的事情（<strong>裁剪/透视除法</strong>）；</li><li><strong>屏幕空间</strong>(Screen Space)：所有的坐标都由屏幕视角来观察。<strong>坐标的范围是从0到屏幕的宽/高</strong>；</li><li><strong>LookAt矩阵</strong>：一种特殊类型的观察矩阵，它<strong>创建了一个坐标系</strong>，其中<strong>所有坐标都根据从一个位置正在观察目标的用户旋转或者平移</strong>；</li><li><strong>欧拉角</strong>(Euler Angles)：被定义为<strong>偏航角</strong>(Yaw)，<strong>俯仰角</strong>(Pitch)，和<strong>滚转角</strong>(Roll)从而允许我们通过这<strong>三个值构造任何3D方向</strong>。</li></ul></div><div class="article-licensing box"><div class="licensing-title"><p>《LearnOpenGL》入门 笔记</p><p><a href="https://yumi-cn.github.io/2021/01/23/learnopengl-c1/">https://yumi-cn.github.io/2021/01/23/learnopengl-c1/</a></p></div><div class="licensing-meta level is-mobile"><div class="level-left"><div class="level-item is-narrow"><div><h6>作者</h6><p>Yumiko</p></div></div><div class="level-item is-narrow"><div><h6>发布于</h6><p>2021-01-23</p></div></div><div class="level-item is-narrow"><div><h6>更新于</h6><p>2021-01-23</p></div></div><div class="level-item is-narrow"><div><h6>许可协议</h6><p><a class="icon" rel="noopener" target="_blank" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a><a class="icon" rel="noopener" target="_blank" title="Attribution" href="https://creativecommons.org/licenses/by/4.0/"><i class="fab fa-creative-commons-by"></i></a><a class="icon" rel="noopener" target="_blank" title="Noncommercial" href="https://creativecommons.org/licenses/by-nc/4.0/"><i class="fab fa-creative-commons-nc"></i></a></p></div></div></div></div></div><div class="article-tags is-size-7 mb-4"><span class="mr-2">#</span><a class="link-muted mr-2" rel="tag" href="/tags/%E7%AC%94%E8%AE%B0/">笔记</a></div></article></div><div class="card"><div class="card-content"><h3 class="menu-label has-text-centered">喜欢这篇文章？打赏一下作者吧</h3><div class="buttons is-centered"><a class="button donate" data-type="alipay"><span class="icon is-small"><i class="fab fa-alipay"></i></span><span>支付宝</span><span class="qrcode"><img src="/images/zfb.jpg" alt="支付宝"></span></a><a class="button donate" data-type="wechat"><span class="icon is-small"><i class="fab fa-weixin"></i></span><span>微信</span><span class="qrcode"><img src="/images/wx.jpg" alt="微信"></span></a><a class="button donate" href="https://afdian.net/@yumiko-cn" target="_blank" rel="noopener" data-type="afdian"><span class="icon is-small"><i class="fas fa-charging-station"></i></span><span>爱发电</span></a></div></div></div><nav class="post-navigation mt-4 level is-mobile"><div class="level-end"><a class="article-nav-next level level-item link-muted" href="/2021/01/23/s2o-c6/"><span class="level-item">《剑指Offer》第6章笔记 各项能力</span><i class="level-item fas fa-chevron-right"></i></a></div></nav><div class="card"><div class="card-content"><h3 class="title is-5">评论</h3><div id="comment-container"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/gitalk@1.6.2/dist/gitalk.css"><script src="https://cdn.jsdelivr.net/npm/gitalk@1.6.2/dist/gitalk.min.js"></script><script>var gitalk=new Gitalk({id:"44dfb6b7d7dca2929050de665e09ccfd",repo:"yumi-cn.github.io",owner:"yumi-cn",clientID:"30141472b2ad1cb657d1",clientSecret:"80e26278051f7251bd46f5ec93317fec6675a7b4",admin:["yumi-cn"],createIssueManually:!1,distractionFreeMode:!1,perPage:20,pagerDirection:"last",enableHotKey:!0,language:"zh-CN"});gitalk.render("comment-container")</script></div></div></div><div class="column column-left is-4-tablet is-4-desktop is-3-widescreen order-1"><div class="card widget" data-type="profile"><div class="card-content"><nav class="level"><div class="level-item has-text-centered flex-shrink-1"><div><figure class="image is-128x128 mx-auto mb-2"><img class="avatar is-rounded" src="/images/avatar.jpg" alt="Yumiko"></figure><p class="title is-size-4 is-block" style="line-height:inherit">Yumiko</p><p class="is-size-6 is-block">游戏/引擎/技美</p><p class="is-size-6 is-flex justify-content-center"><i class="fas fa-map-marker-alt mr-1"></i><span>中国 杭州</span></p></div></div></nav><nav class="level is-mobile"><div class="level-item has-text-centered is-marginless"><div><p class="heading">文章</p><a href="/archives"><p class="title">22</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">专栏</p><a href="/categories"><p class="title">5</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">主题</p><a href="/tags"><p class="title">1</p></a></div></div></nav><div class="level"><a class="level-item button is-primary is-rounded" href="https://github.com/yumi-cn" target="_blank" rel="noopener">关注我</a></div><div class="level is-mobile"><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Github" href="https://github.com/yumi-cn"><i class="fab fa-github"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Bilibili" href="https://space.bilibili.com/11413916"><i class="fab fa-youtube"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Pixiv" href="https://www.pixiv.net/users/25096815"><i class="fas fa-palette"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="RSS" href="/atom.xml"><i class="fas fa-rss"></i></a></div></div></div><div class="card widget" data-type="categories"><div class="card-content"><div class="menu"><h3 class="menu-label">专栏</h3><ul class="menu-list"><li><a class="level is-mobile" href="/categories/3D%E6%B8%B8%E6%88%8F%E4%B8%8E%E5%9B%BE%E5%BD%A2%E5%AD%A6%E7%9A%84%E6%95%B0%E5%AD%A6/"><span class="level-start"><span class="level-item">3D游戏与图形学的数学</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/categories/LearnOpenGL/"><span class="level-start"><span class="level-item">LearnOpenGL</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/Real-Time-Rendering-4th/"><span class="level-start"><span class="level-item">Real Time Rendering 4th</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/%E5%89%91%E6%8C%87Offer/"><span class="level-start"><span class="level-item">剑指Offer</span></span><span class="level-end"><span class="level-item tag">15</span></span></a></li><li><a class="level is-mobile" href="/categories/%E8%AE%A1%E5%88%92-Flags/"><span class="level-start"><span class="level-item">计划-Flags</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li></ul></div></div></div><div class="card widget" data-type="recent-posts"><div class="card-content"><h3 class="menu-label">最新文章</h3><article class="media"><div class="media-content"><p class="date"><time datetime="2021-01-23T11:46:18.000Z">2021-01-23</time></p><p class="title"><a href="/2021/01/23/learnopengl-c1/">《LearnOpenGL》入门 笔记</a></p><p class="categories"><a href="/categories/LearnOpenGL/">LearnOpenGL</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time datetime="2021-01-23T08:04:48.000Z">2021-01-23</time></p><p class="title"><a href="/2021/01/23/s2o-c6/">《剑指Offer》第6章笔记 各项能力</a></p><p class="categories"><a href="/categories/%E5%89%91%E6%8C%87Offer/">剑指Offer</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time datetime="2021-01-11T14:04:48.000Z">2021-01-11</time></p><p class="title"><a href="/2021/01/11/s2o-c5-optimize/">《剑指Offer》第5章笔记 优化效率</a></p><p class="categories"><a href="/categories/%E5%89%91%E6%8C%87Offer/">剑指Offer</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time datetime="2021-01-03T07:45:17.000Z">2021-01-03</time></p><p class="title"><a href="/2021/01/03/s2o-c4-part3/">《剑指Offer》第4章笔记 解题的思路 P3</a></p><p class="categories"><a href="/categories/%E5%89%91%E6%8C%87Offer/">剑指Offer</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time datetime="2021-01-02T08:43:28.000Z">2021-01-02</time></p><p class="title"><a href="/2021/01/02/s2o-c4-part2/">《剑指Offer》第4章笔记 解题的思路 P2</a></p><p class="categories"><a href="/categories/%E5%89%91%E6%8C%87Offer/">剑指Offer</a></p></div></article></div></div><div class="column-right-shadow is-hidden-widescreen is-sticky"></div></div><div class="column column-right is-4-tablet is-4-desktop is-3-widescreen is-hidden-touch is-hidden-desktop-only order-3 is-sticky"><div class="card widget" id="toc" data-type="toc"><div class="card-content"><div class="menu"><h3 class="menu-label">目录</h3><ul class="menu-list"><li><a class="level is-mobile" href="#OpenGL"><span class="level-left"><span class="level-item">OpenGL</span></span></a></li><li><a class="level is-mobile" href="#创建窗口"><span class="level-left"><span class="level-item">创建窗口</span></span></a></li><li><a class="level is-mobile" href="#你好，窗口"><span class="level-left"><span class="level-item">你好，窗口</span></span></a></li><li><a class="level is-mobile" href="#你好，三角形"><span class="level-left"><span class="level-item">你好，三角形</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#顶点输入"><span class="level-left"><span class="level-item">顶点输入</span></span></a></li><li><a class="level is-mobile" href="#顶点着色器-Vertex-Shader"><span class="level-left"><span class="level-item">顶点着色器 Vertex Shader</span></span></a></li><li><a class="level is-mobile" href="#编译着色器"><span class="level-left"><span class="level-item">编译着色器</span></span></a></li><li><a class="level is-mobile" href="#片段着色器"><span class="level-left"><span class="level-item">片段着色器</span></span></a></li><li><a class="level is-mobile" href="#着色器程序"><span class="level-left"><span class="level-item">着色器程序</span></span></a></li><li><a class="level is-mobile" href="#链接顶点属性"><span class="level-left"><span class="level-item">链接顶点属性</span></span></a></li><li><a class="level is-mobile" href="#顶点数组对象"><span class="level-left"><span class="level-item">顶点数组对象</span></span></a></li><li><a class="level is-mobile" href="#一直期待的三角形"><span class="level-left"><span class="level-item">一直期待的三角形</span></span></a></li><li><a class="level is-mobile" href="#索引缓冲对象"><span class="level-left"><span class="level-item">索引缓冲对象</span></span></a></li><li><a class="level is-mobile" href="#练习题"><span class="level-left"><span class="level-item">练习题</span></span></a></li></ul></li><li><a class="level is-mobile" href="#着色器"><span class="level-left"><span class="level-item">着色器</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#GLSL"><span class="level-left"><span class="level-item">GLSL</span></span></a></li><li><a class="level is-mobile" href="#数据类型"><span class="level-left"><span class="level-item">数据类型</span></span></a></li><li><a class="level is-mobile" href="#输入与输出"><span class="level-left"><span class="level-item">输入与输出</span></span></a></li><li><a class="level is-mobile" href="#Uniform"><span class="level-left"><span class="level-item">Uniform</span></span></a></li><li><a class="level is-mobile" href="#更多属性"><span class="level-left"><span class="level-item">更多属性</span></span></a></li><li><a class="level is-mobile" href="#我们自己的着色器类"><span class="level-left"><span class="level-item">我们自己的着色器类</span></span></a></li><li><a class="level is-mobile" href="#从文件读取"><span class="level-left"><span class="level-item">从文件读取</span></span></a></li></ul></li><li><a class="level is-mobile" href="#纹理"><span class="level-left"><span class="level-item">纹理</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#纹理环绕方式"><span class="level-left"><span class="level-item">纹理环绕方式</span></span></a></li><li><a class="level is-mobile" href="#纹理过滤"><span class="level-left"><span class="level-item">纹理过滤</span></span></a></li><li><a class="level is-mobile" href="#多级渐远纹理"><span class="level-left"><span class="level-item">多级渐远纹理</span></span></a></li><li><a class="level is-mobile" href="#加载与创建纹理"><span class="level-left"><span class="level-item">加载与创建纹理</span></span></a></li><li><a class="level is-mobile" href="#生成纹理"><span class="level-left"><span class="level-item">生成纹理</span></span></a></li><li><a class="level is-mobile" href="#应用纹理"><span class="level-left"><span class="level-item">应用纹理</span></span></a></li><li><a class="level is-mobile" href="#纹理单元"><span class="level-left"><span class="level-item">纹理单元</span></span></a></li><li><a class="level is-mobile" href="#练习题-1"><span class="level-left"><span class="level-item">练习题</span></span></a></li></ul></li><li><a class="level is-mobile" href="#变换"><span class="level-left"><span class="level-item">变换</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#向量"><span class="level-left"><span class="level-item">向量</span></span></a></li><li><a class="level is-mobile" href="#矩阵"><span class="level-left"><span class="level-item">矩阵</span></span></a></li><li><a class="level is-mobile" href="#矩阵与向量相乘"><span class="level-left"><span class="level-item">矩阵与向量相乘</span></span></a></li><li><a class="level is-mobile" href="#单位矩阵"><span class="level-left"><span class="level-item">单位矩阵</span></span></a></li><li><a class="level is-mobile" href="#缩放"><span class="level-left"><span class="level-item">缩放</span></span></a></li><li><a class="level is-mobile" href="#位移"><span class="level-left"><span class="level-item">位移</span></span></a></li><li><a class="level is-mobile" href="#旋转"><span class="level-left"><span class="level-item">旋转</span></span></a></li><li><a class="level is-mobile" href="#矩阵的组合"><span class="level-left"><span class="level-item">矩阵的组合</span></span></a></li><li><a class="level is-mobile" href="#实践"><span class="level-left"><span class="level-item">实践</span></span></a></li></ul></li><li><a class="level is-mobile" href="#坐标系统"><span class="level-left"><span class="level-item">坐标系统</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#概述"><span class="level-left"><span class="level-item">概述</span></span></a></li><li><a class="level is-mobile" href="#局部空间"><span class="level-left"><span class="level-item">局部空间</span></span></a></li><li><a class="level is-mobile" href="#世界空间"><span class="level-left"><span class="level-item">世界空间</span></span></a></li><li><a class="level is-mobile" href="#观察空间"><span class="level-left"><span class="level-item">观察空间</span></span></a></li><li><a class="level is-mobile" href="#裁剪空间"><span class="level-left"><span class="level-item">裁剪空间</span></span></a></li><li><a class="level is-mobile" href="#正射投影"><span class="level-left"><span class="level-item">正射投影</span></span></a></li><li><a class="level is-mobile" href="#透视投影"><span class="level-left"><span class="level-item">透视投影</span></span></a></li><li><a class="level is-mobile" href="#把它们都组合到一起"><span class="level-left"><span class="level-item">把它们都组合到一起</span></span></a></li><li><a class="level is-mobile" href="#进入3D"><span class="level-left"><span class="level-item">进入3D</span></span></a></li><li><a class="level is-mobile" href="#更多的3D"><span class="level-left"><span class="level-item">更多的3D</span></span></a></li><li><a class="level is-mobile" href="#Z缓冲"><span class="level-left"><span class="level-item">Z缓冲</span></span></a></li><li><a class="level is-mobile" href="#更多的立方体！"><span class="level-left"><span class="level-item">更多的立方体！</span></span></a></li><li><a class="level is-mobile" href="#练习题-2"><span class="level-left"><span class="level-item">练习题</span></span></a></li></ul></li><li><a class="level is-mobile" href="#摄像机"><span class="level-left"><span class="level-item">摄像机</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#摄像机-观察空间"><span class="level-left"><span class="level-item">摄像机/观察空间</span></span></a></li><li><a class="level is-mobile" href="#Look-At"><span class="level-left"><span class="level-item">Look At</span></span></a></li><li><a class="level is-mobile" href="#自由移动"><span class="level-left"><span class="level-item">自由移动</span></span></a></li><li><a class="level is-mobile" href="#移动速度"><span class="level-left"><span class="level-item">移动速度</span></span></a></li><li><a class="level is-mobile" href="#视角移动"><span class="level-left"><span class="level-item">视角移动</span></span></a></li><li><a class="level is-mobile" href="#摄像机类"><span class="level-left"><span class="level-item">摄像机类</span></span></a></li></ul></li><li><a class="level is-mobile" href="#词汇复习"><span class="level-left"><span class="level-item">词汇复习</span></span></a></li></ul></div></div><script src="/js/toc.js" defer></script></div></div></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/"><img src="/images/logo.jpg" alt="画码余生" height="28"></a><p class="is-size-7"><span>&copy; 2021 Yumiko</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a></p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Attribution 4.0 International" href="https://creativecommons.org/licenses/by/4.0/"><i class="fab fa-creative-commons-by"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="GitHub" href="https://github.com/yumi-cn"><i class="fab fa-github"></i></a></p></div></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" async></script><script>moment.locale("zh-CN")</script><script>var IcarusThemeSettings={article:{highlight:{clipboard:!0,fold:"unfolded"}}}</script><script src="/js/column.js"></script><script src="/js/animation.js"></script><a id="back-to-top" title="回到顶端" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back_to_top.js" defer></script><script src="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.js" defer></script><script>window.addEventListener("load", () => {
      window.cookieconsent.initialise({
        type: "info",
        theme: "edgeless",
        static: false,
        position: "bottom-left",
        content: {
          message: "此网站使用Cookie来改善您的体验。",
          dismiss: "知道了！",
          allow: "允许使用Cookie",
          deny: "拒绝",
          link: "了解更多",
          policy: "Cookie政策",
          href: "https://www.cookiesandyou.com/",
        },
        palette: {
          popup: {
            background: "#edeff5",
            text: "#838391"
          },
          button: {
            background: "#4b81e8"
          },
        },
      });
    });</script><script src="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/js/lightgallery.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/katex.min.css"><script src="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/katex.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/contrib/auto-render.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/contrib/mhchem.js" defer></script><script>window.addEventListener("load",function(){document.querySelectorAll('[role="article"] > .content').forEach(function(e){renderMathInElement(e)})})</script><script src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="想要查找什么..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/js/insight.js" defer></script><script>document.addEventListener("DOMContentLoaded",function(){loadInsight({contentUrl:"/content.json"},{hint:"想要查找什么...",untitled:"(无标题)",posts:"文章",pages:"页面",categories:"专栏",tags:"主题"})})</script></body></html>