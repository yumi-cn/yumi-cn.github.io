<!doctype html><html lang="zh"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1"><meta><title>《剑指Offer》第5章笔记 优化效率 - 画码余生</title><link rel="manifest" href="/manifest.json"><meta name="application-name" content="画码余生"><meta name="msapplication-TileImage" content="/images/favicon.ico"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="画码余生"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta description="时间与空间，是算法永恒的话题。"><meta property="og:type" content="blog"><meta property="og:title" content="《剑指Offer》第5章笔记 优化效率"><meta property="og:url" content="https://yumi-cn.github.io/2021/01/11/s2o-c5-optimize/"><meta property="og:site_name" content="画码余生"><meta property="og:description" content="时间与空间，是算法永恒的话题。"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://yumi-cn.github.io/images/s2o-c5-f1.jpg"><meta property="og:image" content="https://yumi-cn.github.io/images/s2o-c5-f2.jpg"><meta property="og:image" content="https://yumi-cn.github.io/images/s2o-c5-f3.jpg"><meta property="og:image" content="https://yumi-cn.github.io/images/s2o-c5-f4.jpg"><meta property="og:image" content="https://yumi-cn.github.io/images/s2o-c5-f5.jpg"><meta property="og:image" content="https://yumi-cn.github.io/images/s2o-c5-f6.jpg"><meta property="og:image" content="https://yumi-cn.github.io/images/s2o-c5-f7.jpg"><meta property="article:published_time" content="2021-01-11T14:04:48.000Z"><meta property="article:modified_time" content="2021-01-14T10:23:20.987Z"><meta property="article:author" content="Yumiko"><meta property="article:tag" content="笔记"><meta property="twitter:card" content="summary"><meta property="twitter:image" content="/images/s2o-c5-f1.jpg"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"https://yumi-cn.github.io/2021/01/11/s2o-c5-optimize/"},"headline":"画码余生","image":["https://yumi-cn.github.io/images/s2o-c5-f1.jpg","https://yumi-cn.github.io/images/s2o-c5-f2.jpg","https://yumi-cn.github.io/images/s2o-c5-f3.jpg","https://yumi-cn.github.io/images/s2o-c5-f4.jpg","https://yumi-cn.github.io/images/s2o-c5-f5.jpg","https://yumi-cn.github.io/images/s2o-c5-f6.jpg","https://yumi-cn.github.io/images/s2o-c5-f7.jpg"],"datePublished":"2021-01-11T14:04:48.000Z","dateModified":"2021-01-14T10:23:20.987Z","author":{"@type":"Person","name":"Yumiko"},"description":"时间与空间，是算法永恒的话题。"}</script><link rel="canonical" href="https://yumi-cn.github.io/2021/01/11/s2o-c5-optimize/"><link rel="alternate" href="/atom.xml" title="画码余生" type="application/atom+xml"><link rel="icon" href="/images/favicon.ico"><link rel="stylesheet" href="https://cdn.bootcdn.net/ajax/libs/font-awesome/5.15.1/css/all.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@9.12.0/styles/atom-one-light.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link rel="stylesheet" href="/css/default.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/css/justifiedGallery.min.css"><script src="https://cdn.jsdelivr.net/npm/pace-js@1.0.2/pace.min.js"></script><meta name="generator" content="Hexo 5.2.0"></head><body class="is-3-column"><nav class="navbar navbar-main"><div class="container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/"><img src="/images/logo.jpg" alt="画码余生" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">主页</a><a class="navbar-item" href="/archives">文章</a><a class="navbar-item" href="/categories">专栏</a><a class="navbar-item" href="/tags">主题</a><a class="navbar-item" href="/about">关于我</a></div><div class="navbar-end"><a class="navbar-item" target="_blank" rel="noopener" title="Github" href="https://github.com/yumi-cn"><i class="fab fa-github"></i></a><a class="navbar-item is-hidden-tablet catalogue" title="目录" href="javascript:;"><i class="fas fa-list-ul"></i></a><a class="navbar-item search" title="搜索" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-6-widescreen"><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time datetime="2021-01-11T14:04:48.000Z" title="2021-01-11T14:04:48.000Z">2021-01-11</time>发表</span><span class="level-item"><time datetime="2021-01-14T10:23:20.987Z" title="2021-01-14T10:23:20.987Z">2021-01-14</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/%E5%89%91%E6%8C%87Offer/">剑指Offer</a></span><span class="level-item">1 小时读完 (大约12171个字)</span></div></div><h1 class="title is-3 is-size-4-mobile">《剑指Offer》第5章笔记 优化效率</h1><div class="content"><blockquote><p>时间与空间，是算法永恒的话题。</p></blockquote><a id="more"></a><h2 id="1-面试官谈效率"><a href="#1-面试官谈效率" class="headerlink" title="1 面试官谈效率"></a>1 面试官谈效率</h2><p>大佬们说的名言名句。</p><p>咕咕待更。</p><h2 id="2-时间效率"><a href="#2-时间效率" class="headerlink" title="2 时间效率"></a>2 时间效率</h2><p>面试官除了考查应聘者的编程能力，还关注应聘者有没有不断优化效率、追求完美的态度和能力。</p><p>首先，我们的编程习惯对代码的时间效率有很大影响。比如C/C++程序员要养成采用<strong>引用（或指针）传递复杂类型参数</strong>的习惯。如果采用值传递的方式，则从形参到实参会产生一次复制操作，这样的复制大部分时候是多余的，应该尽量避免。再比如，C#中做多次字符串的拼接操作，尽量不要用多次<code>String</code>的<code>+</code>运算符来拼接字符串，因为这样会产生很多<code>String</code>的临时实例，造成时间和空间的浪费，更好的办法是用<code>StringBuilder</code>的<code>Append</code>方法来完成字符串的拼接。如果我们平时不太注意这些影响代码效率的细节，没有养成好的编码习惯，写出的代码可能会让面试官大失所望。</p><p>其次，即使同一个算法用<strong>循环和递归两种思路实现</strong>的<strong>时间效率可能会大不一样</strong>。递归的本质是把一个大的复杂问题分解成两个或者多个小的简单问题。如果小问题有相互重叠的部分，那么直接用递归实现虽然代码显得很简洁，但时间效率可能会非常差，对于这种题目，可以用递归地思路来分析，写代码的时候可以基于循环实现，并且用数组来保存中间结果，绝大部分动态规划算法的分析和代码实现都是分这两个步骤完成的。</p><p>再次，代码的<strong>时间效率</strong>还能体现应聘者<strong>对数据结构和算法功底的掌握程度</strong>。同样是查找，如果是顺序查找则需要<code>O(n)</code>的时间；如果输入的是排序的数组则只需要<code>O(logn)</code>的时间；如果事先已经构造好了哈希表，那么查找在<code>O(1)</code>时间内就能完成。</p><p>最后，应聘者在面试的时候要展示<strong>敏捷的思维能力</strong>和<strong>追求完美的激情</strong>，这些对最终的面试结果也有很重要的影响。</p><h2 id="面试题-39-48"><a href="#面试题-39-48" class="headerlink" title="面试题 39-48"></a>面试题 39-48</h2><blockquote><p>面试题39：数组中出现次数超过一半的数字。</p></blockquote><p>数组中有一个数字出现的次数超过数组长度的一半，请找出这个数字。例如，输入一个长度为<code>9</code>的数组<code>&#123;1,2,3,2,2,2,5,4,2&#125;</code>。由于数字<code>2</code>在数组中出现了<code>5</code>次，超过数组长度的一半，因此输出<code>2</code>。</p><p><strong>解法一</strong>：基于Partition函数的时间复杂度为<code>O(n)</code>的算法。</p><p>数组中有一个数字出现的次数超过了数组长度的一半，如果这个数组排序，那么<strong>排序之后位于数组中间</strong>的数字，一定就是那个<strong>出现次数超过数组长度一半的数字</strong>。这个数字就是统计学上的中位数，即长度为<code>n</code>的数组中第<code>n/2</code>大的数字。我们有成熟的时间复杂度为<code>O(n)</code>的算法得到数组中任意第<code>k</code>大的数字。</p><p>这种算法受快速排序算法的启发。在随机快速排序算法中，先在数组中随机选择一个数字，然后调整数组中数字的顺序，使得比选中的数字小的数字都排在它的左边，比选中的数字大的数字都排在它的右边。如果这个<strong>选中的数字</strong>下标刚好是<code>n/2</code>，则这个数字就是数组的中位数；如果下标大于<code>n/2</code>，那么中位数应该在它的左边，接着在它的左边找；如果下标小于<code>n/2</code>，中位数在它的右边，接着在它的右边找。这是一个典型的递归过程。</p><p>完整实现代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">partition</span><span class="params">(<span class="keyword">int</span>* numbers, <span class="keyword">int</span> len, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(start == end) &#123;</span><br><span class="line">        <span class="keyword">return</span> start;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> anchor = numbers[end];</span><br><span class="line">    <span class="keyword">int</span> left = start;</span><br><span class="line">    <span class="keyword">int</span> right = end - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(left &lt; right) &#123;</span><br><span class="line">        <span class="keyword">while</span>(numbers[left] &lt; anchor &amp;&amp; left &lt; right) &#123;</span><br><span class="line">            left++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(numbers[right] &gt;= anchor &amp;&amp; left &lt; right) &#123;</span><br><span class="line">            right--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(left != right) &#123;</span><br><span class="line">            <span class="keyword">int</span> temp = numbers[left];</span><br><span class="line">            numbers[left] = numbers[right];</span><br><span class="line">            numbers[right] = temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(left != end - <span class="number">1</span> || numbers[left] &gt; anchor) &#123;</span><br><span class="line">        <span class="keyword">int</span> temp = numbers[left];</span><br><span class="line">        numbers[left] = numbers[end];</span><br><span class="line">        numbers[end] = temp;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        left = end;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> left;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> g_input_invalid = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check_array</span><span class="params">(<span class="keyword">int</span>* numbers, <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">    g_input_invalid = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span>(numbers == <span class="literal">nullptr</span> || len &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        g_input_invalid = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> g_input_invalid;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check_more_than_half</span><span class="params">(<span class="keyword">int</span>* numbers, <span class="keyword">int</span> len, <span class="keyword">int</span> number)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> times = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(numbers[i] == number) &#123;</span><br><span class="line">            times++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">bool</span> is_more_than_half = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">if</span>(times * <span class="number">2</span> &lt;= len) &#123;</span><br><span class="line">        g_input_invalid = <span class="literal">true</span>;</span><br><span class="line">        is_more_than_half = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> is_more_than_half;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">more_than_half_num</span><span class="params">(<span class="keyword">int</span>* numbers, <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(check_array(numbers, len)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> middle = len &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> start = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> end = len - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> index = partition(numbers, len, start, end);</span><br><span class="line">    <span class="keyword">while</span>(index != middle) &#123;</span><br><span class="line">        <span class="keyword">if</span>(index &gt; middle) &#123;</span><br><span class="line">            end = index - <span class="number">1</span>;</span><br><span class="line">            index = partition(numbers, len, start, end);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            start = index + <span class="number">1</span>;</span><br><span class="line">            index = partition(numbers, len, start, end);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> result = numbers[middle];</span><br><span class="line">    <span class="keyword">if</span>(!check_more_than_half(numbers, len, result)) &#123;</span><br><span class="line">        result = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> numbers[] = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">2</span> &#125;;</span><br><span class="line">    <span class="keyword">int</span> result = more_than_half_num(numbers, <span class="number">9</span>);</span><br><span class="line">    <span class="keyword">if</span>(g_input_invalid) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Invalid input.\n&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Result: %d\n&quot;</span>, result);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在面试的时候，除了完成基本功能，还要考虑一些无效的输入。如果函数的输入参数是一个指针（数组在参数传递的时候退化为指针），就要考虑这个指针可能为<code>nullptr</code>。代码中的<code>check_array</code>用来判断输入的数组是不是无效的。<code>check_more_than_half</code>用来检验输入的数组中，是不是这个数字出现次数大于长度一半，用全局变量<code>g_input_invalid</code>来表示输入无效的情况。</p><p><strong>解法二</strong>：根据数组特点找出时间复杂度为<code>O(n)</code>的算法。</p><p>从另一个角度来解决这个问题。数组中有一个数字出现的次数超过数组长度的一半，也就是说<strong>它出现的次数比其他所有数字出现的和还要多</strong>。因此，考虑在遍历数组的时候保存<strong>两个值</strong>，一个是<strong>数组中的一个数字</strong>，另一个是<strong>次数</strong>。当遍历到下一个数字时，如果下一个数字和之前保存的数字相同，则<strong>次数加1</strong>；如果下一个数字和之前保存的不同，则<strong>次数减1</strong>；如果<strong>次数为0</strong>，则<strong>保存下一个数字</strong>，并把<strong>次数设1</strong>。由于要找的数字出现的次数比其他所有出现的次数之和还要多，那么要找的数字肯定是<strong>最后一次把次数设为1对应的数字</strong>。</p><p>完整实现代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> g_input_invalid = <span class="literal">false</span>;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check_array</span><span class="params">(<span class="keyword">int</span>* numbers, <span class="keyword">int</span> len)</span> </span>&#123; ... &#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check_more_than_half</span><span class="params">(<span class="keyword">int</span>* numbers, <span class="keyword">int</span> len, <span class="keyword">int</span> number)</span> </span>&#123; ... &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">more_than_half_num</span><span class="params">(<span class="keyword">int</span>* numbers, <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(check_array(numbers, len)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> result = numbers[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">int</span> times = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(times == <span class="number">0</span>) &#123;</span><br><span class="line">            result = numbers[i];</span><br><span class="line">            times = <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(numbers[i] == result) &#123;</span><br><span class="line">            times++;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            times--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(!check_more_than_half(numbers, len, result)) &#123;</span><br><span class="line">        result = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> numbers[] = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">2</span> &#125;;</span><br><span class="line">    <span class="keyword">int</span> result = more_than_half_num(numbers, <span class="number">9</span>);</span><br><span class="line">    <span class="keyword">if</span>(g_input_invalid) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Invalid input.\n&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Result: %d\n&quot;</span>, result);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>两种解法算法的时间复杂度都是<code>O(n)</code>，在第一种解法中，需要交换数组中数字的顺序，这就会修改输入的数组，而在面试的时候需要尝试和面试官讨论，明确需求，如果说不能修改输入的数组，就只能采用第二种解法了。</p><hr><blockquote><p>面试题40：最小的K个数。</p></blockquote><p>输入<code>n</code>个整数，找出其中最小的<code>k</code>个数，例如，输入<code>4,5,1,6,2,7,3,8</code>这<code>8</code>个数字，则最小的<code>4</code>个数字是<code>1,2,3,4</code>。</p><p>最简单直观的解法就是进行<code>k</code>次数组遍历，每一次找出一个相对最小值，时间复杂度<code>O(nk)</code>，代码比较简单就不再写了，主要讲两种优化的思路。</p><p><strong>解法一</strong>：时间复杂度为<code>O(n)</code>的算法，只有当我们<strong>可以修改输入的数组时</strong>可用。</p><p>同样可以基于<code>partition</code>函数来解决这个问题。如果基于数组的第<code>k</code>个数字来调整，使得比第<code>k</code>个数字小的所有数字都位于数组的左边，比第<code>k</code>个数大的所有数字都位于数组的右边。这样，位于数组中左边的<code>k</code>个数字就是最小的<code>k</code>个数字（<code>k</code>个数字不一定是排序的）。</p><p>完整实现代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">partition</span><span class="params">(<span class="keyword">int</span>* numbers, <span class="keyword">int</span> len, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123; ... &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">find_k_min</span><span class="params">(<span class="keyword">int</span>* input, <span class="keyword">int</span> n, <span class="keyword">int</span>* output, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(input == <span class="literal">nullptr</span> || output == <span class="literal">nullptr</span> || k &gt; n || n &lt;= <span class="number">0</span> || k &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> start = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> end = n - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> index = partition(input, n, start, end);</span><br><span class="line">    <span class="keyword">while</span>(index != k - <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span>(index &gt; k - <span class="number">1</span>) &#123;</span><br><span class="line">            end = index - <span class="number">1</span>;</span><br><span class="line">            index = partition(input, n, start, end);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            start = index + <span class="number">1</span>;</span><br><span class="line">            index = partition(input, n, start, end);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; i++) &#123;</span><br><span class="line">        output[i] = input[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> input[] = &#123; <span class="number">4</span>,<span class="number">5</span>,<span class="number">1</span>,<span class="number">6</span>,<span class="number">2</span>,<span class="number">7</span>,<span class="number">3</span>,<span class="number">8</span> &#125;;</span><br><span class="line">    <span class="keyword">int</span> n = <span class="number">8</span>;</span><br><span class="line">    <span class="keyword">int</span> k = <span class="number">4</span>;</span><br><span class="line">    <span class="keyword">int</span>* output = <span class="keyword">new</span> <span class="keyword">int</span>[k];</span><br><span class="line">    find_k_min(input, n, output, k);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, output[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果面试官要求不能修改输入的数组，那么就只能另辟蹊径。</p><p><strong>解法二</strong>：时间复杂度为<code>O(nlogk)</code>的算法，特别适合处理海量数据。</p><p>先创建一个大小为<code>k</code>的数据容器来存储最小的<code>k</code>个数字，接下来每次从输入的<code>n</code>个整数中读入一个数。如果容器中少于<code>k</code>个，则直接把这次读入的整数放入容器中；如果容器已经有<code>k</code>个了，此时<strong>比较读入的数字和容器中最大的数字</strong>，如果读入的更小，就插入容器，删除掉最大的。</p><p>如果用一棵二叉树（堆）来实现容器，那么就能在<code>O(logk)</code>时间内完成一个序列的最大值构建（<code>O(1)</code>的时间得到最大值，<code>O(logk)</code>时间完成删除和插入操作），对于<code>n</code>个输入数字，总的时间效率是<code>O(nlogk)</code>。</p><p>从头实现一个最大堆需要一定的代码，面试的几十分钟内很难完成，我们可以借助STL提供的一些数据结构，例如<code>set</code>或者<code>multiset</code>（区别是后者可以重复），如果面试官不反对使用STL，就可以直接拿来用，根据这道题的需求，使用<code>multiset</code>更加合适一点。</p><p>完整实现代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// std::greater 代表递减排序 最大的在begin</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">std</span>::<span class="built_in">multiset</span>&lt;<span class="keyword">int</span>, <span class="built_in">std</span>::greater&lt;<span class="keyword">int</span>&gt;&gt; int_set;</span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">std</span>::<span class="built_in">multiset</span>&lt;<span class="keyword">int</span>, <span class="built_in">std</span>::greater&lt;<span class="keyword">int</span>&gt;&gt;::iterator int_set_iter;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">find_k_min</span><span class="params">(<span class="keyword">int</span>* input, <span class="keyword">int</span> n, <span class="keyword">int</span>* output, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(input == <span class="literal">nullptr</span> || output == <span class="literal">nullptr</span> || k &gt; n || n &lt;= <span class="number">0</span> || k &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    int_set <span class="built_in">set</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">set</span>.size() &lt; k) &#123;</span><br><span class="line">            <span class="built_in">set</span>.insert(input[i]);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            int_set_iter iter = <span class="built_in">set</span>.begin();</span><br><span class="line">            <span class="keyword">if</span>(*iter &gt; input[i]) &#123;</span><br><span class="line">                <span class="built_in">set</span>.erase(iter);</span><br><span class="line">                <span class="built_in">set</span>.insert(input[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    int_set_iter iter = <span class="built_in">set</span>.begin();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; i++) &#123;</span><br><span class="line">        output[i] = *iter;</span><br><span class="line">        iter++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> input[] = &#123; <span class="number">4</span>,<span class="number">5</span>,<span class="number">1</span>,<span class="number">6</span>,<span class="number">2</span>,<span class="number">7</span>,<span class="number">3</span>,<span class="number">8</span> &#125;;</span><br><span class="line">    <span class="keyword">int</span> n = <span class="number">8</span>;</span><br><span class="line">    <span class="keyword">int</span> k = <span class="number">4</span>;</span><br><span class="line">    <span class="keyword">int</span>* output = <span class="keyword">new</span> <span class="keyword">int</span>[k];</span><br><span class="line">    find_k_min(input, n, output, k);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, output[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>第一种基于函数<code>partition</code>的第一种解法平均时间复杂度是<code>O(n)</code>，比第二种解法要快，但同时也有限制，比如会修改输入的数组（开<code>O(n)</code>空间虽然可以解决，但是有额外的空间代价）。</p><p>第二种基于最大堆容器的解法虽然慢，但一是没有修改输入的数据，二是算法适合海量数据的处理，因为第二种方法不用一次性将全部数据都读入到内存中，而第一种方法只有全部读入才能计算。</p><hr><blockquote><p>面试题41：数据流中的中位数。</p></blockquote><p>如何得到一个数据流的中位数？如果从数据流读出的<strong>数据是奇数个</strong>，那么中位数就是所有值排序之后位于中间的数值；如果从数据流中读取<strong>偶数个数值</strong>，那么中位数是排序之后两个数的平均值。</p><p>数据是从一个数据流中读出来的，<strong>因而数据的数目随着时间的变化而增加</strong>，如果用一个数据容器来保存从流中读出来的数据，<strong>则当有新的数据从流中读出来，这些数据就插入数据容器</strong>（所以中位数是一个不断在变化的值，和容器的状态相关）。</p><p>那么可以考虑用几种不同的数据结构来作为容器：</p><ul><li><strong>数组</strong>：没有排序，可以使用<code>partition</code>找出数组的中位数，输入复杂度<code>O(1)</code>，找数中位数<code>O(n)</code>；</li><li><strong>排序数组</strong>：<code>O(logn)</code>时间搜索，但需要<code>O(n)</code>时间来插入，得到中位数的时间是<code>O(1)</code>；</li><li><strong>排序链表</strong>：<code>O(n)</code>时间插入，定义两个指针来指向链表中间的节点（不断调整的开销<code>O(1)</code>），所以找出中位数只需要<code>O(1)</code>；</li><li><strong>AVL树</strong>：<code>O(logn)</code>时间插入一个新节点，用<code>O(1)</code>时间得到所有节点的中位数，虽然AVL效率很高，但是大部分编程语言的函数库都没有实现这个数据结构，自己在短时间内实现也很麻烦；</li><li><strong>最大堆+最小堆</strong>：以把中位数定义为将数组分为两个部分，前一部分小于中位数，后一部分大于中位数，所以其实我们不需要前后部分一定要完整地排序，我们只需要得到前一部分的最大值和后一部分的最小值，所以可以<strong>用最大堆来组织前一部分，用最小堆组织后一部分</strong>，让两部分的大小接近相等，插入时间<code>O(logn)</code>，得到中位数的时间<code>O(1)</code>。</li></ul><div align="center"><p><img src="/images/s2o-c5-f1.jpg"><br><img src="/images/s2o-c5-f2.jpg"></p></div><p>基于STL中的函数<code>push_heap</code>、<code>pop_heap</code>及<code>vector</code>实现堆。比较仿函数<code>less</code>和<code>greater</code>分别用来实现最大堆和最小堆。</p><p>完整实现代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt; // push_heap/pop_heap/less/greater</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;exception&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="class"><span class="keyword">class</span> <span class="title">DynamicArray</span> &#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(T num)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(((min.size() + max.size()) &amp; <span class="number">1</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// 已经有偶数个，但有可能是0</span></span><br><span class="line">                <span class="keyword">if</span>(max.size() &gt; <span class="number">0</span> &amp;&amp; num &lt; max[<span class="number">0</span>]) &#123;</span><br><span class="line">                    <span class="comment">// 如果这个数比最大堆的堆顶元素小，要先放进最大堆</span></span><br><span class="line">                    max.push_back(num);</span><br><span class="line">                    <span class="comment">// 构建堆</span></span><br><span class="line">                    <span class="built_in">std</span>::push_heap(max.begin(), max.end(), <span class="built_in">std</span>::less&lt;T&gt;());</span><br><span class="line">                    <span class="comment">// 拿出堆顶元素</span></span><br><span class="line">                    num = max[<span class="number">0</span>];</span><br><span class="line">                    <span class="comment">// pop_head，将堆顶元素放在后面</span></span><br><span class="line">                    <span class="built_in">std</span>::pop_heap(max.begin(), max.end(), <span class="built_in">std</span>::less&lt;T&gt;());</span><br><span class="line">                    <span class="comment">// 元素出堆</span></span><br><span class="line">                    max.pop_back();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 元素进最小堆</span></span><br><span class="line">                min.push_back(num);</span><br><span class="line">                <span class="built_in">std</span>::push_heap(min.begin(), min.end(), <span class="built_in">std</span>::greater&lt;T&gt;());</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 已经有奇数个</span></span><br><span class="line">                <span class="keyword">if</span>(min.size() &gt; <span class="number">0</span> &amp;&amp; min[<span class="number">0</span>] &lt; num) &#123;</span><br><span class="line">                    <span class="comment">// 如果这个数比最小堆的堆顶元素大，要先放进最小堆</span></span><br><span class="line">                    min.push_back(num);</span><br><span class="line">                    <span class="comment">// 构建堆</span></span><br><span class="line">                    <span class="built_in">std</span>::push_heap(min.begin(), min.end(), <span class="built_in">std</span>::greater&lt;T&gt;());</span><br><span class="line">                    <span class="comment">// 拿出堆顶元素</span></span><br><span class="line">                    num = min[<span class="number">0</span>];</span><br><span class="line">                    <span class="comment">// 堆顶元素放在后面</span></span><br><span class="line">                    <span class="built_in">std</span>::pop_heap(min.begin(), min.end(), <span class="built_in">std</span>::greater&lt;T&gt;());</span><br><span class="line">                    <span class="comment">// 元素出堆</span></span><br><span class="line">                    min.pop_back();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 元素进最大堆</span></span><br><span class="line">                max.push_back(num);</span><br><span class="line">                <span class="built_in">std</span>::push_heap(max.begin(), max.end(), <span class="built_in">std</span>::less&lt;T&gt;());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function">T <span class="title">get_median</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">int</span> size = min.size() + max.size();</span><br><span class="line">            <span class="keyword">if</span>(size == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// throw error</span></span><br><span class="line">                <span class="function"><span class="built_in">std</span>::logic_error <span class="title">ex</span><span class="params">(<span class="string">&quot;Empty!&quot;</span>)</span></span>;</span><br><span class="line">                <span class="keyword">throw</span> <span class="built_in">std</span>::exception(ex);</span><br><span class="line">            &#125;</span><br><span class="line">            T median = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span>((size &amp; <span class="number">1</span>) == <span class="number">1</span>) &#123;</span><br><span class="line">                median = min[<span class="number">0</span>]; <span class="comment">// 偶数的时候进最小堆，所以奇数时最小堆会多一个</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                median = (min[<span class="number">0</span>] + max[<span class="number">0</span>]) / <span class="number">2</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> median;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;T&gt; min;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;T&gt; max;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">stream_median</span><span class="params">(<span class="keyword">int</span>* stream, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(stream == <span class="literal">nullptr</span> || n &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    DynamicArray&lt;<span class="keyword">int</span>&gt; darray; <span class="comment">// 注意模板类的声明使用方法</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        darray.insert(stream[i]);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Read index=%d, median=%d\n&quot;</span>, i, darray.get_median());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> stream[] = &#123; <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>&#125;;</span><br><span class="line">    stream_median(stream, <span class="number">20</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中使用到了代码里不常用的模板类，如果面试题有说明具体的数据类型，也可以直接用那个数据类型，而不是使用模板类。</p><p>其中使用到的几个和堆相关的函数进行一下说明，以后可能会用到：</p><ul><li><code>make_heap(begin, end, comp)</code>：虽然在这里没有用到，但还是说明一下，将一个数组(<code>vector</code>)的指定部分(<code>[begin,end)</code>)进行堆排序，堆顶元素放在第一个位置，默认使用的<code>comp</code>是<code>less&lt;T&gt;</code>，即最大元素放在第一个位置（最大堆），<code>greater&lt;T&gt;</code>为最小元素放在第一个位置（最小堆）；</li><li><code>push_heap(begin, end, comp)</code>：一般在调用前，把一个新元素放在数组的尾部(<code>vec.push_back(elm)</code>)，然后再调用函数对插入尾部的元素做堆排序；</li><li><code>pop_heap(begin, end, comp)</code>：将堆顶元素移动到数组尾部，同时将剩下的元素重新构造成堆结构；</li><li><code>sort_heap(begin, end, comp)</code>：将一个堆做排序，最终成为一个有序的序列，前提条件是输入的数组范围本身是一个对应<code>comp</code>的堆，如果<code>comp</code>是<code>less&lt;T&gt;</code>，最大堆最终序列是一个递增序列（大的在后面），如果是<code>greater&lt;T&gt;</code>，最小堆最终序列是一个递减序列（小的在后面）；</li></ul><hr><blockquote><p>面试题42：连续子数组的最大和。</p></blockquote><p>输入一个整型数组，数组里有正数也有负数。数组中的一个或连续多个整数组成一个子数组。求所有子数组的和的最大值（就是和最大的那个子数组的和值是多少），要求时间复杂度<code>O(n)</code>；例如，输入的数组为<code>&#123;1,-2,3,10,-4,7,2,-5&#125;</code>，和最大的子数组为<code>&#123;3,10,-4,7,2&#125;</code>，因此输出为该子数组的和<code>18</code>。</p><p>最简单直观的暴力遍历法就不说了（时间<code>O(n^2)</code>），只说优化的解决方案。</p><p><strong>解法一</strong>：举例分析数组的规律。</p><p>从头开始往后加可以分析其中的规律，例如从某一步从<code>i</code>开始向后累加和，到<code>j</code>之前如果和已经为负数了，那么对于<code>j</code>而言，如果再加上前面这前<code>j-i</code>个位置的数字肯定不会比<code>j</code>自身要大，所以要计算从<code>j</code>开始的可能最大子数组和，就不用再加上前<code>j-i</code>位置的数字，重新从<code>j</code>开始求子数组和；同时求和的过程中，不断的更新记录的最大和。</p><div align="center"><p><img src="/images/s2o-c5-f3.jpg" alt="计算数组{1,-2,3,10,-4,7,2,-5}中最大子数组和的过程"></p></div><p>完整实现代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;limits.h&gt; // INT_MIN INT_MAX</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> g_invalid_input = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check_input</span><span class="params">(<span class="keyword">int</span>* data, <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">    g_invalid_input = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span>(data == <span class="literal">nullptr</span> || len &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        g_invalid_input = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find_max_sub_sum</span><span class="params">(<span class="keyword">int</span>* data, <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!check_input(data, len)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> max_sum = INT_MIN;</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(sum &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            sum = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        sum += data[i];</span><br><span class="line">        <span class="keyword">if</span>(max_sum &lt; sum) &#123;</span><br><span class="line">            max_sum = sum;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> max_sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> data[] = &#123;<span class="number">1</span>, <span class="number">-2</span>, <span class="number">3</span>, <span class="number">10</span>, <span class="number">-4</span>, <span class="number">7</span>, <span class="number">2</span>, <span class="number">-5</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> result = find_max_sub_sum(data, <span class="number">8</span>);</span><br><span class="line">    <span class="keyword">if</span>(g_invalid_input) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Invalid input.\n&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Max sum: %d\n&quot;</span>, result); <span class="comment">// 18</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>解法二</strong>：动态规划法。</p><p>如果用函数<code>f(i)</code>表示以第<code>i</code>个数字结尾的子数组（即必须包含这个尾元素）的最大和，那么我们需要求出<code>max&#123;f(i)&#125;, 0&lt;=i&lt;=n</code>，可以用如下递归公式来求<code>f(i)</code>：</p><div align="center"><p><img src="/images/s2o-c5-f4.jpg"></p></div><p>其实公式的意义和解法一的思路是相同的，不过表达形式不同，代码就不再写一遍了。</p><hr><blockquote><p>面试题43：1~n整数中1出现的次数。</p></blockquote><p>输入一个整数<code>n</code>，求<code>1~n</code>这<code>n</code>个整数的十进制表示中<code>1</code>出现的次数，例如，输入<code>12</code>，<code>1~12</code>这些整数中包含<code>1</code>的数字有<code>1、10、11</code>和<code>12</code>，<code>1</code>一共出现了<code>5</code>次。</p><p>简单地方法就不再写了，主要写一下书上的优化方法（其实还蛮不好理解的），直接看书上举的例子吧。</p><ul><li>例如<code>1~21345</code>，首先拆成<code>1~1345</code>和<code>1346~21345</code>，前者可以递归地调用<code>1~n</code>；</li><li><code>1346~21345</code>必然会包含<code>10000~19999</code>（因为<code>21345</code>的顶位<code>2</code>大于<code>1</code>），所以顶位上出现的1的个数有<code>10^4</code>个；如果定位小于<code>1</code>，即只包括<code>1346~11345</code>或者说<code>10000~11345</code>这部分，顶位的1个数就只有<code>1346+1</code>个；</li><li><code>1346~21345</code>数完顶位后，开始计数其他位的1个数，此时分为两组<code>1346~11345</code>,<code>11346~21345</code>，这样分的目的是，<code>1346~11345</code>的后4位<code>x1346~x1345</code>整好覆盖了4位数的所有情况<code>0~9999</code>，所以只需要其中一位固定1，其他位任选<code>0~9</code>，就可以得到该位上的1个数，所以对于一组<code>1346~11345</code>有<code>4*10^3</code>个，<code>11346~21345</code>同理<code>4*10^3</code>个，所以一共<code>2*4*10^3</code>个；</li><li>最后将递归求解的<code>1~1345</code>计数，和<code>1346~21345</code>顶位计数和其他位技术相加，就得到最后的结果。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pow_base_10</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> result = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">unsigned</span> <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        result *= <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">count_1</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* str_n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!str_n || *str_n &lt; <span class="string">&#x27;0&#x27;</span> || *str_n &gt; <span class="string">&#x27;9&#x27;</span> || *str_n == <span class="string">&#x27;\0&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> first = *str_n - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> len = (<span class="keyword">unsigned</span> <span class="keyword">int</span>)<span class="built_in">strlen</span>(str_n);</span><br><span class="line">    <span class="keyword">if</span>(len == <span class="number">1</span> &amp;&amp; first == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(len == <span class="number">1</span> &amp;&amp; first &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 假设str_n是 21345</span></span><br><span class="line">    <span class="comment">// num_first_digit 是数字10000~19999的第一位中的数目</span></span><br><span class="line">    <span class="keyword">int</span> num_first_digit = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(first &gt; <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">// 无论first有多大，只要大于1</span></span><br><span class="line">        <span class="comment">// 就包含10000~19999这些数（目前的例子下）</span></span><br><span class="line">        <span class="comment">// 所以目前的顶位出现的1的数量有 10^(len-1)个</span></span><br><span class="line">        num_first_digit = pow_base_10(len - <span class="number">1</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(first == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">// 如果fisrt位1，就是10000~11345这种情况</span></span><br><span class="line">        <span class="comment">// 这个时候就有1345+1个1出现在顶位上</span></span><br><span class="line">        num_first_digit = atoi(str_n + <span class="number">1</span>) + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 1346~21345除了在顶位之外的数位上1的情况</span></span><br><span class="line">    <span class="comment">// 最高位是2，所以分成两段 1346~11345 11346~21345</span></span><br><span class="line">    <span class="comment">// 每一段剩下的4位数字中，选择其中一位是1，其余三位可以在0~9数字中选择</span></span><br><span class="line">    <span class="comment">// 根据排列组合有 2 * 4 * 10^3</span></span><br><span class="line">    <span class="keyword">int</span> num_other_digit = first * (len - <span class="number">1</span>) * pow_base_10(len - <span class="number">2</span>);</span><br><span class="line">    <span class="comment">// 1~1345的1的数目</span></span><br><span class="line">    <span class="keyword">int</span> num_rec = count_1(str_n + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> num_first_digit + num_other_digit + num_rec;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">count_1_from_1_to_n</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n &lt; <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">char</span> str_n[<span class="number">50</span>];</span><br><span class="line">    <span class="built_in">sprintf</span>(str_n, <span class="string">&quot;%d&quot;</span>, n);</span><br><span class="line">    <span class="keyword">return</span> count_1(str_n);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;1~%d have %d &#x27;1&#x27;\n&quot;</span>, <span class="number">12</span>, count_1_from_1_to_n(<span class="number">12</span>));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;1~%d have %d &#x27;1&#x27;\n&quot;</span>, <span class="number">21345</span>, count_1_from_1_to_n(<span class="number">21345</span>));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最基础的思路需要<code>O(nlogn)</code>的时间，优化后的思路只需要<code>O(logn)</code>，所以要快得多。</p><hr><blockquote><p>面试题44：数字序列中某一位的数字。</p></blockquote><p>数字以<code>0123456789101112131415...</code>的格式，序列化到一个字符序列中。在这个序列中，第5位(从0开始计数)是5，第13位是1，第19位是4，等等。写一个函数，求任意第<code>n</code>位对应的数字。</p><p>直接的方法就是从0开始逐一地枚举每个数组，每枚举一个数字时，求该数字是几位数，并把位数累加，如果位数只和小于或等于输入的n，则继续枚举下一个数字，当累加位数大于n时，第n位数字一定在这个数字里，我们再从该数字中找出对应的一位。</p><p>这样的方法还不够优化，其实是可以有规律地一段段跳过的，例如寻找第<code>1001</code>位：</p><ul><li><code>0~9</code>一共10个字符，<code>1001</code>&gt;<code>10</code>，在后面的字符中寻找第<code>991</code>位；</li><li><code>10~99</code>一共180(90*2)个字符，<code>991</code>&gt;<code>180</code>，在后面的字符中寻找第<code>881</code>位；</li><li><code>100~999</code>一共2700(900*3)个字符，<code>881</code>&lt;<code>2700</code>，所以第<code>n</code>位一定是<code>100~999</code>中间的某个数，由于<code>811=270*3+1</code>，意味着第<code>881</code>位是从<code>100</code>开始的第<code>270</code>个数字(<code>370</code>)的中间1位，即<code>7</code>。</li></ul><p>完整代码实现：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt; // std::pow</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 得到为m位数字总共有多少个</span></span><br><span class="line"><span class="comment">// 例如m=2，返回(10~99)一共90个</span></span><br><span class="line"><span class="comment">// m=3，返回(100~999)一共900个</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">count_of_integers</span><span class="params">(<span class="keyword">int</span> digits)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(digits == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> count = (<span class="keyword">int</span>) <span class="built_in">std</span>::<span class="built_in">pow</span>(<span class="number">10</span>, digits - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">9</span> * count;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 得到在m位数字中，第一个数字</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">begin_num</span><span class="params">(<span class="keyword">int</span> digits)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(digits == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">int</span>) <span class="built_in">std</span>::<span class="built_in">pow</span>(<span class="number">10</span>, digits - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 得到在m位数字中，第n位到是什么</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">digit_at_n</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> digits)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 例如370 = 100 + 881 / 3</span></span><br><span class="line">    <span class="keyword">int</span> number = begin_num(digits) + n / digits;</span><br><span class="line">    <span class="comment">// 例如1 = 3 - 881 % 3</span></span><br><span class="line">    <span class="comment">// from right 是为了之后求数的时候直接从底位开始</span></span><br><span class="line">    <span class="keyword">int</span> n_from_right = digits - n % digits;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n_from_right; i++) &#123;</span><br><span class="line">        number /= <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> number % <span class="number">10</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">digit_at_n</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> digits = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> numbers = count_of_integers(digits);</span><br><span class="line">        <span class="keyword">if</span>(n &lt; numbers * digits) &#123;</span><br><span class="line">            <span class="keyword">return</span> digit_at_n(n, digits);</span><br><span class="line">        &#125;</span><br><span class="line">        n -= digits * numbers;</span><br><span class="line">        digits++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, digit_at_n(<span class="number">0</span>));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, digit_at_n(<span class="number">1000</span>));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, digit_at_n(<span class="number">1001</span>));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, digit_at_n(<span class="number">1002</span>));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><blockquote><p>面试题45：把数组排成最小的数。</p></blockquote><p>输入一个<strong>正整数数组</strong>，把数组里<strong>所有数字</strong>拼接起来<strong>排成一个数</strong>，打印能拼接出的所有数字中<strong>最小的一个</strong>。例如，输入<code>&#123;3,32,321&#125;</code>，则打印出这3个数字能排成的最小数字<code>321323</code><br>。</p><p>基础的思路是全排列，然后找出最小的，时间开销一般是<code>O(n!)</code>，优化的思路也不会很复杂，比如就单看两个数<code>nn</code>和<code>mm</code>，他们两个如何拼接可以最小，也就是比较<code>nnmm</code>和<code>mmnn</code>，那么当整个数组都是前一个数在前面的情况下可以让两个数的结果最小，顺序拼接的结果自然也是最小的（即不会出现比这个结果还小的结果），所以最后问题变成利用这种规则去对数组进行排序。</p><p>完整实现代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt; // sort</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt; // strcpy strcmp strcat</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> g_invalid_input = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check_data</span><span class="params">(<span class="keyword">int</span>* data, <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">    g_invalid_input = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span>(data == <span class="literal">nullptr</span> || len &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        g_invalid_input = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 校验是否都是正整数</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(data[i] &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            g_invalid_input = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAX_INT_LEN = <span class="number">10</span>;</span><br><span class="line"><span class="comment">// 申请两个全局字符数组，避免排序函数中反复申请，浪费时间</span></span><br><span class="line"><span class="keyword">char</span>* g_str_comb1 = <span class="keyword">new</span> <span class="keyword">char</span>[MAX_INT_LEN * <span class="number">2</span> + <span class="number">1</span>];</span><br><span class="line"><span class="keyword">char</span>* g_str_comb2 = <span class="keyword">new</span> <span class="keyword">char</span>[MAX_INT_LEN * <span class="number">2</span> + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">compare</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* num1, <span class="keyword">const</span> <span class="keyword">char</span>* num2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">strcpy</span>(g_str_comb1, num1);</span><br><span class="line">    <span class="built_in">strcat</span>(g_str_comb1, num2);</span><br><span class="line">    <span class="built_in">strcpy</span>(g_str_comb2, num2);</span><br><span class="line">    <span class="built_in">strcat</span>(g_str_comb2, num1);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">strcmp</span>(g_str_comb1, g_str_comb2) == <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">min_concat</span><span class="params">(<span class="keyword">int</span>* data, <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!check_data(data, len)) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 其实还要考虑两个int相连有可能会超过int表示范围</span></span><br><span class="line">    <span class="comment">// 所以转用字符串可能更合适，同时也不会修改原数据的顺序</span></span><br><span class="line">    <span class="keyword">char</span>** str_data = <span class="keyword">new</span> <span class="keyword">char</span>*[len];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">        str_data[i] = <span class="keyword">new</span> <span class="keyword">char</span>[MAX_INT_LEN + <span class="number">1</span>];</span><br><span class="line">        <span class="built_in">sprintf</span>(str_data[i], <span class="string">&quot;%d&quot;</span>, data[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">std</span>::sort(str_data, str_data + len, compare);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>, str_data[i]);</span><br><span class="line">        <span class="keyword">delete</span>[] str_data[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">delete</span>[] str_data;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> data[] = &#123;<span class="number">3</span>, <span class="number">32</span>, <span class="number">321</span>, <span class="number">8</span>, <span class="number">44</span>, <span class="number">1</span>, <span class="number">143</span>&#125;;</span><br><span class="line">    min_concat(data, <span class="number">7</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码中需要注意的一个地方是，如果直接用数字排序的方式，可能会在比较<code>nnmm</code>和<code>mmnn</code>时，这种拼接结果超出<code>int</code>的表示范围，而导致错误结果，所以可能出现大数的情况，要注意用字符串来替代处理。另外书上的代码在校验输入的时候，漏掉了对数组的是否是正整数的判断，上面代码也补上了，并且书上代码使用的排序方法是<code>qsort</code>，个人建议使用<code>sort</code>，一般情况下更加效率和便利。</p><p>书上有细致的讲，如何去证明这样的方法的正确性（比较规则的三个角度，自反性(<code>aa = aa</code>)、对称性(<code>a&lt;b =&gt; ab&lt;ba, ba&gt;ab, =&gt; b&gt;a</code>)以及传递性(<code>a&lt;b,b&lt;c =&gt; ab&lt;ba, bc&lt;cb =&gt; ac&lt;ca</code>)，和反证法，假设结果不是最小的，存在一个更小的，然后去推出假设不成立），尤其是当面试官问到的时候，也要能够说出缘由来，这里就不再复述了。</p><hr><blockquote><p>面试题46：把数字翻译成字符串。</p></blockquote><p>给定一个数字，按照如下规则把它翻译成字符串：<code>0</code>翻译成<code>a</code>，<code>1</code>翻译成<code>b</code>，…，<code>11</code>翻译成<code>l</code>，…，<code>25</code>翻译成<code>z</code>。一个数字可能有多个翻译。例如<code>12258</code>有5种不同的翻译，分别是<code>bccfi</code>、<code>bwf1</code>、<code>bczi</code>、<code>mcfi</code>和<code>mzi</code>。实现一个函数，用来计算一个数字有多少种不同的翻译方法。</p><p>直观的递归方法是，<code>12258</code>可以拆解为求解<code>2258</code>和<code>258</code>两个子问题，其中有可分支的条件是<code>c1==1 || (c1==2 &amp;&amp; c2 &lt;= 5)</code>，否则只能单线往下求解。</p><p>单纯递归完整代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAX_INT_LEN = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">kinds_of_encode</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* str_num)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(*str_num == <span class="string">&#x27;\0&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">char</span> c1 = *str_num, c2 = *(str_num + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span>(c1 == <span class="string">&#x27;1&#x27;</span> || (c1 == <span class="string">&#x27;2&#x27;</span> &amp;&amp; c2 &lt;= <span class="string">&#x27;5&#x27;</span>)) &#123;</span><br><span class="line">        <span class="keyword">return</span> kinds_of_encode(str_num + <span class="number">1</span>) + kinds_of_encode(str_num + <span class="number">2</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> kinds_of_encode(str_num + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">kinds_of_encode</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(num &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 用字符数组来处理更加方便一点</span></span><br><span class="line">    <span class="keyword">char</span>* str_num = <span class="keyword">new</span> <span class="keyword">char</span>[MAX_INT_LEN + <span class="number">1</span>];</span><br><span class="line">    <span class="built_in">sprintf</span>(str_num, <span class="string">&quot;%d&quot;</span>, num);</span><br><span class="line">    <span class="keyword">int</span> result = kinds_of_encode(str_num);</span><br><span class="line">    <span class="keyword">delete</span>[] str_num;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, kinds_of_encode(<span class="number">12258</span>)); <span class="comment">// 5</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>尽管看起来很简洁，但是这并不是最优的代码，例如<code>2258</code>和<code>258</code>两个子问题，<code>2258</code>会继续分支出<code>258</code>和<code>58</code>，在这一步<code>258</code>子问题被反复求解了，导致了计算的浪费。递归是从最大的问题开始自上而下的解决，其实我们也可以从最小的子问题开始自下而上的解决，来消除重复子问题。</p><p>也就是说，<strong>从数字的末尾开始，从右到左翻译</strong>，并计算不同翻译的数目。</p><p>完整实现代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">kinds_of_encode</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(num &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 从右向左翻译，避免重复子问题</span></span><br><span class="line">    <span class="keyword">char</span>* str_num = <span class="keyword">new</span> <span class="keyword">char</span>[MAX_INT_LEN + <span class="number">1</span>];</span><br><span class="line">    <span class="built_in">sprintf</span>(str_num, <span class="string">&quot;%d&quot;</span>, num);</span><br><span class="line">    <span class="keyword">int</span> len = <span class="built_in">strlen</span>(str_num);</span><br><span class="line">    <span class="keyword">int</span>* results = <span class="keyword">new</span> <span class="keyword">int</span>[len];</span><br><span class="line">    results[len - <span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">char</span> c1, c2;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = len - <span class="number">2</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        c1 = *(str_num + i);</span><br><span class="line">        c2 = *(str_num + i + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span>(c1 == <span class="string">&#x27;1&#x27;</span> || (c1 == <span class="string">&#x27;2&#x27;</span> &amp;&amp; c2 &lt;= <span class="string">&#x27;5&#x27;</span>)) &#123;</span><br><span class="line">            results[i] = results[i + <span class="number">1</span>] + results[i + <span class="number">2</span>];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            results[i] = results[i + <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> result = results[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">delete</span>[] str_num;</span><br><span class="line">    <span class="keyword">delete</span>[] results;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, kinds_of_encode(<span class="number">12258</span>)); <span class="comment">// 5</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><blockquote><p>面试题47：礼物的最大价值。</p></blockquote><p>在一个<code>m x n</code>的棋盘的每一格都放有一个礼物，每个礼物都有一定的价值（价值大于0）。可以从棋盘的左上角开始拿格子里的礼物，并每次向右或向下移动一格，直到到达棋盘的右下角。给定一个棋盘以及礼物价值，请问最多能拿到多少价值的礼物？</p><p>例如，下面的棋盘中，如果沿着带下划线的数字线路（1、12、5、7、7、16、5），那么我们能拿到最大价值为53的礼物。</p><div align="center"><p><img src="/images/s2o-c5-f5.jpg"></p></div><p>定义<code>f(i,j)</code>为到达坐标<code>(i,j)</code>的格子时，能拿到的礼物总和的最大值，我们有两种途径来到达坐标为<code>(i,j)</code>的格子，通过格子<code>(i-1,j)</code>左侧或者<code>(i,j-1)</code>上侧，所以<code>f(i,j)=max(f(i-1,j), f(i,j-1)) + gift[i,j]</code>，<code>gift[i,j]</code>表示坐标<code>(i,j)</code>的格子里礼物的价值。</p><p>典型的动态规划问题，定义一个辅助二维数组，数组中<code>(i,j)</code>表示到达该格子时，能拿到的礼物价值总和的最大值。</p><p>完整实现代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">max_gift_value</span><span class="params">(<span class="keyword">int</span>** values, <span class="keyword">int</span> rows, <span class="keyword">int</span> cols)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(values == <span class="literal">nullptr</span> || *values == <span class="literal">nullptr</span> || rows &lt;= <span class="number">0</span> || cols &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span>** max_values = <span class="keyword">new</span> <span class="keyword">int</span>*[rows];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; rows; i++) &#123;</span><br><span class="line">        max_values[i] = <span class="keyword">new</span> <span class="keyword">int</span>[cols];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; rows; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; cols; j++) &#123;</span><br><span class="line">            <span class="keyword">int</span> left = <span class="number">0</span>, up = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span>(i &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                up = max_values[i - <span class="number">1</span>][j];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(j &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                left = max_values[i][j - <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">int</span> value = *((<span class="keyword">int</span> *)values + cols * i + j);</span><br><span class="line">            max_values[i][j] = <span class="built_in">std</span>::max(left, up) + value;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> max_value = max_values[rows<span class="number">-1</span>][cols<span class="number">-1</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; rows; i++) &#123;</span><br><span class="line">        <span class="keyword">delete</span>[] max_values[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">delete</span>[] max_values;</span><br><span class="line">    <span class="keyword">return</span> max_value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> rows = <span class="number">4</span>, cols = <span class="number">4</span>;</span><br><span class="line">    <span class="keyword">int</span> values[<span class="number">4</span>][<span class="number">4</span>] = &#123;</span><br><span class="line">        &#123;<span class="number">1</span>, <span class="number">10</span>, <span class="number">3</span>, <span class="number">8</span>&#125;,</span><br><span class="line">        &#123;<span class="number">12</span>, <span class="number">2</span>, <span class="number">9</span>, <span class="number">6</span>&#125;,</span><br><span class="line">        &#123;<span class="number">5</span>, <span class="number">7</span>, <span class="number">4</span>, <span class="number">11</span>&#125;,</span><br><span class="line">        &#123;<span class="number">3</span>, <span class="number">7</span>, <span class="number">16</span>, <span class="number">5</span>&#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Max gift value: %d&quot;</span>, max_gift_value((<span class="keyword">int</span>**)values, rows, cols));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>考虑进一步的优化（主要是空间上），前面我们提到，到达坐标为<code>(i,j)</code>的格子时，最大价值依赖于<code>(i,j-1)</code>左侧和<code>(i-1,j)</code>上侧两个格子，因为此第<code>i-2</code>行及更上面的所有格子礼物的最大价值实际没有保存的必要。我们可以用一个一维数组来替代前面代码中的二维数组<code>max_values</code>，一维数组的长度为<code>cols</code>。</p><p>优化之后的代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">max_gift_value</span><span class="params">(<span class="keyword">int</span>** values, <span class="keyword">int</span> rows, <span class="keyword">int</span> cols)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(values == <span class="literal">nullptr</span> || *values == <span class="literal">nullptr</span> || rows &lt;= <span class="number">0</span> || cols &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span>* max_values = <span class="keyword">new</span> <span class="keyword">int</span>[rows]; <span class="comment">// 修改为一维数组</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; rows; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; cols; j++) &#123;</span><br><span class="line">            <span class="keyword">int</span> left = <span class="number">0</span>, up = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span>(i &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                up = max_values[j]; <span class="comment">// 此时j位置保存的为上一行的数据</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(j &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                left = max_values[j - <span class="number">1</span>]; <span class="comment">// 此时j-1位置已经是该行的数据</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">int</span> value = *((<span class="keyword">int</span> *)values + cols * i + j);</span><br><span class="line">            max_values[j] = <span class="built_in">std</span>::max(left, up) + value; <span class="comment">// 更新j为该行的数据</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> max_value = max_values[cols<span class="number">-1</span>];</span><br><span class="line">    <span class="keyword">delete</span>[] max_values;</span><br><span class="line">    <span class="keyword">return</span> max_value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><blockquote><p>面试题48：最长不含重复字符的子字符串。</p></blockquote><p>请从字符串中找出一个<strong>最长的不包含重复字符</strong>的子字符串，计算该最长子字符串的长度。假设字符串中只包含<code>a~z</code>。例如<code>arabcacfr</code>中，最长的不包含重复字符的子字符串是<code>acfr</code>，长度是<code>4</code>(还有子串<code>rabc</code>)。</p><p>这道题其实和之前的最大子数组和（面试题42）的思路有异曲同工之妙，同样有两种方法，一种是通过规律观察，另一种就是书上讲的动态规划法。首先讲一下这类“连续子串的最大/小”问题的一种规律解法，申明两个指针从头开始，头指针指向子串的头部，尾指针指向子串的尾部，尾指针每一步都向后移动一尾，同时根据移动后尾指针访问的状况（以及结合之前的值）来判断如何移动头指针。在本题目中，约束条件是不包含重复字符，也就是说当尾指针访问到一个重复字符时，就要调整头指针移向下一个不会让子串出现重复字符的位置（也就是跳到下一个满足约束的子串），记录过程中子串的最大长度，最后返回最大长度，时间复杂度<code>O(n)</code>。</p><p>完整实现代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">longest_substr_no_dup</span><span class="params">(<span class="keyword">char</span>* str)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(str == <span class="literal">nullptr</span> || <span class="built_in">strlen</span>(str) == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">map</span>&lt;<span class="keyword">char</span>, <span class="keyword">bool</span>&gt; char_map;</span><br><span class="line">    <span class="comment">// 初始化map</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; i++) &#123;</span><br><span class="line">        char_map[<span class="string">&#x27;a&#x27;</span>+i] = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">char</span>* start = str;</span><br><span class="line">    <span class="keyword">char</span>* end = str;</span><br><span class="line">    <span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> max_len = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">strlen</span>(str); i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(!char_map[*end]) &#123;</span><br><span class="line">            <span class="comment">// 没有遇到重复字符，子串长度+1</span></span><br><span class="line">            len++;</span><br><span class="line">            max_len = (max_len &lt; len) ? len : max_len;</span><br><span class="line">            char_map[*end] = <span class="literal">true</span>;</span><br><span class="line">            end++;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 直到start遇到该重复字符为止</span></span><br><span class="line">            <span class="keyword">while</span>(*start != *end) &#123;</span><br><span class="line">                char_map[*start] = <span class="literal">false</span>;</span><br><span class="line">                start++;</span><br><span class="line">                len--;</span><br><span class="line">            &#125;</span><br><span class="line">            start++;</span><br><span class="line">            char_map[*end] = <span class="literal">true</span>;</span><br><span class="line">            end++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> max_len;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span>* str = <span class="string">&quot;arabcacfr&quot;</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s longest substr no dup: %d&quot;</span>, str, longest_substr_no_dup(str));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码中使用到了<code>std::map&lt;char, bool&gt;</code>来记录当前子串的字符出现情况，也可以自行建立一个<code>bool</code>数组实现记录。</p><p>然后再看一下书上的动态规划思路（其实和面试题42的动态规划解法也类似），定义<code>f(i)</code>表示以第<code>i</code>个字符结尾的不包含重复字符的子串的最长长度。如果是从左到右的计算顺序，当我们计算<code>f(i)</code>的时候<code>f(i-1)</code>已经被计算出了。</p><ul><li>如果第<code>i</code>个字符没有出现过，那么<code>f(i)=f(i-1)+1</code>；</li><li>如果第<code>i</code>个字符之前已经出现过了，要先计算第<code>i</code>个字符和它上次出现在字符串中位置的距离，记为d，接着要分两种情况：<ul><li>如果<code>d &lt;= f(i-1)</code>，此时第i个字符上次出现在<code>f(i-1)</code>对应的最长子字符串之中，因此<code>f(i)=d</code>；</li><li>如果<code>d &gt; f(i-1)</code>，此时第i个字符上次出现在<code>f(i-1)</code>对应的最长子字符串之前，因此仍然有<code>f(i)=f(i-1)+1</code>。</li></ul></li></ul><p>完整实现代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">longest_substr_no_dup</span><span class="params">(<span class="keyword">char</span>* str)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(str == <span class="literal">nullptr</span> || <span class="built_in">strlen</span>(str) == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> max_len = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> str_len = <span class="built_in">strlen</span>(str);</span><br><span class="line">    <span class="keyword">int</span>* position = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">26</span>]; <span class="comment">// 存储每个字符上次出现的下标</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; i++) &#123;</span><br><span class="line">        position[i] = <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; str_len; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> prev_index = position[*(str+i) - <span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">        <span class="keyword">if</span>(prev_index &lt; <span class="number">0</span> || i - prev_index &gt; len) &#123;</span><br><span class="line">            len++;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>(len &gt; max_len) &#123;</span><br><span class="line">                max_len = len;</span><br><span class="line">            &#125;</span><br><span class="line">            len = i - prev_index;</span><br><span class="line">        &#125;</span><br><span class="line">        position[*(str+i) - <span class="string">&#x27;a&#x27;</span>] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(len &gt; max_len) &#123;</span><br><span class="line">        max_len = len;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">delete</span> position;</span><br><span class="line">    <span class="keyword">return</span> max_len;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-时间与空间的平衡"><a href="#3-时间与空间的平衡" class="headerlink" title="3 时间与空间的平衡"></a>3 时间与空间的平衡</h2><p>由于内存的容量增加迅速，在软件开发的过程中我们允许以牺牲一定的空间为代价来优化时间性能，以尽可能地缩短软件的响应时间。这就是我们通常所说的“以空间换时间”。</p><p>在面试的时候，如果我们分配少量的辅助空间来保存计算的中间结果以提高时间效率，则通常是可以被接受的。</p><p>但“空间换时间”并不一定都是可行的，面试的时候要具体问题具体分析，也就是对时间和空间的平衡考量。</p><h2 id="面试题-49-52"><a href="#面试题-49-52" class="headerlink" title="面试题 49-52"></a>面试题 49-52</h2><blockquote><p>面试题49：丑数。</p></blockquote><p>把只包含因子<code>2、3</code>和<code>5</code>的数称作丑数(Ugly Number）。求按从小到大的顺序的第1500个丑数。例如<code>6、8</code>都是丑数，但<code>14</code>不是。习惯上把<code>1</code>当作第1个丑数。</p><p>判断一个数是不是丑数的方法，就是依次除以因数<code>2、3、5</code>，每一个因数都是无法再除了再除下一个因数，如果三个因数都除尽了，剩下的为1，则为丑数，否则不是丑数，简单实现的判别函数：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">is_ugly</span><span class="params">(<span class="keyword">int</span> number)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(number % <span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line">        number /= <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(number % <span class="number">3</span> == <span class="number">0</span>) &#123;</span><br><span class="line">        number /= <span class="number">3</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(number % <span class="number">5</span> == <span class="number">0</span>) &#123;</span><br><span class="line">        number /= <span class="number">5</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (number == <span class="number">1</span>) ? <span class="literal">true</span> : <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>每个数依次的判别是不是丑数肯定是不够高效的。</p><p><strong>优化思路</strong>：创建数组保存已找到的丑数，用空间换时间的解法。</p><p>根据丑数的定义，丑数应该是另一个丑数乘以2、3或者5的结果（1除外），因此，我们可以创建一个数组，里面数字是排好序的丑数，每个丑数都是前面的丑数乘以2、3或者5得到的。</p><p>这种思路的关键在于怎么确保数组里面的丑数排好序。假设数组已有若干个排好序的丑数，把最大的丑数记为M，分析如何生成下一个丑数。下一个丑数肯定是前面某一个丑数乘以2、3或者5得到的，并且我们仅仅需要第一个大于M的丑数，也不用去乘以前方的所有丑数，其中一定有一个丑数满足一个条件，他是从小到大的第一个乘以2会大于M的丑数，记为<code>T_2</code>，类似的有<code>T_3</code>、<code>T_5</code>，每一次我们只需要在<code>T_2 * 2</code>和<code>T_3 * 3</code>和<code>T_5 * 5</code>中找到较小的一个即可（并且要更新所有<code>T</code>）。</p><p>完整实现代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">min</span><span class="params">(<span class="keyword">int</span> num1, <span class="keyword">int</span> num2, <span class="keyword">int</span> num3)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> min = (num1 &lt; num2) ? num1 : num2;</span><br><span class="line">    min = (min &lt; num3) ? min : num3;</span><br><span class="line">    <span class="keyword">return</span> min;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ugly_num_at_n</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> *ugly_nums = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">    ugly_nums[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> next_ugly_index = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span>* pt2 = ugly_nums;</span><br><span class="line">    <span class="keyword">int</span>* pt3 = ugly_nums;</span><br><span class="line">    <span class="keyword">int</span>* pt5 = ugly_nums;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(next_ugly_index &lt; n) &#123;</span><br><span class="line">        <span class="keyword">int</span> min_num = min(*pt2 * <span class="number">2</span>, *pt3 * <span class="number">3</span>, *pt5 * <span class="number">5</span>);</span><br><span class="line">        ugly_nums[next_ugly_index] = min_num;</span><br><span class="line">        <span class="keyword">while</span>(*pt2 * <span class="number">2</span> &lt;= min_num) &#123;</span><br><span class="line">            pt2++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(*pt3 * <span class="number">3</span> &lt;= min_num) &#123;</span><br><span class="line">            pt3++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(*pt5 * <span class="number">5</span> &lt;= min_num) &#123;</span><br><span class="line">            pt5++;</span><br><span class="line">        &#125;</span><br><span class="line">        next_ugly_index++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> ugly = ugly_nums[n - <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">delete</span>[] ugly_nums;</span><br><span class="line">    <span class="keyword">return</span> ugly;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Ugly Num at %d is %d\n&quot;</span>, <span class="number">1500</span>, ugly_num_at_n(<span class="number">1500</span>)); <span class="comment">// 859963392</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Ugly Num at %d is %d\n&quot;</span>, <span class="number">5</span>, ugly_num_at_n(<span class="number">5</span>)); <span class="comment">// 5</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Ugly Num at %d is %d\n&quot;</span>, <span class="number">1</span>, ugly_num_at_n(<span class="number">1</span>)); <span class="comment">// 1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><blockquote><p>面试题50：第一次只出现一次的字符。</p></blockquote><p>题目一：字符串中第一个只出现一次的字符。</p><p>在字符串中找出第一个只出现一次的字符。如输入<code>abaccdeff</code>，则输出<code>b</code>。</p><p>直接的思路是每次都比较一个字符是否在其后面出现，这种思路的时间复杂度是<code>O(n^2)</code>，效率不够高，可以考虑用空间换时间。如果我们可以统计每个字符出现的次数，可能就会变得简单的多，一般也用哈希表来解决这种问题。</p><p>哈希表是一种比较复杂的数据结构，C++标准模板库中的<code>map</code>和<code>unordered_map</code>实现了哈希表的功能，可以直接用。由于本题的特殊性，我们其实只需要一个非常简单的哈希表就能满足要求，因此我们可以考虑实现一个简单的哈希表。字符(char)是一个长度为8(bit)的数据类型，因此总共有256种可能性。我们创建一个长度为256的数组，每个字母根据其ASCII码值作为数组的下标对应数组的一个数组，而数组中存储的是每个字符出现的次数。这样我们就创建了一个大小为256、以字符ASCII码为键值的哈希表。</p><p>第一次扫描时，更新一个字符的出现次数需要时间<code>O(1)</code>，总共<code>O(n)</code>；第二次扫描时，寻找第一个出现次数为<code>1</code>的字符，时间也是<code>O(n)</code>。同时我们需要一个辅助数组，大小是<code>1KB</code>，由于数组大小是一个常数，因此认为这种算法的空间复杂度是<code>O(1)</code>。</p><p>完整实现代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">char</span> <span class="title">first_unique_char</span><span class="params">(<span class="keyword">char</span>* str)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(str == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> TABLE_SIZE = <span class="number">256</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> hash_table[TABLE_SIZE];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">unsigned</span> <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; TABLE_SIZE; i++) &#123;</span><br><span class="line">        hash_table[i] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">char</span>* pchar = str;</span><br><span class="line">    <span class="keyword">while</span>(*pchar != <span class="string">&#x27;\0&#x27;</span>) &#123;</span><br><span class="line">        hash_table[*pchar]++;</span><br><span class="line">        pchar++;</span><br><span class="line">    &#125;</span><br><span class="line">    pchar = str;</span><br><span class="line">    <span class="keyword">while</span>(*pchar != <span class="string">&#x27;\0&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span>(hash_table[*pchar] == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> *pchar;</span><br><span class="line">        &#125;</span><br><span class="line">        pchar++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span>* str = <span class="string">&quot;abaccdeff&quot;</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;First unique char of %s is %c&quot;</span>, str, first_unique_char(str));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>题目二：字符流中第一个只出现一次的字符。</p><p>实现一个函数，用来找出字符流中第一个只出现一次的字符。例如，字符流只读出<code>go</code>时，第一个只出现一次的字符是<code>g</code>；当读出<code>google</code>时，第一个只出现一次的字符时<code>l</code>。</p><p>可以定义一个数据容器来<strong>保存字符在字符流中的位置</strong>。当一个字符第一次从字符流读出来时，把位置保存在数据容器中。当字符再次从字符流中读取时，这时把它在容器中保存的值更新为一个特殊值（如负数）。而在查找第一个只出现一次的字符时，只需要遍历容器，找到最小的位置即可。</p><p>完整实现代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;limits.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CharStatistics</span> &#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        CharStatistics(): index(<span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">256</span>; i++) &#123;</span><br><span class="line">                occurrence[i] = <span class="number">-1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">char</span> ch)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(occurrence[ch] == <span class="number">-1</span>) &#123;</span><br><span class="line">                occurrence[ch] = index;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span>(occurrence[ch] &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                occurrence[ch] = <span class="number">-2</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            index++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">char</span> <span class="title">first_unique_char</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">char</span> ch = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">            <span class="keyword">int</span> min_index = INT_MAX;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">256</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span>(occurrence[i] &gt;= <span class="number">0</span> &amp;&amp; occurrence[i] &lt; min_index) &#123;</span><br><span class="line">                    ch = (<span class="keyword">char</span>)i;</span><br><span class="line">                    min_index = occurrence[i];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> ch;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="comment">// occurrence[i] : A char with ASCII value i;</span></span><br><span class="line">        <span class="comment">// occurrence[i] = -1 : not found yet</span></span><br><span class="line">        <span class="comment">// occurrence[i] = -2 : have been found for mutlple times</span></span><br><span class="line">        <span class="comment">// occurrence[i] &gt;= 0 : have been found only once</span></span><br><span class="line">        <span class="keyword">int</span> occurrence[<span class="number">256</span>];</span><br><span class="line">        <span class="keyword">int</span> index;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    CharStatistics char_statistics;</span><br><span class="line">    <span class="keyword">char</span>* stream = <span class="string">&quot;google&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">6</span>; i++) &#123;</span><br><span class="line">        char_statistics.insert(stream[i]);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;After insert %c, first unique char is %c\n&quot;</span>, stream[i],</span><br><span class="line">            char_statistics.first_unique_char());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><blockquote><p>面试题51：数组中的逆序对。</p></blockquote><p>在数组中的两个数字，如果前面一个数字大于后面的数字，则这两个数字组成一个逆序对。输入一个数组，求出这个数组中的逆序对的总数。例如，数组<code>&#123;7,5,6,4&#125;</code>中，一共有5个逆序对，分别是<code>(7,5)</code>、<code>(7,6)</code>、<code>(7,4)</code>、<code>(5,4)</code>和<code>(6,4)</code>。</p><div align="center"><p><img src="/images/s2o-c5-f6.jpg" alt="统计逆序对的过程"></p></div><div align="center"><p><img src="/images/s2o-c5-f7.jpg" alt="(d)中合并两个子数组并统计逆序对的过程"></p></div><ul><li>(a) P1指向的数字大于P2指向的数字（先比较最大的），表示数组中存在逆序对，把逆序对数目加2（后一个子数组的长度），并把7复制到辅助数组，向前移动P1和P3；</li><li>(b) P1指向的数字小于P2指向的数字，没有逆序对。把P2指向的数字复制到辅助数组，并向前移动P2和P3；</li><li>(c) P1指向的数字大于P2指向的数字，存在逆序对，把逆序对数目加1（后一个子数组的剩余长度），把5复制到辅助数组，想前移动P1和P3；</li><li>(…) 直到只剩一个元素，复制到辅助数组，结束合并，开始下一次相邻数组的合并。</li></ul><p>过程有点类似与归并排序，不过为了统计逆序对，从尾部开始合并。</p><p>完整实现代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">inverse_pair_core</span><span class="params">(<span class="keyword">int</span>* data, <span class="keyword">int</span>* copy, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(start == end) &#123;</span><br><span class="line">        copy[start] == data[start];</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> len = (end - start) / <span class="number">2</span>;</span><br><span class="line">    <span class="comment">// 注意这里交换了copy和data的位置，实现了交替使用</span></span><br><span class="line">    <span class="comment">// 一次合并排序的结果保存在data中</span></span><br><span class="line">    <span class="keyword">int</span> left = inverse_pair_core(copy, data, start, start + len);</span><br><span class="line">    <span class="keyword">int</span> right = inverse_pair_core(copy, data, start + len + <span class="number">1</span>, end);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> i = start + len;</span><br><span class="line">    <span class="keyword">int</span> j = end;</span><br><span class="line">    <span class="keyword">int</span> index_copy = end;</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(i &gt;= start &amp;&amp; j &gt;= start + len + <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span>(data[i] &gt; data[j]) &#123;</span><br><span class="line">            <span class="comment">// 前面的大于后面的</span></span><br><span class="line">            copy[index_copy--] = data[i--];</span><br><span class="line">            count += j - start - len;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 前面的小于后面的</span></span><br><span class="line">            copy[index_copy--] = data[j--];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 拷贝剩余的</span></span><br><span class="line">    <span class="keyword">while</span>(i &gt;= start) &#123;</span><br><span class="line">        copy[index_copy--] = data[i--];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(j &gt;= start + len + <span class="number">1</span>) &#123;</span><br><span class="line">        copy[index_copy--] = data[j--];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> left + right + count;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">inverse_pair</span><span class="params">(<span class="keyword">int</span>* data, <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(data == <span class="literal">nullptr</span> || len &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span>* copy = <span class="keyword">new</span> <span class="keyword">int</span>[len];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">        copy[i] = data[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> count = inverse_pair_core(data, copy, <span class="number">0</span>, len - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">delete</span>[] copy;</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> data[] = &#123;<span class="number">7</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">4</span>&#125;;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Data have %d inverse pair.\n&quot;</span>, inverse_pair(data, <span class="number">4</span>));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>归并排序的时间复杂度是<code>O(nlogn)</code>，比直观方法的<code>O(n^2)</code>要快，但同时归并需要一个长度为<code>n</code>的辅助数组，所以用了<code>O(n)</code>的空间来换时间效率的提升。</p><hr><blockquote><p>面试题52：两个链表的第一个公共节点。</p></blockquote><p>输入两个链表，找出他们的第一个公共节点。链表节点定义如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> key;</span><br><span class="line">    node* pnext;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其实有之前题目的铺垫，这里蛮容易想到根据两个链不同长度来调整起始指针的位置，调整起始后的两个指针，同步移动，当相遇时就是两个链表的公共节点，时间复杂度<code>O(m+n)</code>，<code>m</code>和<code>n</code>是两个链表的长度。</p><p>完整实现代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> key;</span><br><span class="line">    node* pnext;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">node* <span class="title">init_node</span><span class="params">(<span class="keyword">int</span> key)</span> </span>&#123; ... &#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init_list</span><span class="params">(node** pphead1, node** pphead2)</span> </span>&#123; ... &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">get_list_len</span><span class="params">(node* phead)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line">    node* pnode = phead;</span><br><span class="line">    <span class="keyword">while</span>(pnode != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        len++;</span><br><span class="line">        pnode = pnode-&gt;pnext;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> len;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">node* <span class="title">find_first_common_node</span><span class="params">(node* phead1, node* phead2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> len1 = get_list_len(phead1);</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> len2 = get_list_len(phead2);</span><br><span class="line">    <span class="keyword">if</span>(len1 == <span class="number">0</span> || len2 == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> len_diff = len1 - len2;</span><br><span class="line">    node* plong_list = phead1;</span><br><span class="line">    node* pshort_list = phead2;</span><br><span class="line">    <span class="keyword">if</span>(len2 &gt; len1) &#123;</span><br><span class="line">        len_diff = len2 - len1;</span><br><span class="line">        plong_list = phead2;</span><br><span class="line">        pshort_list = phead1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len_diff; i++) &#123;</span><br><span class="line">        plong_list = plong_list-&gt;pnext;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(plong_list != <span class="literal">nullptr</span> &amp;&amp; pshort_list != <span class="literal">nullptr</span></span><br><span class="line">          &amp;&amp; plong_list != pshort_list) &#123;</span><br><span class="line">        plong_list = plong_list-&gt;pnext;</span><br><span class="line">        pshort_list = pshort_list-&gt;pnext;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> plong_list;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    node* phead1;</span><br><span class="line">    node* phead2;</span><br><span class="line">    init_list(&amp;phead1, &amp;phead2);</span><br><span class="line">    node* first_common_node = find_first_common_node(phead1, phead2);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;First common node is %d\n&quot;</span>, first_common_node-&gt;key);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>书上还提到了一种方法，非常的巧妙，尤其是在这种需要在单向链表反向查找时，可以使用一个栈来实现逆向查询，例如在本题中，如果我们可以从两个链表的尾节点开始逆向查找，那么最后一个相同的节点，也就是第一个公共节点，可以使用两个栈来实现这个过程，时间开销<code>O(m+n)</code>，空间开销<code>O(m+n)</code>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">node* <span class="title">find_first_common_node</span><span class="params">(node* phead1, node* phead2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(phead1 == <span class="literal">nullptr</span> || phead2 == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;node*&gt; stk1, stk2;</span><br><span class="line">    <span class="keyword">while</span>(phead1 != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        stk1.push_back(phead1);</span><br><span class="line">        phead1 = phead1-&gt;pnext;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(phead2 != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        stk2.push_back(phead2);</span><br><span class="line">        phead2 = phead2-&gt;pnext;</span><br><span class="line">    &#125;</span><br><span class="line">    node* common_node = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">while</span>(!stk1.empty() &amp;&amp; !stk2.empty()) &#123;</span><br><span class="line">        <span class="keyword">if</span>(stk1[stk1.size() - <span class="number">1</span>] == stk2[stk2.size() - <span class="number">1</span>]) &#123;</span><br><span class="line">            common_node = stk1[stk1.size() - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        stk1.pop_back();</span><br><span class="line">        stk2.pop_back();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> common_node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>后一种方法虽然多了一个<code>O(m+n)</code>的空间开销，但是在一些单纯链表方法不能方便解决的时候，也不妨是一种构思的思路。</p><h2 id="4-总结"><a href="#4-总结" class="headerlink" title="4 总结"></a>4 总结</h2><p>编程面试时，面试官通常对时间复杂度和空间复杂度都会有要求，并且一般情况下面试官更加关注时间复杂度。</p><p>降低时间复杂度的第一种方法是<strong>改用更加高效的算法</strong>；第二种方法是<strong>用空间换时间</strong>。</p><p>以空间换时间并不一定都是可行的方案，还要注意辅助空间的大小，消耗空间过大也是得不偿失的。</p></div><div class="article-licensing box"><div class="licensing-title"><p>《剑指Offer》第5章笔记 优化效率</p><p><a href="https://yumi-cn.github.io/2021/01/11/s2o-c5-optimize/">https://yumi-cn.github.io/2021/01/11/s2o-c5-optimize/</a></p></div><div class="licensing-meta level is-mobile"><div class="level-left"><div class="level-item is-narrow"><div><h6>作者</h6><p>Yumiko</p></div></div><div class="level-item is-narrow"><div><h6>发布于</h6><p>2021-01-11</p></div></div><div class="level-item is-narrow"><div><h6>更新于</h6><p>2021-01-14</p></div></div><div class="level-item is-narrow"><div><h6>许可协议</h6><p><a class="icon" rel="noopener" target="_blank" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a><a class="icon" rel="noopener" target="_blank" title="Attribution" href="https://creativecommons.org/licenses/by/4.0/"><i class="fab fa-creative-commons-by"></i></a><a class="icon" rel="noopener" target="_blank" title="Noncommercial" href="https://creativecommons.org/licenses/by-nc/4.0/"><i class="fab fa-creative-commons-nc"></i></a></p></div></div></div></div></div><div class="article-tags is-size-7 mb-4"><span class="mr-2">#</span><a class="link-muted mr-2" rel="tag" href="/tags/%E7%AC%94%E8%AE%B0/">笔记</a></div></article></div><div class="card"><div class="card-content"><h3 class="menu-label has-text-centered">喜欢这篇文章？打赏一下作者吧</h3><div class="buttons is-centered"><a class="button donate" data-type="alipay"><span class="icon is-small"><i class="fab fa-alipay"></i></span><span>支付宝</span><span class="qrcode"><img src="/images/zfb.jpg" alt="支付宝"></span></a><a class="button donate" data-type="wechat"><span class="icon is-small"><i class="fab fa-weixin"></i></span><span>微信</span><span class="qrcode"><img src="/images/wx.jpg" alt="微信"></span></a><a class="button donate" href="https://afdian.net/@yumiko-cn" target="_blank" rel="noopener" data-type="afdian"><span class="icon is-small"><i class="fas fa-charging-station"></i></span><span>爱发电</span></a></div></div></div><nav class="post-navigation mt-4 level is-mobile"><div class="level-start"><a class="article-nav-prev level level-item link-muted" href="/2021/01/23/s2o-c6/"><i class="level-item fas fa-chevron-left"></i><span class="level-item">《剑指Offer》第6章笔记 各项能力</span></a></div><div class="level-end"><a class="article-nav-next level level-item link-muted" href="/2021/01/03/s2o-c4-part3/"><span class="level-item">《剑指Offer》第4章笔记 解题的思路 P3</span><i class="level-item fas fa-chevron-right"></i></a></div></nav><div class="card"><div class="card-content"><h3 class="title is-5">评论</h3><div id="comment-container"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/gitalk@1.6.2/dist/gitalk.css"><script src="https://cdn.jsdelivr.net/npm/gitalk@1.6.2/dist/gitalk.min.js"></script><script>var gitalk=new Gitalk({id:"700c2e55298478c93d8eb6ce36d7d0dc",repo:"yumi-cn.github.io",owner:"yumi-cn",clientID:"30141472b2ad1cb657d1",clientSecret:"80e26278051f7251bd46f5ec93317fec6675a7b4",admin:["yumi-cn"],createIssueManually:!1,distractionFreeMode:!1,perPage:20,pagerDirection:"last",enableHotKey:!0,language:"zh-CN"});gitalk.render("comment-container")</script></div></div></div><div class="column column-left is-4-tablet is-4-desktop is-3-widescreen order-1"><div class="card widget" data-type="profile"><div class="card-content"><nav class="level"><div class="level-item has-text-centered flex-shrink-1"><div><figure class="image is-128x128 mx-auto mb-2"><img class="avatar is-rounded" src="/images/avatar.jpg" alt="Yumiko"></figure><p class="title is-size-4 is-block" style="line-height:inherit">Yumiko</p><p class="is-size-6 is-block">游戏/引擎/技美</p><p class="is-size-6 is-flex justify-content-center"><i class="fas fa-map-marker-alt mr-1"></i><span>中国 杭州</span></p></div></div></nav><nav class="level is-mobile"><div class="level-item has-text-centered is-marginless"><div><p class="heading">文章</p><a href="/archives"><p class="title">26</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">专栏</p><a href="/categories"><p class="title">5</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">主题</p><a href="/tags"><p class="title">1</p></a></div></div></nav><div class="level"><a class="level-item button is-primary is-rounded" href="https://github.com/yumi-cn" target="_blank" rel="noopener">关注我</a></div><div class="level is-mobile"><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Github" href="https://github.com/yumi-cn"><i class="fab fa-github"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Bilibili" href="https://space.bilibili.com/11413916"><i class="fab fa-youtube"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Pixiv" href="https://www.pixiv.net/users/25096815"><i class="fas fa-palette"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="RSS" href="/atom.xml"><i class="fas fa-rss"></i></a></div></div></div><div class="card widget" data-type="categories"><div class="card-content"><div class="menu"><h3 class="menu-label">专栏</h3><ul class="menu-list"><li><a class="level is-mobile" href="/categories/3D%E6%B8%B8%E6%88%8F%E4%B8%8E%E5%9B%BE%E5%BD%A2%E5%AD%A6%E7%9A%84%E6%95%B0%E5%AD%A6/"><span class="level-start"><span class="level-item">3D游戏与图形学的数学</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/categories/LearnOpenGL/"><span class="level-start"><span class="level-item">LearnOpenGL</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/categories/Real-Time-Rendering-4th/"><span class="level-start"><span class="level-item">Real Time Rendering 4th</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/%E5%89%91%E6%8C%87Offer/"><span class="level-start"><span class="level-item">剑指Offer</span></span><span class="level-end"><span class="level-item tag">15</span></span></a></li><li><a class="level is-mobile" href="/categories/%E8%AE%A1%E5%88%92-Flags/"><span class="level-start"><span class="level-item">计划-Flags</span></span><span class="level-end"><span class="level-item tag">5</span></span></a></li></ul></div></div></div><div class="card widget" data-type="recent-posts"><div class="card-content"><h3 class="menu-label">最新文章</h3><article class="media"><div class="media-content"><p class="date"><time datetime="2021-03-13T03:28:19.000Z">2021-03-13</time></p><p class="title"><a href="/2021/03/13/plan-2021-03/">3月的计划</a></p><p class="categories"><a href="/categories/%E8%AE%A1%E5%88%92-Flags/">计划-Flags</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time datetime="2021-02-02T12:05:19.000Z">2021-02-02</time></p><p class="title"><a href="/2021/02/02/plan-2021-02/">2月的计划</a></p><p class="categories"><a href="/categories/%E8%AE%A1%E5%88%92-Flags/">计划-Flags</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time datetime="2021-01-26T13:34:18.000Z">2021-01-26</time></p><p class="title"><a href="/2021/01/26/learnopengl-c2/">《LearnOpenGL》光照 笔记</a></p><p class="categories"><a href="/categories/LearnOpenGL/">LearnOpenGL</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time datetime="2021-01-24T01:26:52.000Z">2021-01-24</time></p><p class="title"><a href="/2021/01/24/leetcode-200-select/">《LeetCode》精选200题计划</a></p><p class="categories"><a href="/categories/%E8%AE%A1%E5%88%92-Flags/">计划-Flags</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time datetime="2021-01-23T11:46:18.000Z">2021-01-23</time></p><p class="title"><a href="/2021/01/23/learnopengl-c1/">《LearnOpenGL》入门 笔记</a></p><p class="categories"><a href="/categories/LearnOpenGL/">LearnOpenGL</a></p></div></article></div></div><div class="column-right-shadow is-hidden-widescreen is-sticky"></div></div><div class="column column-right is-4-tablet is-4-desktop is-3-widescreen is-hidden-touch is-hidden-desktop-only order-3 is-sticky"><div class="card widget" id="toc" data-type="toc"><div class="card-content"><div class="menu"><h3 class="menu-label">目录</h3><ul class="menu-list"><li><a class="level is-mobile" href="#1-面试官谈效率"><span class="level-left"><span class="level-item">1 面试官谈效率</span></span></a></li><li><a class="level is-mobile" href="#2-时间效率"><span class="level-left"><span class="level-item">2 时间效率</span></span></a></li><li><a class="level is-mobile" href="#面试题-39-48"><span class="level-left"><span class="level-item">面试题 39-48</span></span></a></li><li><a class="level is-mobile" href="#3-时间与空间的平衡"><span class="level-left"><span class="level-item">3 时间与空间的平衡</span></span></a></li><li><a class="level is-mobile" href="#面试题-49-52"><span class="level-left"><span class="level-item">面试题 49-52</span></span></a></li><li><a class="level is-mobile" href="#4-总结"><span class="level-left"><span class="level-item">4 总结</span></span></a></li></ul></div></div><script src="/js/toc.js" defer></script></div></div></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/"><img src="/images/logo.jpg" alt="画码余生" height="28"></a><p class="is-size-7"><span>&copy; 2021 Yumiko</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a></p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Attribution 4.0 International" href="https://creativecommons.org/licenses/by/4.0/"><i class="fab fa-creative-commons-by"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="GitHub" href="https://github.com/yumi-cn"><i class="fab fa-github"></i></a></p></div></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" async></script><script>moment.locale("zh-CN")</script><script>var IcarusThemeSettings={article:{highlight:{clipboard:!0,fold:"unfolded"}}}</script><script src="/js/column.js"></script><script src="/js/animation.js"></script><a id="back-to-top" title="回到顶端" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back_to_top.js" defer></script><script src="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.js" defer></script><script>window.addEventListener("load", () => {
      window.cookieconsent.initialise({
        type: "info",
        theme: "edgeless",
        static: false,
        position: "bottom-left",
        content: {
          message: "此网站使用Cookie来改善您的体验。",
          dismiss: "知道了！",
          allow: "允许使用Cookie",
          deny: "拒绝",
          link: "了解更多",
          policy: "Cookie政策",
          href: "https://www.cookiesandyou.com/",
        },
        palette: {
          popup: {
            background: "#edeff5",
            text: "#838391"
          },
          button: {
            background: "#4b81e8"
          },
        },
      });
    });</script><script src="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/js/lightgallery.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/katex.min.css"><script src="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/katex.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/contrib/auto-render.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/contrib/mhchem.js" defer></script><script>window.addEventListener("load",function(){document.querySelectorAll('[role="article"] > .content').forEach(function(e){renderMathInElement(e)})})</script><script src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="想要查找什么..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/js/insight.js" defer></script><script>document.addEventListener("DOMContentLoaded",function(){loadInsight({contentUrl:"/content.json"},{hint:"想要查找什么...",untitled:"(无标题)",posts:"文章",pages:"页面",categories:"专栏",tags:"主题"})})</script></body></html>