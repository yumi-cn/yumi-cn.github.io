<!doctype html><html lang="zh"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1"><meta><title>《剑指Offer》第4章笔记 解题的思路 P2 - 画码余生</title><link rel="manifest" href="/manifest.json"><meta name="application-name" content="画码余生"><meta name="msapplication-TileImage" content="/images/favicon.ico"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="画码余生"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta description="一眼看不出问题的隐藏规律时，说不定能通过举例来发现。"><meta property="og:type" content="blog"><meta property="og:title" content="《剑指Offer》第4章笔记 解题的思路 P2"><meta property="og:url" content="https://yumi-cn.github.io/2021/01/02/s2o-c4-part2/"><meta property="og:site_name" content="画码余生"><meta property="og:description" content="一眼看不出问题的隐藏规律时，说不定能通过举例来发现。"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://yumi-cn.github.io/images/s2o-c4-part2-f1.jpg"><meta property="og:image" content="https://yumi-cn.github.io/images/s2o-c4-part2-f2.jpg"><meta property="og:image" content="https://yumi-cn.github.io/images/s2o-c4-part2-f3.jpg"><meta property="article:published_time" content="2021-01-02T08:43:28.000Z"><meta property="article:modified_time" content="2021-01-02T08:43:43.370Z"><meta property="article:author" content="Yumiko"><meta property="article:tag" content="笔记"><meta property="twitter:card" content="summary"><meta property="twitter:image" content="/images/s2o-c4-part2-f1.jpg"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"https://yumi-cn.github.io/2021/01/02/s2o-c4-part2/"},"headline":"画码余生","image":["https://yumi-cn.github.io/images/s2o-c4-part2-f1.jpg","https://yumi-cn.github.io/images/s2o-c4-part2-f2.jpg","https://yumi-cn.github.io/images/s2o-c4-part2-f3.jpg"],"datePublished":"2021-01-02T08:43:28.000Z","dateModified":"2021-01-02T08:43:43.370Z","author":{"@type":"Person","name":"Yumiko"},"description":"一眼看不出问题的隐藏规律时，说不定能通过举例来发现。"}</script><link rel="canonical" href="https://yumi-cn.github.io/2021/01/02/s2o-c4-part2/"><link rel="alternate" href="/atom.xml" title="画码余生" type="application/atom+xml"><link rel="icon" href="/images/favicon.ico"><link rel="stylesheet" href="https://cdn.bootcdn.net/ajax/libs/font-awesome/5.15.1/css/all.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@9.12.0/styles/atom-one-light.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link rel="stylesheet" href="/css/default.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/css/justifiedGallery.min.css"><script src="https://cdn.jsdelivr.net/npm/pace-js@1.0.2/pace.min.js"></script><meta name="generator" content="Hexo 5.2.0"></head><body class="is-3-column"><nav class="navbar navbar-main"><div class="container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/"><img src="/images/logo.jpg" alt="画码余生" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">主页</a><a class="navbar-item" href="/archives">文章</a><a class="navbar-item" href="/categories">专栏</a><a class="navbar-item" href="/tags">主题</a><a class="navbar-item" href="/about">关于我</a></div><div class="navbar-end"><a class="navbar-item" target="_blank" rel="noopener" title="Github" href="https://github.com/yumi-cn"><i class="fab fa-github"></i></a><a class="navbar-item is-hidden-tablet catalogue" title="目录" href="javascript:;"><i class="fas fa-list-ul"></i></a><a class="navbar-item search" title="搜索" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-6-widescreen"><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time datetime="2021-01-02T08:43:28.000Z" title="2021-01-02T08:43:28.000Z">2021-01-02</time>发表</span><span class="level-item"><time datetime="2021-01-02T08:43:43.370Z" title="2021-01-02T08:43:43.370Z">2021-01-02</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/%E5%89%91%E6%8C%87Offer/">剑指Offer</a></span><span class="level-item">21 分钟读完 (大约3085个字)</span></div></div><h1 class="title is-3 is-size-4-mobile">《剑指Offer》第4章笔记 解题的思路 P2</h1><div class="content"><blockquote><p>一眼看不出问题的隐藏规律时，说不定能通过举例来发现。</p></blockquote><a id="more"></a><h2 id="1、2-章节"><a href="#1、2-章节" class="headerlink" title="1、2 章节"></a>1、2 章节</h2><p>包含面试题27-29。</p><p>请到《第4章笔记 解题的思路 P1》阅读这部分内容。</p><h2 id="3-举例让抽象问题具体化"><a href="#3-举例让抽象问题具体化" class="headerlink" title="3 举例让抽象问题具体化"></a>3 举例让抽象问题具体化</h2><p>和上一节画图的方法一样，我们也可以借助举例模拟的方法来思考分析复杂的问题。当一眼看不出问题中隐藏的规律时，可以试着用一两个具体的例子模拟操作的过程，说不定能通过具体的例子找到抽象的规律。</p><p>具体的例子也可以帮助我们向面试官解释算法思路，也能帮助我们确保代码的质量，举出来的例子可以当作测试用例检验代码的正确性。</p><h2 id="面试题-30-34"><a href="#面试题-30-34" class="headerlink" title="面试题 30-34"></a>面试题 30-34</h2><blockquote><p>面试题30：包含min函数的栈。</p></blockquote><p>定义栈的数据结构，在该类型中实现一个能够得到栈的最小元素的min函数，在该栈中，调用<code>min</code>、<code>push</code>、<code>pop</code>的时间复杂度都是<code>O(1)</code>。</p><p>这道题容易曲解成是对这一组元素的排序，就容易陷入到一个思维陷阱，开始怀疑是怎么在<code>O(n)</code>时间内做到对这些元素的排序的（常用的排序也需要<code>O(nlogn)</code>的时间），其实多举几个例子可以发现，这个过程并不完全等价于是对一组元素的排序，栈的<code>min</code>值是有条件性的，取决于栈中到底有什么样的元素，以及<strong>这些元素的入栈顺序</strong>，所以用一个相同长度的栈，来存储一个元素入栈后，栈的<code>min</code>值是多少，就可以同步地在<code>O(1)</code>时间里实现<code>min</code>的获取。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> max_len = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">MinStack</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> <span class="built_in">stack</span>[max_len];</span><br><span class="line">    <span class="keyword">int</span> min_stack[max_len];</span><br><span class="line">    <span class="keyword">int</span> anchor = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> elem)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(anchor &lt; max_len - <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="built_in">stack</span>[anchor + <span class="number">1</span>] = elem;</span><br><span class="line">            <span class="keyword">if</span>(anchor == <span class="number">-1</span> || min_stack[anchor] &gt; elem) &#123;</span><br><span class="line">                min_stack[anchor + <span class="number">1</span>] = elem;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                min_stack[anchor + <span class="number">1</span>] = min_stack[anchor];</span><br><span class="line">            &#125;</span><br><span class="line">            anchor++;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// throw error</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> pop() &#123;</span><br><span class="line">        <span class="keyword">if</span>(anchor &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            anchor--;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">stack</span>[anchor + <span class="number">1</span>];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// throw error</span></span><br><span class="line">            <span class="keyword">return</span> - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">min</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(anchor &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> min_stack[anchor];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// throw error</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    MinStack min_stack;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">        min_stack.push(<span class="number">4</span> - i);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;After push %d, min=%d\n&quot;</span>, <span class="number">4</span> - i, min_stack.min());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// After push 4, min=4</span></span><br><span class="line">    <span class="comment">// After push 3, min=3</span></span><br><span class="line">    <span class="comment">// After push 2, min=2</span></span><br><span class="line">    <span class="comment">// After push 1, min=1</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> pop = min_stack.pop();</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;After pop %d, min=%d\n&quot;</span>, pop, min_stack.min());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// After pop 1, min=2</span></span><br><span class="line">    <span class="comment">// After pop 2, min=3</span></span><br><span class="line">    <span class="comment">// After pop 3, min=4</span></span><br><span class="line">    <span class="comment">// After pop 4, min=-1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><blockquote><p>面试题31：栈的压入、弹出序列。</p></blockquote><p>输入两个整数序列，第一个序列表示栈的压入顺序，请判断第二个序列是否为该栈的弹出顺序。假设压入栈的所有数字均不相等，例如<code>&#123;1,2,3,4,5&#125;</code>是某栈的压栈序列，序列<code>&#123;4,5,3,2,1&#125;</code>是该栈的对应一个弹出序列，但<code>&#123;4,3,5,1,2&#125;</code>就不可能是该压栈的弹出序列。</p><p>PS：题目其实说的蛮含糊的，只要理解一个关键点就好了，它指的是执行一系列压栈和弹出操作，并不是先只压栈然后再只弹出，所以一个入栈顺序为<code>&#123;1,2,3,4,5&#125;</code>，出栈顺序也可能是<code>&#123;1,2,3,4,5&#125;</code>（进一个就出一个）。</p><p>比较直观的方法就是用一个栈来模拟整个流程，看这个流程是否能匹配上压栈和弹出的顺序。</p><p>每次压栈结束后，就检查剩余的出栈顺序，如果下一个出栈的元素就栈顶的元素就出栈，并且循环检查，直到无法再出栈。如果入栈都结束后，出栈顺序或者栈内不为空，则表示出栈顺序有错误。</p><p>完整实现代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">is_pop_order</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span>* ppush, <span class="keyword">const</span> <span class="keyword">int</span>* ppop, <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">bool</span> possible = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span>(ppush != <span class="literal">nullptr</span> &amp;&amp; ppop != <span class="literal">nullptr</span> &amp;&amp; len &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">int</span>* pnext_push = ppush;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">int</span>* pnext_pop = ppop;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; <span class="built_in">stack</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(pnext_pop - ppop &lt; len) &#123;</span><br><span class="line">            <span class="keyword">while</span>(<span class="built_in">stack</span>.empty() || <span class="built_in">stack</span>.top() != *pnext_pop) &#123;</span><br><span class="line">                <span class="comment">// 元素压栈</span></span><br><span class="line">                <span class="keyword">if</span>(pnext_push - ppush == len) &#123;</span><br><span class="line">                    <span class="keyword">break</span>; <span class="comment">// 元素全部已入栈</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="built_in">stack</span>.push(*pnext_push);</span><br><span class="line">                pnext_push++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span>(!<span class="built_in">stack</span>.empty() &amp;&amp; <span class="built_in">stack</span>.top() == *pnext_pop) &#123;</span><br><span class="line">                <span class="comment">// 元素出栈</span></span><br><span class="line">                <span class="built_in">stack</span>.pop();</span><br><span class="line">                pnext_pop++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(pnext_push - ppush == len &amp;&amp; pnext_pop - ppop != len) &#123;</span><br><span class="line">                <span class="comment">// 入栈已空，但出栈还未空，不是正确的出栈顺序</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">stack</span>.empty() &amp;&amp; pnext_pop - ppop == len) &#123;</span><br><span class="line">            possible = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> possible;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span>* ppush, <span class="keyword">const</span> <span class="keyword">int</span>* ppop, <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, is_pop_order(ppush, ppop, len)?<span class="string">&quot;yes&quot;</span>:<span class="string">&quot;no&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> push_order[<span class="number">5</span>] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> pop_order1[<span class="number">5</span>] = &#123;<span class="number">4</span>,<span class="number">5</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> pop_order2[<span class="number">5</span>] = &#123;<span class="number">4</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">1</span>,<span class="number">2</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> pop_order3[<span class="number">5</span>] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> pop_order4[<span class="number">5</span>] = &#123;<span class="number">5</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>&#125;;</span><br><span class="line">    test(push_order, pop_order1, <span class="number">5</span>); <span class="comment">// yes</span></span><br><span class="line">    test(push_order, pop_order2, <span class="number">5</span>); <span class="comment">// no</span></span><br><span class="line">    test(push_order, pop_order3, <span class="number">5</span>); <span class="comment">// yes</span></span><br><span class="line">    test(push_order, pop_order4, <span class="number">5</span>); <span class="comment">// yes</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><blockquote><p>面试题32：从上到下打印二叉树。</p></blockquote><p><strong>题目一</strong>：不分行从上到下打印，同一层按照从左到右的顺序打印，节点定义：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> value;</span><br><span class="line">    node* pleft;</span><br><span class="line">    node* pright;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>思路就是之前有提到过的层序遍历了，使用队列的数据结构来辅助遍历。</p><div align="center"><p><img src="/images/s2o-c4-part2-f1.jpg" alt="打印顺序：8,6,10,5,7,9,11"></p></div><p>完整实现代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> value;</span><br><span class="line">    node* pleft;</span><br><span class="line">    node* pright;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">node* <span class="title">init_node</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123; ... &#125;</span><br><span class="line"><span class="function">node* <span class="title">init_tree</span><span class="params">()</span> </span>&#123; ... &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">level_order_traversal</span><span class="params">(node* proot)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(proot == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">queue</span>&lt;node*&gt; q;</span><br><span class="line">    q.push(proot);</span><br><span class="line">    node* pnode;</span><br><span class="line">    <span class="keyword">while</span>(!q.empty()) &#123;</span><br><span class="line">        pnode = q.front();</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, pnode-&gt;value);</span><br><span class="line">        <span class="keyword">if</span>(pnode-&gt;pleft != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            q.push(pnode-&gt;pleft);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(pnode-&gt;pright != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            q.push(pnode-&gt;pright);</span><br><span class="line">        &#125;</span><br><span class="line">        q.pop();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    node* proot = init_tree();</span><br><span class="line">    level_order_traversal(proot);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>PS：书上代码用的队列是<code>deque</code>双端队列，不是很明白作者的用意，这里我就直接用普通队列<code>queue</code>了。</p><p><strong>题目二</strong>：分行从上到下打印二叉树，每一层打印到一行，例如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">8</span></span><br><span class="line"><span class="number">6</span> <span class="number">10</span></span><br><span class="line"><span class="number">5</span> <span class="number">7</span> <span class="number">9</span> <span class="number">11</span></span><br></pre></td></tr></table></figure><p>队列除了保存节点顺序，还要保存一个层数，在题目一代码基础上进行稍微的修改。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;utility&gt; // use std::pair</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;tuple&gt; // use std::tie</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> value;</span><br><span class="line">    node* pleft;</span><br><span class="line">    node* pright;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">node* <span class="title">init_node</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123; ... &#125;</span><br><span class="line"><span class="function">node* <span class="title">init_tree</span><span class="params">()</span> </span>&#123; ... &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">level_order_traversal</span><span class="params">(node* proot)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(proot == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">queue</span>&lt;<span class="built_in">std</span>::<span class="built_in">pair</span>&lt;node*, <span class="keyword">int</span>&gt;&gt; q;</span><br><span class="line">    q.push(<span class="built_in">std</span>::<span class="built_in">make_pair</span>(proot, <span class="number">1</span>));</span><br><span class="line">    node* pnode;</span><br><span class="line">    <span class="keyword">int</span> level;</span><br><span class="line">    <span class="keyword">int</span> last_level = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(!q.empty()) &#123;</span><br><span class="line">        <span class="built_in">std</span>::tie(pnode, level) = q.front();</span><br><span class="line">        <span class="keyword">if</span>(level &gt; last_level) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">            last_level = level;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\t&quot;</span>, pnode-&gt;value);</span><br><span class="line">        <span class="keyword">if</span>(pnode-&gt;pleft != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            q.push(<span class="built_in">std</span>::<span class="built_in">make_pair</span>(pnode-&gt;pleft, level + <span class="number">1</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(pnode-&gt;pright != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            q.push(<span class="built_in">std</span>::<span class="built_in">make_pair</span>(pnode-&gt;pright, level + <span class="number">1</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        q.pop();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    node* proot = init_tree();</span><br><span class="line">    level_order_traversal(proot);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>书上代码把逻辑拆分的有点复杂，不够简洁，所以就用自己的方式来写了，在队列的节点中嵌入了节点的层数，用一个变量<code>last_level</code>来保存上一次打印节点的层数，如果发现已经到了下一层，就先输出一个换行，逻辑上更加简洁。</p><p><strong>题目三</strong>：之字形打印二叉树，第一行按照从左到右顺序，第二行按照从右到左顺序，第三行从左到右，依次类推。</p><p>可以简单地理解为，奇数行照常顺序打印，而偶数行需要逆向打印，所以可以简单地给偶数行添加一个栈结构，先全部压栈，再出栈打印，其他流程照旧，即可实现题目的要求，在题目二的代码基础上稍加修改即可。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;utility&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;tuple&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> value;</span><br><span class="line">    node* pleft;</span><br><span class="line">    node* pright;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">node* <span class="title">init_node</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123; ... &#125;</span><br><span class="line"><span class="function">node* <span class="title">init_tree</span><span class="params">()</span> </span>&#123; ... &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">level_order_traversal_zigzag</span><span class="params">(node* proot)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(proot == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">queue</span>&lt;<span class="built_in">std</span>::<span class="built_in">pair</span>&lt;node*, <span class="keyword">int</span>&gt;&gt; q;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; print_stack;</span><br><span class="line">    q.push(<span class="built_in">std</span>::<span class="built_in">make_pair</span>(proot, <span class="number">1</span>));</span><br><span class="line">    node* pnode;</span><br><span class="line">    <span class="keyword">int</span> level;</span><br><span class="line">    <span class="keyword">int</span> last_level = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(!q.empty()) &#123;</span><br><span class="line">        <span class="built_in">std</span>::tie(pnode, level) = q.front();</span><br><span class="line">        <span class="keyword">if</span>(level &gt; last_level) &#123;</span><br><span class="line">            <span class="keyword">if</span>(level &amp; <span class="number">0x1</span> == <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">while</span>(!print_stack.empty()) &#123;</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;%d\t&quot;</span>, print_stack.top());</span><br><span class="line">                    print_stack.pop();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">            last_level = level;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(level &amp; <span class="number">0x1</span> == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="comment">// 奇数行直接输出</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d\t&quot;</span>, pnode-&gt;value);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 偶数行先压栈</span></span><br><span class="line">            print_stack.push(pnode-&gt;value);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(pnode-&gt;pleft != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            q.push(<span class="built_in">std</span>::<span class="built_in">make_pair</span>(pnode-&gt;pleft, level + <span class="number">1</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(pnode-&gt;pright != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            q.push(<span class="built_in">std</span>::<span class="built_in">make_pair</span>(pnode-&gt;pright, level + <span class="number">1</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        q.pop();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 最后一层是偶数层时， 需要继续清空输出</span></span><br><span class="line">    <span class="keyword">while</span>(!print_stack.empty()) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\t&quot;</span>, print_stack.top());</span><br><span class="line">        print_stack.pop();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    node* proot = init_tree();</span><br><span class="line">    level_order_traversal_zigzag(proot);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>书上的代码逻辑稍微复杂一点，要用两个栈来完成两层的循环之字输出，理解起来稍微比较难，所以我就只是简单地在题目二的基础上进行修改了，逻辑上理解起来更加方便。</p><hr><blockquote><p>面试题33：二叉搜索树的后序遍历序列。</p></blockquote><p>输入一个整数数组，判断该数组是不是<strong>某二叉搜索树的后序遍历结果</strong>。如果是则返回<code>true</code>，否则返回<code>false</code>。假设输入的数组的任意两个数字互不相同，如，<code>&#123;5,7,6,9,11,10,8&#125;</code>，则返回<code>true</code>，因为整数序列是下图的二叉搜索树的后序遍历结果，如果输入<code>&#123;7,4,6,5&#125;</code>，则返回<code>false</code>，无法找到这样的二叉搜索树。</p><div align="center"><p><img src="/images/s2o-c4-part2-f2.jpg"></p></div><p><strong>后序遍历的特点在于最后访问根节点</strong>，所以对于一个树（或子树）的后续遍历序列，根节点都是最后一个数，另外，<strong>对于二叉搜索树的一个节点，其左子树的节点都小于该节点，右子树的节点都大于该节点</strong>，在遍历序列上体现就是前一部分大于节点值，后一部分小于节点值。所以解题的思路就是递归地去分解后续遍历序列，不断的去验证各个节点子树对应的后续遍历是否满足二叉搜索树的特性即可。</p><p>完整实现代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">is_post_order</span><span class="params">(<span class="keyword">int</span> sequence[], <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(sequence == <span class="literal">nullptr</span> || start &gt; end) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(start == end) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> pstart, pend;</span><br><span class="line">    <span class="keyword">for</span>(pstart = start; pstart &lt; end; pstart++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(sequence[pstart] &gt; sequence[end]) &#123;</span><br><span class="line">            pstart--;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(pend = end - <span class="number">1</span>; pend &gt;= start; pend--) &#123;</span><br><span class="line">        <span class="keyword">if</span>(sequence[pend] &lt; sequence[end]) &#123;</span><br><span class="line">            pend++;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(pstart == pend) &#123;</span><br><span class="line">        <span class="comment">// 全偏树，此时所有节点都大于或小于子树根节点</span></span><br><span class="line">        <span class="keyword">return</span> is_post_order(sequence, start, end<span class="number">-1</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(pstart + <span class="number">1</span> == pend) &#123;</span><br><span class="line">        <span class="comment">// 左子树都小于节点，右子树都大于节点</span></span><br><span class="line">        <span class="keyword">bool</span> bleft = is_post_order(sequence, start, pstart);</span><br><span class="line">        <span class="keyword">bool</span> bright = is_post_order(sequence, pend, end<span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">return</span> bleft &amp;&amp; bright;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 不满足要求</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">(<span class="keyword">int</span> sequence[], <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, is_post_order(sequence, start, end)?<span class="string">&quot;yes&quot;</span>:<span class="string">&quot;no&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sequence1[] = &#123; <span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">9</span>,<span class="number">11</span>,<span class="number">10</span>,<span class="number">8</span> &#125;;</span><br><span class="line">    <span class="keyword">int</span> sequence2[] = &#123; <span class="number">7</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">5</span> &#125;;</span><br><span class="line">    test(sequence1, <span class="number">0</span>, <span class="number">6</span>); <span class="comment">// yes</span></span><br><span class="line">    test(sequence2, <span class="number">0</span>, <span class="number">3</span>); <span class="comment">// no</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>比较细致地考虑的话，要记得把全偏树的情况考虑到，此时根节点前面的所有节点都属于一个子树，而不是还是分左子树和右子树。</p><hr><blockquote><p>面试题34：二叉树中和为某一值的路径。</p></blockquote><p>输入<strong>一棵二叉树和一个整数</strong>，打印出二叉树中<strong>节点值的和</strong>为输入整数的所有路径。从树的根节点开始往下一直到叶节点所经过的节点形成一条路径。二叉树节点的定义如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> value;</span><br><span class="line">    node* pleft;</span><br><span class="line">    node* pright;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><div align="center"><p><img src="/images/s2o-c4-part2-f3.jpg" alt="和为22的路径有两条，10、5、7和10、12"></p></div><p>直观的方法应该就是递归地往下遍历所有情况，到叶节点的时候计算路径上的节点和，如果和等于输入的整数，则输出路径。</p><p>完整实现代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> value;</span><br><span class="line">    node* pleft;</span><br><span class="line">    node* pright;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">node* <span class="title">init_node</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123; ... &#125;</span><br><span class="line"><span class="function">node* <span class="title">init_tree</span><span class="params">()</span> </span>&#123; ... &#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;node*&gt; path; <span class="comment">// 存储路径</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">find_path</span><span class="params">(node* pnode, <span class="keyword">int</span> sum, <span class="keyword">int</span> expect_sum)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(pnode == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(pnode-&gt;pleft == <span class="literal">nullptr</span> &amp;&amp; pnode-&gt;pright == <span class="literal">nullptr</span></span><br><span class="line">        &amp;&amp; sum + pnode-&gt;value == expect_sum) &#123;</span><br><span class="line">        <span class="comment">// 满足要求，输出节点</span></span><br><span class="line">        path.push_back(pnode);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; path.size(); i++) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, path[i]-&gt;value);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">        path.pop_back();</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    path.push_back(pnode);</span><br><span class="line">    <span class="keyword">if</span>(pnode-&gt;pleft != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        find_path(pnode-&gt;pleft, sum + pnode-&gt;value, expect_sum);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(pnode-&gt;pright != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        find_path(pnode-&gt;pright, sum + pnode-&gt;value, expect_sum);</span><br><span class="line">    &#125;</span><br><span class="line">    path.pop_back();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    node* tree = init_tree();</span><br><span class="line">    find_path(tree, <span class="number">0</span>, <span class="number">22</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这道题可能会联想到提前剪枝的优化，例如当还没有到叶节点时，发现和已经大于了期望值的和，此时提前停止往下查询的操作叫做剪枝，但需要注意的是本题目中并没有限定节点的值<code>value</code>一定是正数(类型也是<code>int</code>而非<code>unsigned int</code>)，可以出现途中和大于期望值和，所以本题不能用这样的剪枝优化方法。</p><h2 id="4-分解让复杂问题简单化"><a href="#4-分解让复杂问题简单化" class="headerlink" title="4 分解让复杂问题简单化"></a>4 分解让复杂问题简单化</h2><p>包含面试题35-38。</p><p>请到《第4章笔记 高质量代码 P3》阅读这部分内容。</p></div><div class="article-licensing box"><div class="licensing-title"><p>《剑指Offer》第4章笔记 解题的思路 P2</p><p><a href="https://yumi-cn.github.io/2021/01/02/s2o-c4-part2/">https://yumi-cn.github.io/2021/01/02/s2o-c4-part2/</a></p></div><div class="licensing-meta level is-mobile"><div class="level-left"><div class="level-item is-narrow"><div><h6>作者</h6><p>Yumiko</p></div></div><div class="level-item is-narrow"><div><h6>发布于</h6><p>2021-01-02</p></div></div><div class="level-item is-narrow"><div><h6>更新于</h6><p>2021-01-02</p></div></div><div class="level-item is-narrow"><div><h6>许可协议</h6><p><a class="icon" rel="noopener" target="_blank" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a><a class="icon" rel="noopener" target="_blank" title="Attribution" href="https://creativecommons.org/licenses/by/4.0/"><i class="fab fa-creative-commons-by"></i></a><a class="icon" rel="noopener" target="_blank" title="Noncommercial" href="https://creativecommons.org/licenses/by-nc/4.0/"><i class="fab fa-creative-commons-nc"></i></a></p></div></div></div></div></div><div class="article-tags is-size-7 mb-4"><span class="mr-2">#</span><a class="link-muted mr-2" rel="tag" href="/tags/%E7%AC%94%E8%AE%B0/">笔记</a></div></article></div><div class="card"><div class="card-content"><h3 class="menu-label has-text-centered">喜欢这篇文章？打赏一下作者吧</h3><div class="buttons is-centered"><a class="button donate" data-type="alipay"><span class="icon is-small"><i class="fab fa-alipay"></i></span><span>支付宝</span><span class="qrcode"><img src="/images/zfb.jpg" alt="支付宝"></span></a><a class="button donate" data-type="wechat"><span class="icon is-small"><i class="fab fa-weixin"></i></span><span>微信</span><span class="qrcode"><img src="/images/wx.jpg" alt="微信"></span></a><a class="button donate" href="https://afdian.net/@yumiko-cn" target="_blank" rel="noopener" data-type="afdian"><span class="icon is-small"><i class="fas fa-charging-station"></i></span><span>爱发电</span></a></div></div></div><nav class="post-navigation mt-4 level is-mobile"><div class="level-start"><a class="article-nav-prev level level-item link-muted" href="/2021/01/02/s2o-c4-part3/"><i class="level-item fas fa-chevron-left"></i><span class="level-item">《剑指Offer》第4章笔记 解题的思路 P3</span></a></div><div class="level-end"><a class="article-nav-next level level-item link-muted" href="/2021/01/01/s2o-c4-part1/"><span class="level-item">《剑指Offer》第4章笔记 解题的思路 P1</span><i class="level-item fas fa-chevron-right"></i></a></div></nav><div class="card"><div class="card-content"><h3 class="title is-5">评论</h3><div id="comment-container"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/gitalk@1.6.2/dist/gitalk.css"><script src="https://cdn.jsdelivr.net/npm/gitalk@1.6.2/dist/gitalk.min.js"></script><script>var gitalk=new Gitalk({id:"100c91af503e74f5e27f9286cc4988c5",repo:"yumi-cn.github.io",owner:"yumi-cn",clientID:"30141472b2ad1cb657d1",clientSecret:"80e26278051f7251bd46f5ec93317fec6675a7b4",admin:["yumi-cn"],createIssueManually:!1,distractionFreeMode:!1,perPage:20,pagerDirection:"last",enableHotKey:!0,language:"zh-CN"});gitalk.render("comment-container")</script></div></div></div><div class="column column-left is-4-tablet is-4-desktop is-3-widescreen order-1"><div class="card widget" data-type="profile"><div class="card-content"><nav class="level"><div class="level-item has-text-centered flex-shrink-1"><div><figure class="image is-128x128 mx-auto mb-2"><img class="avatar is-rounded" src="/images/avatar.jpg" alt="Yumiko"></figure><p class="title is-size-4 is-block" style="line-height:inherit">Yumiko</p><p class="is-size-6 is-block">游戏/引擎/技美</p><p class="is-size-6 is-flex justify-content-center"><i class="fas fa-map-marker-alt mr-1"></i><span>中国 杭州</span></p></div></div></nav><nav class="level is-mobile"><div class="level-item has-text-centered is-marginless"><div><p class="heading">文章</p><a href="/archives"><p class="title">19</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">专栏</p><a href="/categories"><p class="title">4</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">主题</p><a href="/tags"><p class="title">1</p></a></div></div></nav><div class="level"><a class="level-item button is-primary is-rounded" href="https://github.com/yumi-cn" target="_blank" rel="noopener">关注我</a></div><div class="level is-mobile"><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Github" href="https://github.com/yumi-cn"><i class="fab fa-github"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Bilibili" href="https://space.bilibili.com/11413916"><i class="fab fa-youtube"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Pixiv" href="https://www.pixiv.net/users/25096815"><i class="fas fa-palette"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="RSS" href="/atom.xml"><i class="fas fa-rss"></i></a></div></div></div><div class="card widget" data-type="categories"><div class="card-content"><div class="menu"><h3 class="menu-label">专栏</h3><ul class="menu-list"><li><a class="level is-mobile" href="/categories/3D%E6%B8%B8%E6%88%8F%E4%B8%8E%E5%9B%BE%E5%BD%A2%E5%AD%A6%E7%9A%84%E6%95%B0%E5%AD%A6/"><span class="level-start"><span class="level-item">3D游戏与图形学的数学</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/categories/Real-Time-Rendering-4th/"><span class="level-start"><span class="level-item">Real Time Rendering 4th</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/%E5%89%91%E6%8C%87Offer/"><span class="level-start"><span class="level-item">剑指Offer</span></span><span class="level-end"><span class="level-item tag">13</span></span></a></li><li><a class="level is-mobile" href="/categories/%E8%AE%A1%E5%88%92-Flags/"><span class="level-start"><span class="level-item">计划-Flags</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li></ul></div></div></div><div class="card widget" data-type="recent-posts"><div class="card-content"><h3 class="menu-label">最新文章</h3><article class="media"><div class="media-content"><p class="date"><time datetime="2021-01-02T08:45:17.000Z">2021-01-02</time></p><p class="title"><a href="/2021/01/02/s2o-c4-part3/">《剑指Offer》第4章笔记 解题的思路 P3</a></p><p class="categories"><a href="/categories/%E5%89%91%E6%8C%87Offer/">剑指Offer</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time datetime="2021-01-02T08:43:28.000Z">2021-01-02</time></p><p class="title"><a href="/2021/01/02/s2o-c4-part2/">《剑指Offer》第4章笔记 解题的思路 P2</a></p><p class="categories"><a href="/categories/%E5%89%91%E6%8C%87Offer/">剑指Offer</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time datetime="2021-01-01T08:55:16.000Z">2021-01-01</time></p><p class="title"><a href="/2021/01/01/s2o-c4-part1/">《剑指Offer》第4章笔记 解题的思路 P1</a></p><p class="categories"><a href="/categories/%E5%89%91%E6%8C%87Offer/">剑指Offer</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time datetime="2021-01-01T04:26:35.000Z">2021-01-01</time></p><p class="title"><a href="/2021/01/01/s2o-c3-part2/">《剑指Offer》第3章笔记 高质量代码 P2</a></p><p class="categories"><a href="/categories/%E5%89%91%E6%8C%87Offer/">剑指Offer</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time datetime="2020-12-30T11:05:35.000Z">2020-12-30</time></p><p class="title"><a href="/2020/12/30/s2o-c3-part1/">《剑指Offer》第3章笔记 高质量代码 P1</a></p><p class="categories"><a href="/categories/%E5%89%91%E6%8C%87Offer/">剑指Offer</a></p></div></article></div></div><div class="column-right-shadow is-hidden-widescreen is-sticky"></div></div><div class="column column-right is-4-tablet is-4-desktop is-3-widescreen is-hidden-touch is-hidden-desktop-only order-3 is-sticky"><div class="card widget" id="toc" data-type="toc"><div class="card-content"><div class="menu"><h3 class="menu-label">目录</h3><ul class="menu-list"><li><a class="level is-mobile" href="#1、2-章节"><span class="level-left"><span class="level-item">1、2 章节</span></span></a></li><li><a class="level is-mobile" href="#3-举例让抽象问题具体化"><span class="level-left"><span class="level-item">3 举例让抽象问题具体化</span></span></a></li><li><a class="level is-mobile" href="#面试题-30-34"><span class="level-left"><span class="level-item">面试题 30-34</span></span></a></li><li><a class="level is-mobile" href="#4-分解让复杂问题简单化"><span class="level-left"><span class="level-item">4 分解让复杂问题简单化</span></span></a></li></ul></div></div><script src="/js/toc.js" defer></script></div></div></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/"><img src="/images/logo.jpg" alt="画码余生" height="28"></a><p class="is-size-7"><span>&copy; 2021 Yumiko</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a></p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Attribution 4.0 International" href="https://creativecommons.org/licenses/by/4.0/"><i class="fab fa-creative-commons-by"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="GitHub" href="https://github.com/yumi-cn"><i class="fab fa-github"></i></a></p></div></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" async></script><script>moment.locale("zh-CN")</script><script>var IcarusThemeSettings={article:{highlight:{clipboard:!0,fold:"unfolded"}}}</script><script src="/js/column.js"></script><script src="/js/animation.js"></script><a id="back-to-top" title="回到顶端" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back_to_top.js" defer></script><script src="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.js" defer></script><script>window.addEventListener("load", () => {
      window.cookieconsent.initialise({
        type: "info",
        theme: "edgeless",
        static: false,
        position: "bottom-left",
        content: {
          message: "此网站使用Cookie来改善您的体验。",
          dismiss: "知道了！",
          allow: "允许使用Cookie",
          deny: "拒绝",
          link: "了解更多",
          policy: "Cookie政策",
          href: "https://www.cookiesandyou.com/",
        },
        palette: {
          popup: {
            background: "#edeff5",
            text: "#838391"
          },
          button: {
            background: "#4b81e8"
          },
        },
      });
    });</script><script src="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/js/lightgallery.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/katex.min.css"><script src="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/katex.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/contrib/auto-render.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/contrib/mhchem.js" defer></script><script>window.addEventListener("load",function(){document.querySelectorAll('[role="article"] > .content').forEach(function(e){renderMathInElement(e)})})</script><script src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="想要查找什么..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/js/insight.js" defer></script><script>document.addEventListener("DOMContentLoaded",function(){loadInsight({contentUrl:"/content.json"},{hint:"想要查找什么...",untitled:"(无标题)",posts:"文章",pages:"页面",categories:"专栏",tags:"主题"})})</script></body></html>