<!doctype html><html lang="zh"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1"><meta><title>《LearnOpenGL》光照 笔记 - 画码余生</title><link rel="manifest" href="/manifest.json"><meta name="application-name" content="画码余生"><meta name="msapplication-TileImage" content="/images/favicon.ico"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="画码余生"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta description="上帝说，要有光，于是便有了光。"><meta property="og:type" content="blog"><meta property="og:title" content="《LearnOpenGL》光照 笔记"><meta property="og:url" content="https://yumi-cn.github.io/2021/01/26/learnopengl-c2/"><meta property="og:site_name" content="画码余生"><meta property="og:description" content="上帝说，要有光，于是便有了光。"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://yumi-cn.github.io/images/learnopengl-c2-cover.jpg"><meta property="article:published_time" content="2021-01-26T13:34:18.000Z"><meta property="article:modified_time" content="2021-01-26T13:34:55.616Z"><meta property="article:author" content="Yumiko"><meta property="article:tag" content="笔记"><meta property="twitter:card" content="summary"><meta property="twitter:image" content="/images/learnopengl-c2-cover.jpg"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"https://yumi-cn.github.io/2021/01/26/learnopengl-c2/"},"headline":"画码余生","image":["https://yumi-cn.github.io/images/learnopengl-c2-cover.jpg"],"datePublished":"2021-01-26T13:34:18.000Z","dateModified":"2021-01-26T13:34:55.616Z","author":{"@type":"Person","name":"Yumiko"},"description":"上帝说，要有光，于是便有了光。"}</script><link rel="canonical" href="https://yumi-cn.github.io/2021/01/26/learnopengl-c2/"><link rel="alternate" href="/atom.xml" title="画码余生" type="application/atom+xml"><link rel="icon" href="/images/favicon.ico"><link rel="stylesheet" href="https://cdn.bootcdn.net/ajax/libs/font-awesome/5.15.1/css/all.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@9.12.0/styles/atom-one-light.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link rel="stylesheet" href="/css/default.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/css/justifiedGallery.min.css"><script src="https://cdn.jsdelivr.net/npm/pace-js@1.0.2/pace.min.js"></script><meta name="generator" content="Hexo 5.2.0"></head><body class="is-3-column"><nav class="navbar navbar-main"><div class="container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/"><img src="/images/logo.jpg" alt="画码余生" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">主页</a><a class="navbar-item" href="/archives">文章</a><a class="navbar-item" href="/categories">专栏</a><a class="navbar-item" href="/tags">主题</a><a class="navbar-item" href="/about">关于我</a></div><div class="navbar-end"><a class="navbar-item" target="_blank" rel="noopener" title="Github" href="https://github.com/yumi-cn"><i class="fab fa-github"></i></a><a class="navbar-item is-hidden-tablet catalogue" title="目录" href="javascript:;"><i class="fas fa-list-ul"></i></a><a class="navbar-item search" title="搜索" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-6-widescreen"><div class="card"><div class="card-image"><span class="image is-7by3"><img class="fill" src="/images/learnopengl-c2-cover.jpg" alt="《LearnOpenGL》光照 笔记"></span></div><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time datetime="2021-01-26T13:34:18.000Z" title="2021-01-26T13:34:18.000Z">2021-01-26</time>发表</span><span class="level-item"><time datetime="2021-01-26T13:34:55.616Z" title="2021-01-26T13:34:55.616Z">2021-01-26</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/LearnOpenGL/">LearnOpenGL</a></span><span class="level-item">3 小时读完 (大约22527个字)</span></div></div><h1 class="title is-3 is-size-4-mobile">《LearnOpenGL》光照 笔记</h1><div class="content"><blockquote><p>上帝说，要有光，于是便有了光。</p></blockquote><a id="more"></a><blockquote><p>笔记摘录源地址：<a target="_blank" rel="noopener" href="https://learnopengl-cn.github.io/">LearnOpenGL CN</a></p></blockquote><h2 id="颜色"><a href="#颜色" class="headerlink" title="颜色"></a>颜色</h2><p>颜色可以数字化的由红色(Red)、绿色(Green)和蓝色(Blue)三个分量组成，它们通常被缩写为<strong>RGB</strong>。仅仅用这三个值就可以组合出任意一种颜色。例如，要获取一个珊瑚红(Coral)色的话，我们可以定义这样的一个颜色向量：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">glm::vec3 <span class="title">coral</span><span class="params">(<span class="number">1.0f</span>, <span class="number">0.5f</span>, <span class="number">0.31f</span>)</span></span>;</span><br></pre></td></tr></table></figure><p>我们在现实生活中<strong>看到某一物体的颜色并不是这个物体真正拥有的颜色</strong>，而是<strong>它所反射的</strong>(Reflected)<strong>颜色</strong>。换句话说，那些不能被物体所吸收(Absorb)的颜色（被拒绝的颜色）就是我们能够感知到的物体的颜色。</p><p>例如，<strong>太阳光能被看见的白光其实是由许多不同的颜色组合而成的</strong>。如果我们将白光照在一个蓝色的玩具上，这个蓝色的玩具会吸收白光中除了蓝色以外的所有子颜色，不被吸收的蓝色光被反射到我们的眼中，让这个玩具看起来是蓝色的。下图显示的是一个珊瑚红的玩具，它以不同强度反射了多个颜色。</p><div align="center"><p><img src="/images/learnopengl-c2-f1.jpg"></p></div><p>你可以看到，<strong>白色的阳光实际上是所有可见颜色的集合，物体吸收了其中的大部分颜色</strong>。它仅反射了代表物体颜色的部分，<strong>被反射颜色的组合就是我们所感知到的颜色</strong>（此例中为珊瑚红）。</p><p>这些颜色反射的定律被直接地运用在图形领域。当我们在OpenGL中<strong>创建一个光源时</strong>，我们希望给光源一个颜色。在上一段中我们有一个白色的太阳，所以我们也将光源设置为白色。<strong>当我们把光源的颜色与物体的颜色值相乘</strong>，所得到的<strong>就是这个物体所反射的颜色</strong>（也就是我们所感知到的颜色）。</p><p>让我们再次审视我们的玩具（这一次它还是珊瑚红），看看如何在图形学中计算出它的反射颜色。我们将这两个颜色向量作分量相乘，结果就是最终的颜色向量了：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">glm::vec3 <span class="title">lightColor</span><span class="params">(<span class="number">1.0f</span>, <span class="number">1.0f</span>, <span class="number">1.0f</span>)</span></span>;</span><br><span class="line"><span class="function">glm::vec3 <span class="title">toyColor</span><span class="params">(<span class="number">1.0f</span>, <span class="number">0.5f</span>, <span class="number">0.31f</span>)</span></span>;</span><br><span class="line">glm::vec3 result = lightColor * toyColor;</span><br><span class="line"><span class="comment">// result = (1.0f, 0.5f, 0.31f)</span></span><br></pre></td></tr></table></figure><p>我们可以看到<strong>玩具的颜色吸收了白色光源中很大一部分的颜色</strong>，但它根据自身的颜色值<strong>对红、绿、蓝三个分量都做出了一定的反射</strong>。这也表现了<strong>现实中颜色的工作原理</strong>。由此，我们可以<strong>定义物体的颜色</strong>为<strong>物体从一个光源反射各个颜色分量的大小</strong>。现在，如果我们使用<strong>绿色的光源</strong>又会发生什么呢？</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">glm::vec3 <span class="title">lightColor</span><span class="params">(<span class="number">0.0f</span>, <span class="number">1.0f</span>, <span class="number">0.0f</span>)</span></span>;</span><br><span class="line"><span class="function">glm::vec3 <span class="title">toyColor</span><span class="params">(<span class="number">1.0f</span>, <span class="number">0.5f</span>, <span class="number">0.31f</span>)</span></span>;</span><br><span class="line">glm::vec3 result = lightColor * toyColor;</span><br><span class="line"><span class="comment">// result = (0.0f, 0.5f, 0.0f)</span></span><br></pre></td></tr></table></figure><p>可以看到，并没有红色和蓝色的光让我们的玩具来吸收或反射。这个玩具<strong>吸收了光线中一半的绿色值，但仍然也反射了一半的绿色值</strong>。玩具现在看上去是<strong>深绿色</strong>(Dark-greenish)的。我们可以看到，如果我们用绿色光源来照射玩具，那么只有绿色分量能被反射和感知到，<strong>红色和蓝色都不能被我们所感知到</strong>。这样做的结果是，<strong>一个珊瑚红的玩具突然变成了深绿色物体</strong>。现在我们来看另一个例子，使用<strong>深橄榄绿色</strong>(Dark olive-green)的光源：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">glm::vec3 <span class="title">lightColor</span><span class="params">(<span class="number">0.33f</span>, <span class="number">0.42f</span>, <span class="number">0.18f</span>)</span></span>;</span><br><span class="line"><span class="function">glm::vec3 <span class="title">toyColor</span><span class="params">(<span class="number">1.0f</span>, <span class="number">0.5f</span>, <span class="number">0.31f</span>)</span></span>;</span><br><span class="line">glm::vec3 result = lightColor * toyColor;</span><br><span class="line"><span class="comment">// result = (0.33f, 0.21f, 0.06f)</span></span><br></pre></td></tr></table></figure><p>可以看到，我们可以使用不同的光源颜色来让物体显现出意想不到的颜色。有创意地利用颜色其实并不难。</p><h3 id="创建一个光照场景"><a href="#创建一个光照场景" class="headerlink" title="创建一个光照场景"></a>创建一个光照场景</h3><p>首先我们需要一个<strong>物体来作为被投光</strong>(Cast the light)的对象，我们将使用前面教程中的那个著名的立方体箱子。我们<strong>还需要一个物体来代表光源在3D场景中的位置</strong>。简单起见，我们依然使用一个<strong>立方体来代表光源</strong>。</p><p>准备立方体箱子的数据。</p><p>我们首先需要一个<strong>顶点着色器</strong>来绘制箱子。与之前的顶点着色器相比，<strong>容器的顶点位置是保持不变的</strong>（虽然这一次我们不需要纹理坐标了），因此顶点着色器中没有新的代码。我们将会使用之前教程<strong>顶点着色器的精简版</strong>：</p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#version 330 core</span></span><br><span class="line"><span class="keyword">layout</span> (<span class="keyword">location</span> = <span class="number">0</span>) <span class="keyword">in</span> <span class="type">vec3</span> aPos;</span><br><span class="line"></span><br><span class="line"><span class="keyword">uniform</span> <span class="type">mat4</span> model;</span><br><span class="line"><span class="keyword">uniform</span> <span class="type">mat4</span> view;</span><br><span class="line"><span class="keyword">uniform</span> <span class="type">mat4</span> projection;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> main() &#123;</span><br><span class="line">    <span class="built_in">gl_Position</span> = projection * view * model * <span class="type">vec4</span>(aPos, <span class="number">1.0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>记得更新你的顶点数据和属性指针使其与新的顶点着色器保持一致。</p><p>因为我们还要创建一个<strong>表示灯</strong>（光源）<strong>的立方体</strong>，所以我们还要为这个灯创建一个专门的VAO。当然我们也可以让这个灯和其它物体使用同一个VAO，简单地对它的model（模型）矩阵做一些变换就好了，然而接下来的教程中<strong>我们会频繁地对顶点数据和属性指针做出修改</strong>，我们并<strong>不想让这些修改影响到灯</strong>（我们只关心灯的顶点位置），因此我们<strong>有必要为灯创建一个新的VAO</strong>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> lightVAO;</span><br><span class="line">glGenVertexArrays(<span class="number">1</span>, &amp;lightVAO);</span><br><span class="line">glBindVertexArray(lightVAO);</span><br><span class="line"><span class="comment">// 只需要绑定VBO不用再次设置VBO的数据，因为箱子的VBO数据中已经包含了正确的立方体顶点数据</span></span><br><span class="line">glBindBuffer(GL_ARRAY_BUFFER, VBO);</span><br><span class="line"><span class="comment">// 设置灯立方体的顶点属性（对我们的灯来说仅仅只有位置数据）</span></span><br><span class="line">glVertexAttribPointer(<span class="number">0</span>, <span class="number">3</span>, GL_FLOAT, GL_FALSE, <span class="number">3</span> * <span class="keyword">sizeof</span>(<span class="keyword">float</span>), (<span class="keyword">void</span>*)<span class="number">0</span>);</span><br><span class="line">glEnableVertexAttribArray(<span class="number">0</span>);</span><br></pre></td></tr></table></figure><p>现在我们已经创建了表示灯和被照物体箱子，我们只需要再<strong>定义一个片段着色器</strong>就行了：</p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#version 330 core</span></span><br><span class="line"><span class="keyword">out</span> <span class="type">vec4</span> FragColor;</span><br><span class="line"></span><br><span class="line"><span class="keyword">uniform</span> <span class="type">vec3</span> objectColor;</span><br><span class="line"><span class="keyword">uniform</span> <span class="type">vec3</span> lightColor;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> main() &#123;</span><br><span class="line">    FragColor = <span class="type">vec4</span>(lightColor * objectColor, <span class="number">1.0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个片段着色器从uniform变量中<strong>接受物体的颜色和光源的颜色</strong>。正如本节一开始所讨论的那样，我们将光源的颜色和物体（反射的）颜色相乘。这个着色器理解起来应该很容易。我们把物体的颜色设置为之前提到的珊瑚红色，并把光源设置为白色。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">lightingShader.use();</span><br><span class="line">lightingShader.setVec3(<span class="string">&quot;objectColor&quot;</span>, <span class="number">1.0f</span>, <span class="number">0.5f</span>, <span class="number">0.31f</span>);</span><br><span class="line">lightingShader.setVec3(<span class="string">&quot;lightColor&quot;</span>,  <span class="number">1.0f</span>, <span class="number">1.0f</span>, <span class="number">1.0f</span>);</span><br></pre></td></tr></table></figure><p>要注意的是，<strong>当我们修改顶点或者片段着色器后</strong>，<strong>灯的位置或颜色也会随之改变</strong>，这并不是我们想要的效果。我们<strong>不希望灯的颜色在接下来的教程中因光照计算的结果而受到影响</strong>，而是<strong>希望它能够与其它的计算分离</strong>。我们希望灯一直保持明亮，不受其它颜色变化的影响（这样它才更像是一个真实的光源）。</p><p>为了实现这个目标，我们<strong>需要为灯的绘制创建另外的一套着色器</strong>，从而能保证它能够在<strong>其它光照着色器发生改变的时候不受影响</strong>。顶点着色器与我们当前的顶点着色器是一样的，所以你可以直接把现在的顶点着色器用在灯上。<strong>灯的片段着色器给灯定义了一个不变的常量白色，保证了灯的颜色一直是亮的</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#version 330 core</span></span><br><span class="line">out vec4 FragColor;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    FragColor = vec4(<span class="number">1.0</span>); <span class="comment">// 将向量的四个分量全部设置为1.0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>当我们想要绘制我们的物体的时候</strong>，我们需要使用刚刚定义的光照着色器来绘制箱子（或者可能是其它的物体）。<strong>当我们想要绘制灯的时候</strong>，我们会使用灯的着色器。在之后的教程里我们会逐步更新这个光照着色器，从而能够慢慢地实现更真实的效果。</p><p>使用这个灯立方体的主要目的是为了<strong>让我们知道光源在场景中的具体位置</strong>。我们通常在场景中定义一个光源的位置，但这只是一个位置，它并没有视觉意义。为了显示真正的灯，<strong>我们将表示光源的立方体绘制在与光源相同的位置</strong>。我们将使用我们为它新建的片段着色器来绘制它，让它一直处于白色的状态，不受场景中的光照影响。</p><p>我们声明一个全局vec3变量来表示光源在场景的世界空间坐标中的位置：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">glm::vec3 <span class="title">lightPos</span><span class="params">(<span class="number">1.2f</span>, <span class="number">1.0f</span>, <span class="number">2.0f</span>)</span></span>;</span><br></pre></td></tr></table></figure><p>然后我们把灯位移到这里，然后将它缩小一点，让它不那么明显：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">model = glm::mat4();</span><br><span class="line">model = glm::translate(model, lightPos);</span><br><span class="line">model = glm::scale(model, glm::vec3(<span class="number">0.2f</span>));</span><br></pre></td></tr></table></figure><p>最后完整的渲染过程部分：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (!glfwWindowShouldClose(window)) &#123;</span><br><span class="line">    <span class="keyword">float</span> currentFrame = glfwGetTime();</span><br><span class="line">    deltaTime = currentFrame - lastFrame;</span><br><span class="line">    lastFrame = currentFrame;</span><br><span class="line"></span><br><span class="line">    process_input(window);</span><br><span class="line"></span><br><span class="line">    glClearColor(<span class="number">0.1f</span>, <span class="number">0.1f</span>, <span class="number">0.1f</span>, <span class="number">1.0f</span>);</span><br><span class="line">    glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 渲染立方体</span></span><br><span class="line">    shader.use();</span><br><span class="line">    shader.setVec3(<span class="string">&quot;objectColor&quot;</span>, glm::vec3(<span class="number">1.0f</span>, <span class="number">0.5f</span>, <span class="number">0.31f</span>));</span><br><span class="line">    shader.setVec3(<span class="string">&quot;lightColor&quot;</span>, glm::vec3(<span class="number">1.0f</span>, <span class="number">1.0f</span>, <span class="number">1.0f</span>));</span><br><span class="line"></span><br><span class="line">    glm::mat4 view = camera.GetViewMatrix();</span><br><span class="line"></span><br><span class="line">    glm::mat4 projection = glm::mat4(<span class="number">1.0f</span>);</span><br><span class="line">    projection = glm::perspective(glm::radians(camera.Zoom), (<span class="keyword">float</span>)width / (<span class="keyword">float</span>)height, <span class="number">0.1f</span>, <span class="number">100.0f</span>);</span><br><span class="line">    shader.setMat4(<span class="string">&quot;view&quot;</span>, view);</span><br><span class="line">    shader.setMat4(<span class="string">&quot;projection&quot;</span>, projection);</span><br><span class="line"></span><br><span class="line">    glm::mat4 model = glm::mat4(<span class="number">1.0f</span>);</span><br><span class="line">    shader.setMat4(<span class="string">&quot;model&quot;</span>, model);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 绑定VAO</span></span><br><span class="line">    glBindVertexArray(data.cube_VAO);</span><br><span class="line">    glDrawArrays(GL_TRIANGLES, <span class="number">0</span>, <span class="number">36</span>);</span><br><span class="line">    <span class="comment">// 解绑VAO</span></span><br><span class="line">    glBindVertexArray(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 渲染光源</span></span><br><span class="line">    light_shader.use();</span><br><span class="line">    light_shader.setMat4(<span class="string">&quot;view&quot;</span>, view);</span><br><span class="line">    light_shader.setMat4(<span class="string">&quot;projection&quot;</span>, projection);</span><br><span class="line">    model = glm::mat4(<span class="number">1.0f</span>);</span><br><span class="line">    model = glm::translate(model, light_pos);</span><br><span class="line">    model = glm::scale(model, glm::vec3(<span class="number">0.2f</span>)); <span class="comment">// a smaller cube</span></span><br><span class="line">    light_shader.setMat4(<span class="string">&quot;model&quot;</span>, model);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 绑定VAO</span></span><br><span class="line">    glBindVertexArray(data.light_VAO);</span><br><span class="line">    glDrawArrays(GL_TRIANGLES, <span class="number">0</span>, <span class="number">36</span>);</span><br><span class="line">    <span class="comment">// 解绑VAO</span></span><br><span class="line">    glBindVertexArray(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// glfwSwapBuffers函数会交换颜色缓冲</span></span><br><span class="line">    <span class="comment">// 它是一个储存着GLFW窗口每一个像素颜色值的大缓冲</span></span><br><span class="line">    <span class="comment">// 它在这一迭代中被用来绘制，并且将会作为输出显示在屏幕上。</span></span><br><span class="line">    glfwSwapBuffers(window);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// glfwPollEvents函数检查有没有触发什么事件</span></span><br><span class="line">    <span class="comment">// 比如键盘输入、鼠标移动、更新窗口状态等</span></span><br><span class="line">    <span class="comment">// 并调用对应的回调函数（可以通过回调方法手动设置）</span></span><br><span class="line">    glfwPollEvents();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><div align="center"><p><img src="/images/learnopengl-c2-f2.jpg"></p></div><h2 id="基础光照"><a href="#基础光照" class="headerlink" title="基础光照"></a>基础光照</h2><p>现实世界的光照是极其复杂的，而且会受到诸多因素的影响，这是我们有限的计算能力所无法模拟的。因此OpenGL的光照使用的是简化的模型，对现实的情况进行近似，这样处理起来会更容易一些，而且看起来也差不多一样。这些光照模型都是基于我们对光的物理特性的理解。其中一个模型被称为<strong>冯氏光照模型</strong>(Phong Lighting Model)。冯氏光照模型的主要结构由3个分量组成：<strong>环境</strong>(Ambient)、<strong>漫反射</strong>(Diffuse)和<strong>镜面</strong>(Specular)光照。下面这张图展示了这些光照分量看起来的样子：</p><div align="center"><p><img src="/images/learnopengl-c2-f3.jpg"></p></div><ul><li><strong>环境光照</strong>(Ambient Lighting)：即使在黑暗的情况下，世界上通常也仍然有一些光亮（月亮、远处的光），所以物体几乎永远不会是完全黑暗的。为了模拟这个，我们会使用一个环境光照常量，它永远会给物体一些颜色。</li><li><strong>漫反射光照</strong>(Diffuse Lighting)：模拟光源对物体的<strong>方向性影响</strong>(Directional Impact)。它是冯氏光照模型中视觉上<strong>最显著的分量</strong>。物体的<strong>某一部分越是正对着光源，它就会越亮</strong>。</li><li><strong>镜面光照</strong>(Specular Lighting)：模拟有<strong>光泽物体上面出现的亮点</strong>。镜面光照的颜色相比于物体的颜色会<strong>更倾向于光的颜色</strong>。</li></ul><h3 id="环境光照"><a href="#环境光照" class="headerlink" title="环境光照"></a>环境光照</h3><p>光通常都不是来自于同一个光源，而是来自于我们周围分散的很多光源，即使它们可能并不是那么显而易见。光的一个属性是，它可以向很多方向发散并反弹，从而能够到达不是非常直接临近的点。所以，光能够在其它的表面上反射，对一个物体产生间接的影响。考虑到这种情况的算法叫做<strong>全局照明</strong>(Global Illumination)算法，但是<strong>这种算法既开销高昂又极其复杂</strong>。</p><p>由于我们现在对那种又复杂又开销高昂的算法不是很感兴趣，所以我们将<strong>会先使用一个简化的全局照明模型，即环境光照</strong>。正如你在上一节所学到的，我们使用一个很小的常量（光照）颜色，添加到物体片段的最终颜色中，这样子的话即便场景中没有直接的光源也能看起来存在有一些发散的光。</p><p>把环境光照添加到场景里非常简单。我们用<strong>光的颜色乘以一个很小的常量环境因子</strong>，再<strong>乘以物体的颜色</strong>，然后将最终结果作为片段的颜色：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">float</span> ambientStrength = <span class="number">0.1</span>;</span><br><span class="line">    vec3 ambient = ambientStrength * lightColor;</span><br><span class="line">    vec3 result = ambient * objectColor;</span><br><span class="line">    FragColor = vec4(result, <span class="number">1.0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><div align="center"><p><img src="/images/learnopengl-c2-f4.jpg"></p></div><h3 id="漫反射光照"><a href="#漫反射光照" class="headerlink" title="漫反射光照"></a>漫反射光照</h3><p>环境光照本身不能提供最有趣的结果，但是<strong>漫反射光照就能开始对物体产生显著的视觉影响了</strong>。漫反射光照使物体上与光线方向越接近的片段能从光源处获得更多的亮度。为了能够更好的理解漫反射光照，请看下图：</p><div align="center"><p><img src="/images/learnopengl-c2-f5.jpg"></p></div><p>图左上方有一个光源，它所发出的光线落在物体的一个片段上。<strong>我们需要测量这个光线是以什么角度接触到这个片段的</strong>。如果<strong>光线垂直于物体表面，这束光对物体的影响会最大化</strong>（译注：更亮）。为了测量光线和片段的角度，我们使用一个叫做<strong>法向量</strong>(Normal Vector)的东西，它是<strong>垂直于片段表面的一个向量</strong>（这里以黄色箭头表示），我们在后面再讲这个东西。<strong>这两个向量</strong>（光线方向向量和法向量）<strong>之间的角度很容易就能够通过点乘计算出来</strong>。</p><p>注意，<strong>为了得到两个向量夹角的余弦值</strong>，我们使用的是<strong>单位向量</strong>（长度为1的向量），所以我们需要确保所有的向量都是标准化的，否则点乘返回的就不仅仅是余弦值了。</p><p>所以，计算漫反射光照需要什么？</p><ul><li><strong>法向量</strong>：一个垂直于顶点表面的向量。</li><li><strong>定向的光线</strong>：作为光源的位置与片段的位置之间向量差的方向向量。为了计算这个光线，我们需要光的位置向量和片段的位置向量。</li></ul><h3 id="法向量"><a href="#法向量" class="headerlink" title="法向量"></a>法向量</h3><p>法向量是一个垂直于顶点表面的（单位）向量。<strong>由于顶点本身并没有表面</strong>（它只是空间中一个独立的点），我们利用它周围的顶点来计算出这个顶点的表面。我们能够使用一个小技巧，使用叉乘对立方体所有的顶点计算法向量，但是<strong>由于3D立方体不是一个复杂的形状</strong>，所以我们可以<strong>简单地把法线数据手工添加到顶点数据中</strong>。试着去想象一下，这些<strong>法向量真的是垂直于立方体各个平面的表面的</strong>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">float</span> vertices[] = &#123;</span><br><span class="line">    <span class="number">-0.5f</span>, <span class="number">-0.5f</span>, <span class="number">-0.5f</span>,  <span class="number">0.0f</span>,  <span class="number">0.0f</span>, <span class="number">-1.0f</span>,</span><br><span class="line">     <span class="number">0.5f</span>, <span class="number">-0.5f</span>, <span class="number">-0.5f</span>,  <span class="number">0.0f</span>,  <span class="number">0.0f</span>, <span class="number">-1.0f</span>,</span><br><span class="line">     <span class="number">0.5f</span>,  <span class="number">0.5f</span>, <span class="number">-0.5f</span>,  <span class="number">0.0f</span>,  <span class="number">0.0f</span>, <span class="number">-1.0f</span>,</span><br><span class="line">     <span class="number">0.5f</span>,  <span class="number">0.5f</span>, <span class="number">-0.5f</span>,  <span class="number">0.0f</span>,  <span class="number">0.0f</span>, <span class="number">-1.0f</span>,</span><br><span class="line">    <span class="number">-0.5f</span>,  <span class="number">0.5f</span>, <span class="number">-0.5f</span>,  <span class="number">0.0f</span>,  <span class="number">0.0f</span>, <span class="number">-1.0f</span>,</span><br><span class="line">    <span class="number">-0.5f</span>, <span class="number">-0.5f</span>, <span class="number">-0.5f</span>,  <span class="number">0.0f</span>,  <span class="number">0.0f</span>, <span class="number">-1.0f</span>,</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>由于我们向顶点数组添加了额外的数据，所以我们应该更新光照的顶点着色器：</p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#version 330 core</span></span><br><span class="line"><span class="keyword">layout</span> (<span class="keyword">location</span> = <span class="number">0</span>) <span class="keyword">in</span> <span class="type">vec3</span> aPos;</span><br><span class="line"><span class="keyword">layout</span> (<span class="keyword">location</span> = <span class="number">1</span>) <span class="keyword">in</span> <span class="type">vec3</span> aNormal;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>现在我们已经向每个顶点添加了一个法向量并更新了顶点着色器，<strong>我们还要更新顶点属性指针</strong>。注意，<strong>灯使用同样的顶点数组作为它的顶点数据，然而灯的着色器并没有使用新添加的法向量</strong>。我们不需要更新灯的着色器或者是属性的配置，<strong>但是我们必须至少修改一下顶点属性指针</strong>来适应新的顶点数组的大小：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">glVertexAttribPointer(<span class="number">0</span>, <span class="number">3</span>, GL_FLOAT, GL_FALSE, <span class="number">6</span> * <span class="keyword">sizeof</span>(<span class="keyword">float</span>), (<span class="keyword">void</span>*)<span class="number">0</span>);</span><br><span class="line">glEnableVertexAttribArray(<span class="number">0</span>);</span><br><span class="line">glVertexAttribPointer(<span class="number">1</span>, <span class="number">3</span>, GL_FLOAT, GL_FALSE, <span class="number">6</span> * <span class="keyword">sizeof</span>(<span class="keyword">float</span>), (<span class="keyword">void</span>*)(<span class="number">3</span> * <span class="keyword">sizeof</span>(<span class="keyword">float</span>)));</span><br><span class="line">glEnableVertexAttribArray(<span class="number">1</span>);</span><br><span class="line">...</span><br><span class="line">glVertexAttribPointer(<span class="number">0</span>, <span class="number">3</span>, GL_FLOAT, GL_FALSE, <span class="number">6</span> * <span class="keyword">sizeof</span>(<span class="keyword">float</span>), (<span class="keyword">void</span>*)<span class="number">0</span>);</span><br><span class="line">glEnableVertexAttribArray(<span class="number">0</span>);</span><br></pre></td></tr></table></figure><p>虽然对灯的着色器使用不能完全利用的顶点数据<strong>看起来不是那么高效</strong>，<strong>但这些顶点数据已经从箱子对象载入后开始就储存在GPU的内存里了</strong>，所以我们<strong>并不需要储存新数据到GPU内存中</strong>。这<strong>实际上比给灯专门分配一个新的VBO更高效了</strong>。</p><p>所有光照的计算都是在片段着色器里进行，所以我们需要将法向量由顶点着色器传递到片段着色器。我们这么做：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#version 330 core</span></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">out vec3 Normal;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    gl_Position = projection * view * model * vec4(aPos, <span class="number">1.0f</span>);</span><br><span class="line">    normal = aNormal;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>接下来，在片段着色器中定义相应的输入变量：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">in vec3 Normal;</span><br></pre></td></tr></table></figure><p><strong>计算漫反射光照</strong></p><p>我们现在对每个顶点都有了法向量，但是我们<strong>仍然需要光源的位置向量和片段的位置向量。</strong>由于光源的位置是一个静态变量，我们可以简单地在<strong>片段着色器中</strong>把它声明为uniform：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">uniform vec3 lightPos;</span><br></pre></td></tr></table></figure><p>然后在渲染循环中（渲染循环的外面也可以，因为它不会改变）更新uniform。我们使用在前面声明的<code>lightPos</code>向量作为光源位置：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lightingShader.setVec3(<span class="string">&quot;lightPos&quot;</span>, lightPos);</span><br></pre></td></tr></table></figure><p>最后，我们还需要片段的位置。我们会在世界空间中进行所有的光照计算，<strong>因此我们需要一个在世界空间中的顶点位置</strong>。我们可以通过把<strong>顶点位置属性乘以模型矩阵</strong>（不是观察和投影矩阵）来把它变换到<strong>世界空间坐标</strong>。这个在顶点着色器中很容易完成，所以我们<strong>声明一个输出变量</strong>，并计算它的世界空间坐标：</p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">out</span> <span class="type">vec3</span> Normal;</span><br><span class="line"><span class="keyword">out</span> <span class="type">vec3</span> FragPos;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> main() &#123;</span><br><span class="line">    <span class="built_in">gl_Position</span> = projection * view * model * <span class="type">vec4</span>(aPos, <span class="number">1.0</span>f);</span><br><span class="line">    FragPos = <span class="type">vec3</span>(model * <span class="type">vec4</span>(aPos, <span class="number">1.0</span>));</span><br><span class="line">    normal = aNormal;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>最后，在<strong>片段着色器中添加相应的输入变量</strong>。</p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">in</span> <span class="type">vec3</span> FragPos;</span><br></pre></td></tr></table></figure><p>现在，所有需要的变量都设置好了，我们可以在<strong>片段着色器中添加光照计算</strong>了。</p><p>我们需要做的<strong>第一件事</strong>是计算<strong>光源和片段位置之间的方向向量</strong>。前面提到，光的方向向量是光源位置向量与片段位置向量之间的向量差。你可能记得在变换教程中，我们能够简单地通过让两个向量相减的方式计算向量差。我们同样希望确保所有相关向量最后都转换为单位向量，所以我们把法线和最终的方向向量都进行标准化：</p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">vec3</span> norm = <span class="built_in">normalize</span>(Normal);</span><br><span class="line"><span class="type">vec3</span> lightDir = <span class="built_in">normalize</span>(lightPos - FragPos);</span><br></pre></td></tr></table></figure><p><strong>当计算光照时我们通常不关心一个向量的模长或它的位置，我们只关心它们的方向</strong>。所以，几乎所有的计算都使用<strong>单位向量完成</strong>，因为这简化了大部分的计算（比如点乘）。所以当进行光照计算时，确保你总是对相关向量进行标准化，来保证它们是真正地单位向量。<strong>忘记对向量进行标准化是一个十分常见的错误</strong>。</p><p>下一步，我们对norm和lightDir向量进行<strong>点乘</strong>，计算光源对当前片段实际的漫发射影响。<strong>结果值再乘以光的颜色，得到漫反射分量</strong>。两个向量之间的角度越大，漫反射分量就会越小：</p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">float</span> diff = <span class="built_in">max</span>(<span class="built_in">dot</span>(norm, lightDir), <span class="number">0.0</span>);</span><br><span class="line"><span class="type">vec3</span> diffuse = diff * lightColor;</span><br></pre></td></tr></table></figure><p>现在我们有了<strong>环境光分量和漫反射分量</strong>，我们把它们相加，然后把结果乘以物体的颜色，来获得片段最后的输出颜色。</p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">vec3</span> norm = <span class="built_in">normalize</span>(Normal);</span><br><span class="line"><span class="type">vec3</span> lightDir = <span class="built_in">normalize</span>(lightPos - FragPos);</span><br><span class="line"><span class="type">float</span> diff = <span class="built_in">max</span>(<span class="built_in">dot</span>(norm, lightDir), <span class="number">0.0</span>);</span><br><span class="line"><span class="type">vec3</span> diffuse = diff * lightColor;</span><br><span class="line"></span><br><span class="line"><span class="type">float</span> ambientStrength = <span class="number">0.1</span>;</span><br><span class="line"><span class="type">vec3</span> ambient = ambientStrength * lightColor;</span><br><span class="line"></span><br><span class="line"><span class="type">vec3</span> result = (ambient + diffuse) * objectColor;</span><br><span class="line">FragColor = <span class="type">vec4</span>(result, <span class="number">1.0</span>);</span><br></pre></td></tr></table></figure><div align="center"><p><img src="/images/learnopengl-c2-f6.jpg"></p></div><p>你可以看到使用了漫反射光照，立方体看起来就真的像个立方体了。尝试在你的脑中想象一下法向量，并在立方体周围移动，<strong>注意观察法向量和光的方向向量之间的夹角越大，片段就会越暗</strong>。</p><p><strong>最后一件事</strong></p><p>现在我们已经把<strong>法向量从顶点着色器传到了片段着色器</strong>。可是，目前片段着色器里的计算都是在<strong>世界空间坐标中进行的</strong>。所以，我们是不是<strong>应该把法向量也转换为世界空间坐标</strong>？基本正确，但是这<strong>不是简单地把它乘以一个模型矩阵就能搞定的</strong>。</p><p>首先，<strong>法向量只是一个方向向量</strong>，不能表达空间中的特定位置。同时，法向量没有齐次坐标（顶点位置中的w分量）。这意味着，<strong>位移不应该影响到法向量</strong>。因此，如果<strong>我们打算把法向量乘以一个模型矩阵，我们就要从矩阵中移除位移部分，只选用模型矩阵左上角3×3的矩阵</strong>（注意，我们也可以把法向量的w分量设置为0，再乘以4×4矩阵；这同样可以移除位移）。对于法向量，我们<strong>只希望对它实施缩放和旋转变换</strong>。</p><p>其次，<strong>如果模型矩阵执行了不等比缩放</strong>，顶点的改变会<strong>导致法向量不再垂直于表面了</strong>。因此，我们不能用这样的模型矩阵来变换法向量。下面的图展示了应用了不等比缩放的模型矩阵对法向量的影响：</p><div align="center"><p><img src="/images/learnopengl-c2-f7.jpg"></p></div><p>每当我们应用一个不等比缩放时（注意：<strong>等比缩放不会破坏法线</strong>，因为法线的方向没被改变，<strong>仅仅改变了法线的长度，而这很容易通过标准化来修复</strong>），法向量就不会再垂直于对应的表面了，这样光照就会被破坏。</p><p>修复这个行为的诀窍是<strong>使用一个为法向量专门定制的模型矩阵</strong>。这个矩阵称之为法线矩阵(Normal Matrix)，它使用了一些线性代数的操作来移除对法向量错误缩放的影响。</p><p>法线矩阵被定义为「模型矩阵左上角的<strong>逆矩阵的转置矩阵</strong>」。注意，大部分的资源都会将法线矩阵定义为应用到模型-观察矩阵(Model-view Matrix)上的操作，但是由于我们<strong>只在世界空间中进行操作</strong>（不是在观察空间），我们<strong>只使用模型矩阵</strong>。</p><p>在<strong>顶点着色器</strong>中，我们可以使用<code>inverse</code>和<code>transpose</code>函数自己生成这个法线矩阵，这两个函数对所有类型矩阵都有效。注意我们还要把被处理过的矩阵<strong>强制转换</strong>为<code>3×3</code>矩阵，来保证<strong>它失去了位移属性</strong>以及能够乘以vec3的法向量。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Normal = mat3(transpose(inverse(model))) * aNormal;</span><br></pre></td></tr></table></figure><p>在漫反射光照部分，光照表现并没有问题，<strong>这是因为我们没有对物体本身执行任何缩放操作，所以并不是必须要使用一个法线矩阵</strong>，仅仅让模型矩阵乘以法线也可以。可是，<strong>如果你进行了不等比缩放</strong>，使用法线矩阵去乘以法向量就是必不可少的了。</p><p>即使是对于着色器来说，<strong>逆矩阵也是一个开销比较大的运算</strong>，因此，只要可能就应该避免在着色器中进行逆矩阵运算，它们必须为你场景中的每个顶点都进行这样的处理。用作学习目这样做是可以的，<strong>但是对于一个对效率有要求的应用来说，在绘制之前你最好用CPU计算出法线矩阵</strong>，然后通过uniform<strong>把值传递给着色器</strong>（像模型矩阵一样）。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">glm::mat3 normal_model = (glm::mat3)glm::transpose(glm::inverse(model));</span><br><span class="line">shader.setMat3(<span class="string">&quot;normal_model&quot;</span>, normal_model);</span><br><span class="line">...</span><br><span class="line">normal_model = (glm::mat3)glm::transpose(glm::inverse(model));</span><br><span class="line">light_shader.setMat3(<span class="string">&quot;normal_model&quot;</span>, normal_model);</span><br></pre></td></tr></table></figure><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="keyword">uniform</span> <span class="type">mat3</span> normal_model;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> main() &#123;</span><br><span class="line">    <span class="built_in">gl_Position</span> = projection * view * model * <span class="type">vec4</span>(aPos, <span class="number">1.0</span>f);</span><br><span class="line">    FragPos = <span class="type">vec3</span>(model * <span class="type">vec4</span>(aPos, <span class="number">1.0</span>));</span><br><span class="line">    Normal = normal_model * aNormal;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="镜面光照"><a href="#镜面光照" class="headerlink" title="镜面光照"></a>镜面光照</h3><p>把<strong>镜面高光</strong>(Specular Highlight)加进来，这样冯氏光照才算完整。</p><p>和漫反射光照一样，<strong>镜面光照也是依据光的方向向量和物体的法向量来决定的</strong>，但是它也依赖于观察方向，例如玩家是从什么方向看着这个片段的。<strong>镜面光照是基于光的反射特性</strong>。如果我们想象物体表面像一面镜子一样，那么，无论我们从哪里去看那个表面所反射的光，镜面光照都会达到最大化。你可以从下面的图片看到效果：</p><div align="center"><p><img src="/images/learnopengl-c2-f8.jpg"></p></div><p>我们通过反射法向量周围光的方向来计算反射向量。然后我们计算<strong>反射向量和视线方向</strong>的角度差，如果夹角越小，那么镜面光的影响就会越大。它的作用效果就是，当我们去看光被物体所反射的那个方向的时候，我们会看到一个高光。</p><p><strong>观察向量是镜面光照附加的一个变量</strong>，我们可以使用<strong>观察者世界空间位置和片段的位置来计算它</strong>。之后，我们计算镜面光强度，用它乘以光源的颜色，再将它加上环境光和漫反射分量。</p><p>我们选择在<strong>世界空间进行光照计算</strong>，但是<strong>大多数人趋向于在观察空间进行光照计算</strong>。在观察空间计算的好处是，<strong>观察者的位置</strong>总是(0, 0, 0)，所以这样你直接就获得了观察者位置。可是我发现在学习的时候<strong>在世界空间中计算光照更符合直觉</strong>。如果你仍然希望在观察空间计算光照的话，你需要将所有相关的向量都用观察矩阵进行变换（记得也要改变法线矩阵）。</p><p>为了得到观察者的世界空间坐标，我们简单地使用<strong>摄像机对象的位置坐标代替</strong>。所以我们把另一个uniform添加到<strong>片段着色器</strong>，把相应的<strong>摄像机位置坐标</strong>传给片段着色器：</p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">uniform</span> <span class="type">vec3</span> viewPos;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lightingShader.setVec3(<span class="string">&quot;viewPos&quot;</span>, camera.Position);</span><br></pre></td></tr></table></figure><p>现在我们已经获得所有需要的变量，可以计算高光强度了。首先，我们定义一个<strong>镜面强度</strong>(Specular Intensity)变量，给镜面高光一个中等亮度颜色，让它不要产生过度的影响。</p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">float</span> specularStrength = <span class="number">0.5</span>;</span><br></pre></td></tr></table></figure><p>如果我们把它设置为<code>1.0f</code>，我们会得到一个非常亮的镜面光分量，这对于一个珊瑚色的立方体来说有点太多了。下一步，我们<strong>计算视线方向向量</strong>，和对应的<strong>沿着法线轴的反射向量</strong>：</p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">vec3</span> viewDir = <span class="built_in">normalize</span>(viewPos - FragPos);</span><br><span class="line"><span class="type">vec3</span> reflectDir = <span class="built_in">reflect</span>(-lightDir, norm);</span><br></pre></td></tr></table></figure><p>需要注意的是我们对<code>lightDir</code>向量<strong>进行了取反</strong>。<code>reflect</code>函数要求<strong>第一个向量是从光源指向片段位置的向量</strong>，但是<code>lightDir</code>当前正好相反，是<strong>从片段指向光源</strong>（由先前我们计算lightDir向量时，<strong>减法的顺序决定</strong>）。为了保证我们得到正确的reflect向量，我们通过对lightDir向量取反来获得相反的方向。<strong>第二个参数</strong>要求是一个法向量，所以我们提供的是<strong>已标准化的norm向量</strong>。</p><p>剩下要做的是<strong>计算镜面分量</strong>。下面的代码完成了这件事：</p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">float</span> spec = <span class="built_in">pow</span>(<span class="built_in">max</span>(<span class="built_in">dot</span>(viewDir, reflectDir), <span class="number">0.0</span>), <span class="number">32</span>);</span><br><span class="line"><span class="type">vec3</span> specular = specularStrength * spec * lightColor;</span><br></pre></td></tr></table></figure><p>我们先计算<strong>视线方向与反射方向的点乘</strong>（并确保它不是负值），然后<strong>取它的32次幂</strong>。这个32是高光的<strong>反光度</strong>(Shininess)。一个物体的<strong>反光度越高</strong>，反射光的能力越强，散射得越少，高光点就会越小。在下面的图片里，你会看到不同反光度的视觉效果影响：</p><div align="center"><p><img src="/images/learnopengl-c2-f9.jpg"></p></div><p>我们不希望镜面成分过于显眼，所以我们把指数保持为32。剩下的最后一件事情是把它加到环境光分量和漫反射分量里，再用结果乘以物体的颜色：</p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">vec3</span> result = (ambient + diffuse + specular) * objectColor;</span><br><span class="line">FragColor = <span class="type">vec4</span>(result, <span class="number">1.0</span>);</span><br></pre></td></tr></table></figure><p>我们现在为冯氏光照计算了全部的光照分量。</p><div align="center"><p><img src="/images/learnopengl-c2-f10.jpg"></p></div><p><strong>在光照着色器的早期</strong>，开发者曾经在<strong>顶点着色器中实现冯氏光照模型</strong>。在顶点着色器中做光照的优势是，相比片段来说，<strong>顶点要少得多，因此会更高效</strong>，所以（开销大的）光照计算频率会更低。然而，<strong>顶点着色器中的最终颜色值是仅仅只是那个顶点的颜色值</strong>，<strong>片段的颜色值是由插值光照颜色所得来的</strong>。结果就是这种光照看起来不会非常真实，<strong>除非使用了大量顶点</strong>。</p><div align="center"><p><img src="/images/learnopengl-c2-f11.jpg"></p></div><p>在<strong>顶点着色器中实现的冯氏光照模型</strong>叫做<strong>Gouraud着色</strong>(Gouraud Shading)，而不是冯氏着色(Phong Shading)。记住，由于插值，这种光照看起来有点逊色。<strong>冯氏着色能产生更平滑的光照效果</strong>。</p><h3 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h3><ul><li>目前，我们的光源时静止的，你可以尝试使用sin或cos函数让光源在场景中来回移动。观察光照随时间的改变能让你更容易理解冯氏光照模型；</li><li>尝试使用<strong>不同的环境光、漫反射和镜面强度</strong>，观察它们怎么是影响光照效果的。同样，尝试实验一下<strong>镜面光照的反光度因子</strong>。尝试理解为什么某一个值能够有着某一种视觉输出；</li><li>在观察空间（而不是世界空间）中计算冯氏光照；</li><li>尝试实现一个Gouraud着色（而不是冯氏着色）。如果你做对了话，立方体的光照应该会看起来有些奇怪，尝试推理为什么它会看起来这么奇怪。</li></ul><h2 id="材质"><a href="#材质" class="headerlink" title="材质"></a>材质</h2><p><strong>在现实世界里，每个物体会对光产生不同的反应</strong>。比如说，钢看起来通常会比陶瓷花瓶更闪闪发光，木头箱子也不会像钢制箱子那样对光产生很强的反射。每个物体对镜面高光也有不同的反应。有些物体反射光的时候不会有太多的散射(Scatter)，因而产生一个较小的高光点，而有些物体则会散射很多，产生一个有着更大半径的高光点。<strong>如果我们想要在OpenGL中模拟多种类型的物体</strong>，我们必须为<strong>每个物体分别定义一个材质</strong>(Material)<strong>属性</strong>。</p><p>在上一节中，我们指定了一个物体和光的颜色，以及结合环境光和镜面强度分量，来定义物体的视觉输出。<strong>当描述一个物体的时候</strong>，我们可以用这<strong>三个分量来定义一个材质颜色</strong>(Material Color)：<strong>环境光照</strong>(Ambient Lighting)、<strong>漫反射光照</strong>(Diffuse Lighting)和<strong>镜面光照</strong>(Specular Lighting)。通过为每个分量指定一个颜色，我们就能够对物体的颜色输出有着精细的控制了。现在，我们<strong>再添加反光度</strong>(Shininess)这个分量到上述的三个颜色中，这就有我们需要的所有材质属性了：</p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#version 330 core</span></span><br><span class="line">struct Material &#123;</span><br><span class="line">    <span class="type">vec3</span> ambient;</span><br><span class="line">    <span class="type">vec3</span> diffuse;</span><br><span class="line">    <span class="type">vec3</span> specular;</span><br><span class="line">    <span class="type">float</span> shininess;</span><br><span class="line">&#125;; </span><br><span class="line"></span><br><span class="line"><span class="keyword">uniform</span> Material material;</span><br></pre></td></tr></table></figure><p>在<strong>片段着色器</strong>中，我们创建一个<strong>结构体</strong>(Struct)来<strong>储存物体的材质属性</strong>。我们也可以把它们储存为独立的uniform值，<strong>但是作为一个结构体来储存会更有条理一些</strong>。我们首先定义结构体的<strong>布局</strong>(Layout)，然后使用刚创建的结构体为类型，简单地声明一个uniform变量。</p><p>你可以看到，<strong>我们为每个冯氏光照模型的分量都定义一个颜色向量</strong>。<strong>ambient材质</strong>向量定义了在<strong>环境光照下这个物体反射得是什么颜色</strong>，<strong>通常这是和物体颜色相同的颜色</strong>。<strong>diffuse材质</strong>向量定义了在漫反射光照下物体的颜色。（和环境光照一样）漫反射颜色也要<strong>设置为我们需要的物体颜色</strong>。<strong>specular材质</strong>向量设置的是镜面光照对物体的颜色影响（或者甚至可能反射一个物体特定的镜面高光颜色）。最后，<strong>shininess影响镜面高光的散射/半径</strong>。</p><p>这<strong>四个元素定义了一个物体的材质</strong>，通过它们我们能够模拟很多现实世界中的材质。<a target="_blank" rel="noopener" href="http://devernay.free.fr/cours/opengl/materials.html">devernay.free.fr</a>上的一个表格展示了几种材质属性，它们模拟了现实世界中的真实材质。下面的图片展示了几种现实世界的材质对我们的立方体的影响：</p><div align="center"><p><img src="/images/cpp-c2-f22.jpg"></p></div><p>可以看到，通过正确地指定一个物体的材质属性，我们对这个物体的感知也就不同了。效果非常明显，<strong>但是要想获得更真实的效果，我们最终需要更加复杂的形状，而不单单是一个立方体</strong>。在后面的教程中，我们会讨论更复杂的形状。</p><p>首先，让我们在着色器中实现这样的一个材质系统。</p><h3 id="设置材质"><a href="#设置材质" class="headerlink" title="设置材质"></a>设置材质</h3><p>我们在片段着色器中创建了一个材质结构体的uniform，所以下面我们希望<strong>修改一下光照的计算来顺应新的材质属性</strong>。由于所有材质变量都储存在结构体中，我们可以从uniform变量material中访问它们：</p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> main() &#123;</span><br><span class="line">    <span class="comment">// 环境光</span></span><br><span class="line">    <span class="type">vec3</span> ambient = lightColor * material.ambient;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 漫反射</span></span><br><span class="line">    <span class="type">vec3</span> norm = <span class="built_in">normalize</span>(Normal);</span><br><span class="line">    <span class="type">vec3</span> lightDir = <span class="built_in">normalize</span>(lightPos - FragPos);</span><br><span class="line">    <span class="type">float</span> diff = <span class="built_in">max</span>(<span class="built_in">dot</span>(norm, lightDir), <span class="number">0.0</span>);</span><br><span class="line">    <span class="type">vec3</span> diffuse = lightColor * (diff * material.diffuse);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 镜面光</span></span><br><span class="line">    <span class="type">vec3</span> viewDir = <span class="built_in">normalize</span>(viewPos - FragPos);</span><br><span class="line">    <span class="type">vec3</span> reflectDir = <span class="built_in">reflect</span>(-lightDir, norm);</span><br><span class="line">    <span class="type">float</span> spec = <span class="built_in">pow</span>(<span class="built_in">max</span>(<span class="built_in">dot</span>(viewDir, reflectDir), <span class="number">0.0</span>), material.shininess);</span><br><span class="line">    <span class="type">vec3</span> specular = lightColor * (spec * material.specular);</span><br><span class="line"></span><br><span class="line">    <span class="type">vec3</span> result = ambient + diffuse + specular;</span><br><span class="line">    FragColor = <span class="type">vec4</span>(result, <span class="number">1.0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，我们现在在需要的地方访问了材质结构体中的所有属性，并且这次是根据材质的颜色来计算最终的输出颜色的。<strong>物体的每个材质属性都乘上了它们对应的光照分量</strong>。</p><p>我们现在可以在程序中设置适当的uniform，对物体设置材质了。GLSL中的结构体在设置uniform时并没有什么特别之处。<strong>结构体只是作为uniform变量的一个封装</strong>，所以如果想填充这个结构体的话，<strong>我们仍需要对每个单独的uniform进行设置</strong>，但这次要<strong>带上结构体名的前缀</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">lightingShader.setVec3(<span class="string">&quot;material.ambient&quot;</span>, <span class="number">1.0f</span>, <span class="number">0.5f</span>, <span class="number">0.31f</span>);</span><br><span class="line">lightingShader.setVec3(<span class="string">&quot;material.diffuse&quot;</span>, <span class="number">1.0f</span>, <span class="number">0.5f</span>, <span class="number">0.31f</span>);</span><br><span class="line">lightingShader.setVec3(<span class="string">&quot;material.specular&quot;</span>, <span class="number">0.5f</span>, <span class="number">0.5f</span>, <span class="number">0.5f</span>);</span><br><span class="line">lightingShader.setFloat(<span class="string">&quot;material.shininess&quot;</span>, <span class="number">32.0f</span>);</span><br></pre></td></tr></table></figure><p>我们将<strong>环境光和漫反射分量设置成我们想要让物体所拥有的颜色</strong>，而将<strong>镜面分量设置为一个中等亮度的颜色</strong>，我们不希望镜面分量在这个物体上过于强烈。我们将反光度保持为32。现在我们能够程序中非常容易地修改物体的材质了。</p><p>运行程序，你应该会得到下面这样的结果：</p><div align="center"><p><img src="/images/learnopengl-c2-f12.jpg"></p></div><p>但它看起来很奇怪不是吗？</p><h3 id="光的属性"><a href="#光的属性" class="headerlink" title="光的属性"></a>光的属性</h3><p>这个物体太亮了。<strong>物体过亮的原因是环境光、漫反射和镜面光这三个颜色对任何一个光源都会去全力反射</strong>。光源对环境光、漫反射和镜面光分量<strong>也具有着不同的强度</strong>。前面的教程，我们通过使用一个强度值改变环境光和镜面光强度的方式解决了这个问题。我们想做一个类似的系统，但是这次是要为<strong>每个光照分量都指定一个强度向量</strong>。</p><p><strong>我们希望为光照属性创建一个与材质结构体类似的结构体</strong>：</p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">struct Light &#123;</span><br><span class="line">    <span class="type">vec3</span> position;</span><br><span class="line"></span><br><span class="line">    <span class="type">vec3</span> ambient;</span><br><span class="line">    <span class="type">vec3</span> diffuse;</span><br><span class="line">    <span class="type">vec3</span> specular;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">uniform</span> Light light;</span><br></pre></td></tr></table></figure><p>一个光源对它的<code>ambient</code>、<code>diffuse</code>和<code>specular</code><strong>光照有着不同的强度</strong>。环境光照通常会设置为一个比较低的强度，因为我们不希望环境光颜色太过显眼。光源的漫反射分量通常设置为光所具有的颜色，通常是一个比较明亮的白色。镜面光分量通常会保持为vec3(1.0)，以最大强度发光。注意我们也将光源的位置添加到了结构体中。</p><p>和材质uniform一样，我们需要更新片段着色器：</p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">vec3</span> ambient  = light.ambient * material.ambient;</span><br><span class="line"><span class="type">vec3</span> diffuse  = light.diffuse * (diff * material.diffuse);</span><br><span class="line"><span class="type">vec3</span> specular = light.specular * (spec * material.specular);</span><br></pre></td></tr></table></figure><p>我们接下来在程序中设置光照强度：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">lightingShader.setVec3(<span class="string">&quot;light.position&quot;</span>, lightPos);</span><br><span class="line">lightingShader.setVec3(<span class="string">&quot;light.ambient&quot;</span>,  <span class="number">0.2f</span>, <span class="number">0.2f</span>, <span class="number">0.2f</span>);</span><br><span class="line">lightingShader.setVec3(<span class="string">&quot;light.diffuse&quot;</span>,  <span class="number">0.5f</span>, <span class="number">0.5f</span>, <span class="number">0.5f</span>); <span class="comment">// 将光照调暗了一些以搭配场景</span></span><br><span class="line">lightingShader.setVec3(<span class="string">&quot;light.specular&quot;</span>, <span class="number">1.0f</span>, <span class="number">1.0f</span>, <span class="number">1.0f</span>);</span><br></pre></td></tr></table></figure><p>现在我们调整了光照对物体材质的影响，我们应该能得到一个更类似于上一节的视觉效果。但这次我们有了对光照和物体材质的完全掌控：</p><div align="center"><p><img src="/images/learnopengl-c2-f13.jpg"></p></div><h3 id="不同的光源颜色"><a href="#不同的光源颜色" class="headerlink" title="不同的光源颜色"></a>不同的光源颜色</h3><p>到目前为止，我们都只对光源设置了从白到灰到黑范围内的颜色，这样只会改变物体各个分量的强度，而不是它的真正颜色。<strong>由于现在能够非常容易地访问光照的属性了，我们可以随着时间改变它们的颜色，从而获得一些非常有意思的效果</strong>。由于所有的东西都在片段着色器中配置好了，修改光源的颜色非常简单，我们能够立刻创造一些很有趣的效果。</p><p>我们可以利用sin和glfwGetTime函数<strong>改变光源的环境光和漫反射颜色</strong>，从而很容易地让光源的颜色随着时间变化：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">glm::vec3 lightColor;</span><br><span class="line">lightColor.x = <span class="built_in">sin</span>(glfwGetTime() * <span class="number">2.0f</span>);</span><br><span class="line">lightColor.y = <span class="built_in">sin</span>(glfwGetTime() * <span class="number">0.7f</span>);</span><br><span class="line">lightColor.z = <span class="built_in">sin</span>(glfwGetTime() * <span class="number">1.3f</span>);</span><br><span class="line"></span><br><span class="line">glm::vec3 diffuseColor = lightColor   * glm::vec3(<span class="number">0.5f</span>); <span class="comment">// 降低影响</span></span><br><span class="line">glm::vec3 ambientColor = diffuseColor * glm::vec3(<span class="number">0.2f</span>); <span class="comment">// 很低的影响</span></span><br><span class="line"></span><br><span class="line">lightingShader.setVec3(<span class="string">&quot;light.ambient&quot;</span>, ambientColor);</span><br><span class="line">lightingShader.setVec3(<span class="string">&quot;light.diffuse&quot;</span>, diffuseColor);</span><br></pre></td></tr></table></figure><div align="center"><p><img src="/images/learnopengl-c2-f14.jpg"></p></div><h3 id="练习-1"><a href="#练习-1" class="headerlink" title="练习"></a>练习</h3><ul><li>你能像教程一开始那样，定义相应的材质来模拟现实世界的物体吗？注意材质表格中的环境光值可能与漫反射值不一样，它们没有考虑光照的强度。要想纠正这一问题，你需要将所有的光照强度都设置为vec3(1.0)，这样才能得到正确的输出。</li></ul><h2 id="光照贴图"><a href="#光照贴图" class="headerlink" title="光照贴图"></a>光照贴图</h2><p>在上一节中，我们讨论了让每个物体都拥有自己独特的材质从而对光照做出不同的反应的方法。这样子能够很容易在一个光照的场景中给每个物体一个独特的外观，<strong>但是这仍不能对一个物体的视觉输出提供足够多的灵活性</strong>。</p><p>在上一节中，<strong>我们将整个物体的材质定义为一个整体</strong>，但现实世界中的物体通常并不只包含有一种材质，<strong>而是由多种材质所组成</strong>。想想一辆汽车：它的外壳非常有光泽，车窗会部分反射周围的环境，轮胎不会那么有光泽，所以它没有镜面高光，轮毂非常闪亮（如果你洗车了的话）。汽车同样会有漫反射和环境光颜色，它们在整个物体上也不会是一样的，汽车有着许多种不同的环境光/漫反射颜色。<strong>总之，这样的物体在不同的部件上都有不同的材质属性</strong>。</p><p>所以，上一节中的那个材质系统是肯定不够的，它只是一个最简单的模型，所以我们需要拓展之前的系统，引入<strong>漫反射贴图</strong>和<strong>镜面光贴图</strong>。这允许我们<strong>对物体的漫反射分量</strong>（以及间接地对环境光分量，它们几乎总是一样的）和<strong>镜面光分量有着更精确的控制</strong>。</p><h3 id="漫反射贴图"><a href="#漫反射贴图" class="headerlink" title="漫反射贴图"></a>漫反射贴图</h3><p>我们希望通过<strong>某种方式对物体的每个片段单独设置漫反射颜色</strong>。有能够让我们根据片段在物体上的位置来获取颜色值得系统吗？</p><p>这可能听起来很熟悉，而且<strong>事实上这个系统我们已经使用很长时间了</strong>。这听起来很像在之前教程中详细讨论过的纹理，而这基本就是这样：<strong>一个纹理</strong>。我们仅仅是对同样的原理使用了不同的名字：<strong>其实都是使用一张覆盖物体的图像</strong>，让我们能够逐片段索引其独立的颜色值。在光照场景中，它通常叫做一个<strong>漫反射贴图</strong>(Diffuse Map)（3D艺术家通常都这么叫它），它是一个表现了物体<strong>所有的漫反射颜色的纹理图像</strong>。</p><p>为了演示漫反射贴图，我们将会使用下面的图片，它是一个有钢边框的木箱：</p><div align="center"><p><img src="/images/learnopengl-c2-f15.jpg"></p></div><p>在着色器中使用漫反射贴图的方法和纹理教程中是完全一样的。但<strong>这次我们会将纹理储存</strong>为<strong>Material结构体</strong>中的一个<strong>sampler2D</strong>。我们将<strong>之前定义的vec3漫反射颜色向量替换为漫反射贴图</strong>。</p><p>注意sampler2D是所谓的<strong>不透明类型</strong>(Opaque Type)，也就是说我们<strong>不能将它实例化</strong>，只能通过uniform来<strong>定义它</strong>。如果我们使用除uniform以外的方法（比如函数的参数）实例化这个结构体，GLSL会抛出一些奇怪的错误。这同样<strong>也适用于任何封装了不透明类型的结构体</strong>。</p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">struct Material &#123;</span><br><span class="line">    <span class="type">sampler2D</span> diffuse;</span><br><span class="line">    <span class="type">vec3</span>      specular;</span><br><span class="line">    <span class="type">float</span>     shininess;</span><br><span class="line">&#125;; </span><br><span class="line">...</span><br><span class="line"><span class="keyword">in</span> <span class="type">vec2</span> TexCoords;</span><br></pre></td></tr></table></figure><p>如果你非常固执，仍想将环境光颜色设置为一个（漫反射值之外）不同的值，你也可以保留这个环境光的vec3，<strong>但整个物体仍只能拥有一个环境光颜色</strong>。如果想要对不同片段有不同的环境光值，你需要对环境光值单独使用另外一个纹理。</p><p>注意我们将在片段着色器中<strong>再次需要纹理坐标</strong>，所以我们声明一个额外的输入变量。接下来我们只需要从纹理中采样片段的漫反射颜色值即可：</p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">vec3</span> diffuse = light.diffuse * diff * <span class="type">vec3</span>(<span class="built_in">texture</span>(material.diffuse, TexCoords));</span><br></pre></td></tr></table></figure><p>不要忘记将环境光得材质颜色设置为漫反射材质颜色同样的值。</p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">vec3</span> ambient = light.ambient * <span class="type">vec3</span>(<span class="built_in">texture</span>(material.diffuse, TexCoords));</span><br></pre></td></tr></table></figure><p>这就是使用漫反射贴图的全部步骤了。你可以看到，这并不是什么新的东西，但这能够极大地提高视觉品质。为了让它正常工作，<strong>我们还需要使用纹理坐标更新顶点数据，将它们作为顶点属性传递到片段着色器，加载材质并绑定材质到合适的纹理单元</strong>。</p><p>更新后的顶点数据：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">float</span> vertices[] = &#123;</span><br><span class="line">    <span class="comment">// positions          // normals           // texture coords</span></span><br><span class="line">    <span class="number">-0.5f</span>, <span class="number">-0.5f</span>, <span class="number">-0.5f</span>,  <span class="number">0.0f</span>,  <span class="number">0.0f</span>, <span class="number">-1.0f</span>,  <span class="number">0.0f</span>, <span class="number">0.0f</span>,</span><br><span class="line">     <span class="number">0.5f</span>, <span class="number">-0.5f</span>, <span class="number">-0.5f</span>,  <span class="number">0.0f</span>,  <span class="number">0.0f</span>, <span class="number">-1.0f</span>,  <span class="number">1.0f</span>, <span class="number">0.0f</span>,</span><br><span class="line">     <span class="number">0.5f</span>,  <span class="number">0.5f</span>, <span class="number">-0.5f</span>,  <span class="number">0.0f</span>,  <span class="number">0.0f</span>, <span class="number">-1.0f</span>,  <span class="number">1.0f</span>, <span class="number">1.0f</span>,</span><br><span class="line">     <span class="number">0.5f</span>,  <span class="number">0.5f</span>, <span class="number">-0.5f</span>,  <span class="number">0.0f</span>,  <span class="number">0.0f</span>, <span class="number">-1.0f</span>,  <span class="number">1.0f</span>, <span class="number">1.0f</span>,</span><br><span class="line">    <span class="number">-0.5f</span>,  <span class="number">0.5f</span>, <span class="number">-0.5f</span>,  <span class="number">0.0f</span>,  <span class="number">0.0f</span>, <span class="number">-1.0f</span>,  <span class="number">0.0f</span>, <span class="number">1.0f</span>,</span><br><span class="line">    <span class="number">-0.5f</span>, <span class="number">-0.5f</span>, <span class="number">-0.5f</span>,  <span class="number">0.0f</span>,  <span class="number">0.0f</span>, <span class="number">-1.0f</span>,  <span class="number">0.0f</span>, <span class="number">0.0f</span>,</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>顶点数据现在包含了<strong>顶点位置、法向量和立方体顶点处的纹理坐标</strong>。让我们<strong>更新顶点着色器</strong>来以顶点属性的形式接受纹理坐标，并将它们传递到片段着色器中：</p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#version 330 core</span></span><br><span class="line"><span class="keyword">layout</span> (<span class="keyword">location</span> = <span class="number">0</span>) <span class="keyword">in</span> <span class="type">vec3</span> aPos;</span><br><span class="line"><span class="keyword">layout</span> (<span class="keyword">location</span> = <span class="number">1</span>) <span class="keyword">in</span> <span class="type">vec3</span> aNormal;</span><br><span class="line"><span class="keyword">layout</span> (<span class="keyword">location</span> = <span class="number">2</span>) <span class="keyword">in</span> <span class="type">vec2</span> aTexCoords;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">out</span> <span class="type">vec2</span> TexCoords;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> main() &#123;</span><br><span class="line">    ...</span><br><span class="line">    TexCoords = aTexCoords;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>记得去<strong>更新两个VAO的顶点属性指针来匹配新的顶点数据</strong>，并<strong>加载箱子图像为一个纹理</strong>。在绘制箱子之前，我们希望将要用的纹理单元赋值到material.diffuse这个uniform采样器，并绑定箱子的纹理到这个纹理单元：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">lightingShader.setInt(<span class="string">&quot;material.diffuse&quot;</span>, <span class="number">0</span>);</span><br><span class="line">...</span><br><span class="line">glActiveTexture(GL_TEXTURE0);</span><br><span class="line">glBindTexture(GL_TEXTURE_2D, diffuseMap);</span><br></pre></td></tr></table></figure><p>使用了漫反射贴图之后，细节再一次得到惊人的提升，这次箱子有了光照开始闪闪发光了。你的箱子看起来可能像这样：</p><div align="center"><p><img src="/images/learnopengl-c2-f16.jpg"></p></div><h3 id="镜面光贴图"><a href="#镜面光贴图" class="headerlink" title="镜面光贴图"></a>镜面光贴图</h3><p>你可能会注意到，<strong>镜面高光看起来有些奇怪，因为我们的物体大部分都是木头，我们知道木头不应该有这么强的镜面高光的</strong>。我们可以将物体的镜面光材质设置为vec3(0.0)来解决这个问题，但这也意味着箱子钢制的边框将不再能够显示镜面高光了，我们知道<strong>钢铁应该是有一些镜面高光的</strong>。所以，<strong>我们想要让物体的某些部分以不同的强度显示镜面高光</strong>。这个问题看起来和漫反射贴图非常相似。是巧合吗？我想不是。</p><p>我们同样可以使用一个<strong>专门用于镜面高光的纹理贴图</strong>。这也就意味着我们需要生成一个<strong>黑白的</strong>（如果你想得话也可以是彩色的）纹理，来定义<strong>物体每部分的镜面光强度</strong>。下面是一个<strong>镜面光贴图</strong>(Specular Map)的例子：</p><div align="center"><p><img src="/images/learnopengl-c2-f17.jpg"></p></div><p>镜面高光的强度<strong>可以通过图像每个像素的亮度来获取</strong>。镜面光贴图上的每个像素都可以由一个颜色向量来表示，比如说黑色代表颜色向量vec3(0.0)，灰色代表颜色向量vec3(0.5)。在片段着色器中，我们接下来会<strong>取样对应的颜色值并将它乘以光源的镜面强度</strong>。一个像素越「白」，<strong>乘积就会越大，物体的镜面光分量就会越亮</strong>。</p><p>由于箱子大部分都由木头所组成，而且木头材质应该没有镜面高光，<strong>所以漫反射纹理的整个木头部分全部都转换成了黑色。箱子钢制边框的镜面光强度是有细微变化的，钢铁本身会比较容易受到镜面高光的影响，而裂缝则不会</strong>。</p><p>从实际角度来说，木头其实也有镜面高光，尽管它的<strong>反光度</strong>(Shininess)<strong>很小</strong>（更多的光被散射），影响也比较小，但是为了教学目的，我们可以假设木头不会对镜面光有任何反应。</p><p>使用Photoshop或Gimp之类的工具，<strong>将漫反射纹理转换为镜面光纹理还是比较容易的</strong>，只需要剪切掉一些部分，<strong>将图像转换为黑白的</strong>，并<strong>增加亮度/对比度</strong>就好了。</p><p><strong>采样镜面光贴图</strong></p><p>镜面光贴图和其它的纹理非常类似，所以代码也和漫反射贴图的代码很类似。记得要保证正确地加载图像并生成一个纹理对象。<strong>由于我们正在同一个片段着色器中使用另一个纹理采样器，我们必须要对镜面光贴图使用一个不同的纹理单元</strong>，所以我们在渲染之前先把它绑定到合适的纹理单元上：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">lightingShader.setInt(<span class="string">&quot;material.specular&quot;</span>, <span class="number">1</span>);</span><br><span class="line">...</span><br><span class="line">glActiveTexture(GL_TEXTURE1);</span><br><span class="line">glBindTexture(GL_TEXTURE_2D, specularMap);</span><br></pre></td></tr></table></figure><p>接下来更新<strong>片段着色器的材质属性</strong>，让其接受一个sampler2D而不是vec3作为镜面光分量：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Material</span> &#123;</span></span><br><span class="line">    sampler2D diffuse;</span><br><span class="line">    sampler2D specular;</span><br><span class="line">    <span class="keyword">float</span>     shininess;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>最后我们希望采样镜面光贴图，来获取片段所对应的镜面光强度：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vec3 specular = light.specular * spec * vec3(texture(material.specular, TexCoords));</span><br></pre></td></tr></table></figure><p>通过使用镜面光贴图我们可以可以对物体设置大量的细节，<strong>比如物体的哪些部分需要有闪闪发光的属性，我们甚至可以设置它们对应的强度</strong>。镜面光贴图能够在漫反射贴图之上给予我们更高一层的控制。</p><p>如果你想另辟蹊径，你<strong>也可以在镜面光贴图中使用真正的颜色</strong>，不仅设置每个片段的镜面光强度，还设置了镜面高光的颜色。<strong>从现实角度来说，镜面高光的颜色大部分</strong>（甚至全部）<strong>都是由光源本身所决定的</strong>，所以这样<strong>并不能生成非常真实的视觉效果</strong>（这也是为什么图像通常是黑白的，我们只关心强度）。</p><p>如果你现在运行程序的话，你可以清楚地看到箱子的材质现在和真实的钢制边框箱子非常类似了：</p><div align="center"><p><img src="/images/learnopengl-c2-f18.jpg"></p></div><p><strong>通过使用漫反射和镜面光贴图，我们可以给相对简单的物体添加大量的细节</strong>。我们甚至可以使用<strong>法线/凹凸贴图</strong>(Normal/Bump Map)或者<strong>反射贴图</strong>(Reflection Map)给物体添加更多的细节，但这些将会留到之后的教程中。</p><h3 id="练习题"><a href="#练习题" class="headerlink" title="练习题"></a>练习题</h3><ul><li>调整光源的环境光、漫反射和镜面光向量，看看它们如何影响箱子的视觉输出。</li><li>尝试在片段着色器中反转镜面光贴图的颜色值，让木头显示镜面高光而钢制边缘不反光（由于钢制边缘中有一些裂缝，边缘仍会显示一些镜面高光，虽然强度会小很多）。</li><li>使用漫反射贴图创建一个彩色而不是黑白的镜面光贴图，看看结果看起来并不是那么真实了。如果你不会生成的话，可以使用这张彩色的镜面光贴图。</li><li>添加一个叫做<strong>放射光贴图</strong>(Emission Map)的东西，它是一个<strong>储存了每个片段的发光值</strong>(Emission Value)的贴图。发光值是一个包含（假设）<strong>光源的物体发光</strong>(Emit)<strong>时可能显现的颜色</strong>，这样的话物体就能够<strong>忽略光照条件进行发光</strong>(Glow)。游戏中某个物体在发光的时候，你通常看到的就是<strong>放射光贴图</strong>（比如 机器人的眼，或是箱子上的灯带）。将这个纹理（作者为 creativesam）作为<strong>放射光贴图添加到箱子上，产生这些字母都在发光的效果</strong>。</li></ul><h2 id="投光物"><a href="#投光物" class="headerlink" title="投光物"></a>投光物</h2><p>我们目前使用的光照都来自于空间中的一个点。它能给我们不错的效果，但现实世界中，我们有很多种类的光照，每种的表现都不同。将<strong>光投射</strong>(Cast)到物体的光源叫做<strong>投光物</strong>(Light Caster)。在这一节中，我们将会讨论几种<strong>不同类型的投光物</strong>。学会模拟不同种类的光源是又一个能够进一步丰富场景的工具。</p><p>我们首先将会讨论<strong>定向光</strong>(Directional Light)，接下来是<strong>点光源</strong>(Point Light)，它是我们之前学习的光源的拓展，最后我们将会讨论<strong>聚光</strong>(Spotlight)。在下一节中我们将讨论如何将这些不同种类的光照类型整合到一个场景之中。</p><h3 id="平行光"><a href="#平行光" class="headerlink" title="平行光"></a>平行光</h3><p><strong>当一个光源处于很远的地方时，来自光源的每条光线就会近似于互相平行</strong>。不论物体和/或者观察者的位置，看起来好像所有的光都来自于同一个方向。当我们使用一个假设光源处于无限远处的模型时，它就被称为定向光，因为它的所有光线都有着相同的方向，它与光源的位置是没有关系的。</p><p><strong>定向光非常好的一个例子就是太阳</strong>。太阳距离我们并不是无限远，但它已经远到在光照计算中可以把它视为无限远了。所以来自太阳的所有光线将被模拟为平行光线，我们可以在下图看到：</p><div align="center"><p><img src="/images/learnopengl-c2-f19.jpg"></p></div><p>因为所有的光线都是平行的，所以物体与光源的相对位置是不重要的，因为对场景中每一个物体光的方向都是一致的。<strong>由于光的位置向量保持一致，场景中每个物体的光照计算将会是类似的</strong>。</p><p>我们可以<strong>定义一个光线方向向量而不是位置向量来模拟一个定向光</strong>。着色器的计算基本保持不变，但这次我们将直接使用光的direction向量而不是通过direction来计算lightDir向量。</p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">struct Light &#123;</span><br><span class="line">    <span class="comment">// vec3 position; // 使用定向光就不再需要了</span></span><br><span class="line">    <span class="type">vec3</span> direction;</span><br><span class="line"></span><br><span class="line">    <span class="type">vec3</span> ambient;</span><br><span class="line">    <span class="type">vec3</span> diffuse;</span><br><span class="line">    <span class="type">vec3</span> specular;</span><br><span class="line">&#125;;</span><br><span class="line">...</span><br><span class="line"><span class="type">void</span> main() &#123;</span><br><span class="line">  <span class="type">vec3</span> lightDir = <span class="built_in">normalize</span>(-light.direction);</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意我们首先对<code>light.direction</code><strong>向量取反</strong>。我们目前使用的光照计算需求<strong>一个从片段至光源的光线方向</strong>，但人们更习惯定义<strong>定向光为一个从光源出发的全局方向</strong>。所以我们需要对全局光照方向向量取反来改变它的方向，它现在是一个指向光源的方向向量了。而且，记得对向量进行标准化，假设输入向量为一个单位向量是很不明智的。</p><p>最终的<code>lightDir</code>向量将和以前一样用在漫反射和镜面光计算中。</p><p>为了清楚地展示定向光对多个物体具有相同的影响，我们将会再次使用坐标系统章节最后的那个箱子派对的场景。如果你错过了派对，<strong>我们先定义了十个不同的箱子位置，并对每个箱子都生成了一个不同的模型矩阵，每个模型矩阵都包含了对应的局部-世界坐标变换</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">unsigned</span> <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">    glm::mat4 model;</span><br><span class="line">    model = glm::translate(model, cubePositions[i]);</span><br><span class="line">    <span class="keyword">float</span> angle = <span class="number">20.0f</span> * i;</span><br><span class="line">    model = glm::rotate(model, glm::radians(angle), glm::vec3(<span class="number">1.0f</span>, <span class="number">0.3f</span>, <span class="number">0.5f</span>));</span><br><span class="line">    lightingShader.setMat4(<span class="string">&quot;model&quot;</span>, model);</span><br><span class="line"></span><br><span class="line">    glDrawArrays(GL_TRIANGLES, <span class="number">0</span>, <span class="number">36</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同时，不要忘记定义光源的方向（注意我们将方向定义为从光源出发的方向，你可以很容易看到光的方向朝下）。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lightingShader.setVec3(<span class="string">&quot;light.direction&quot;</span>, <span class="number">-0.2f</span>, <span class="number">-1.0f</span>, <span class="number">-0.3f</span>);</span><br></pre></td></tr></table></figure><p>我们一直将光的位置和位置向量定义为vec3，<strong>但一些人会喜欢将所有的向量都定义为vec4</strong>。当我们将<strong>位置向量</strong>定义为一个vec4时，<strong>很重要的一点是要将w分量设置为1.0</strong>，这样变换和投影才能正确应用。然而，当我们定义一个<strong>方向向量为vec4的时候</strong>，我们不想让位移有任何的效果（因为它仅仅代表的是方向），所以我们将<strong>w分量设置为0.0</strong>。</p><p>方向向量就会像这样来表示：vec4(0.2f, 1.0f, 0.3f, <strong>0.0f</strong>)。这也可以作为一个快速检测光照类型的工具：你可以检测w分量是否等于1.0，来检测它是否是光的位置向量；w分量等于0.0，则它是光的方向向量，这样就能根据这个来调整光照计算了：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(lightVector.w == <span class="number">0.0</span>) <span class="comment">// 注意浮点数据类型的误差</span></span><br><span class="line">  <span class="comment">// 执行定向光照计算</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(lightVector.w == <span class="number">1.0</span>)</span><br><span class="line">  <span class="comment">// 根据光源的位置做光照计算（与上一节一样）</span></span><br></pre></td></tr></table></figure><p>这正是旧OpenGL（固定函数式）<strong>决定光源是定向光还是位置光源</strong>(Positional Light Source)的方法，并根据它来调整光照。</p><p>如果你现在编译程序，在场景中自由移动，你就可以看到好像有一个太阳一样的光源对所有的物体投光。</p><div align="center"><p><img src="/images/learnopengl-c2-f20.jpg"></p></div><h3 id="点光源"><a href="#点光源" class="headerlink" title="点光源"></a>点光源</h3><p><strong>定向光对于照亮整个场景的全局光源是非常棒的</strong>，但除了定向光之外我们也需要一些<strong>分散在场景中的点光源</strong>(Point Light)。点光源是处于世界中某一个位置的光源，它会<strong>朝着所有方向发光</strong>，<strong>但光线会随着距离逐渐衰减</strong>。想象作为投光物的灯泡和火把，它们都是点光源。</p><div align="center"><p><img src="/images/learnopengl-c2-f21.jpg"></p></div><p>在之前的教程中，我们一直都在使用一个<strong>简化的点光源</strong>。我们在给定位置有一个光源，它会从它的光源位置开始朝着所有方向散射光线。<strong>然而，我们定义的光源模拟的是永远不会衰减的光线，这看起来像是光源亮度非常的强</strong>。在大部分的3D模拟中，我们都希望<strong>模拟的光源仅照亮光源附近的区域而不是整个场景</strong>。</p><p>如果你将10个箱子加入到上一节光照场景中，你会注意到在最后面的箱子和在灯面前的箱子都以相同的强度被照亮，并没有定义一个公式来将光随距离衰减。<strong>我们希望在后排的箱子与前排的箱子相比仅仅是被轻微地照亮</strong>。</p><p><strong>衰减</strong></p><p><strong>随着光线传播距离的增长逐渐削减光的强度通常叫做衰减</strong>(Attenuation)。随距离减少光强度的<strong>一种方式是使用一个线性方程</strong>。这样的方程能够随着距离的增长线性地减少光的强度，从而让远处的物体更暗。然而，<strong>这样的线性方程通常会看起来比较假</strong>。在现实世界中，<strong>灯在近处通常会非常亮，但随着距离的增加光源的亮度一开始会下降非常快</strong>，但在<strong>远处时剩余的光强度就会下降的非常缓慢了</strong>。所以，我们需要一个不同的公式来减少光的强度。</p><p>幸运的是一些聪明的人已经帮我们解决了这个问题。下面这个公式根据片段距光源的距离计算了衰减值，之后我们会将它乘以光的强度向量：</p><div align="center"><p><img src="/images/learnopengl-c2-f22.jpg"></p></div><p>在这里d代表了片段距光源的距离。接下来为了计算衰减值，我们定义3个（可配置的）项：<strong>常数项Kc</strong>、<strong>一次项Kl</strong>和<strong>二次项Kq</strong>。</p><ul><li>常数项通常保持为1.0，<strong>它的主要作用是保证分母永远不会比1小</strong>，否则的话在某些距离上它反而会增加强度，这肯定不是我们想要的效果。</li><li>一次项会与距离值相乘，以线性的方式减少强度。</li><li>二次项会与距离的平方相乘，让光源以二次递减的方式减少强度。二次项在距离比较小的时候影响会比一次项小很多，但当距离值比较大的时候它就会比一次项更大了。</li></ul><p>由于二次项的存在，<strong>光线会在大部分时候以线性的方式衰退，直到距离变得足够大，让二次项超过一次项，光的强度会以更快的速度下降</strong>。这样的结果就是，<strong>光在近距离时亮度很高，但随着距离变远亮度迅速降低，最后会以更慢的速度减少亮度</strong>。下面这张图显示了在100的距离内衰减的效果：</p><div align="center"><p><img src="/images/learnopengl-c2-f23.jpg"></p></div><p>原例中的图其实很难看出来在其描述的“距离变得足够大，光的强度会以更快的速度下降”，其实这只有在最初的一部分才是这样的，在那之后强度下降的速度就开始放缓了，在下面数学画图中可以更加清楚的看到这样的现象。</p><div align="center"><p><img src="/images/learnopengl-c2-f25.jpg"></p></div><p>你可以看到光在近距离的时候有着最高的强度，但随着距离增长，它的强度明显减弱，并缓慢地在距离大约100的时候强度接近0。这正是我们想要的。</p><p><strong>选择正确地值</strong></p><p>但是，该对这三个项设置什么值呢？<strong>正确地设定它们的值取决于很多因素</strong>：<strong>环境、希望光覆盖的距离、光的类型等</strong>。在大多数情况下，这都是经验的问题，以及适量的调整。下面这个表格显示了模拟一个（大概）真实的，覆盖特定半径（距离）的光源时，这些项可能取的一些值。<strong>第一列</strong>指定的是在给定的三项时光所<strong>能覆盖的距离</strong>。这些值是大多数光源很好的起始点，它们由Ogre3D的Wiki所提供：</p><div align="center"><p><img src="/images/learnopengl-c2-f24.jpg"></p></div><p>你可以看到，<strong>常数项Kc在所有的情况下都是1.0</strong>。一次项Kl为了覆盖更远的距离通常都很小，二次项Kq甚至更小。尝试对这些值进行实验，看看它们在你的实现中有什么效果。在我们的环境中，32到100的距离对大多数的光源都足够了。</p><p><strong>实现衰减</strong></p><p>为了实现衰减，在<strong>片段着色器中</strong>我们还需要<strong>三个额外的值</strong>：也就是公式中的<strong>常数项、一次项和二次项</strong>。它们最好储存在之前定义的Light结构体中。注意我们使用<strong>上一节中计算lightDir的方法</strong>，而不是上面定向光部分的。</p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">struct Light &#123;</span><br><span class="line">    <span class="type">vec3</span> position;</span><br><span class="line"></span><br><span class="line">    <span class="type">vec3</span> ambient;</span><br><span class="line">    <span class="type">vec3</span> diffuse;</span><br><span class="line">    <span class="type">vec3</span> specular;</span><br><span class="line"></span><br><span class="line">    <span class="type">float</span> constant;</span><br><span class="line">    <span class="type">float</span> linear;</span><br><span class="line">    <span class="type">float</span> quadratic;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>然后我们将在OpenGL中设置这些项。我们希望光源能够覆盖50的距离，所以我们会使用表格中对应的常数项、一次项和二次项：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">lightingShader.setFloat(<span class="string">&quot;light.constant&quot;</span>,  <span class="number">1.0f</span>);</span><br><span class="line">lightingShader.setFloat(<span class="string">&quot;light.linear&quot;</span>,    <span class="number">0.09f</span>);</span><br><span class="line">lightingShader.setFloat(<span class="string">&quot;light.quadratic&quot;</span>, <span class="number">0.032f</span>);</span><br></pre></td></tr></table></figure><p>在片段着色器中实现衰减还是比较直接的：我们根据公式计算衰减值，之后再分别乘以环境光、漫反射和镜面光分量。</p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">float</span> <span class="built_in">distance</span>    = <span class="built_in">length</span>(light.position - FragPos);</span><br><span class="line"><span class="type">float</span> attenuation = <span class="number">1.0</span> / (light.constant + light.linear * <span class="built_in">distance</span> + </span><br><span class="line">                light.quadratic * (<span class="built_in">distance</span> * <span class="built_in">distance</span>));</span><br></pre></td></tr></table></figure><p>接下来，我们将包含这个衰减值到光照计算中，将它分别乘以环境光、漫反射和镜面光颜色。</p><p><strong>我们可以将环境光分量保持不变</strong>，让环境光照不会随着距离减少，<strong>但是如果我们使用多于一个的光源，所有的环境光分量将会开始叠加</strong>，所以在这种情况下我们也希望衰减环境光照。</p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">vec3</span> result = attenuation * (ambient + diffuse + specular);</span><br></pre></td></tr></table></figure><div align="center"><p><img src="/images/learnopengl-c2-f26.jpg"></p></div><p>你可以看到，只有前排的箱子被照亮的，距离最近的箱子是最亮的。后排的箱子一点都没有照亮，因为它们离光源实在是太远了。你可以在这里找到程序的代码。</p><p>点光源就是一个能够配置位置和衰减的光源。它是我们光照工具箱中的又一个光照类型。</p><h3 id="聚光"><a href="#聚光" class="headerlink" title="聚光"></a>聚光</h3><p>我们要讨论的最后一种类型的光是<strong>聚光</strong>(Spotlight)。聚光是位于环境中某个位置的光源，<strong>它只朝一个特定方向而不是所有方向照射光线</strong>。这样的结果就是只有在聚光方向的<strong>特定半径内的物体才会被照亮</strong>，其它的物体都会保持黑暗。聚光很好的例子就是路灯或手电筒。</p><p>OpenGL中聚光是用一个<strong>世界空间位置</strong>、一个<strong>方向</strong>和一个<strong>切光角</strong>(Cutoff Angle)来表示的，<strong>切光角指定了聚光的半径</strong>（译注：是<strong>圆锥的半径不是距光源距离那个半径</strong>）。对于每个片段，我们会计算片段是否位于聚光的切光方向之间（也就是在锥形内），如果是的话，我们就会相应地照亮片段。下面这张图会让你明白聚光是如何工作的：</p><div align="center"><p><img src="/images/learnopengl-c2-f27.jpg"></p></div><ul><li>LightDir：从片段指向光源的向量。</li><li>SpotDir：聚光所指向的方向。</li><li><strong>Phi</strong>ϕ：指定了聚光半径的切光角。落在这个角度之外的物体都不会被这个聚光所照亮。</li><li><strong>Theta</strong>θ：LightDir向量和SpotDir向量之间的夹角。<strong>在聚光内部的话θ值应该比ϕ值小</strong>。</li></ul><p>所以我们要做的就是<strong>计算LightDir向量和SpotDir向量之间的点积</strong>（还记得它会返回两个单位向量夹角的余弦值吗？），并将它与<strong>切光角ϕ值对比</strong>。你现在应该了解聚光究竟是什么了，下面我们将以手电筒的形式创建一个聚光。</p><p><strong>手电筒</strong></p><p>手电筒(Flashlight)是一个<strong>位于观察者位置的聚光</strong>，通常它都会<strong>瞄准玩家视角的正前方</strong>。基本上说，手电筒就是普通的聚光，但它的位置和方向会随着玩家的位置和朝向不断更新。</p><p>所以，在<strong>片段着色器中</strong>我们需要的值有<strong>聚光的位置向量</strong>（来计算光的方向向量）、<strong>聚光的方向向量和一个切光角</strong>。我们可以将它们储存在Light结构体中：</p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">struct Light &#123;</span><br><span class="line">    <span class="type">vec3</span>  position;</span><br><span class="line">    <span class="type">vec3</span>  direction;</span><br><span class="line">    <span class="type">float</span> cutOff;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>接下来我们将合适的值传到着色器中：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">lightingShader.setVec3(<span class="string">&quot;light.position&quot;</span>,  camera.Position);</span><br><span class="line">lightingShader.setVec3(<span class="string">&quot;light.direction&quot;</span>, camera.Front);</span><br><span class="line">lightingShader.setFloat(<span class="string">&quot;light.cutOff&quot;</span>,   glm::<span class="built_in">cos</span>(glm::radians(<span class="number">12.5f</span>)));</span><br></pre></td></tr></table></figure><p>你可以看到，<strong>我们并没有给切光角设置一个角度值，反而是用角度值计算了一个余弦值，将余弦结果传递到片段着色器中</strong>。这样做的原因是在片段着色器中，我们会计算LightDir和SpotDir向量的点积，<strong>这个点积返回的将是一个余弦值而不是角度值，所以我们不能直接使用角度值和余弦值进行比较</strong>。为了获取角度值我们需要计算点积结果的反余弦，这是一个开销很大的计算。所以<strong>为了节约一点性能开销，我们将会计算切光角对应的余弦值，并将它的结果传入片段着色器中</strong>。由于这两个角度现在都由余弦角来表示了，我们可以直接对它们进行比较而不用进行任何开销高昂的计算。</p><p>接下来就是<strong>计算θ值</strong>，并将它和切光角ϕ对比，来决定是否在聚光的内部：</p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> main() &#123;</span><br><span class="line">    <span class="type">vec3</span> norm = <span class="built_in">normalize</span>(Normal);</span><br><span class="line">    <span class="type">vec3</span> lightDir = <span class="built_in">normalize</span>(light.position - FragPos);</span><br><span class="line">    ...</span><br><span class="line">    <span class="type">float</span> theta = <span class="built_in">dot</span>(lightDir, <span class="built_in">normalize</span>(-light.direction));</span><br><span class="line">    <span class="type">vec3</span> result;</span><br><span class="line">    <span class="keyword">if</span>(theta &gt; light.cutOff) &#123;</span><br><span class="line">        <span class="comment">// 执行光照计算</span></span><br><span class="line">        ...</span><br><span class="line">        <span class="type">float</span> <span class="built_in">distance</span> = <span class="built_in">length</span>(light.position - FragPos);</span><br><span class="line">        <span class="type">float</span> attenuation = <span class="number">1.0</span> / (light.constant + light.linear * <span class="built_in">distance</span> + </span><br><span class="line">                    light.quadratic * (<span class="built_in">distance</span> * <span class="built_in">distance</span>));</span><br><span class="line">    </span><br><span class="line">        result = attenuation * (ambient + diffuse + specular);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 否则，使用环境光，让场景在聚光之外时不至于完全黑暗</span></span><br><span class="line">        result = ambient;</span><br><span class="line">    &#125;</span><br><span class="line">    FragColor = <span class="type">vec4</span>(result, <span class="number">1.0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们首先计算了<strong>lightDir和取反的direction向量</strong>（取反的是因为我们想<strong>让向量指向光源而不是从光源出发</strong>）之间的点积。记住要对所有的相关向量标准化。</p><p>运行程序，你将会看到一个聚光，它仅会照亮聚光圆锥内的片段。看起来像是这样的：</p><div align="center"><p><img src="/images/learnopengl-c2-f28.jpg"></p></div><p>但这仍看起来有些假，<strong>主要是因为聚光有一圈硬边</strong>。当一个片段遇到聚光圆锥的边缘时，它会完全变暗，<strong>没有一点平滑的过渡</strong>。<strong>一个真实的聚光将会在边缘处逐渐减少亮度。</strong></p><p><strong>平滑/软化边缘</strong></p><p>为了创建一种看起来边缘平滑的聚光，我们需要模拟聚光有一个<strong>内圆锥</strong>(Inner Cone)和一个<strong>外圆锥</strong>(Outer Cone)。我们可以将内圆锥设置为上一部分中的那个圆锥，但我们也<strong>需要一个外圆锥，来让光从内圆锥逐渐减暗，直到外圆锥的边界</strong>。</p><p>为了创建一个外圆锥，我们只需要再定义一个余弦值来代表聚光方向向量和外圆锥向量（等于它的半径）的夹角。然后，<strong>如果一个片段处于内外圆锥之间，将会给它计算出一个0.0到1.0之间的强度值</strong>。如果片段在内圆锥之内，它的强度就是1.0，如果在外圆锥之外强度值就是0.0。</p><p>我们可以用下面这个公式来计算这个值：</p><div align="center"><p><img src="/images/learnopengl-c2-f29.jpg"></p></div><p>这里<strong>ϵ</strong>(Epsilon)是<strong>内</strong>（ϕ）和<strong>外圆锥</strong>（γ）之间的<strong>余弦值差</strong>（ϵ=ϕ−γ）。最终的<strong>I值就是在当前片段聚光的强度</strong>。</p><p>这基本上就是在内外余弦值之间根据θ插值。</p><p>我们现在有了一个<strong>在聚光外是负的，在内圆锥内大于1.0的，在边缘处于两者之间的强度值了</strong>。如果我们正确地<strong>约束(Clamp)这个值</strong>，在片段着色器中就不再需要if-else了，我们能够使用<strong>计算出来的强度值直接乘以光照分量</strong>：</p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> main() &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="type">float</span> theta = <span class="built_in">dot</span>(lightDir, <span class="built_in">normalize</span>(-light.direction));</span><br><span class="line">    <span class="type">float</span> epsilon = light.cutOff - light.outerCutOff;</span><br><span class="line">    <span class="type">float</span> intensity = <span class="built_in">clamp</span>((theta - light.outerCutOff) / epsilon, <span class="number">0.0</span>, <span class="number">1.0</span>);</span><br><span class="line">    ...</span><br><span class="line">    <span class="type">vec3</span> result = attenuation * (ambient + diffuse * intensity + specular * intensity);</span><br><span class="line"></span><br><span class="line">    FragColor = <span class="type">vec4</span>(result, <span class="number">1.0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意我们使用了clamp函数，它把第一个参数约束(Clamp)在了0.0到1.0之间。这保证强度值不会在[0, 1]区间之外。</p><p>确定你将outerCutOff值添加到了Light结构体之中，并在程序中设置它的uniform值。下面的图片中，我们使用的内切光角是12.5，外切光角是17.5：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">lightingShader.setFloat(<span class="string">&quot;light.cutOff&quot;</span>, glm::<span class="built_in">cos</span>(glm::radians(<span class="number">12.5f</span>)));</span><br><span class="line">lightingShader.setFloat(<span class="string">&quot;light.outerCutOff&quot;</span>, glm::<span class="built_in">cos</span>(glm::radians(<span class="number">17.5f</span>)));</span><br></pre></td></tr></table></figure><div align="center"><p><img src="/images/learnopengl-c2-f30.jpg"></p></div><p>啊，这样看起来就好多了。</p><h2 id="多光源"><a href="#多光源" class="headerlink" title="多光源"></a>多光源</h2><p>我们在前面的教程中已经学习了许多关于OpenGL中光照的知识，其中包括冯氏着色(Phong Shading)、材质(Material)、光照贴图(Lighting Map)以及不同种类的投光物(Light Caster)。在这一节中，我们将结合之前学过的所有知识，<strong>创建一个包含六个光源的场景</strong>。我们将模拟一个<strong>类似太阳的定向光</strong>(Directional Light)光源，<strong>四个分散在场景中的点光源</strong>(Point Light)，以及一个<strong>手电筒</strong>(Flashlight)。</p><p>为了在场景中使用多个光源，我们希望将<strong>光照计算封装到GLSL函数中</strong>。这样做的原因是，<strong>每一种光源都需要一种不同的计算方法</strong>，而一旦我们想对多个光源进行光照计算时，代码很快就会变得非常复杂。<strong>如果我们只在main函数中进行所有的这些计算，代码很快就会变得难以理解</strong>。</p><p>GLSL中的函数和C函数很相似，它有一个<strong>函数名</strong>、一个<strong>返回值类型</strong>，如果函数不是在main函数之前声明的，我们还必须在代码文件顶部声明一个原型。我们<strong>对每个光照类型都创建一个不同的函数</strong>：<strong>定向光、点光源和聚光</strong>。</p><p>当我们在场景中使用多个光源时，通常使用以下方法：我们需要有一个<strong>单独的颜色向量代表片段的输出颜色</strong>。对于<strong>每一个光源</strong>，它对片段的贡献颜色将会<strong>加到片段的输出颜色向量上</strong>。所以场景中的每个光源都会计算它们各自对片段的影响，并结合为一个最终的输出颜色。大体的结构会像是这样：</p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">out</span> <span class="type">vec4</span> FragColor;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> main()</span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// 定义一个输出颜色值</span></span><br><span class="line">  <span class="type">vec3</span> output;</span><br><span class="line">  <span class="comment">// 将定向光的贡献加到输出中</span></span><br><span class="line">  output += someFunctionToCalculateDirectionalLight();</span><br><span class="line">  <span class="comment">// 对所有的点光源也做相同的事情</span></span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; nr_of_point_lights; i++)</span><br><span class="line">    output += someFunctionToCalculatePointLight();</span><br><span class="line">  <span class="comment">// 也加上其它的光源（比如聚光）</span></span><br><span class="line">  output += someFunctionToCalculateSpotLight();</span><br><span class="line"></span><br><span class="line">  FragColor = <span class="type">vec4</span>(output, <span class="number">1.0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实际的代码对每一种实现都可能不同，但大体的结构都是差不多的。我们定义了几个函数，用来计算每个光源的影响，并将最终的结果颜色加到输出颜色向量上。<strong>例如，如果两个光源都很靠近一个片段，那么它们所结合的贡献将会形成一个比单个光源照亮时更加明亮的片段</strong>。</p><h3 id="定向光"><a href="#定向光" class="headerlink" title="定向光"></a>定向光</h3><p>我么需要在<strong>片段着色器中</strong>定义一个<strong>函数来计算定向光</strong>对相应片段的贡献：它接受<strong>一些参数并计算一个定向光照颜色</strong>。</p><p>首先，我们需要<strong>定义一个定向光源最少所需要的变量</strong>。我们可以将这些变量储存在一个叫做DirLight的结构体中，并将它定义为一个uniform。需要的变量在上一节中都介绍过：</p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">struct DirLight &#123;</span><br><span class="line">    <span class="type">vec3</span> direction;</span><br><span class="line"></span><br><span class="line">    <span class="type">vec3</span> ambient;</span><br><span class="line">    <span class="type">vec3</span> diffuse;</span><br><span class="line">    <span class="type">vec3</span> specular;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">uniform</span> DirLight dirLight;</span><br></pre></td></tr></table></figure><p>接下来我们可以将dirLight传入一个函数：</p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">vec3</span> CalcDirLight(DirLight light, <span class="type">vec3</span> normal, <span class="type">vec3</span> viewDir);</span><br></pre></td></tr></table></figure><p>和C/C++一样，<strong>如果我们想调用一个函数</strong>（这里是在main函数中调用），<strong>这个函数需要在调用者的行数之前被定义过</strong>。在这个例子中我们更喜欢在main函数以下定义函数，所以上面要求就不满足了。所以，我们需要在main函数之上定义函数的原型，这和C语言中是一样的。</p><p>你可以看到，这个函数需要一个DirLight结构体和其它两个向量来进行计算。如果你认真完成了上一节的话，这个函数的内容应该理解起来很容易：</p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">vec3</span> CalcDirLight(DirLight light, <span class="type">vec3</span> normal, <span class="type">vec3</span> viewDir) &#123;</span><br><span class="line">    <span class="type">vec3</span> lightDir = <span class="built_in">normalize</span>(-light.direction);</span><br><span class="line">    <span class="comment">// 漫反射着色</span></span><br><span class="line">    <span class="type">float</span> diff = <span class="built_in">max</span>(<span class="built_in">dot</span>(normal, lightDir), <span class="number">0.0</span>);</span><br><span class="line">    <span class="comment">// 镜面光着色</span></span><br><span class="line">    <span class="type">vec3</span> reflectDir = <span class="built_in">reflect</span>(-lightDir, normal);</span><br><span class="line">    <span class="type">float</span> spec = <span class="built_in">pow</span>(<span class="built_in">max</span>(<span class="built_in">dot</span>(viewDir, reflectDir), <span class="number">0.0</span>), material.shininess);</span><br><span class="line">    <span class="comment">// 合并结果</span></span><br><span class="line">    <span class="type">vec3</span> ambient  = light.ambient  * <span class="type">vec3</span>(<span class="built_in">texture</span>(material.diffuse, TexCoords));</span><br><span class="line">    <span class="type">vec3</span> diffuse  = light.diffuse  * diff * <span class="type">vec3</span>(<span class="built_in">texture</span>(material.diffuse, TexCoords));</span><br><span class="line">    <span class="type">vec3</span> specular = light.specular * spec * <span class="type">vec3</span>(<span class="built_in">texture</span>(material.specular, TexCoords));</span><br><span class="line">    <span class="keyword">return</span> (ambient + diffuse + specular);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="点光源-1"><a href="#点光源-1" class="headerlink" title="点光源"></a>点光源</h3><p>和定向光一样，我们也希望<strong>定义一个用于计算点光源对相应片段贡献</strong>，以及<strong>衰减</strong>，的函数。同样，我们定义一个包含了点光源所需所有变量的结构体：</p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">struct PointLight &#123;</span><br><span class="line">    <span class="type">vec3</span> position;</span><br><span class="line"></span><br><span class="line">    <span class="type">float</span> constant;</span><br><span class="line">    <span class="type">float</span> linear;</span><br><span class="line">    <span class="type">float</span> quadratic;</span><br><span class="line"></span><br><span class="line">    <span class="type">vec3</span> ambient;</span><br><span class="line">    <span class="type">vec3</span> diffuse;</span><br><span class="line">    <span class="type">vec3</span> specular;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">#define NR_POINT_LIGHTS 4</span></span><br><span class="line"><span class="keyword">uniform</span> PointLight pointLights[NR_POINT_LIGHTS];</span><br></pre></td></tr></table></figure><p>你可以看到，我们在GLSL中使用了<strong>预处理指令来定义了我们场景中点光源的数量</strong>。接着我们使用了这个<code>NR_POINT_LIGHTS</code>常量来创建了一个<code>PointLight</code><strong>结构体的数组</strong>。GLSL中的数组和C数组一样，可以使用一对方括号来创建。现在我们有<strong>四个待填充数据的PointLight结构体</strong>。</p><p>点光源函数的原型如下：</p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">vec3</span> CalcPointLight(PointLight light, <span class="type">vec3</span> normal, <span class="type">vec3</span> fragPos, <span class="type">vec3</span> viewDir);</span><br></pre></td></tr></table></figure><p>这个函数从参数中获取所需的所有数据，并返回一个代表该点光源对片段的颜色贡献的vec3。我们再一次聪明地从之前的教程中复制粘贴代码，完成了下面这样的函数：</p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">vec3</span> CalcPointLight(PointLight light, <span class="type">vec3</span> normal, <span class="type">vec3</span> fragPos, <span class="type">vec3</span> viewDir) &#123;</span><br><span class="line">    <span class="type">vec3</span> lightDir = <span class="built_in">normalize</span>(light.position - fragPos);</span><br><span class="line">    <span class="comment">// 漫反射着色</span></span><br><span class="line">    <span class="type">float</span> diff = <span class="built_in">max</span>(<span class="built_in">dot</span>(normal, lightDir), <span class="number">0.0</span>);</span><br><span class="line">    <span class="comment">// 镜面光着色</span></span><br><span class="line">    <span class="type">vec3</span> reflectDir = <span class="built_in">reflect</span>(-lightDir, normal);</span><br><span class="line">    <span class="type">float</span> spec = <span class="built_in">pow</span>(<span class="built_in">max</span>(<span class="built_in">dot</span>(viewDir, reflectDir), <span class="number">0.0</span>), material.shininess);</span><br><span class="line">    <span class="comment">// 衰减</span></span><br><span class="line">    <span class="type">float</span> <span class="built_in">distance</span>    = <span class="built_in">length</span>(light.position - fragPos);</span><br><span class="line">    <span class="type">float</span> attenuation = <span class="number">1.0</span> / (light.constant + light.linear * <span class="built_in">distance</span> + </span><br><span class="line">                 light.quadratic * (<span class="built_in">distance</span> * <span class="built_in">distance</span>));    </span><br><span class="line">    <span class="comment">// 合并结果</span></span><br><span class="line">    <span class="type">vec3</span> ambient  = light.ambient  * <span class="type">vec3</span>(<span class="built_in">texture</span>(material.diffuse, TexCoords));</span><br><span class="line">    <span class="type">vec3</span> diffuse  = light.diffuse  * diff * <span class="type">vec3</span>(<span class="built_in">texture</span>(material.diffuse, TexCoords));</span><br><span class="line">    <span class="type">vec3</span> specular = light.specular * spec * <span class="type">vec3</span>(<span class="built_in">texture</span>(material.specular, TexCoords));</span><br><span class="line">    <span class="keyword">return</span> attenuation * (ambient + diffuse + specular);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将这些功能抽象到这样一个函数中的优点是，我们<strong>能够不用重复的代码而很容易地计算多个点光源的光照了</strong>。在main函数中，我们<strong>只需要创建一个循环</strong>，遍历整个点光源数组，对每个点光源调用CalcPointLight就可以了。</p><h3 id="聚光-1"><a href="#聚光-1" class="headerlink" title="聚光"></a>聚光</h3><p>类似的：</p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">struct SpotLight &#123;</span><br><span class="line">    <span class="type">vec3</span> position;</span><br><span class="line">    <span class="type">vec3</span> direction;</span><br><span class="line">    <span class="type">float</span> cutOff;</span><br><span class="line">    <span class="type">float</span> outerCutOff;</span><br><span class="line"></span><br><span class="line">    <span class="type">float</span> constant;</span><br><span class="line">    <span class="type">float</span> linear;</span><br><span class="line">    <span class="type">float</span> quadratic;</span><br><span class="line"></span><br><span class="line">    <span class="type">vec3</span> ambient;</span><br><span class="line">    <span class="type">vec3</span> diffuse;</span><br><span class="line">    <span class="type">vec3</span> specular;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">uniform</span> SpotLight spotLight;</span><br></pre></td></tr></table></figure><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> CalcSpotLight(SpotLight light, <span class="type">vec3</span> normal, <span class="type">vec3</span> fragPos, <span class="type">vec3</span> viewDir) &#123;</span><br><span class="line">    <span class="type">vec3</span> lightDir = <span class="built_in">normalize</span>(light.position - fragPos);</span><br><span class="line">    <span class="type">float</span> theta = <span class="built_in">dot</span>(lightDir, <span class="built_in">normalize</span>(-light.direction));</span><br><span class="line">    <span class="type">float</span> epsilon = light.cutOff - light.outerCutOff;</span><br><span class="line">    <span class="type">float</span> intensity = <span class="built_in">clamp</span>((theta - light.outerCutOff) / epsilon, <span class="number">0.0</span>, <span class="number">1.0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 环境光</span></span><br><span class="line">    <span class="type">vec3</span> ambient = light.ambient * <span class="type">vec3</span>(<span class="built_in">texture</span>(material.diffuse, TexCoords));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 漫反射</span></span><br><span class="line">    <span class="type">float</span> diff = <span class="built_in">max</span>(<span class="built_in">dot</span>(norm, lightDir), <span class="number">0.0</span>);</span><br><span class="line">    <span class="type">vec3</span> diffuse = light.diffuse * diff * <span class="type">vec3</span>(<span class="built_in">texture</span>(material.diffuse, TexCoords));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 镜面光</span></span><br><span class="line">    <span class="type">vec3</span> viewDir = <span class="built_in">normalize</span>(viewPos - FragPos);</span><br><span class="line">    <span class="type">vec3</span> reflectDir = <span class="built_in">reflect</span>(-lightDir, norm);</span><br><span class="line">    <span class="type">float</span> spec = <span class="built_in">pow</span>(<span class="built_in">max</span>(<span class="built_in">dot</span>(viewDir, reflectDir), <span class="number">0.0</span>), material.shininess);</span><br><span class="line">    <span class="type">vec3</span> specular = light.specular * spec * <span class="type">vec3</span>(<span class="built_in">texture</span>(material.specular, TexCoords));</span><br><span class="line"></span><br><span class="line">    <span class="type">float</span> <span class="built_in">distance</span> = <span class="built_in">length</span>(light.position - FragPos);</span><br><span class="line">    <span class="type">float</span> attenuation = <span class="number">1.0</span> / (light.constant + light.linear * <span class="built_in">distance</span> + </span><br><span class="line">                light.quadratic * (<span class="built_in">distance</span> * <span class="built_in">distance</span>));</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> attenuation * (ambient + diffuse * intensity + specular * intensity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="合并结果"><a href="#合并结果" class="headerlink" title="合并结果"></a>合并结果</h3><p>现在我们已经定义了一个计算定向光的函数和一个计算点光源的函数了，我们可以将它们合并放到main函数中。</p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> main() &#123;</span><br><span class="line">    <span class="comment">// 属性</span></span><br><span class="line">    <span class="type">vec3</span> norm = <span class="built_in">normalize</span>(Normal);</span><br><span class="line">    <span class="type">vec3</span> viewDir = <span class="built_in">normalize</span>(viewPos - FragPos);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 第一阶段：定向光照</span></span><br><span class="line">    <span class="type">vec3</span> result = CalcDirLight(dirLight, norm, viewDir);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; NR_POINT_LIGHTS; i++) &#123;</span><br><span class="line">        result += CalcPointLight(pointLights[i], norm, FragPos, viewDir);</span><br><span class="line">    &#125;</span><br><span class="line">    result += CalcSpotLight(spotLight, norm, FragPos, viewDir);  </span><br><span class="line"></span><br><span class="line">    FragColor = <span class="type">vec4</span>(result, <span class="number">1.0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>每个光源类型都将它们的贡献加到了最终的输出颜色上，直到所有的光源都处理完了。<strong>最终的颜色包含了场景中所有光源的颜色影响所合并的结果</strong>。</p><p>设置定向光结构体的uniform应该非常熟悉了，<strong>但是你可能会在想我们该如何设置点光源的uniform值，因为点光源的uniform现在是一个PointLight的数组了</strong>。这并不是我们以前讨论过的话题。</p><p>很幸运的是，这并不是很复杂，<strong>设置一个结构体数组的uniform和设置一个结构体的uniform是很相似的</strong>，但是这一次在访问uniform位置的时候，我们需要<strong>定义对应的数组下标值</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lightingShader.setFloat(<span class="string">&quot;pointLights[0].constant&quot;</span>, <span class="number">1.0f</span>);</span><br></pre></td></tr></table></figure><p>在这里我们索引了pointLights数组中的第一个PointLight，并获取了constant变量的位置。但这也意味着不幸的是我们<strong>必须对这四个点光源手动设置uniform值，这让点光源本身就产生了28个uniform调用，非常冗长</strong>。你也可以尝试将这些抽象出去一点，定义一个点光源类，让它来为你设置uniform值，但最后你仍然要用这种方式设置所有光源的uniform值。</p><p>别忘了，<strong>我们还需要为每个点光源定义一个位置向量</strong>，所以我们让它们在场景中分散一点。我们会定义另一个<code>glm::vec3</code>数组来包含点光源的位置：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">glm::vec3 pointLightPositions[] = &#123;</span><br><span class="line">    glm::vec3( <span class="number">0.7f</span>,  <span class="number">0.2f</span>,  <span class="number">2.0f</span>),</span><br><span class="line">    glm::vec3( <span class="number">2.3f</span>, <span class="number">-3.3f</span>, <span class="number">-4.0f</span>),</span><br><span class="line">    glm::vec3(<span class="number">-4.0f</span>,  <span class="number">2.0f</span>, <span class="number">-12.0f</span>),</span><br><span class="line">    glm::vec3( <span class="number">0.0f</span>,  <span class="number">0.0f</span>, <span class="number">-3.0f</span>)</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>接下来我们从<code>pointLights</code>数组中索引对应的<code>PointLight</code>，将它的<code>position</code>值设置为刚刚定义的位置值数组中的其中一个。同时我们还要保证<strong>现在绘制的是四个灯立方体而不是仅仅一个</strong>。只要对每个灯物体创建一个不同的模型矩阵就可以了，和我们之前对箱子的处理类似。</p><p>如果你还使用了手电筒的话，所有光源组合的效果将看起来和下图差不多：</p><div align="center"><p><img src="/images/learnopengl-c2-f31.jpg"></p></div><p>你可以看到，很显然天空中有一个全局照明（像一个太阳），我们有四个光源分散在场景中，以及玩家视角的手电筒。看起来是不是非常不错？</p><p>上面图片中的所有光源都是使用上一节中所使用的默认属性，但如果你愿意实验这些数值的话，你能够得到很多有意思的结果。<strong>艺术家和关卡设计师通常都在编辑器中不断的调整这些光照参数，保证光照与环境相匹配。</strong>在我们刚刚创建的简单光照环境中，你可以简单地调整一下光源的属性，创建很多有意思的视觉效果：</p><p>我们也改变了清屏的颜色来更好地反应光照。你可以看到，只需要简单地调整一些光照参数，你就能创建完全不同的氛围。</p><div align="center"><p><img src="/images/learnopengl-c2-f32.jpg"></p></div><h2 id="复习"><a href="#复习" class="headerlink" title="复习"></a>复习</h2><p>总的来说我们在学习光照教程的时候，<strong>关于OpenGL本身并没有什么新东西</strong>，除了想访问uniform数组这样细枝末节的知识。目前为止的所有教程都是关于使用一些技巧或者公式来操作着色器，达到真实的光照效果。<strong>这再一次想你展示了着色器的威力。着色器是非常灵活的，你也亲眼见证了我们仅仅使用一些3D向量和可配置的变量就能够创造出惊人的图像这一点</strong>。</p><p>在前面的几个教程中，你学习了<strong>颜色、冯氏光照模型</strong>（包括环境光照、漫反射光照和镜面光照）、<strong>物体的材质、可配置的光照属性、漫反射和镜面光贴图、不同种类的光</strong>，并且学习了怎样将所有所学知识融会贯通，合并到一个程序当中。记得去实验一下不同的光照、材质颜色、光照属性，并且试着利用你无穷的创造力创建自己的环境。</p><p>在下一节当中，我们在我们的场景当中加入更高级的形状，这些形状将会在我们之前讨论过的光照模型中非常好看。</p><p>词汇表：</p><ul><li><strong>颜色向量</strong>(Color Vector)：一个通过红绿蓝(RGB)分量的组合描绘大部分真实颜色的向量。<strong>一个物体的颜色实际上是该物体所不能吸收的反射颜色分量</strong>。</li><li><strong>冯氏光照模型</strong>(Phong Lighting Model)：一个通过计算<strong>环境光，漫反射，和镜面光分量的值</strong>来估计真实光照的模型。</li><li><strong>环境光照</strong>(Ambient Lighting)：通过给每个没有被光照的物体很小的亮度，使其不是完全黑暗的，从而对全局光照进行估计。</li><li><strong>漫反射着色</strong>(Diffuse Shading)：一个<strong>顶点/片段与光线方向越接近，光照会越强</strong>。使用了法向量来计算角度。</li><li><strong>法向量</strong>(Normal Vector)：一个垂直于平面的单位向量。</li><li><strong>法线矩阵</strong>(Normal Matrix)：一个3x3矩阵，或者说是没有平移的模型（或者模型-观察）矩阵。它也被以某种方式修改（逆转置），<strong>从而在应用非统一缩放时，保持法向量朝向正确的方向</strong>。否则法向量会在使用非统一缩放时被扭曲。</li><li><strong>镜面光照</strong>(Specular Lighting)：当<strong>观察者视线靠近光源在表面的反射线时会显示的镜面高光</strong>。镜面光照是由观察者的方向，光源的方向和设定高光分散量的反光度值三个量共同决定的。</li><li><strong>冯氏着色</strong>(Phong Shading)：冯氏光照模型应用在片段着色器。</li><li><strong>Gouraud着色</strong>(Gouraud shading)：冯氏光照模型应用在顶点着色器上。在使用很少数量的顶点时会产生明显的瑕疵。会得到效率提升但是损失了视觉质量。</li><li><strong>GLSL结构体</strong>(GLSL struct)：一个类似于C的结构体，用作着色器变量的容器。大部分时间用来管理输入/输出/uniform。</li><li><strong>材质</strong>(Material)：一个<strong>物体反射的环境光，漫反射，镜面光颜色</strong>。这些东西设定了物体所拥有的颜色。</li><li><strong>光照属性</strong>(Light(properties))：一个<strong>光的环境光，漫反射，镜面光的强度</strong>。可以使用任何颜色值，对每一个冯氏分量(Phong Component)定义光源发出的颜色/强度。</li><li><strong>漫反射贴图</strong>(Diffuse Map)：一个设定了每个片段中<strong>漫反射颜色的纹理贴图</strong>。</li><li><strong>镜面光贴图</strong>(Specular Map)：一个设定了每一个片段的<strong>镜面光强度/颜色的纹理贴图</strong>。仅在物体的特定区域显示镜面高光。</li><li><strong>定向光</strong>(Directional Light)：只有一个方向的光源。它被建模为不管距离有多长所有光束都是平行而且其方向向量在整个场景中保持不变。</li><li><strong>点光源</strong>(Point Light)：一个在场景中有位置的，光线逐渐衰减的光源。</li><li><strong>衰减</strong>(Attenuation)：光随着距离减少强度的过程，通常使用在<strong>点光源和聚光下</strong>。</li><li><strong>聚光</strong>(Spotlight)：一个被定义为在某一个方向上的锥形的光源。</li><li><strong>手电筒</strong>(Flashlight)：一个摆放在观察者视角的聚光。</li><li><strong>GLSL uniform数组</strong>(GLSL Uniform Array)：一个uniform值数组。它的工作原理和C语言数组大致一样，<strong>只是不能动态分配内存</strong>。</li></ul></div><div class="article-licensing box"><div class="licensing-title"><p>《LearnOpenGL》光照 笔记</p><p><a href="https://yumi-cn.github.io/2021/01/26/learnopengl-c2/">https://yumi-cn.github.io/2021/01/26/learnopengl-c2/</a></p></div><div class="licensing-meta level is-mobile"><div class="level-left"><div class="level-item is-narrow"><div><h6>作者</h6><p>Yumiko</p></div></div><div class="level-item is-narrow"><div><h6>发布于</h6><p>2021-01-26</p></div></div><div class="level-item is-narrow"><div><h6>更新于</h6><p>2021-01-26</p></div></div><div class="level-item is-narrow"><div><h6>许可协议</h6><p><a class="icon" rel="noopener" target="_blank" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a><a class="icon" rel="noopener" target="_blank" title="Attribution" href="https://creativecommons.org/licenses/by/4.0/"><i class="fab fa-creative-commons-by"></i></a><a class="icon" rel="noopener" target="_blank" title="Noncommercial" href="https://creativecommons.org/licenses/by-nc/4.0/"><i class="fab fa-creative-commons-nc"></i></a></p></div></div></div></div></div><div class="article-tags is-size-7 mb-4"><span class="mr-2">#</span><a class="link-muted mr-2" rel="tag" href="/tags/%E7%AC%94%E8%AE%B0/">笔记</a></div></article></div><div class="card"><div class="card-content"><h3 class="menu-label has-text-centered">喜欢这篇文章？打赏一下作者吧</h3><div class="buttons is-centered"><a class="button donate" data-type="alipay"><span class="icon is-small"><i class="fab fa-alipay"></i></span><span>支付宝</span><span class="qrcode"><img src="/images/zfb.jpg" alt="支付宝"></span></a><a class="button donate" data-type="wechat"><span class="icon is-small"><i class="fab fa-weixin"></i></span><span>微信</span><span class="qrcode"><img src="/images/wx.jpg" alt="微信"></span></a><a class="button donate" href="https://afdian.net/@yumiko-cn" target="_blank" rel="noopener" data-type="afdian"><span class="icon is-small"><i class="fas fa-charging-station"></i></span><span>爱发电</span></a></div></div></div><nav class="post-navigation mt-4 level is-mobile"><div class="level-start"><a class="article-nav-prev level level-item link-muted" href="/2021/02/02/plan-2021-02/"><i class="level-item fas fa-chevron-left"></i><span class="level-item">2月的计划</span></a></div><div class="level-end"><a class="article-nav-next level level-item link-muted" href="/2021/01/24/leetcode-200-select/"><span class="level-item">《LeetCode》精选200题计划</span><i class="level-item fas fa-chevron-right"></i></a></div></nav><div class="card"><div class="card-content"><h3 class="title is-5">评论</h3><div id="comment-container"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/gitalk@1.6.2/dist/gitalk.css"><script src="https://cdn.jsdelivr.net/npm/gitalk@1.6.2/dist/gitalk.min.js"></script><script>var gitalk=new Gitalk({id:"dcf0e84b40e9f8cf7300406ec759f65e",repo:"yumi-cn.github.io",owner:"yumi-cn",clientID:"30141472b2ad1cb657d1",clientSecret:"80e26278051f7251bd46f5ec93317fec6675a7b4",admin:["yumi-cn"],createIssueManually:!1,distractionFreeMode:!1,perPage:20,pagerDirection:"last",enableHotKey:!0,language:"zh-CN"});gitalk.render("comment-container")</script></div></div></div><div class="column column-left is-4-tablet is-4-desktop is-3-widescreen order-1"><div class="card widget" data-type="profile"><div class="card-content"><nav class="level"><div class="level-item has-text-centered flex-shrink-1"><div><figure class="image is-128x128 mx-auto mb-2"><img class="avatar is-rounded" src="/images/avatar.jpg" alt="Yumiko"></figure><p class="title is-size-4 is-block" style="line-height:inherit">Yumiko</p><p class="is-size-6 is-block">游戏/引擎/技美</p><p class="is-size-6 is-flex justify-content-center"><i class="fas fa-map-marker-alt mr-1"></i><span>中国 杭州</span></p></div></div></nav><nav class="level is-mobile"><div class="level-item has-text-centered is-marginless"><div><p class="heading">文章</p><a href="/archives"><p class="title">25</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">专栏</p><a href="/categories"><p class="title">5</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">主题</p><a href="/tags"><p class="title">1</p></a></div></div></nav><div class="level"><a class="level-item button is-primary is-rounded" href="https://github.com/yumi-cn" target="_blank" rel="noopener">关注我</a></div><div class="level is-mobile"><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Github" href="https://github.com/yumi-cn"><i class="fab fa-github"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Bilibili" href="https://space.bilibili.com/11413916"><i class="fab fa-youtube"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Pixiv" href="https://www.pixiv.net/users/25096815"><i class="fas fa-palette"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="RSS" href="/atom.xml"><i class="fas fa-rss"></i></a></div></div></div><div class="card widget" data-type="categories"><div class="card-content"><div class="menu"><h3 class="menu-label">专栏</h3><ul class="menu-list"><li><a class="level is-mobile" href="/categories/3D%E6%B8%B8%E6%88%8F%E4%B8%8E%E5%9B%BE%E5%BD%A2%E5%AD%A6%E7%9A%84%E6%95%B0%E5%AD%A6/"><span class="level-start"><span class="level-item">3D游戏与图形学的数学</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/categories/LearnOpenGL/"><span class="level-start"><span class="level-item">LearnOpenGL</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/categories/Real-Time-Rendering-4th/"><span class="level-start"><span class="level-item">Real Time Rendering 4th</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/%E5%89%91%E6%8C%87Offer/"><span class="level-start"><span class="level-item">剑指Offer</span></span><span class="level-end"><span class="level-item tag">15</span></span></a></li><li><a class="level is-mobile" href="/categories/%E8%AE%A1%E5%88%92-Flags/"><span class="level-start"><span class="level-item">计划-Flags</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li></ul></div></div></div><div class="card widget" data-type="recent-posts"><div class="card-content"><h3 class="menu-label">最新文章</h3><article class="media"><div class="media-content"><p class="date"><time datetime="2021-02-02T12:05:19.000Z">2021-02-02</time></p><p class="title"><a href="/2021/02/02/plan-2021-02/">2月的计划</a></p><p class="categories"><a href="/categories/%E8%AE%A1%E5%88%92-Flags/">计划-Flags</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time datetime="2021-01-26T13:34:18.000Z">2021-01-26</time></p><p class="title"><a href="/2021/01/26/learnopengl-c2/">《LearnOpenGL》光照 笔记</a></p><p class="categories"><a href="/categories/LearnOpenGL/">LearnOpenGL</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time datetime="2021-01-24T01:26:52.000Z">2021-01-24</time></p><p class="title"><a href="/2021/01/24/leetcode-200-select/">《LeetCode》精选200题计划</a></p><p class="categories"><a href="/categories/%E8%AE%A1%E5%88%92-Flags/">计划-Flags</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time datetime="2021-01-23T11:46:18.000Z">2021-01-23</time></p><p class="title"><a href="/2021/01/23/learnopengl-c1/">《LearnOpenGL》入门 笔记</a></p><p class="categories"><a href="/categories/LearnOpenGL/">LearnOpenGL</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time datetime="2021-01-23T08:04:48.000Z">2021-01-23</time></p><p class="title"><a href="/2021/01/23/s2o-c6/">《剑指Offer》第6章笔记 各项能力</a></p><p class="categories"><a href="/categories/%E5%89%91%E6%8C%87Offer/">剑指Offer</a></p></div></article></div></div><div class="column-right-shadow is-hidden-widescreen is-sticky"></div></div><div class="column column-right is-4-tablet is-4-desktop is-3-widescreen is-hidden-touch is-hidden-desktop-only order-3 is-sticky"><div class="card widget" id="toc" data-type="toc"><div class="card-content"><div class="menu"><h3 class="menu-label">目录</h3><ul class="menu-list"><li><a class="level is-mobile" href="#颜色"><span class="level-left"><span class="level-item">颜色</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#创建一个光照场景"><span class="level-left"><span class="level-item">创建一个光照场景</span></span></a></li></ul></li><li><a class="level is-mobile" href="#基础光照"><span class="level-left"><span class="level-item">基础光照</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#环境光照"><span class="level-left"><span class="level-item">环境光照</span></span></a></li><li><a class="level is-mobile" href="#漫反射光照"><span class="level-left"><span class="level-item">漫反射光照</span></span></a></li><li><a class="level is-mobile" href="#法向量"><span class="level-left"><span class="level-item">法向量</span></span></a></li><li><a class="level is-mobile" href="#镜面光照"><span class="level-left"><span class="level-item">镜面光照</span></span></a></li><li><a class="level is-mobile" href="#练习"><span class="level-left"><span class="level-item">练习</span></span></a></li></ul></li><li><a class="level is-mobile" href="#材质"><span class="level-left"><span class="level-item">材质</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#设置材质"><span class="level-left"><span class="level-item">设置材质</span></span></a></li><li><a class="level is-mobile" href="#光的属性"><span class="level-left"><span class="level-item">光的属性</span></span></a></li><li><a class="level is-mobile" href="#不同的光源颜色"><span class="level-left"><span class="level-item">不同的光源颜色</span></span></a></li><li><a class="level is-mobile" href="#练习-1"><span class="level-left"><span class="level-item">练习</span></span></a></li></ul></li><li><a class="level is-mobile" href="#光照贴图"><span class="level-left"><span class="level-item">光照贴图</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#漫反射贴图"><span class="level-left"><span class="level-item">漫反射贴图</span></span></a></li><li><a class="level is-mobile" href="#镜面光贴图"><span class="level-left"><span class="level-item">镜面光贴图</span></span></a></li><li><a class="level is-mobile" href="#练习题"><span class="level-left"><span class="level-item">练习题</span></span></a></li></ul></li><li><a class="level is-mobile" href="#投光物"><span class="level-left"><span class="level-item">投光物</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#平行光"><span class="level-left"><span class="level-item">平行光</span></span></a></li><li><a class="level is-mobile" href="#点光源"><span class="level-left"><span class="level-item">点光源</span></span></a></li><li><a class="level is-mobile" href="#聚光"><span class="level-left"><span class="level-item">聚光</span></span></a></li></ul></li><li><a class="level is-mobile" href="#多光源"><span class="level-left"><span class="level-item">多光源</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#定向光"><span class="level-left"><span class="level-item">定向光</span></span></a></li><li><a class="level is-mobile" href="#点光源-1"><span class="level-left"><span class="level-item">点光源</span></span></a></li><li><a class="level is-mobile" href="#聚光-1"><span class="level-left"><span class="level-item">聚光</span></span></a></li><li><a class="level is-mobile" href="#合并结果"><span class="level-left"><span class="level-item">合并结果</span></span></a></li></ul></li><li><a class="level is-mobile" href="#复习"><span class="level-left"><span class="level-item">复习</span></span></a></li></ul></div></div><script src="/js/toc.js" defer></script></div></div></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/"><img src="/images/logo.jpg" alt="画码余生" height="28"></a><p class="is-size-7"><span>&copy; 2021 Yumiko</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a></p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Attribution 4.0 International" href="https://creativecommons.org/licenses/by/4.0/"><i class="fab fa-creative-commons-by"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="GitHub" href="https://github.com/yumi-cn"><i class="fab fa-github"></i></a></p></div></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" async></script><script>moment.locale("zh-CN")</script><script>var IcarusThemeSettings={article:{highlight:{clipboard:!0,fold:"unfolded"}}}</script><script src="/js/column.js"></script><script src="/js/animation.js"></script><a id="back-to-top" title="回到顶端" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back_to_top.js" defer></script><script src="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.js" defer></script><script>window.addEventListener("load", () => {
      window.cookieconsent.initialise({
        type: "info",
        theme: "edgeless",
        static: false,
        position: "bottom-left",
        content: {
          message: "此网站使用Cookie来改善您的体验。",
          dismiss: "知道了！",
          allow: "允许使用Cookie",
          deny: "拒绝",
          link: "了解更多",
          policy: "Cookie政策",
          href: "https://www.cookiesandyou.com/",
        },
        palette: {
          popup: {
            background: "#edeff5",
            text: "#838391"
          },
          button: {
            background: "#4b81e8"
          },
        },
      });
    });</script><script src="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/js/lightgallery.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/katex.min.css"><script src="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/katex.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/contrib/auto-render.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/contrib/mhchem.js" defer></script><script>window.addEventListener("load",function(){document.querySelectorAll('[role="article"] > .content').forEach(function(e){renderMathInElement(e)})})</script><script src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="想要查找什么..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/js/insight.js" defer></script><script>document.addEventListener("DOMContentLoaded",function(){loadInsight({contentUrl:"/content.json"},{hint:"想要查找什么...",untitled:"(无标题)",posts:"文章",pages:"页面",categories:"专栏",tags:"主题"})})</script></body></html>